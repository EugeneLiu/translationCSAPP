[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 06  Machine Level Programming II  Control.mp4
Video File: ../../../../Desktop/csapp/Lecture 06  Machine Level Programming II  Control.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.125000
Scroll Position: 825
Active Line: 836
Video Position: 132568

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.72,0:00:08.00,English,,0,0,0,,Okay let's continue on coverage of machine level programming
Dialogue: 0,0:00:01.72,0:00:08.00,Chinese,,0,0,0,,好，让我们继续学习machine level编程
Dialogue: 0,0:00:08.82,0:00:11.46,English,,0,0,0,,The second, I think a six part series
Dialogue: 0,0:00:08.82,0:00:11.46,Chinese,,0,0,0,,第二部分，我将分六个系列
Dialogue: 0,0:00:12.14,0:00:16.76,English,,0,0,0,,As I mentioned yesterday machine level programming is sort of the core of this course
Dialogue: 0,0:00:12.14,0:00:16.76,Chinese,,0,0,0,,如同我昨天提到的，machine level编程是这门课程的核心
Dialogue: 0,0:00:16.92,0:00:23.04,English,,0,0,0,,That it gives you a set of tools and understanding that take you well beyond
Dialogue: 0,0:00:16.92,0:00:23.04,Chinese,,0,0,0,,它为你提供了一套工具和理解，让你远远超越
Dialogue: 0,0:00:23.04,0:00:29.70,English,,0,0,0,,What you're sort of average run-of-the-mill of programmer or software developer would know about
Dialogue: 0,0:00:23.04,0:00:29.70,Chinese,,0,0,0,,那种普通的程序员或软件开发人员所知道的
Dialogue: 0,0:00:30.08,0:00:34.52,English,,0,0,0,,And it's very powerful in terms of your better understanding of the system
Dialogue: 0,0:00:30.08,0:00:34.52,Chinese,,0,0,0,,它能帮助你更好的理解操作系统
Dialogue: 0,0:00:34.80,0:00:41.80,English,,0,0,0,,What goes wrong? Why programs crash? What the meaning of those are?
Dialogue: 0,0:00:34.80,0:00:41.80,Chinese,,0,0,0,,是什么错了？程序为什么崩溃？这些东西意味着什么？
Dialogue: 0,0:00:41.82,0:00:43.82,English,,0,0,0,,So it's a fairly core part of the material
Dialogue: 0,0:00:41.82,0:00:43.82,Chinese,,0,0,0,,所以这部分是本课的核心
Dialogue: 0,0:00:44.48,0:00:46.96,English,,0,0,0,,As you know the data lab is due tonight
Dialogue: 0,0:00:44.48,0:00:46.96,Chinese,,0,0,0,,As you know the data lab is due tonight
Dialogue: 0,0:00:47.74,0:00:53.26,English,,0,0,0,,And the next lab out is called the "bomb lab" and I believe that's coming out tonight as well
Dialogue: 0,0:00:47.74,0:00:53.26,Chinese,,0,0,0,,And the next lab out is called the "bomb lab" and I believe that's coming out tonight as well
Dialogue: 0,0:00:53.90,0:01:00.00,English,,0,0,0,,So the bomb lab will rely on your ability to understand machine level code
Dialogue: 0,0:00:53.90,0:01:00.00,Chinese,,0,0,0,,So the bomb lab will rely on your ability to understand machine level code
Dialogue: 0,0:01:00.70,0:01:06.46,English,,0,0,0,,So the these two lectures will actually be enough to give you started on some of the earlier parts of that lab
Dialogue: 0,0:01:00.70,0:01:06.46,Chinese,,0,0,0,,So the these two lectures will actually be enough to give you started on some of the earlier parts of that lab
Dialogue: 0,0:01:07.02,0:01:10.16,English,,0,0,0,,You'll learn a lot more at recitation on Monday
Dialogue: 0,0:01:07.02,0:01:10.16,Chinese,,0,0,0,,You'll learn a lot more at recitation on Monday
Dialogue: 0,0:01:10.16,0:01:14.20,English,,0,0,0,,Either in person or if you're viewing the recorded version of that
Dialogue: 0,0:01:10.16,0:01:14.20,Chinese,,0,0,0,,Either in person or if you're viewing the recorded version of that
Dialogue: 0,0:01:14.64,0:01:17.54,English,,0,0,0,,That will help you move along on bomb lab
Dialogue: 0,0:01:14.64,0:01:17.54,Chinese,,0,0,0,,That will help you move along on bomb lab
Dialogue: 0,0:01:18.00,0:01:23.14,English,,0,0,0,,Like all the labs in this course,at least the first two, we give you a fair amount of time for them
Dialogue: 0,0:01:18.00,0:01:23.14,Chinese,,0,0,0,,Like all the labs in this course,at least the first two, we give you a fair amount of time for them
Dialogue: 0,0:01:23.72,0:01:29.62,English,,0,0,0,,But don't be fooled into thinking that means you can just slack off or work on other courses
Dialogue: 0,0:01:23.72,0:01:29.62,Chinese,,0,0,0,,But don't be fooled into thinking that means you can just slack off or work on other courses
Dialogue: 0,0:01:30.20,0:01:33.96,English,,0,0,0,,And then the last few moments jump in and finish this lab
Dialogue: 0,0:01:30.20,0:01:33.96,Chinese,,0,0,0,,And then the last few moments jump in and finish this lab
Dialogue: 0,0:01:34.10,0:01:40.10,English,,0,0,0,,The bomb lab once you get the hang of what you're doing,it's pretty you can just kind of crank along
Dialogue: 0,0:01:34.10,0:01:40.10,Chinese,,0,0,0,,The bomb lab once you get the hang of what you're doing,it's pretty you can just kind of crank along
Dialogue: 0,0:01:40.58,0:01:46.96,English,,0,0,0,,But there's a certain learning curve that will take you to even get started on it effectively
Dialogue: 0,0:01:40.58,0:01:46.96,Chinese,,0,0,0,,But there's a certain learning curve that will take you to even get started on it effectively
Dialogue: 0,0:01:47.08,0:01:48.28,English,,0,0,0,,So don't put it off
Dialogue: 0,0:01:47.08,0:01:48.28,Chinese,,0,0,0,,So don't put it off
Dialogue: 0,0:01:56.66,0:02:12.30,English,,0,0,0,,Um or with this
Dialogue: 0,0:01:56.66,0:02:12.30,Chinese,,0,0,0,,嗯。。。这个
Dialogue: 0,0:02:12.30,0:02:16.40,English,,0,0,0,,So last time we introduced the very basic principles of machine level programming
Dialogue: 0,0:02:12.30,0:02:16.40,Chinese,,0,0,0,,所以上次我们介绍了machine level编程的基本原理
Dialogue: 0,0:02:16.40,0:02:21.84,English,,0,0,0,,The idea of there being special state that you have access to the registers
Dialogue: 0,0:02:16.40,0:02:21.84,Chinese,,0,0,0,,The idea of there being special state that you have access to the registers
Dialogue: 0,0:02:21.84,0:02:27.22,English,,0,0,0,,Which people came out to class nesta a register is part of memory?No
Dialogue: 0,0:02:21.84,0:02:27.22,Chinese,,0,0,0,,Which people came out to class nesta a register is part of memory?No
Dialogue: 0,0:02:27.44,0:02:29.38,English,,0,0,0,,Are they part of the cache？No
Dialogue: 0,0:02:27.44,0:02:29.38,Chinese,,0,0,0,,它们是cache的一部分吗？不
Dialogue: 0,0:02:29.90,0:02:34.30,English,,0,0,0,,They special,they're different,they don't exist to a C level program
Dialogue: 0,0:02:29.90,0:02:34.30,Chinese,,0,0,0,,它们特殊 与众不同的是，他们不存在于C语言这类高级语言中
Dialogue: 0,0:02:34.30,0:02:37.06,English,,0,0,0,,When you're programming in C, you don't have any visibility into them
Dialogue: 0,0:02:34.30,0:02:37.06,Chinese,,0,0,0,,当你用C编程的时候，你无法见到它们
Dialogue: 0,0:02:37.66,0:02:44.26,English,,0,0,0,,And in general, today we're going to do then is go beyond the sort of very basics and start talking about the control
Dialogue: 0,0:02:37.66,0:02:44.26,Chinese,,0,0,0,,总的来说，今天开始，我们将深入底层，开始讨论如何控制
Dialogue: 0,0:02:44.26,0:02:50.06,English,,0,0,0,,How you control the flow of execution of instructions at the machine level
Dialogue: 0,0:02:44.26,0:02:50.06,Chinese,,0,0,0,,如何控制machine level的指令执行流程
Dialogue: 0,0:02:50.48,0:02:58.18,English,,0,0,0,,And how you use those techniques to implement basic constructs conditional statements,loops and switch statements
Dialogue: 0,0:02:50.48,0:02:58.18,Chinese,,0,0,0,,以及如何使用这些技术来实现基本构造条件语句，循环和switch语句
Dialogue: 0,0:02:59.08,0:03:02.72,English,,0,0,0,,And then next time we'll talk about procedures which warrants a whole lecture of its own
Dialogue: 0,0:02:59.08,0:03:02.72,Chinese,,0,0,0,,And then next time we'll talk about procedures which warrants a whole lecture of its own
Dialogue: 0,0:03:05.16,0:03:09.30,English,,0,0,0,,So that x86 and several machines of its generation
Dialogue: 0,0:03:05.16,0:03:09.30,Chinese,,0,0,0,,x86的这几代的机器
Dialogue: 0,0:03:09.70,0:03:16.22,English,,0,0,0,,Have these curious little of one bit flags that are called condition codes
Dialogue: 0,0:03:09.70,0:03:16.22,Chinese,,0,0,0,,有1bit的标志位被叫做condition codes
Dialogue: 0,0:03:16.54,0:03:19.26,English,,0,0,0,,And they're the basis of how conditional operations work
Dialogue: 0,0:03:16.54,0:03:19.26,Chinese,,0,0,0,,这是条件运算如何运作的基础
Dialogue: 0,0:03:20.86,0:03:26.30,English,,0,0,0,,So to a machine level programmer then we talked last time that
Dialogue: 0,0:03:20.86,0:03:26.30,Chinese,,0,0,0,,那么对于machine level程序员来说，我们上次谈到了这一点
Dialogue: 0,0:03:26.30,0:03:34.04,English,,0,0,0,,You have visibility of the set of registers and the memory
Dialogue: 0,0:03:26.30,0:03:34.04,Chinese,,0,0,0,,你可以看到这里有一组寄存器和内存
Dialogue: 0,0:03:34.44,0:03:37.94,English,,0,0,0,,But you also have more things and this is only a partial list
Dialogue: 0,0:03:34.44,0:03:37.94,Chinese,,0,0,0,,其实会有更多的东西，这只是其中的一部分（指Process State）
Dialogue: 0,0:03:38.02,0:03:41.30,English,,0,0,0,,Actually there's more and more stuff that you can add to this picture
Dialogue: 0,0:03:38.02,0:03:41.30,Chinese,,0,0,0,,实际上有很多的东西可以添加到这个图上面
Dialogue: 0,0:03:41.96,0:03:46.60,English,,0,0,0,,But we talked about in the 64-bit x86-64
Dialogue: 0,0:03:41.96,0:03:46.60,Chinese,,0,0,0,,但是我们现在讨论的是64位的x86-64
Dialogue: 0,0:03:46.60,0:03:56.38,English,,0,0,0,,Now 16 registers,8 of which have names that are historic based on old x86 stuff
Dialogue: 0,0:03:46.60,0:03:56.38,Chinese,,0,0,0,,现在这里有16个寄存器，其中8个从旧的x86时代继承了名字
Dialogue: 0,0:03:56.90,0:04:02.38,English,,0,0,0,,And 8 of which were introduced and so they simply named those %r8 through %r15
Dialogue: 0,0:03:56.90,0:04:02.38,Chinese,,0,0,0,,另外的8个则被简单的命名成%r8到%r15
Dialogue: 0,0:04:03.62,0:04:09.42,English,,0,0,0,,And other registers for the most part the only one that's really special is %rsp
Dialogue: 0,0:04:03.62,0:04:09.42,Chinese,,0,0,0,,这些寄存中，最特别的是%rsp
Dialogue: 0,0:04:09.48,0:04:11.54,English,,0,0,0,,It's the stack pointer tells you where
Dialogue: 0,0:04:09.48,0:04:11.54,Chinese,,0,0,0,,它告诉你栈顶在哪里（栈指针）
Dialogue: 0,0:04:11.76,0:04:15.76,English,,0,0,0,,And we'll learn a lot more about stacks starting next time
Dialogue: 0,0:04:11.76,0:04:15.76,Chinese,,0,0,0,,我们下次将学习更多关于栈的知识
Dialogue: 0,0:04:16.20,0:04:21.98,English,,0,0,0,,But it's sort of where the most the the state is that manages the execution of procedures
Dialogue: 0,0:04:16.20,0:04:21.98,Chinese,,0,0,0,,它是管理程序执行最重要的那个
Dialogue: 0,0:04:23.08,0:04:26.74,English,,0,0,0,,And so you can't just use that or set it in arbitrary ways
Dialogue: 0,0:04:23.08,0:04:26.74,Chinese,,0,0,0,,并且你不可能只是简单使用或是随意设置它的值
Dialogue: 0,0:04:26.74,0:04:32.78,English,,0,0,0,,But the other ones you more or less come with qualifications to that statement
Dialogue: 0,0:04:26.74,0:04:32.78,Chinese,,0,0,0,,But the other ones you more or less come with qualifications to that statement（其他的就不会这么重要）
Dialogue: 0,0:04:33.28,0:04:37.66,English,,0,0,0,,There's another register that they call the %rip which has nothing to do with death
Dialogue: 0,0:04:33.28,0:04:37.66,Chinese,,0,0,0,,另一个被叫做%rip的寄存器，与它字面意思不同（英语中指愿死者安息）
Dialogue: 0,0:04:40.54,0:04:43.42,English,,0,0,0,,It means that...the %rip means instruction pointer
Dialogue: 0,0:04:40.54,0:04:43.42,Chinese,,0,0,0,,它是指令指针的意思
Dialogue: 0,0:04:43.90,0:04:47.74,English,,0,0,0,,In IA32 is called a %eip and now it's called %rip
Dialogue: 0,0:04:43.90,0:04:47.74,Chinese,,0,0,0,,在IA32中也被叫做%eip，现在加%rip
Dialogue: 0,0:04:47.74,0:04:50.84,English,,0,0,0,,Just like the registry used to be %eax and now it's %rax
Dialogue: 0,0:04:47.74,0:04:50.84,Chinese,,0,0,0,,就像%rax寄存器之前被叫做%eax一样
Dialogue: 0,0:04:52.06,0:04:56.52,English,,0,0,0,,So all it contains is the address of the currently executing instruction
Dialogue: 0,0:04:52.06,0:04:56.52,Chinese,,0,0,0,,%rip保存了当前正在执行的指令的地址
Dialogue: 0,0:04:57.12,0:04:58.60,English,,0,0,0,,And you can...
Dialogue: 0,0:04:57.12,0:04:58.60,Chinese,,0,0,0,,并且你可以
Dialogue: 0,0:04:59.04,0:05:02.92,English,,0,0,0,,It's not a register that you access in a normal way
Dialogue: 0,0:04:59.04,0:05:02.92,Chinese,,0,0,0,,虽然这不是一个你能用常规方法访问的寄存器
Dialogue: 0,0:05:02.92,0:05:07.16,English,,0,0,0,,But you actually there are tricks that you can find out what the value of that is
Dialogue: 0,0:05:02.92,0:05:07.16,Chinese,,0,0,0,,但实际上有一些技巧使你可以找出它的值是什么
Dialogue: 0,0:05:07.66,0:05:13.44,English,,0,0,0,,So that just tells you where in the program,what part of the program is currently being executed
Dialogue: 0,0:05:07.66,0:05:13.44,Chinese,,0,0,0,,所以它可以告诉你，当前程序的那一部分正在被执行
Dialogue: 0,0:05:13.90,0:05:16.36,English,,0,0,0,,And then there's these things that are called condition codes
Dialogue: 0,0:05:13.90,0:05:16.36,Chinese,,0,0,0,,然后下面这些被叫做condition codes
Dialogue: 0,0:05:16.36,0:05:19.32,English,,0,0,0,,And we're only showing four there's actually more like eight of them
Dialogue: 0,0:05:16.36,0:05:19.32,Chinese,,0,0,0,,我们只展示了其中的8个，其实他们有更多
Dialogue: 0,0:05:19.90,0:05:22.90,English,,0,0,0,,But not a relevant to our general discussion
Dialogue: 0,0:05:19.90,0:05:22.90,Chinese,,0,0,0,,这并不会影响我们做一般性的讨论
Dialogue: 0,0:05:23.40,0:05:28.42,English,,0,0,0,,That are all one bit flags and they get set not directly
Dialogue: 0,0:05:23.40,0:05:28.42,Chinese,,0,0,0,,它们都是1bit的标志位，并且不是直接被设置的
Dialogue: 0,0:05:28.42,0:05:31.64,English,,0,0,0,,But as a side effect of other operations that take place
Dialogue: 0,0:05:28.42,0:05:31.64,Chinese,,0,0,0,,是其他操作产生的一些副作用
Dialogue: 0,0:05:32.32,0:05:37.32,English,,0,0,0,,And they're the basis for which conditional operation gets decided
Dialogue: 0,0:05:32.32,0:05:37.32,Chinese,,0,0,0,,他们是决定条件操作结果的基础
Dialogue: 0,0:05:37.48,0:05:39.70,English,,0,0,0,,So let's go through what those mean
Dialogue: 0,0:05:37.48,0:05:39.70,Chinese,,0,0,0,,让我们来看一下他们都代表什么
Dialogue: 0,0:05:40.82,0:05:45.22,English,,0,0,0,,And they're given names, but these names are actually useful to memorize what they mean
Dialogue: 0,0:05:40.82,0:05:45.22,Chinese,,0,0,0,,他们都有自己的名字，这将帮助我们记忆它们代表什么
Dialogue: 0,0:05:45.82,0:05:48.26,English,,0,0,0,,So CF means the carry flag
Dialogue: 0,0:05:45.82,0:05:48.26,Chinese,,0,0,0,,CF表示进位标志 (carry flag)
Dialogue: 0,0:05:48.90,0:05:53.20,English,,0,0,0,,And that's if you think of adding two numbers,think of them as two unsigned numbers
Dialogue: 0,0:05:48.90,0:05:53.20,Chinese,,0,0,0,,当你想对两个数字做加法，两个无符号数
Dialogue: 0,0:05:53.68,0:06:00.30,English,,0,0,0,,And you do the binary arithmetic and sometimes an extra one pops out of the left hand side right
Dialogue: 0,0:05:53.68,0:06:00.30,Chinese,,0,0,0,,当你做二进制运算的时候，高位上需要处理低位的进位（？）
Dialogue: 0,0:06:00.30,0:06:05.64,English,,0,0,0,,That's the carry bit,you the numbers you added sort of were too big
Dialogue: 0,0:06:00.30,0:06:05.64,Chinese,,0,0,0,,进位标志就是，当你做加法的两个数字太大的时候
Dialogue: 0,0:06:06.00,0:06:12.80,English,,0,0,0,,To be contained in the 32 or 64-bit or even 16 or 8-bit result
Dialogue: 0,0:06:06.00,0:06:12.80,Chinese,,0,0,0,,用于存放结果可能是32位或者64位，甚至是16位或者8位的空间
Dialogue: 0,0:06:13.64,0:06:16.64,English,,0,0,0,,And so an extra bit was generated that's called the carry bit
Dialogue: 0,0:06:13.64,0:06:16.64,Chinese,,0,0,0,,因此产生的额外的位，就叫进位标志
Dialogue: 0,0:06:18.00,0:06:25.30,English,,0,0,0,,The zero flag(ZF) is what it sounds like it's set if the the value you just computed is zero
Dialogue: 0,0:06:18.00,0:06:25.30,Chinese,,0,0,0,,零标志( zero flag(ZF) )就是字面上的意思，它代表刚刚的运算结果是0
Dialogue: 0,0:06:25.80,0:06:28.66,English,,0,0,0,,These are set typically by arithmetic instructions by the way
Dialogue: 0,0:06:25.80,0:06:28.66,Chinese,,0,0,0,,这些标志位通常由算术指令设置
Dialogue: 0,0:06:29.28,0:06:36.98,English,,0,0,0,,The sign flag(SF) is said if the value just computed as a one in the most significant bit meaning it's a negative value
Dialogue: 0,0:06:29.28,0:06:36.98,Chinese,,0,0,0,,符号标志(sign flag(SF))和刚才计算结果的符号位相同，表示结果是负值
Dialogue: 0,0:06:37.60,0:06:44.04,English,,0,0,0,,And the overflow flag(OF) is a two's complement version of overflow
Dialogue: 0,0:06:37.60,0:06:44.04,Chinese,,0,0,0,,溢出标志overflow flag(OF)代表发生了算术溢出（？）
Dialogue: 0,0:06:44.64,0:06:51.88,English,,0,0,0,,So in particular if you remember from data lab, how do you know if addition of two values is overflowed
Dialogue: 0,0:06:44.64,0:06:51.88,Chinese,,0,0,0,,如果你记得（大概是某节课），那应该知道怎么判断两个数相加会不会溢出（？）
Dialogue: 0,0:06:52.00,0:06:57.30,English,,0,0,0,,If the signs of the operands are the same,but the sign of the result is different than that
Dialogue: 0,0:06:52.00,0:06:57.30,Chinese,,0,0,0,,如果两个操作数的符号相同，但是结果的符号不同
Dialogue: 0,0:06:57.80,0:07:03.66,English,,0,0,0,,So either you added two positive numbers and got a negative result.That was a positive overflow
Dialogue: 0,0:06:57.80,0:07:03.66,Chinese,,0,0,0,,要么是两个正数相加，得到了一个负数，这是一个正溢出
Dialogue: 0,0:07:03.66,0:07:08.53,English,,0,0,0,,Or you added two negative numbers and got a negative result.That's negative overflow
Dialogue: 0,0:07:03.66,0:07:08.53,Chinese,,0,0,0,,或者是，两个负数相加，得到了一个负数，这是负溢出
Dialogue: 0,0:07:08.90,0:07:13.35,English,,0,0,0,,You can't overflow if the two arguments are of opposite signs.right?
Dialogue: 0,0:07:08.90,0:07:13.35,Chinese,,0,0,0,,如果两个操作数的符号相反，就不会溢出，是这样的吧？
Dialogue: 0,0:07:14.24,0:07:21.48,English,,0,0,0,,So those four flags get,set as a sort of normal activity by many of the instructions
Dialogue: 0,0:07:14.24,0:07:21.48,Chinese,,0,0,0,,许多指令都会去设置这四个标志位
Dialogue: 0,0:07:22.08,0:07:25.14,English,,0,0,0,,Not by our friend the lea instruction
Dialogue: 0,0:07:22.08,0:07:25.14,Chinese,,0,0,0,,但不包括 lea 指令
Dialogue: 0,0:07:25.14,0:07:31.18,English,,0,0,0,,Which I mentioned is kind of a quirky instruction that GCC really likes a lot and you'll see it in a lot of places
Dialogue: 0,0:07:25.14,0:07:31.18,Chinese,,0,0,0,,这是一个 GCC 特别喜欢用的奇怪指令，你将在很多地方看到它
Dialogue: 0,0:07:34.20,0:07:39.96,English,,0,0,0,,But in general and most of the time those flags get completely ignored,because who cares right
Dialogue: 0,0:07:34.20,0:07:39.96,Chinese,,0,0,0,,坦白说，大部分时候这些标志位都会被忽略（指不会用到），因为谁在乎啊（笑）
Dialogue: 0,0:07:40.82,0:07:45.08,English,,0,0,0,,But they do show up at various points when you're doing conditional operations
Dialogue: 0,0:07:40.82,0:07:45.08,Chinese,,0,0,0,,但当你做分支操作的时候，是会用到它们的
Dialogue: 0,0:07:47.78,0:07:53.54,English,,0,0,0,,So there's some special instructions whose only effect is to set condition codes
Dialogue: 0,0:07:47.78,0:07:53.54,Chinese,,0,0,0,,但是有一些特殊的指令，只会设置这些标志位
Dialogue: 0,0:07:53.54,0:07:57.72,English,,0,0,0,,And the one that you'll see is especially it's called compare CMP
Dialogue: 0,0:07:53.54,0:07:57.72,Chinese,,0,0,0,,cmp就是这些指令中的一个
Dialogue: 0,0:07:58.34,0:08:07.34,English,,0,0,0,,And by the way the queue at the end of these is all just a reflection of their operating on 64-bit words,quadword as I said
Dialogue: 0,0:07:58.34,0:08:07.34,Chinese,,0,0,0,,And by the way the queue at the end of these is all just a reflection of their operating on 64-bit words,quadword as I said
Dialogue: 0,0:08:07.88,0:08:16.40,English,,0,0,0,,So the comparison is sort of like a subtraction instruction except that you don't do anything with the result
Dialogue: 0,0:08:07.88,0:08:16.40,Chinese,,0,0,0,,cmp有点像是减法指令，只是不会产生结果
Dialogue: 0,0:08:17.20,0:08:21.56,English,,0,0,0,,Normal subtraction instruction is like x minus equals y
Dialogue: 0,0:08:17.20,0:08:21.56,Chinese,,0,0,0,,正常的减法指令，像是 x -= y
Dialogue: 0,0:08:22.52,0:08:26.76,English,,0,0,0,,It will read two numbers but then it will store the result wherever x is stored
Dialogue: 0,0:08:22.52,0:08:26.76,Chinese,,0,0,0,,会读取两个数，然后把结果存到 x 上
Dialogue: 0,0:08:28.08,0:08:33.40,English,,0,0,0,,But compare just takes these two values does the subtraction and doesn't do anything with the result
Dialogue: 0,0:08:28.08,0:08:33.40,Chinese,,0,0,0,,但是 cmp 只是读取两个数，然后做减法，不存储结果
Dialogue: 0,0:08:33.40,0:08:36.88,English,,0,0,0,,But it will set it's these four condition flags
Dialogue: 0,0:08:33.40,0:08:36.88,Chinese,,0,0,0,,但是会设置上述四个标志位
Dialogue: 0,0:08:38.66,0:08:45.96,English,,0,0,0,,And just a few things to keep in mind that are often will be sources of confuse
Dialogue: 0,0:08:38.66,0:08:45.96,Chinese,,0,0,0,,还有一些容易混淆的东西要记住
Dialogue: 0,0:08:46.56,0:08:54.36,English,,0,0,0,,Remember that the arguments in the way we write them in machine code is the opposite of what you'd expect
Dialogue: 0,0:08:46.56,0:08:54.36,Chinese,,0,0,0,,我们在机器码中写参数的顺序和你平常写参数的顺序是反着的
Dialogue: 0,0:08:55.06,0:08:57.38,English,,0,0,0,,By the way,somebody asked me last time
Dialogue: 0,0:08:55.06,0:08:57.38,Chinese,,0,0,0,,顺便说一句，上次有人问我
Dialogue: 0,0:08:57.38,0:09:02.84,English,,0,0,0,,There's another there's sort of two dialects of assembly code used on x86 machines
Dialogue: 0,0:08:57.38,0:09:02.84,Chinese,,0,0,0,,x86上面的汇编有两个变种
Dialogue: 0,0:09:03.46,0:09:07.64,English,,0,0,0,,There's the one that's used by intel and Microsoft and we don't use it
Dialogue: 0,0:09:03.46,0:09:07.64,Chinese,,0,0,0,,一种是Intel和Microsoft使用的，我们不用这种
Dialogue: 0,0:09:08.04,0:09:14.24,English,,0,0,0,,And then there's the one used that sort of used by Linux systems and that's the one we use
Dialogue: 0,0:09:08.04,0:09:14.24,Chinese,,0,0,0,,另一种是被Linux广泛使用的，我们使用这种
Dialogue: 0,0:09:14.66,0:09:19.66,English,,0,0,0,,And they're different,and one of the quirks of them is they write their arguments in different orders
Dialogue: 0,0:09:14.66,0:09:19.66,Chinese,,0,0,0,,他们的一个区别就是写参数的顺序不同
Dialogue: 0,0:09:19.86,0:09:22.58,English,,0,0,0,,So it will drive you crazy reading trying to read
Dialogue: 0,0:09:19.86,0:09:22.58,Chinese,,0,0,0,,所以你读源码的时候可能会抓狂
Dialogue: 0,0:09:22.96,0:09:24.32,English,,0,0,0,,If you're familiar with one
Dialogue: 0,0:09:22.96,0:09:24.32,Chinese,,0,0,0,,如果你熟悉其中一种风格
Dialogue: 0,0:09:24.54,0:09:28.58,English,,0,0,0,,It's like if you've ever tried to drive a car on the wrong side of the road
Dialogue: 0,0:09:24.54,0:09:28.58,Chinese,,0,0,0,,那读另一种的时候就像在公路上逆行一样
Dialogue: 0,0:09:29.30,0:09:31.60,English,,0,0,0,,You often will crash or do bad things
Dialogue: 0,0:09:29.30,0:09:31.60,Chinese,,0,0,0,,你可能会崩溃，或者做错些什么
Dialogue: 0,0:09:33.76,0:09:36.74,English,,0,0,0,,Um so that's just an aside that
Dialogue: 0,0:09:33.76,0:09:36.74,Chinese,,0,0,0,,emm，只是举个例子
Dialogue: 0,0:09:37.02,0:09:42.98,English,,0,0,0,,What I find by the way when I'm looking at code and I see a compare instruction
Dialogue: 0,0:09:37.02,0:09:42.98,Chinese,,0,0,0,,What I find by the way when I'm looking at code and I see a compare instruction
Dialogue: 0,0:09:42.98,0:09:51.10,English,,0,0,0,,I actually write as a comment of compare of the two but I flipped the order
Dialogue: 0,0:09:42.98,0:09:51.10,Chinese,,0,0,0,,我会在注释上写出参数翻转过来的顺序（？）
Dialogue: 0,0:09:51.14,0:09:55.32,English,,0,0,0,,So that I'm sure that I sort of keep in my mind what the comparison was of
Dialogue: 0,0:09:51.14,0:09:55.32,Chinese,,0,0,0,,确保我可以清楚的认出比较的顺序（？）
Dialogue: 0,0:09:56.38,0:10:00.34,English,,0,0,0,,And so these flags get set according to the rules of subtraction
Dialogue: 0,0:09:56.38,0:10:00.34,Chinese,,0,0,0,,像是被减法设置的标志位
Dialogue: 0,0:10:00.44,0:10:04.64,English,,0,0,0,,And so it turns out that the carry flag and the overflow flag
Dialogue: 0,0:10:00.44,0:10:04.64,Chinese,,0,0,0,,以及进位标志和溢出标志
Dialogue: 0,0:10:04.64,0:10:07.30,English,,0,0,0,,You have to sort of flip your sense of what happened
Dialogue: 0,0:10:04.64,0:10:07.30,Chinese,,0,0,0,,你得反过来计算（因为参数顺序是反着写的）
Dialogue: 0,0:10:07.30,0:10:11.62,English,,0,0,0,,Because it's a subtraction rather than addition but it's the same general idea
Dialogue: 0,0:10:07.30,0:10:11.62,Chinese,,0,0,0,,减法不是加法，但都是要反过来计算的（？）
Dialogue: 0,0:10:14.84,0:10:18.92,English,,0,0,0,,So that sort of shows you one particular one
Dialogue: 0,0:10:14.84,0:10:18.92,Chinese,,0,0,0,,So that sort of shows you one particular one
Dialogue: 0,0:10:19.26,0:10:25.82,English,,0,0,0,,In another instruction that you'll see whose only purpose in the world is to to set condition flags
Dialogue: 0,0:10:19.26,0:10:25.82,Chinese,,0,0,0,,有一些指令，它们唯一的用处就是设置条件标志位
Dialogue: 0,0:10:26.04,0:10:31.26,English,,0,0,0,,Condition codes is the test instruction and this is typically used the compare as
Dialogue: 0,0:10:26.04,0:10:31.26,Chinese,,0,0,0,,Condition codes is the test instruction and this is typically used the compare as
Dialogue: 0,0:10:31.42,0:10:34.80,English,,0,0,0,,You'd think it's when you have two values and you want to compare them to each other
Dialogue: 0,0:10:31.42,0:10:34.80,Chinese,,0,0,0,,当你有两个数的时候，想要比较他们可以用cmp指令
Dialogue: 0,0:10:35.30,0:10:39.44,English,,0,0,0,,And the test is if you really just have one value and you want to see what it's like is
Dialogue: 0,0:10:35.30,0:10:39.44,Chinese,,0,0,0,,test指令就是，当你只有一个数的时候，想知道
Dialogue: 0,0:10:39.64,0:10:43.96,English,,0,0,0,,It zero is it negative,those are the main things you care about
Dialogue: 0,0:10:39.64,0:10:43.96,Chinese,,0,0,0,,它是0吗，是负数吗
Dialogue: 0,0:10:44.10,0:10:45.84,English,,0,0,0,,In fact that's the only thing you can determine
Dialogue: 0,0:10:44.10,0:10:45.84,Chinese,,0,0,0,,事实上（test）是你唯一可以确认这些的方式（？）
Dialogue: 0,0:10:46.40,0:10:53.56,English,,0,0,0,,But just because I guess they had up they had sort of a possibility of having two arguments to this
Dialogue: 0,0:10:46.40,0:10:53.56,Chinese,,0,0,0,,But just because I guess they had up they had sort of a possibility of having two arguments to this
Dialogue: 0,0:10:53.94,0:10:56.04,English,,0,0,0,,So they decided well let's to go ahead and do it
Dialogue: 0,0:10:53.94,0:10:56.04,Chinese,,0,0,0,,So they decided well let's to go ahead and do it
Dialogue: 0,0:10:56.48,0:11:02.58,English,,0,0,0,,How do you have two arguments to a test instruction what's and the two results and then test that value
Dialogue: 0,0:10:56.48,0:11:02.58,Chinese,,0,0,0,,How do you have two arguments to a test instruction what's and the two results and then test that value
Dialogue: 0,0:11:03.16,0:11:04.96,English,,0,0,0,,So what you'll typically see is a test
Dialogue: 0,0:11:03.16,0:11:04.96,Chinese,,0,0,0,,So what you'll typically see is a test
Dialogue: 0,0:11:06.60,0:11:13.40,English,,0,0,0,,Where both arguments are the same so testq %rax, %rax
Dialogue: 0,0:11:06.60,0:11:13.40,Chinese,,0,0,0,,Where both arguments are the same so testq %rax, %rax
Dialogue: 0,0:11:14.24,0:11:20.34,English,,0,0,0,,Where so that you're just any register to itself and one property the end operation is
Dialogue: 0,0:11:14.24,0:11:20.34,Chinese,,0,0,0,,Where so that you're just any register to itself and one property the end operation is
Dialogue: 0,0:11:21.12,0:11:27.10,English,,0,0,0,,It's what they call item potent adding ending two things the same things together gives you that same thing
Dialogue: 0,0:11:21.12,0:11:27.10,Chinese,,0,0,0,,It's what they call item potent adding ending two things the same things together gives you that same thing
Dialogue: 0,0:11:31.62,0:11:33.46,English,,0,0,0,,So we can see these
Dialogue: 0,0:11:31.62,0:11:33.46,Chinese,,0,0,0,,So we can see these
Dialogue: 0,0:11:33.46,0:11:35.46,English,,0,0,0,,And now
Dialogue: 0,0:11:33.46,0:11:35.46,Chinese,,0,0,0,,现在
Dialogue: 0,0:11:35.86,0:11:38.26,English,,0,0,0,,So I told you that's how the condition codes get set
Dialogue: 0,0:11:35.86,0:11:38.26,Chinese,,0,0,0,,我讲一下这些条件码是怎么被设置的
Dialogue: 0,0:11:38.26,0:11:41.14,English,,0,0,0,,Now how do you actually read them how do you make use of them
Dialogue: 0,0:11:38.26,0:11:41.14,Chinese,,0,0,0,,你怎么读就怎么用它们（应该是指都是字面意思？）
Dialogue: 0,0:11:41.62,0:11:45.32,English,,0,0,0,,Well there's two in principle you can actually extract
Dialogue: 0,0:11:41.62,0:11:45.32,Chinese,,0,0,0,,这里有两种使用状态码的方式
Dialogue: 0,0:11:45.36,0:11:51.00,English,,0,0,0,,And get the condition code values directly out of this special status register
Dialogue: 0,0:11:45.36,0:11:51.00,Chinese,,0,0,0,,直接从特殊状态寄存器中得到条件码
Dialogue: 0,0:11:51.00,0:11:53.16,English,,0,0,0,,But that's very unusual to do that
Dialogue: 0,0:11:51.00,0:11:53.16,Chinese,,0,0,0,,但是一般不这么做
Dialogue: 0,0:11:53.68,0:12:02.72,English,,0,0,0,,What's more common is you either try to read it in and set a 1 bit flag based on the result in a read some other register
Dialogue: 0,0:11:53.68,0:12:02.72,Chinese,,0,0,0,,更常见的是把这个状态位附加到某个操作的结果当中（进位啊什么的？）
Dialogue: 0,0:12:03.06,0:12:05.48,English,,0,0,0,,Or you try do a conditional branch
Dialogue: 0,0:12:03.06,0:12:05.48,Chinese,,0,0,0,,或是你要做一些条件分支
Dialogue: 0,0:12:06.64,0:12:09.56,English,,0,0,0,,So the first example where you try to read it
Dialogue: 0,0:12:06.64,0:12:09.56,Chinese,,0,0,0,,第一个示例是尝试读它
Dialogue: 0,0:12:10.08,0:12:13.92,English,,0,0,0,,In a way that you can make use of it is done with the set instruction
Dialogue: 0,0:12:10.08,0:12:13.92,Chinese,,0,0,0,,其中一种方式是，通过set指令来使用它们
Dialogue: 0,0:12:14.84,0:12:18.70,English,,0,0,0,,And you'll see there's a whole range of set instructions
Dialogue: 0,0:12:14.84,0:12:18.70,Chinese,,0,0,0,,这里有一系列关于set指令的说明
Dialogue: 0,0:12:19.32,0:12:25.98,English,,0,0,0,,But their only difference is really just what the condition they're setting based on
Dialogue: 0,0:12:19.32,0:12:25.98,Chinese,,0,0,0,,它们的区别是在做这个操作时，所依赖的状态码不同
Dialogue: 0,0:12:27.28,0:12:36.06,English,,0,0,0,,So the what a set instruction does, it sets a single byte of a single register to either 1 or 0
Dialogue: 0,0:12:27.28,0:12:36.06,Chinese,,0,0,0,,所以set指令就是，将寄存器中的一位，设置为1或者0
Dialogue: 0,0:12:36.90,0:12:43.90,English,,0,0,0,,And the basis for whether it's sets it to 1 or 0 is a based on
Dialogue: 0,0:12:36.90,0:12:43.90,Chinese,,0,0,0,,它设置的依据就是
Dialogue: 0,0:12:43.90,0:12:47.02,English,,0,0,0,,What the condition codes are as essence what's the
Dialogue: 0,0:12:43.90,0:12:47.02,Chinese,,0,0,0,,条件码的值
Dialogue: 0,0:12:47.62,0:12:51.10,English,,0,0,0,,What happened your most recent instruction before hand
Dialogue: 0,0:12:47.62,0:12:51.10,Chinese,,0,0,0,,你上一个指令的结果
Dialogue: 0,0:12:51.10,0:12:58.44,English,,0,0,0,,was it a arithmetic instruction or a set instruction or a test instruction or a compare instruction
Dialogue: 0,0:12:51.10,0:12:58.44,Chinese,,0,0,0,,算术指令或是set指令或是test指令或是比较指令
Dialogue: 0,0:12:59.12,0:13:05.52,English,,0,0,0,,And as you can see there's they're all based on some logical combination of these condition codes
Dialogue: 0,0:12:59.12,0:13:05.52,Chinese,,0,0,0,,如你所见，这些指令的逻辑都是基于条件码的
Dialogue: 0,0:13:06.04,0:13:10.04,English,,0,0,0,,That correspond to what the names imply
Dialogue: 0,0:13:06.04,0:13:10.04,Chinese,,0,0,0,,他们的名字和他们的含义一样（？）
Dialogue: 0,0:13:10.44,0:13:17.06,English,,0,0,0,,So for example the sets instruction is true,if the sign flag is true
Dialogue: 0,0:13:10.44,0:13:17.06,Chinese,,0,0,0,,举个例子，当符号标志是1的话，sets就会把最低位设置为1（？）
Dialogue: 0,0:13:17.36,0:13:19.96,English,,0,0,0,,Meaning that the most recent result was negative
Dialogue: 0,0:13:17.36,0:13:19.96,Chinese,,0,0,0,,代表最近的运算结果是负数
Dialogue: 0,0:13:20.78,0:13:27.46,English,,0,0,0,,And there's other ones less than less than or equal to two's complement comparisons
Dialogue: 0,0:13:20.78,0:13:27.46,Chinese,,0,0,0,,这个会在补码比较是小于等于的时候把最低位设置为1（？）
Dialogue: 0,0:13:27.90,0:13:33.64,English,,0,0,0,,And they have to take into consideration did the most recent result cause an overflow or not
Dialogue: 0,0:13:27.90,0:13:33.64,Chinese,,0,0,0,,这个取决于最近一次运算的结果是不是溢出
Dialogue: 0,0:13:33.64,0:13:36.96,English,,0,0,0,,Because that will affect the result of the comparison
Dialogue: 0,0:13:33.64,0:13:36.96,Chinese,,0,0,0,,因为会影响到比较结果（应该是补码表示的时候和无符号数不一样的意思）
Dialogue: 0,0:13:38.58,0:13:43.38,English,,0,0,0,,So that's part of the reason we tortured you with understanding two's complement arithmetic
Dialogue: 0,0:13:38.58,0:13:43.38,Chinese,,0,0,0,,所以我们要求你理解二进制补码的运算
Dialogue: 0,0:13:43.38,0:13:47.70,English,,0,0,0,,And how you compare results and making you understand the bit-level behavior
Dialogue: 0,0:13:43.38,0:13:47.70,Chinese,,0,0,0,,并且你需要知道在二进制下如何比较结果
Dialogue: 0,0:13:48.08,0:13:50.48,English,,0,0,0,,So that you can understand what these instructions do
Dialogue: 0,0:13:48.08,0:13:50.48,Chinese,,0,0,0,,这样你就能理解这些指令的作用
Dialogue: 0,0:13:52.40,0:13:55.06,English,,0,0,0,,So we're cruel but we have a reason for our cruelty
Dialogue: 0,0:13:52.40,0:13:55.06,Chinese,,0,0,0,,虽然你可能不习惯，但我们必须这样做
Dialogue: 0,0:13:57.50,0:14:02.69,English,,0,0,0,,So you say 1 byte how do you deal with 1 byte well here's another thing we didn't tell you yet
Dialogue: 0,0:13:57.50,0:14:02.69,Chinese,,0,0,0,,你可能会问，如何操作（某个寄存器的）一个字节呢？这就是我们接下来要讲的
Dialogue: 0,0:14:03.24,0:14:05.76,English,,0,0,0,,And we're going to keep telling you more stuff over and over again
Dialogue: 0,0:14:03.24,0:14:05.76,Chinese,,0,0,0,,我们会慢慢讲解每一个细节（？）
Dialogue: 0,0:14:06.14,0:14:09.30,English,,0,0,0,,It turns out for every one of these 16 registers
Dialogue: 0,0:14:06.14,0:14:09.30,Chinese,,0,0,0,,事实是，这16个寄存器
Dialogue: 0,0:14:09.76,0:14:15.12,English,,0,0,0,,You can directly set the lowest order byte of it to either 0 or 1
Dialogue: 0,0:14:09.76,0:14:15.12,Chinese,,0,0,0,,你都可以直接将他们的低8位直接设置为0或者1（？）
Dialogue: 0,0:14:15.66,0:14:20.92,English,,0,0,0,,And it won't affect it it turns out it doesn't affect any of the other 7 bytes of that register
Dialogue: 0,0:14:15.66,0:14:20.92,Chinese,,0,0,0,,并且不会影响其他的7个字节
Dialogue: 0,0:14:22.02,0:14:24.14,English,,0,0,0,,So and they all have quirky names
Dialogue: 0,0:14:22.02,0:14:24.14,Chinese,,0,0,0,,所以每个寄存器的低8位都有自己的名字
Dialogue: 0,0:14:25.18,0:14:28.88,English,,0,0,0,,The l means low in there
Dialogue: 0,0:14:25.18,0:14:28.88,Chinese,,0,0,0,,（名字）里面的 l 代表的是低位（low）（比如%al相对于%rax）
Dialogue: 0,0:14:32.14,0:14:38.12,English,,0,0,0,,So here's an example of using putting all this together to do something that's vaguely useful
Dialogue: 0,0:14:32.14,0:14:38.12,Chinese,,0,0,0,,这里有一个使用他们（cmp set 刚才讲的指令）的例子（？）
Dialogue: 0,0:14:40.24,0:14:47.90,English,,0,0,0,,Suppose I want to function gt, that will take two numbers and compare them and set the result
Dialogue: 0,0:14:40.24,0:14:47.90,Chinese,,0,0,0,,假如我想写一个函数 gt，比较两个数并获取结果
Dialogue: 0,0:14:48.20,0:14:54.00,English,,0,0,0,,Return result value of 1 if x > y  and 0 otherwise
Dialogue: 0,0:14:48.20,0:14:54.00,Chinese,,0,0,0,,如果 x > y就返回1，否则返回0
Dialogue: 0,0:14:56.04,0:14:59.76,English,,0,0,0,,And so here's the assembly code with some tabbing problems
Dialogue: 0,0:14:56.04,0:14:59.76,Chinese,,0,0,0,,这段汇编的缩进有点问题
Dialogue: 0,0:15:03.26,0:15:13.38,English,,0,0,0,,Success nothing bugs me hold on
Dialogue: 0,0:15:03.26,0:15:13.38,Chinese,,0,0,0,,这不影响功能，我们继续看
Dialogue: 0,0:15:13.40,0:15:31.70,English,,0,0,0,,I might know try and do this. well no
Dialogue: 0,0:15:13.40,0:15:31.70,Chinese,,0,0,0,,可能是我不小心去掉了缩进
Dialogue: 0,0:15:31.72,0:15:33.18,English,,0,0,0,,I will fix this later
Dialogue: 0,0:15:31.72,0:15:33.18,Chinese,,0,0,0,,我后面会改掉这个
Dialogue: 0,0:15:33.20,0:15:35.94,English,,0,0,0,,Anyways it's not the end of the world
Dialogue: 0,0:15:33.20,0:15:35.94,Chinese,,0,0,0,,它不是世界末日（梗 It's Not the End of the World  是个书名）
Dialogue: 0,0:15:41.52,0:15:49.00,English,,0,0,0,,Normally an assembly code one thing you've noticed is that the instructions are indented by a tab space
Dialogue: 0,0:15:41.52,0:15:49.00,Chinese,,0,0,0,,一般来说，汇编代码通常使用tab来做缩进
Dialogue: 0,0:15:49.04,0:15:52.32,English,,0,0,0,,And the only thing,that's way over in the left margin labels
Dialogue: 0,0:15:49.04,0:15:52.32,Chinese,,0,0,0,,有一个例外 labels一般是靠左边写的
Dialogue: 0,0:15:52.32,0:15:59.92,English,,0,0,0,,So this is just sort of this what the the assembler is actually quite tolerant of formatting things
Dialogue: 0,0:15:52.32,0:15:59.92,Chinese,,0,0,0,,虽然汇编代码对缩进没有强要求
Dialogue: 0,0:15:59.92,0:16:01.40,English,,0,0,0,,But this isn't the way it normally book
Dialogue: 0,0:15:59.92,0:16:01.40,Chinese,,0,0,0,,但一般也不会这么写（指第一行缩进和下面的不一样）
Dialogue: 0,0:16:02.48,0:16:07.36,English,,0,0,0,,So anyways the point is there's a comparing the one rule that
Dialogue: 0,0:16:02.48,0:16:07.36,Chinese,,0,0,0,,我们先不管这个格式，这个地方的重点是比较的规则
Dialogue: 0,0:16:07.36,0:16:10.20,English,,0,0,0,,You need to understand about procedures is that
Dialogue: 0,0:16:07.36,0:16:10.20,Chinese,,0,0,0,,你需要知道这里的处理过程是
Dialogue: 0,0:16:10.30,0:16:16.20,English,,0,0,0,,The first argument is passed in register %rdi and the second register %rsi
Dialogue: 0,0:16:10.30,0:16:16.20,Chinese,,0,0,0,,第一个参数用%rdi，第二个参数用%rsi传入
Dialogue: 0,0:16:16.68,0:16:23.10,English,,0,0,0,,And that if I'm going to return a result from a function I do that by storing it and register %rax before I return
Dialogue: 0,0:16:16.68,0:16:23.10,Chinese,,0,0,0,,然后，如果想要返回结果的话，我会把它存到%rax
Dialogue: 0,0:16:24.62,0:16:28.36,English,,0,0,0,,So the first instruction compares these two
Dialogue: 0,0:16:24.62,0:16:28.36,Chinese,,0,0,0,,第一条指令比较这两个数
Dialogue: 0,0:16:28.82,0:16:31.06,English,,0,0,0,,And you notice how I flip the order that
Dialogue: 0,0:16:28.82,0:16:31.06,Chinese,,0,0,0,,你看，我在这里写参数的顺序是反着的
Dialogue: 0,0:16:31.36,0:16:35.66,English,,0,0,0,,It sets %rsi which is y, and %rdi which is x
Dialogue: 0,0:16:31.36,0:16:35.66,Chinese,,0,0,0,,%rsi 代表 y  %rdi 代表 x
Dialogue: 0,0:16:36.48,0:16:39.14,English,,0,0,0,,But when I annotate it I say x to y
Dialogue: 0,0:16:36.48,0:16:39.14,Chinese,,0,0,0,,但是我写的注释写着这是在比较x y
Dialogue: 0,0:16:39.14,0:16:42.16,English,,0,0,0,,So that I mentally am thinking in the order
Dialogue: 0,0:16:39.14,0:16:42.16,Chinese,,0,0,0,,这会使我思考（脑内运算）的顺序是
Dialogue: 0,0:16:42.16,0:16:45.30,English,,0,0,0,,That the actual comparison is made rather than the way they're listed
Dialogue: 0,0:16:42.16,0:16:45.30,Chinese,,0,0,0,,他们的实际顺序，然不是他们的书写顺序
Dialogue: 0,0:16:45.98,0:16:50.04,English,,0,0,0,,So I always do that when I'm looking at code to help me flip those two around
Dialogue: 0,0:16:45.98,0:16:50.04,Chinese,,0,0,0,,所以我总是会这样写个注释来帮助我把它们的顺序反转过来
Dialogue: 0,0:16:52.46,0:16:58.18,English,,0,0,0,,And then here's our instruction.So that compare instruction set these four condition code register
Dialogue: 0,0:16:52.46,0:16:58.18,Chinese,,0,0,0,,第一条指令，比较指令会设置4个标志位
Dialogue: 0,0:16:58.78,0:17:06.58,English,,0,0,0,,And now the setg sets... Now set this single byte register,the lowest byte of %rax to 1
Dialogue: 0,0:16:58.78,0:17:06.58,Chinese,,0,0,0,,接下来的 setg ，如果比较的结果是大于为真
Dialogue: 0,0:17:06.62,0:17:11.00,English,,0,0,0,,If the result was the comparison was greater
Dialogue: 0,0:17:06.62,0:17:11.00,Chinese,,0,0,0,,就会把%rax的低八位设置为1
Dialogue: 0,0:17:12.24,0:17:16.24,English,,0,0,0,,So according to this rule
Dialogue: 0,0:17:12.24,0:17:16.24,Chinese,,0,0,0,,所以根据这条规则
Dialogue: 0,0:17:19.12,0:17:28.52,English,,0,0,0,,And the factor that was to set just as 1 byte of this 8 bytes register to either 0 or 1
Dialogue: 0,0:17:19.12,0:17:28.52,Chinese,,0,0,0,,结果就是，寄存的8个字节里面只有1个被设置成了0或者1
Dialogue: 0,0:17:29.06,0:17:34.86,English,,0,0,0,,Now my problem is that these remaining 7 bytes have whatever happened to be there before
Dialogue: 0,0:17:29.06,0:17:34.86,Chinese,,0,0,0,,现在我的问题是，剩余的7个字节，无论之前的值是什么
Dialogue: 0,0:17:35.34,0:17:36.88,English,,0,0,0,,And I want it to be all zeros
Dialogue: 0,0:17:35.34,0:17:36.88,Chinese,,0,0,0,,我希望它全部为零（我希望他们全部被设置成0）
Dialogue: 0,0:17:37.78,0:17:41.30,English,,0,0,0,,So the the way it does it is a bit weird
Dialogue: 0,0:17:37.78,0:17:41.30,Chinese,,0,0,0,,这个操作看上去有点奇怪
Dialogue: 0,0:17:43.54,0:17:48.26,English,,0,0,0,,There's an instruction called move with zero extension bite too long
Dialogue: 0,0:17:43.54,0:17:48.26,Chinese,,0,0,0,,有一个叫做零扩展传送的指令（move with zero extension - MOVZX），把一个byte扩展到一个long的长度（64位） 高位填充0
Dialogue: 0,0:17:50.84,0:17:53.02,English,,0,0,0,,Now you get to know these better if with time
Dialogue: 0,0:17:50.84,0:17:53.02,Chinese,,0,0,0,,现在，如果有时间的话，你会更好地了解这些
Dialogue: 0,0:17:54.10,0:17:54.82,English,,0,0,0,,Let me um...
Dialogue: 0,0:17:54.10,0:17:54.82,Chinese,,0,0,0,,让我嗯...
Dialogue: 0,0:17:56.24,0:17:57.36,English,,0,0,0,,And what what...
Dialogue: 0,0:17:56.24,0:17:57.36,Chinese,,0,0,0,,那是什么......
Dialogue: 0,0:17:57.62,0:18:01.16,English,,0,0,0,,That means is you can actually copy a byte from any place
Dialogue: 0,0:17:57.62,0:18:01.16,Chinese,,0,0,0,,这意味着实际上可以从任何地方复制一个字节
Dialogue: 0,0:18:01.92,0:18:05.72,English,,0,0,0,,Like the low order or byte of some other register into a new register
Dialogue: 0,0:18:01.92,0:18:05.72,Chinese,,0,0,0,,比如，一个寄存器的低位或字节，复制到（？）另一个寄存器
Dialogue: 0,0:18:06.50,0:18:11.48,English,,0,0,0,,And you'll put zeros to the left of it,that's what they mean by zero extension
Dialogue: 0,0:18:06.50,0:18:11.48,Chinese,,0,0,0,,并且会在它的左边（高位）填充零，这就是零扩展的含义
Dialogue: 0,0:18:12.54,0:18:17.82,English,,0,0,0,,That seems logical but one thing you'll notice is the destination here is %eax
Dialogue: 0,0:18:12.54,0:18:17.82,Chinese,,0,0,0,,这似乎合乎逻辑，但你可能会注意到，这里的目标地址是％eax
Dialogue: 0,0:18:18.68,0:18:21.38,English,,0,0,0,,Which you'll recall although it doesn't show here
Dialogue: 0,0:18:18.68,0:18:21.38,Chinese,,0,0,0,,这里写的并不是我们想设置的%rax
Dialogue: 0,0:18:21.38,0:18:25.76,English,,0,0,0,,That's the lower 32 bits of register %rax
Dialogue: 0,0:18:21.38,0:18:25.76,Chinese,,0,0,0,,%eax只是％rax的低32位
Dialogue: 0,0:18:27.50,0:18:32.62,English,,0,0,0,,And then you'd say well that only got me halfway there right
Dialogue: 0,0:18:27.50,0:18:32.62,Chinese,,0,0,0,,然后你会说行吧（摊手妥协┑(￣Д ￣)┍），这只设置了低32位
Dialogue: 0,0:18:32.62,0:18:35.98,English,,0,0,0,,How do I make sure the upper 32 bits are set to 0
Dialogue: 0,0:18:32.62,0:18:35.98,Chinese,,0,0,0,,我怎么才能把高32位设置为0呢？
Dialogue: 0,0:18:36.58,0:18:44.90,English,,0,0,0,,Well one of the weird quirks of x86-64 is for any computation
Dialogue: 0,0:18:36.58,0:18:44.90,Chinese,,0,0,0,,x86-64一个奇怪的地方是，任何计算
Dialogue: 0,0:18:45.40,0:18:48.96,English,,0,0,0,,Where the result is a 32-bit result
Dialogue: 0,0:18:45.40,0:18:48.96,Chinese,,0,0,0,,哪怕结果是32位的
Dialogue: 0,0:18:49.76,0:18:53.72,English,,0,0,0,,It will add zeros to the remaining 32 bits of the register
Dialogue: 0,0:18:49.76,0:18:53.72,Chinese,,0,0,0,,它也会将0添加到寄存器的其余（高）32位
Dialogue: 0,0:18:55.04,0:18:59.28,English,,0,0,0,,And it's different for example the byte level operations only affect the bytes
Dialogue: 0,0:18:55.04,0:18:59.28,Chinese,,0,0,0,,这是很特殊的地方，例如字节级操作仅影响它操作的字节
Dialogue: 0,0:18:59.52,0:19:07.20,English,,0,0,0,,The two byte or operations like what you'd have if the data type were short
Dialogue: 0,0:18:59.52,0:19:07.20,Chinese,,0,0,0,,就像是你用的指令只操作两个byte的话
Dialogue: 0,0:19:07.66,0:19:09.08,English,,0,0,0,,Only affect those two bytes
Dialogue: 0,0:19:07.66,0:19:09.08,Chinese,,0,0,0,,就只影响那两个字节（这里应该说的是32位指令不会在高位  低23位里面的高位  自动填充零）
Dialogue: 0,0:19:09.72,0:19:13.22,English,,0,0,0,,But the four byte instructions set the upper bytes to 0
Dialogue: 0,0:19:09.72,0:19:13.22,Chinese,,0,0,0,,但是四字节指令会将高位字节设置为0
Dialogue: 0,0:19:13.78,0:19:18.28,English,,0,0,0,,And that was some somebody at AMD and I don't know who it is
Dialogue: 0,0:19:13.78,0:19:18.28,Chinese,,0,0,0,,这是AMD的某些人，我不知道他们是谁
Dialogue: 0,0:19:18.88,0:19:23.40,English,,0,0,0,,Decided this was a good idea and it might be a good idea but it's really confusing
Dialogue: 0,0:19:18.88,0:19:23.40,Chinese,,0,0,0,,认为这样做很好。这可能是一个好的做法，但它确实令人困惑
Dialogue: 0,0:19:24.84,0:19:29.16,English,,0,0,0,,But that's something you'll have to just sort of remember in the back your mind
Dialogue: 0,0:19:24.84,0:19:29.16,Chinese,,0,0,0,,你需要记住的是
Dialogue: 0,0:19:29.16,0:19:30.70,English,,0,0,0,,When you see things like this
Dialogue: 0,0:19:29.16,0:19:30.70,Chinese,,0,0,0,,当你看到这样的写法
Dialogue: 0,0:19:31.80,0:19:37.72,English,,0,0,0,,So the effect of this instruction is to take this one bit result,which is the lower bit of register %rax
Dialogue: 0,0:19:31.80,0:19:37.72,Chinese,,0,0,0,,指令是取低8位的数据，即寄存器％rax的低位
Dialogue: 0,0:19:38.90,0:19:42.06,English,,0,0,0,,Copy it to the same place as it already is
Dialogue: 0,0:19:38.90,0:19:42.06,Chinese,,0,0,0,,将其复制到原来的位置
Dialogue: 0,0:19:42.86,0:19:46.60,English,,0,0,0,,But then set the remaining 7 bytes to 0,which is what we want
Dialogue: 0,0:19:42.86,0:19:46.60,Chinese,,0,0,0,,但它其实会将剩余的7个字节设置为0，这是我们想要的效果
Dialogue: 0,0:19:48.00,0:19:49.88,English,,0,0,0,,So you'll see this pattern quite often
Dialogue: 0,0:19:48.00,0:19:49.88,Chinese,,0,0,0,,你会经常看到这种写法（目标地址32位 实际上高32位会被置0）
Dialogue: 0,0:19:54.62,0:19:55.72,English,,0,0,0,,Question got it
Dialogue: 0,0:19:54.62,0:19:55.72,Chinese,,0,0,0,,（有人要提问吗）理解了吗
Dialogue: 0,0:19:56.62,0:20:00.60,English,,0,0,0,,Okay so now that's sort of sometimes I want to do this
Dialogue: 0,0:19:56.62,0:20:00.60,Chinese,,0,0,0,,好的，现在有时我想这样做
Dialogue: 0,0:20:01.26,0:20:05.36,English,,0,0,0,,I just want to get a one bit flag as a result of the comparison
Dialogue: 0,0:20:01.26,0:20:05.36,Chinese,,0,0,0,,我只想获得作为比较后产生的某一位标志
Dialogue: 0,0:20:06.12,0:20:11.90,English,,0,0,0,,But more generally I want to do something with that information and not just set one bit
Dialogue: 0,0:20:06.12,0:20:11.90,Chinese,,0,0,0,,更一般地说，我想用这些信息做一些事情而不只是设置某个数的一位
Dialogue: 0,0:20:13.08,0:20:18.82,English,,0,0,0,,So the simplest version is what about a conditional  and if and possibly in else
Dialogue: 0,0:20:13.08,0:20:18.82,Chinese,,0,0,0,,比较常见的场景是条件操作，if和有时候有的else（可以只有if的意思）
Dialogue: 0,0:20:20.54,0:20:24.96,English,,0,0,0,,Well that's done by this actually two ways to do it
Dialogue: 0,0:20:20.54,0:20:24.96,Chinese,,0,0,0,,那么实际上有两种实现方式
Dialogue: 0,0:20:24.99,0:20:28.84,English,,0,0,0,,So we'll go through the sort of general purpose traditional way
Dialogue: 0,0:20:24.99,0:20:28.84,Chinese,,0,0,0,,接下来，我们先看一种传统的写法
Dialogue: 0,0:20:29.22,0:20:34.16,English,,0,0,0,,And then we'll show the more specialized newer way and we'll compare those
Dialogue: 0,0:20:29.22,0:20:34.16,Chinese,,0,0,0,,然后我们将展示另一种更专业的实现方式，并比较两种写法的不同
Dialogue: 0,0:20:34.30,0:20:38.30,English,,0,0,0,,So the traditional way is to use what's known as a jump instruction
Dialogue: 0,0:20:34.30,0:20:38.30,Chinese,,0,0,0,,传统的写法是使用所谓的跳转指令
Dialogue: 0,0:20:38.78,0:20:43.26,English,,0,0,0,,And the jump instruction normally instructions execute in a particular order
Dialogue: 0,0:20:38.78,0:20:43.26,Chinese,,0,0,0,,通常的指令是按照确定的顺序去执行的
Dialogue: 0,0:20:43.74,0:20:47.62,English,,0,0,0,,Just like when you're writing a program and you write a series of statements
Dialogue: 0,0:20:43.74,0:20:47.62,Chinese,,0,0,0,,就像你写个程序，代码一行接一行
Dialogue: 0,0:20:48.18,0:20:50.02,English,,0,0,0,,They execute one after the next
Dialogue: 0,0:20:48.18,0:20:50.02,Chinese,,0,0,0,,它们（汇编指令）一个接一个地执行
Dialogue: 0,0:20:51.00,0:20:55.12,English,,0,0,0,,A jump instruction is a way you can go from wherever you are to someplace else
Dialogue: 0,0:20:51.00,0:20:55.12,Chinese,,0,0,0,,跳转指令是您可以从任何地方到其他地方的方式
Dialogue: 0,0:20:55.66,0:21:02.48,English,,0,0,0,,And either skip over some instructions or jump back to some other a previous position or wherever
Dialogue: 0,0:20:55.66,0:21:02.48,Chinese,,0,0,0,,并且要么跳过某些指令，要么跳回到之前的某个位置，或是任何一个位置
Dialogue: 0,0:21:03.44,0:21:08.56,English,,0,0,0,,And there's two kinds of jumps ones that are unconditional whether several kinds
Dialogue: 0,0:21:03.44,0:21:08.56,Chinese,,0,0,0,,跳转指令分两种，一种是无条件跳转
Dialogue: 0,0:21:08.70,0:21:12.56,English,,0,0,0,,But an unconditional jump means when I say jump you jump
Dialogue: 0,0:21:08.70,0:21:12.56,Chinese,,0,0,0,,无条件跳转意味着一定会跳转
Dialogue: 0,0:21:13.58,0:21:17.26,English,,0,0,0,,But there's others conditional jumps that will actually only do that jumping
Dialogue: 0,0:21:13.58,0:21:17.26,Chinese,,0,0,0,,另一种是有条件跳转，只有在某些条件码（标志位）为真的时候
Dialogue: 0,0:21:17.26,0:21:20.08,English,,0,0,0,,If the condition codes are set appropriately
Dialogue: 0,0:21:17.26,0:21:20.08,Chinese,,0,0,0,,才会跳转
Dialogue: 0,0:21:20.58,0:21:24.06,English,,0,0,0,,And you'll see that the names of these jump instructions are the same as
Dialogue: 0,0:21:20.58,0:21:24.06,Chinese,,0,0,0,,你会看到这些跳转指令的名称与
Dialogue: 0,0:21:24.06,0:21:26.24,English,,0,0,0,,The set instructions with the same conditions
Dialogue: 0,0:21:24.06,0:21:26.24,Chinese,,0,0,0,,具有相同条件的设置指令是一样的
Dialogue: 0,0:21:26.92,0:21:33.34,English,,0,0,0,,So there's a variety of different reasons that the program may be given to either jump or not jump
Dialogue: 0,0:21:26.92,0:21:33.34,Chinese,,0,0,0,,因此，有许多不同的原因可以让程序跳转或不跳转
Dialogue: 0,0:21:38.48,0:21:43.00,English,,0,0,0,,So I'm going to use this one example to show you several different versions of it
Dialogue: 0,0:21:38.48,0:21:43.00,Chinese,,0,0,0,,所以我将用这个例子展示它的几个之间的区别
Dialogue: 0,0:21:43.76,0:21:49.30,English,,0,0,0,,And like everything you'll see here these particular programs aren't that useful
Dialogue: 0,0:21:43.76,0:21:49.30,Chinese,,0,0,0,,你看到的这个程序可能存在一些问题
Dialogue: 0,0:21:49.30,0:21:51.54,English,,0,0,0,,But they illustrate ideas
Dialogue: 0,0:21:49.30,0:21:51.54,Chinese,,0,0,0,,但是用来说明几个跳转指令之间的不同是足够的
Dialogue: 0,0:21:52.24,0:22:00.84,English,,0,0,0,,So imagine I wanted to compute the the difference of two values and then take their absolute value
Dialogue: 0,0:21:52.24,0:22:00.84,Chinese,,0,0,0,,所以想象一下，我想计算两个值的差值然后取其绝对值
Dialogue: 0,0:22:01.78,0:22:04.40,English,,0,0,0,,So there's various ways you can imagine doing it
Dialogue: 0,0:22:01.78,0:22:04.40,Chinese,,0,0,0,,所以有各种各样的方法可以实现这个
Dialogue: 0,0:22:04.40,0:22:09.48,English,,0,0,0,,By the way I'm going to do it is decide to either subtract y from x or x from y
Dialogue: 0,0:22:04.40,0:22:09.48,Chinese,,0,0,0,,总的来说，我需要做的就是从x中减去y或从y减去x
Dialogue: 0,0:22:09.48,0:22:12.38,English,,0,0,0,,Depending on the relative values of those two
Dialogue: 0,0:22:09.48,0:22:12.38,Chinese,,0,0,0,,然后取绝对值
Dialogue: 0,0:22:12.96,0:22:16.20,English,,0,0,0,,And of course the astute observer will notice that
Dialogue: 0,0:22:12.96,0:22:16.20,Chinese,,0,0,0,,当然，有些机智的人会注意到
Dialogue: 0,0:22:17.20,0:22:20.68,English,,0,0,0,,This has problems if you have a team in somewhere
Dialogue: 0,0:22:17.20,0:22:20.68,Chinese,,0,0,0,,（？）
Dialogue: 0,0:22:22.10,0:22:26.22,English,,0,0,0,,If the result because there's no absolute value but we're not going to worry about that
Dialogue: 0,0:22:22.10,0:22:26.22,Chinese,,0,0,0,,（？）
Dialogue: 0,0:22:27.70,0:22:29.86,English,,0,0,0,,Um...so...
Dialogue: 0,0:22:27.70,0:22:29.86,Chinese,,0,0,0,,嗯...所以...
Dialogue: 0,0:22:30.16,0:22:34.56,English,,0,0,0,,In other words I just want to say if x is greater than y, then I want to subtract y from x
Dialogue: 0,0:22:30.16,0:22:34.56,Chinese,,0,0,0,,换句话说，我想表达的就是，如果x大于y，那么从x中减去y
Dialogue: 0,0:22:35.34,0:22:38.60,English,,0,0,0,,And if x is less than or equal to y, I want to subtract x from y
Dialogue: 0,0:22:35.34,0:22:38.60,Chinese,,0,0,0,,如果x小于或等于y，就从y中减去x
Dialogue: 0,0:22:39.74,0:22:44.86,English,,0,0,0,,And here's the code for it where the blue and the red or color coding the different parts of it
Dialogue: 0,0:22:39.74,0:22:44.86,Chinese,,0,0,0,,这里是代码，蓝色和红色来区分不同的分支
Dialogue: 0,0:22:45.76,0:22:51.38,English,,0,0,0,,So here you see the compare instruction and again I've written them out
Dialogue: 0,0:22:45.76,0:22:51.38,Chinese,,0,0,0,,你可以看到，在这里的比较指令，我再次把实际的比较顺序
Dialogue: 0,0:22:53.44,0:22:58.04,English,,0,0,0,,In the reverse order to help me keep track of what the comparison is
Dialogue: 0,0:22:53.44,0:22:58.04,Chinese,,0,0,0,,写了出来，这有助于我们的理解
Dialogue: 0,0:22:58.52,0:23:03.60,English,,0,0,0,,And it says I'm going to compare x and y and if x is less than or equal to y
Dialogue: 0,0:22:58.52,0:23:03.60,Chinese,,0,0,0,,它（注释）说我要比较x和y以及x是否小于或等于y
Dialogue: 0,0:23:03.74,0:23:08.68,English,,0,0,0,,I want to jump to a location specified by this label l4
Dialogue: 0,0:23:03.74,0:23:08.68,Chinese,,0,0,0,,我想跳转到这个标签l4指定的位置
Dialogue: 0,0:23:09.40,0:23:13.68,English,,0,0,0,,And so in general in assembly code if you give a name and then a colon
Dialogue: 0,0:23:09.40,0:23:13.68,Chinese,,0,0,0,,通常在汇编代码中，如果一个名称后面跟着一个冒号
Dialogue: 0,0:23:13.98,0:23:17.24,English,,0,0,0,,What's to the left of that is called a label
Dialogue: 0,0:23:13.98,0:23:17.24,Chinese,,0,0,0,,那么这个东西叫做标签（label）
Dialogue: 0,0:23:17.62,0:23:23.50,English,,0,0,0,,And it's just a tag that it's only visible in the assembly code, it's not actually in the object code
Dialogue: 0,0:23:17.62,0:23:23.50,Chinese,,0,0,0,,它只是一个标签，它只能在汇编代码中看到，它实际上并不在目标代码中
Dialogue: 0,0:23:24.10,0:23:32.16,English,,0,0,0,,That will later I'll be used to compute an address for determining that will encode
Dialogue: 0,0:23:24.10,0:23:32.16,Chinese,,0,0,0,,稍后我将用它来标识一个 跳转指令要跳转到的
Dialogue: 0,0:23:32.16,0:23:34.62,English,,0,0,0,,Where this jump will actually land
Dialogue: 0,0:23:32.16,0:23:34.62,Chinese,,0,0,0,,编译后的地址
Dialogue: 0,0:23:35.44,0:23:36.86,English,,0,0,0,,When you're looking at assembly code
Dialogue: 0,0:23:35.44,0:23:36.86,Chinese,,0,0,0,,当你在看汇编代码时
Dialogue: 0,0:23:36.86,0:23:43.90,English,,0,0,0,,One of the features it provides is a little bit easier way to understand it then to look at addresses
Dialogue: 0,0:23:36.86,0:23:43.90,Chinese,,0,0,0,,标签提供的功能之一是，更简单的标识一个地址
Dialogue: 0,0:23:44.32,0:23:49.00,English,,0,0,0,,And so it just tells you to be looking at that the jump would occur to this position
Dialogue: 0,0:23:44.32,0:23:49.00,Chinese,,0,0,0,,所以它只是告诉你可能会跳转到这个地方
Dialogue: 0,0:23:50.58,0:23:52.78,English,,0,0,0,,And what you'll see here is
Dialogue: 0,0:23:50.58,0:23:52.78,Chinese,,0,0,0,,你在这里看到的是
Dialogue: 0,0:23:53.76,0:23:57.02,English,,0,0,0,,The in these two branches the blue code versus the red
Dialogue: 0,0:23:53.76,0:23:57.02,Chinese,,0,0,0,,蓝色代码与红色代码对应了不同的分支
Dialogue: 0,0:23:57.02,0:24:01.74,English,,0,0,0,,What you're doing is in one case subtracting y from x
Dialogue: 0,0:23:57.02,0:24:01.74,Chinese,,0,0,0,,你正在做的是在一种情况下，从x中减去y
Dialogue: 0,0:24:03.14,0:24:08.16,English,,0,0,0,,Here you move x into our ax and you subtract y from it
Dialogue: 0,0:24:03.14,0:24:08.16,Chinese,,0,0,0,,在这里你将x移动到%rax中，然后从中减去y
Dialogue: 0,0:24:08.74,0:24:12.36,English,,0,0,0,,And here you do the opposite you're subtracting x from y
Dialogue: 0,0:24:08.74,0:24:12.36,Chinese,,0,0,0,,在这里你做的和刚才相反，你从y减去x
Dialogue: 0,0:24:13.74,0:24:17.60,English,,0,0,0,,And in this case
Dialogue: 0,0:24:13.74,0:24:17.60,Chinese,,0,0,0,,在这种情况下
Dialogue: 0,0:24:17.78,0:24:23.12,English,,0,0,0,,So in the first case,you'll make the jump if x is less than or equal to y
Dialogue: 0,0:24:17.78,0:24:23.12,Chinese,,0,0,0,,所以在第一种情况下，如果x小于或等于y，你将进行跳转
Dialogue: 0,0:24:23.74,0:24:27.52,English,,0,0,0,,You'll compact y from x and you'll do a return
Dialogue: 0,0:24:23.74,0:24:27.52,Chinese,,0,0,0,,y-x，然后返回
Dialogue: 0,0:24:27.72,0:24:33.50,English,,0,0,0,,And you remember that I don't have to do anything special to return a value back from a function
Dialogue: 0,0:24:27.72,0:24:33.50,Chinese,,0,0,0,,而且你应该记得，如果要从一个函数中返回一个值，我们并不需要做特殊的操作
Dialogue: 0,0:24:33.50,0:24:36.36,English,,0,0,0,,All I have to do the stick register %rax
Dialogue: 0,0:24:33.50,0:24:36.36,Chinese,,0,0,0,,我们需要做的只有将返回值保存到%rax
Dialogue: 0,0:24:36.78,0:24:39.96,English,,0,0,0,,And calling function will know that's where to find the return value
Dialogue: 0,0:24:36.78,0:24:39.96,Chinese,,0,0,0,,然后调用函数就会知道在哪里找到返回值
Dialogue: 0,0:24:41.04,0:24:42.66,English,,0,0,0,,So here does a ret
Dialogue: 0,0:24:41.04,0:24:42.66,Chinese,,0,0,0,,所以这里有一个ret
Dialogue: 0,0:24:42.98,0:24:47.50,English,,0,0,0,,And here it does the subtraction and it simply does a return directly from that part of it
Dialogue: 0,0:24:42.98,0:24:47.50,Chinese,,0,0,0,,在这里，它做了一次减法，然后简单的调用了ret就直接返回了
Dialogue: 0,0:24:50.84,0:24:53.62,English,,0,0,0,,So it's a pretty straightforward piece of code
Dialogue: 0,0:24:50.84,0:24:53.62,Chinese,,0,0,0,,所以这是一段相当简单的代码
Dialogue: 0,0:24:53.62,0:25:00.82,English,,0,0,0,,But you can see it's using this jumping to create two different parts of code that get executed
Dialogue: 0,0:24:53.62,0:25:00.82,Chinese,,0,0,0,,但是你可以看到它使用了跳转来实现，在不同的条件下
Dialogue: 0,0:25:01.10,0:25:02.86,English,,0,0,0,,Under different conditions
Dialogue: 0,0:25:01.10,0:25:02.86,Chinese,,0,0,0,,执行不同的代码片段
Dialogue: 0,0:25:03.08,0:25:14.06,English,,0,0,0,,Question ?what's that ?i'm sorry I didn't hear you
Dialogue: 0,0:25:03.08,0:25:14.06,Chinese,,0,0,0,,有什么问题吗？对不起，我没有听到你的声音
Dialogue: 0,0:25:14.16,0:25:18.79,English,,0,0,0,,Oh well there's a couple things one is you want the result to end up in %rax
Dialogue: 0,0:25:14.16,0:25:18.79,Chinese,,0,0,0,,哦，为什么结果会保存在%rax？
Dialogue: 0,0:25:19.62,0:25:25.98,English,,0,0,0,,Right and remember the subtract instructions...all the two argument instructions
Dialogue: 0,0:25:19.62,0:25:25.98,Chinese,,0,0,0,,记住，减法指令，所有的两操作数指令
Dialogue: 0,0:25:27.14,0:25:35.18,English,,0,0,0,,There that you take two values and then you the one this,second argument the destination argument
Dialogue: 0,0:25:27.14,0:25:35.18,Chinese,,0,0,0,,会有两个操作数，第二个参数同时也是目标地址
Dialogue: 0,0:25:35.66,0:25:38.00,English,,0,0,0,,You overwrite what was there with the new result
Dialogue: 0,0:25:35.66,0:25:38.00,Chinese,,0,0,0,,它的值会被结果覆盖掉
Dialogue: 0,0:25:38.88,0:25:41.36,English,,0,0,0,,So this is a pretty typical pattern you'll see
Dialogue: 0,0:25:38.88,0:25:41.36,Chinese,,0,0,0,,所以这是一个非常典型的模式，你会看到
Dialogue: 0,0:25:41.86,0:25:48.46,English,,0,0,0,,You move some value into a register and then you into %rax is very common
Dialogue: 0,0:25:41.86,0:25:48.46,Chinese,,0,0,0,,你将一些值移动到一个寄存器中，然后你进入％rax很常见
Dialogue: 0,0:25:48.74,0:25:55.52,English,,0,0,0,,And then you do some arithmetic operation with that register as a destination to kind of update it
Dialogue: 0,0:25:48.74,0:25:55.52,Chinese,,0,0,0,,然后，您使用该寄存器进行一些算术运算作为更新它的目的地
Dialogue: 0,0:25:57.10,0:26:00.88,English,,0,0,0,,If it's like if you're writing in C if all the time you had to write sort of
Dialogue: 0,0:25:57.10,0:26:00.88,Chinese,,0,0,0,,如果你在C语言写作，如果所有的时间你必须写的那样
Dialogue: 0,0:26:01.30,0:26:03.08,English,,0,0,0,,X plus equals something...
Dialogue: 0,0:26:01.30,0:26:03.08,Chinese,,0,0,0,,X加等于某事......
Dialogue: 0,0:26:03.08,0:26:08.68,English,,0,0,0,,X minus equals and that all your arithmetic had to be expressed in those terms
Dialogue: 0,0:26:03.08,0:26:08.68,Chinese,,0,0,0,,X减去等于并且所有算术都必须用这些术语表示
Dialogue: 0,0:26:13.30,0:26:15.66,English,,0,0,0,,Okay so...
Dialogue: 0,0:26:13.30,0:26:15.66,Chinese,,0,0,0,,可以，然后呢...
Dialogue: 0,0:26:16.10,0:26:21.39,English,,0,0,0,,It's fun to look at assembly code for about five minutes and then you get sick of it
Dialogue: 0,0:26:16.10,0:26:21.39,Chinese,,0,0,0,,看待汇编代码大约五分钟然后你就厌倦了它很有趣
Dialogue: 0,0:26:22.04,0:26:25.76,English,,0,0,0,,So one thing to sort of present these same ideas
Dialogue: 0,0:26:22.04,0:26:25.76,Chinese,,0,0,0,,因此有一点可以提出这些相同的想法
Dialogue: 0,0:26:25.76,0:26:31.42,English,,0,0,0,,But give it in a little bit more abstract form is to write it in C
Dialogue: 0,0:26:25.76,0:26:31.42,Chinese,,0,0,0,,但是以更抽象的形式给它是用C写的
Dialogue: 0,0:26:31.76,0:26:34.78,English,,0,0,0,,But in a form of C that looks a lot like assembly code
Dialogue: 0,0:26:31.76,0:26:34.78,Chinese,,0,0,0,,但是在C形式中看起来很像汇编代码
Dialogue: 0,0:26:35.48,0:26:38.18,English,,0,0,0,,And in particular one of the features of C
Dialogue: 0,0:26:35.48,0:26:38.18,Chinese,,0,0,0,,特别是C的一个特点
Dialogue: 0,0:26:38.18,0:26:44.18,English,,0,0,0,,That is not generally advertised is there's a statement called goto
Dialogue: 0,0:26:38.18,0:26:44.18,Chinese,,0,0,0,,通常没有公布的是有一个名为goto的声明
Dialogue: 0,0:26:45.36,0:26:47.44,English,,0,0,0,,And you can put labels in your code
Dialogue: 0,0:26:45.36,0:26:47.44,Chinese,,0,0,0,,您可以在代码中添加标签
Dialogue: 0,0:26:52.26,0:26:55.16,English,,0,0,0,,And you can tell the program
Dialogue: 0,0:26:52.26,0:26:55.16,Chinese,,0,0,0,,你可以告诉程序
Dialogue: 0,0:26:55.16,0:26:59.02,English,,0,0,0,,That if something happens then you want to jump to that part of the program
Dialogue: 0,0:26:55.16,0:26:59.02,Chinese,,0,0,0,,如果发生了某些事情，那么你想跳到程序的那一部分
Dialogue: 0,0:26:59.88,0:27:02.10,English,,0,0,0,,So it looks a lot like that assembly code right
Dialogue: 0,0:26:59.88,0:27:02.10,Chinese,,0,0,0,,所以它看起来很像汇编代码
Dialogue: 0,0:27:02.26,0:27:07.02,English,,0,0,0,,That you saw jump jle instead of what this says
Dialogue: 0,0:27:02.26,0:27:07.02,Chinese,,0,0,0,,你看到跳跃jle而不是这说的
Dialogue: 0,0:27:07.50,0:27:10.64,English,,0,0,0,,It's like I'm doing a test
Dialogue: 0,0:27:07.50,0:27:10.64,Chinese,,0,0,0,,这就像我在做一个测试
Dialogue: 0,0:27:10.92,0:27:16.42,English,,0,0,0,,And then if the test is which in this case I call it end test because it's the opposite of the test
Dialogue: 0,0:27:10.92,0:27:16.42,Chinese,,0,0,0,,然后，如果测试是在这种情况下我称之为结束测试，因为它与测试相反
Dialogue: 0,0:27:17.00,0:27:18.42,English,,0,0,0,,That's in the original program
Dialogue: 0,0:27:17.00,0:27:18.42,Chinese,,0,0,0,,这是在原始计划中
Dialogue: 0,0:27:19.34,0:27:24.84,English,,0,0,0,,And if that end test condition holds I want to jump to another part of the program I'm calling else
Dialogue: 0,0:27:19.34,0:27:24.84,Chinese,,0,0,0,,如果那个结束测试条件成立，我想跳到程序的另一部分，我正在调用其他
Dialogue: 0,0:27:25.98,0:27:32.14,English,,0,0,0,,And you notice I uppercase that because it's not the actual else of a if-then-else
Dialogue: 0,0:27:25.98,0:27:32.14,Chinese,,0,0,0,,而且你注意到我是大写的，因为它不是if-then-else的实际其他内容
Dialogue: 0,0:27:33.28,0:27:35.92,English,,0,0,0,,And same way if this one is well...
Dialogue: 0,0:27:33.28,0:27:35.92,Chinese,,0,0,0,,同样的，如果这个很好......
Dialogue: 0,0:27:38.12,0:27:42.24,English,,0,0,0,,Actually to be most accurate I should have simply said return result from this point
Dialogue: 0,0:27:38.12,0:27:42.24,Chinese,,0,0,0,,实际上，为了最准确，我应该简单地说从这一点返回结果
Dialogue: 0,0:27:43.80,0:27:45.64,English,,0,0,0,,This codes a little bit out a day
Dialogue: 0,0:27:43.80,0:27:45.64,Chinese,,0,0,0,,这个代码有一天了
Dialogue: 0,0:27:46.92,0:27:48.62,English,,0,0,0,,So I should have said return result
Dialogue: 0,0:27:46.92,0:27:48.62,Chinese,,0,0,0,,所以我应该说回报结果
Dialogue: 0,0:27:49.06,0:27:53.78,English,,0,0,0,,But another version would be to have done a goto down to here and return the result from there
Dialogue: 0,0:27:49.06,0:27:53.78,Chinese,,0,0,0,,但另一个版本是在这里完成转到并从那里返回结果
Dialogue: 0,0:27:54.40,0:27:56.82,English,,0,0,0,,And you'll see different compilers generate in different forms
Dialogue: 0,0:27:54.40,0:27:56.82,Chinese,,0,0,0,,你会看到不同的编译器以不同的形式生成
Dialogue: 0,0:27:58.66,0:28:02.30,English,,0,0,0,,So I'm going to typically use this way of presenting code
Dialogue: 0,0:27:58.66,0:28:02.30,Chinese,,0,0,0,,所以我通常会使用这种呈现代码的方式
Dialogue: 0,0:28:02.58,0:28:08.14,English,,0,0,0,,Just so that you can look at and understand what these control structures look like
Dialogue: 0,0:28:02.58,0:28:08.14,Chinese,,0,0,0,,这样您就可以查看并了解这些控制结构的外观
Dialogue: 0,0:28:08.50,0:28:13.96,English,,0,0,0,,Without having to sort of scrutinize the low-level assembly code instructions
Dialogue: 0,0:28:08.50,0:28:13.96,Chinese,,0,0,0,,无需仔细检查低级汇编代码指令
Dialogue: 0,0:28:17.14,0:28:18.48,English,,0,0,0,,So we consider take this...
Dialogue: 0,0:28:17.14,0:28:18.48,Chinese,,0,0,0,,我们考虑把这个作为
Dialogue: 0,0:28:18.60,0:28:19.15,English,,0,0,0,,Questions
Dialogue: 0,0:28:18.60,0:28:19.15,Chinese,,0,0,0,,请说
Dialogue: 0,0:28:19.34,0:28:26.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:28:19.34,0:28:26.74,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:28:26.74,0:28:30.60,English,,0,0,0,,Yeah I think there's a homework or a practice problem of exactly that sort
Dialogue: 0,0:28:26.74,0:28:30.60,Chinese,,0,0,0,,是的，我认为这是一个完整的家庭作业或练习题
Dialogue: 0,0:28:30.84,0:28:33.46,English,,0,0,0,,So in general you could do it neither way and
Dialogue: 0,0:28:30.84,0:28:33.46,Chinese,,0,0,0,,一般来说这里有两种做法
Dialogue: 0,0:28:33.60,0:28:38.16,English,,0,0,0,,Why the compiler picks one versus the other is, I think it's a completely arbitrary decision
Dialogue: 0,0:28:33.60,0:28:38.16,Chinese,,0,0,0,,为什么编译器选择一个而不是另一个，我认为这是谁随便决定的（？）
Dialogue: 0,0:28:39.04,0:28:41.66,English,,0,0,0,,But consistently I found GCC does it this way
Dialogue: 0,0:28:39.04,0:28:41.66,Chinese,,0,0,0,,但我发现GCC始终这么做（指ppt上写的）
Dialogue: 0,0:28:45.62,0:28:52.40,English,,0,0,0,,Okay so let's sort of talking sort of imagine you're writing a compiler
Dialogue: 0,0:28:45.62,0:28:52.40,Chinese,,0,0,0,,假设我们正在写一个编译器
Dialogue: 0,0:28:52.40,0:28:55.90,English,,0,0,0,,How would you take this special case I just showed
Dialogue: 0,0:28:52.40,0:28:55.90,Chinese,,0,0,0,,你会怎么处理我刚才展示的这个特例
Dialogue: 0,0:28:56.12,0:29:02.14,English,,0,0,0,,And generalize it into a rule for compiling if-then-else expressions
Dialogue: 0,0:28:56.12,0:29:02.14,Chinese,,0,0,0,,并将其抽象为编译if-then-else表达式的规则
Dialogue: 0,0:29:02.70,0:29:07.64,English,,0,0,0,,And I'm going to use the version of in see the question mark :version
Dialogue: 0,0:29:02.70,0:29:07.64,Chinese,,0,0,0,,我将使用in的版本看问号：版本
Dialogue: 0,0:29:07.64,0:29:14.30,English,,0,0,0,,Where you kind of encapsulate that whole conditional is a single expression rather than the statement
Dialogue: 0,0:29:07.64,0:29:14.30,Chinese,,0,0,0,,有点像是，封装整个条件是单个表达式而不是语句
Dialogue: 0,0:29:14.30,0:29:18.22,English,,0,0,0,,But you can understand that these rules would be the same in either case
Dialogue: 0,0:29:14.30,0:29:18.22,Chinese,,0,0,0,,但是你可以理解这些规则在任何一种情况下都是相同的
Dialogue: 0,0:29:18.98,0:29:23.00,English,,0,0,0,,So imagine in general you had a C code
Dialogue: 0,0:29:18.98,0:29:23.00,Chinese,,0,0,0,,所以想象一下你有一个C代码
Dialogue: 0,0:29:23.00,0:29:29.14,English,,0,0,0,,Where there's a test controlling whether to return the result of one expression or another
Dialogue: 0,0:29:23.00,0:29:29.14,Chinese,,0,0,0,,哪里有测试控制是否返回一个或另一个表达式的结果
Dialogue: 0,0:29:30.32,0:29:35.96,English,,0,0,0,,And this is what my abs diff code would look like if I wrote it in that form
Dialogue: 0,0:29:30.32,0:29:35.96,Chinese,,0,0,0,,这就是我的abs diff代码，如果我以这种形式编写的话
Dialogue: 0,0:29:37.76,0:29:39.78,English,,0,0,0,,And so in general what we can say is
Dialogue: 0,0:29:37.76,0:29:39.78,Chinese,,0,0,0,,总的来说，我们可以说的是
Dialogue: 0,0:29:41.18,0:29:46.54,English,,0,0,0,,What we'll do is we'll compete well take the test and invert it
Dialogue: 0,0:29:41.18,0:29:46.54,Chinese,,0,0,0,,我们要做的就是参加比赛并将其反转
Dialogue: 0,0:29:47.42,0:29:52.64,English,,0,0,0,,And say if that test is not true then we will ...
Dialogue: 0,0:29:47.42,0:29:52.64,Chinese,,0,0,0,,并说如果那个测试不是真的那么我们会......
Dialogue: 0,0:29:56.14,0:30:01.92,English,,0,0,0,,So if n test is true,then we will jump to some part of the code
Dialogue: 0,0:29:56.14,0:30:01.92,Chinese,,0,0,0,,因此，如果n test为true，那么我们将跳转到代码的某些部分
Dialogue: 0,0:30:01.92,0:30:05.20,English,,0,0,0,,Where we've compiled the code for the else expression(Else_Expr)
Dialogue: 0,0:30:01.92,0:30:05.20,Chinese,,0,0,0,,我们编译了else表达式的代码（Else_Expr）
Dialogue: 0,0:30:06.02,0:30:11.64,English,,0,0,0,,And if it that test fails here, so that the original test condition holds
Dialogue: 0,0:30:06.02,0:30:11.64,Chinese,,0,0,0,,如果测试失败，那么原始测试条件成立
Dialogue: 0,0:30:12.38,0:30:18.78,English,,0,0,0,,Then we'll stick in whatever code it takes to to compute the then expression(Then_Expr)
Dialogue: 0,0:30:12.38,0:30:18.78,Chinese,,0,0,0,,然后我们将坚持使用任何代码来计算then表达式（Then_Expr）
Dialogue: 0,0:30:19.34,0:30:24.12,English,,0,0,0,,And then we'll merge back together in the case you saw where it's just a single little function
Dialogue: 0,0:30:19.34,0:30:24.12,Chinese,,0,0,0,,然后，在你看到它只是一个小函数的情况下，我们将合并回来
Dialogue: 0,0:30:24.46,0:30:27.24,English,,0,0,0,,We can just call a rep here and get out of the thing
Dialogue: 0,0:30:24.46,0:30:27.24,Chinese,,0,0,0,,我们可以在这里打电话给代表，然后退出
Dialogue: 0,0:30:27.66,0:30:32.18,English,,0,0,0,,But if this is one line of code then there's a whole bunch of lines after that
Dialogue: 0,0:30:27.66,0:30:32.18,Chinese,,0,0,0,,但如果这是一行代码，那么之后会有一大堆行
Dialogue: 0,0:30:32.66,0:30:36.04,English,,0,0,0,,Typically you want to merge back together again and continue from there
Dialogue: 0,0:30:32.66,0:30:36.04,Chinese,,0,0,0,,通常，您希望再次合并在一起并从那里继续
Dialogue: 0,0:30:36.38,0:30:42.08,English,,0,0,0,,And so that's what this show is all I'll finish by going to whatever comes afterwards
Dialogue: 0,0:30:36.38,0:30:42.08,Chinese,,0,0,0,,所以这就是这个节目的全部内容，我将通过随后的任何事情来完成
Dialogue: 0,0:30:43.46,0:30:48.78,English,,0,0,0,,So this is a way I like to you know,although we're not writing compilers in this course
Dialogue: 0,0:30:43.46,0:30:48.78,Chinese,,0,0,0,,所以这是我喜欢的一种方式，虽然我们不是在编写本课程的编译器
Dialogue: 0,0:30:48.78,0:30:52.48,English,,0,0,0,,I think it helps to to think in terms of general rules
Dialogue: 0,0:30:48.78,0:30:52.48,Chinese,,0,0,0,,我认为从一般规则来考虑是有帮助的
Dialogue: 0,0:30:52.98,0:30:57.00,English,,0,0,0,,Of how a compiler would translate C code into assembly code
Dialogue: 0,0:30:52.98,0:30:57.00,Chinese,,0,0,0,,编译器如何将C代码转换为汇编代码
Dialogue: 0,0:30:57.50,0:31:02.46,English,,0,0,0,,So that when you see that assembly code you'll recognize these patterns and know what they mean
Dialogue: 0,0:30:57.50,0:31:02.46,Chinese,,0,0,0,,因此，当您看到汇编代码时，您将识别这些模式并知道它们的含义
Dialogue: 0,0:31:02.58,0:31:08.86,English,,0,0,0,,Question....goes to the else clause doesn't like fall through to the john.Yes yes
Dialogue: 0,0:31:02.58,0:31:08.86,Chinese,,0,0,0,,问题....转到else子句不喜欢落到约翰。是的
Dialogue: 0,0:31:09.88,0:31:15.24,English,,0,0,0,,So just as we saw yes in general what like here
Dialogue: 0,0:31:09.88,0:31:15.24,Chinese,,0,0,0,,就像我们在一般情况下看到的一样，就像这里一样
Dialogue: 0,0:31:15.60,0:31:19.42,English,,0,0,0,,It would fall through to the done, good question
Dialogue: 0,0:31:15.60,0:31:19.42,Chinese,,0,0,0,,它会落到完成的好问题上
Dialogue: 0,0:31:23.44,0:31:27.96,English,,0,0,0,,Okay so that's one version of a conditional and that's the most general way
Dialogue: 0,0:31:23.44,0:31:27.96,Chinese,,0,0,0,,好的，这是条件的一个版本，这是最通用的方式
Dialogue: 0,0:31:27.96,0:31:30.08,English,,0,0,0,,And the way it used to always be done
Dialogue: 0,0:31:27.96,0:31:30.08,Chinese,,0,0,0,,以及过去常常做的方式
Dialogue: 0,0:31:30.92,0:31:35.24,English,,0,0,0,,But there's another approach that you'll see fairly common in code
Dialogue: 0,0:31:30.92,0:31:35.24,Chinese,,0,0,0,,但是你会看到另一种在代码中相当常见的方法
Dialogue: 0,0:31:35.38,0:31:38.90,English,,0,0,0,,It's sort of an optimization called conditional move
Dialogue: 0,0:31:35.38,0:31:38.90,Chinese,,0,0,0,,这是一种称为条件移动的优化
Dialogue: 0,0:31:40.06,0:31:45.50,English,,0,0,0,,And it's bit non-intuitive from a software developer's perspective why you'd ever want to do this
Dialogue: 0,0:31:40.06,0:31:45.50,Chinese,,0,0,0,,从软件开发人员的角度来看，为什么你想要这样做，这有点不直观
Dialogue: 0,0:31:46.04,0:31:51.40,English,,0,0,0,,The basic idea is I'm going to compute both the then and the else the values they'd produce
Dialogue: 0,0:31:46.04,0:31:51.40,Chinese,,0,0,0,,基本的想法是我要计算它们产生的值和其他值
Dialogue: 0,0:31:52.12,0:31:54.62,English,,0,0,0,,And only after that I choose which one I use
Dialogue: 0,0:31:52.12,0:31:54.62,Chinese,,0,0,0,,然后我才会选择使用哪一个
Dialogue: 0,0:31:55.62,0:31:59.94,English,,0,0,0,,So it seems wasteful but it actually turns out to be more efficient
Dialogue: 0,0:31:55.62,0:31:59.94,Chinese,,0,0,0,,所以看起来很浪费但事实证明它更有效率
Dialogue: 0,0:32:00.50,0:32:03.06,English,,0,0,0,,If there are fairly simple computations
Dialogue: 0,0:32:00.50,0:32:03.06,Chinese,,0,0,0,,如果有相当简单的计算
Dialogue: 0,0:32:03.60,0:32:08.80,English,,0,0,0,,And the reason of that is and we'll see a little bit more when we talk about performance optimization
Dialogue: 0,0:32:03.60,0:32:08.80,Chinese,,0,0,0,,原因是，当我们谈论性能优化时，我们会看到更多
Dialogue: 0,0:32:09.44,0:32:15.32,English,,0,0,0,,A modern processor is a little like an oil tanker sailing in the sea
Dialogue: 0,0:32:09.44,0:32:15.32,Chinese,,0,0,0,,现代处理器有点像在海上航行的油轮
Dialogue: 0,0:32:15.62,0:32:19.26,English,,0,0,0,,Meaning that it plows along in a certain direction
Dialogue: 0,0:32:15.62,0:32:19.26,Chinese,,0,0,0,,这意味着它在某个方向上犁过
Dialogue: 0,0:32:19.62,0:32:23.40,English,,0,0,0,,And it really is hard to get it to stop or to turn
Dialogue: 0,0:32:19.62,0:32:23.40,Chinese,,0,0,0,,它真的很难让它停下来或转向
Dialogue: 0,0:32:24.64,0:32:27.64,English,,0,0,0,,So that's you say what are you talking about but
Dialogue: 0,0:32:24.64,0:32:27.64,Chinese,,0,0,0,,那就是你说的是你在说什么但是
Dialogue: 0,0:32:28.46,0:32:34.70,English,,0,0,0,,Think of an instruction sequences you know the ocean of code  that you're cruising through
Dialogue: 0,0:32:28.46,0:32:34.70,Chinese,,0,0,0,,想想你知道你正在巡航的代码海洋的指令序列
Dialogue: 0,0:32:35.14,0:32:39.20,English,,0,0,0,,And these things can just fly through a straight sequence of code
Dialogue: 0,0:32:35.14,0:32:39.20,Chinese,,0,0,0,,而这些东西可以直接通过一系列代码
Dialogue: 0,0:32:39.70,0:32:43.16,English,,0,0,0,,Because they are they do what they call pipelining
Dialogue: 0,0:32:39.70,0:32:43.16,Chinese,,0,0,0,,因为他们是他们所谓的流水线
Dialogue: 0,0:32:43.16,0:32:47.48,English,,0,0,0,,Meaning they start bringing in parts of one instruction before they're done with the next
Dialogue: 0,0:32:43.16,0:32:47.48,Chinese,,0,0,0,,这意味着他们在完成下一个指令之前就开始引入一个指令的一部分
Dialogue: 0,0:32:47.72,0:32:51.72,English,,0,0,0,,And actually go up to depths of 20 or more instructions deep of
Dialogue: 0,0:32:47.72,0:32:51.72,Chinese,,0,0,0,,实际上深达20或更深的指令深度
Dialogue: 0,0:32:52.46,0:32:57.32,English,,0,0,0,,How far had they're working sort of fetching forward and future instructions
Dialogue: 0,0:32:52.46,0:32:57.32,Chinese,,0,0,0,,他们在多大程度上取得了前进和未来的指示
Dialogue: 0,0:32:57.70,0:32:59.94,English,,0,0,0,,While finishing up the ones that still remain
Dialogue: 0,0:32:57.70,0:32:59.94,Chinese,,0,0,0,,在完成仍然存在的那些
Dialogue: 0,0:33:00.32,0:33:03.36,English,,0,0,0,,So that's my ocean line or my tanker analogy
Dialogue: 0,0:33:00.32,0:33:03.36,Chinese,,0,0,0,,这就是我的海洋线或我的油轮类比
Dialogue: 0,0:33:04.32,0:33:08.14,English,,0,0,0,,But all of a sudden you come and then what happens when they hit a branch
Dialogue: 0,0:33:04.32,0:33:08.14,Chinese,,0,0,0,,但突然之间你会来，然后当他们到达一个分支时会发生什么
Dialogue: 0,0:33:09.24,0:33:12.00,English,,0,0,0,,They'll try to guess it's called branch prediction
Dialogue: 0,0:33:09.24,0:33:12.00,Chinese,,0,0,0,,他们会试着猜测它被称为分支预测
Dialogue: 0,0:33:12.46,0:33:15.68,English,,0,0,0,,And guess where is this kind of branch going to go
Dialogue: 0,0:33:12.46,0:33:15.68,Chinese,,0,0,0,,猜猜这种分支会去哪里
Dialogue: 0,0:33:15.74,0:33:19.88,English,,0,0,0,,Where it you know well the conditional branch will be taken or is it going to fall through
Dialogue: 0,0:33:15.74,0:33:19.88,Chinese,,0,0,0,,在你熟悉的情况下，条件分支将被采用或将会落空
Dialogue: 0,0:33:20.48,0:33:24.94,English,,0,0,0,,And they're pretty good at that they're good at it 98% of the time
Dialogue: 0,0:33:20.48,0:33:24.94,Chinese,,0,0,0,,并且他们非常擅长98％的时候他们都很擅长
Dialogue: 0,0:33:25.80,0:33:32.68,English,,0,0,0,,So they can even anticipate suta curves in the road  my analogy is breaking down
Dialogue: 0,0:33:25.80,0:33:32.68,Chinese,,0,0,0,,所以他们甚至可以在路上预测suta曲线，我的比喻正在打破
Dialogue: 0,0:33:34.22,0:33:39.84,English,,0,0,0,,And start going in that direction and as long as they get it right it's very efficient
Dialogue: 0,0:33:34.22,0:33:39.84,Chinese,,0,0,0,,并开始朝着这个方向前进，只要他们做对了，就会非常有效率
Dialogue: 0,0:33:40.46,0:33:48.52,English,,0,0,0,,But if they get it wrong it's as if you have to stop the thing back it up turn the other way start again
Dialogue: 0,0:33:40.46,0:33:48.52,Chinese,,0,0,0,,但是，如果他们弄错了，那就好像你必须阻止它反过来转向另一个方向重新开始
Dialogue: 0,0:33:48.80,0:33:54.52,English,,0,0,0,,And that can take 40 instructions 40 clock cycles say to do in bad situations
Dialogue: 0,0:33:48.80,0:33:54.52,Chinese,,0,0,0,,这可能需要40个指令40个时钟周期说在恶劣的情况下做
Dialogue: 0,0:33:54.64,0:33:59.26,English,,0,0,0,,So and this is pretty common if you think of like an absolute value
Dialogue: 0,0:33:54.64,0:33:59.26,Chinese,,0,0,0,,所以，如果您认为这是一个绝对值，这是非常常见的
Dialogue: 0,0:33:59.78,0:34:04.90,English,,0,0,0,,Can you predict whether a value is going to be positive or negative? It not usually
Dialogue: 0,0:33:59.78,0:34:04.90,Chinese,,0,0,0,,你能预测一个价值是正面的还是负面的？通常不会
Dialogue: 0,0:34:05.50,0:34:09.36,English,,0,0,0,,So about half the time whatever you guess you're going to guess wrong
Dialogue: 0,0:34:05.50,0:34:09.36,Chinese,,0,0,0,,所以大约一半的时间，不管你猜你猜错了
Dialogue: 0,0:34:10.06,0:34:13.30,English,,0,0,0,,So these conditional move instructions it turns out
Dialogue: 0,0:34:10.06,0:34:13.30,Chinese,,0,0,0,,事实证明这些条件移动指令
Dialogue: 0,0:34:13.80,0:34:17.64,English,,0,0,0,,It's much easier to just plow through compute both
Dialogue: 0,0:34:13.80,0:34:17.64,Chinese,,0,0,0,,通过计算两者来简化要容易得多
Dialogue: 0,0:34:17.64,0:34:23.04,English,,0,0,0,,And then at the last minute all you have to do is move a value into a register or not
Dialogue: 0,0:34:17.64,0:34:23.04,Chinese,,0,0,0,,然后在最后一分钟，您所要做的就是将值移入寄存器或不移位
Dialogue: 0,0:34:23.04,0:34:27.24,English,,0,0,0,,And that doesn't require stopping the whole processor and making this turn
Dialogue: 0,0:34:23.04,0:34:27.24,Chinese,,0,0,0,,这并不需要停止整个处理器并进行此转变
Dialogue: 0,0:34:28.22,0:34:30.60,English,,0,0,0,,So that's my long explanation for
Dialogue: 0,0:34:28.22,0:34:30.60,Chinese,,0,0,0,,所以这是我的长期解释
Dialogue: 0,0:34:31.26,0:34:37.14,English,,0,0,0,,And if you don't want to understand that I'll just say well just trust me. it's a good idea sometimes
Dialogue: 0,0:34:31.26,0:34:37.14,Chinese,,0,0,0,,如果你不想明白，我只会说得好，只要相信我。有时这是个好主意
Dialogue: 0,0:34:40.60,0:34:47.72,English,,0,0,0,,So the the general pattern then if I use the same idea is I want to compute both results
Dialogue: 0,0:34:40.60,0:34:47.72,Chinese,,0,0,0,,那么一般模式如果我使用相同的想法是我想要计算两个结果
Dialogue: 0,0:34:47.72,0:34:52.92,English,,0,0,0,,And I'll call the result and this is an eval this is eval the eval value
Dialogue: 0,0:34:47.72,0:34:52.92,Chinese,,0,0,0,,我将调用结果，这是一个eval，这是eval的eval值
Dialogue: 0,0:34:53.66,0:34:55.18,English,,0,0,0,,I'll compute both of them
Dialogue: 0,0:34:53.66,0:34:55.18,Chinese,,0,0,0,,我会计算它们
Dialogue: 0,0:34:55.66,0:35:01.38,English,,0,0,0,,I'll do my test and then this red thing imagine that's all done with a single instruction
Dialogue: 0,0:34:55.66,0:35:01.38,Chinese,,0,0,0,,我会做我的测试然后这个红色的事情想象所有这一切都是用一条指令完成的
Dialogue: 0,0:35:01.38,0:35:05.82,English,,0,0,0,,That says I'll copy the value of eval to result
Dialogue: 0,0:35:01.38,0:35:05.82,Chinese,,0,0,0,,这就是说我会将eval的值复制到结果中
Dialogue: 0,0:35:06.40,0:35:10.60,English,,0,0,0,,But only if my condition holds so that's why it's called a conditional move
Dialogue: 0,0:35:06.40,0:35:10.60,Chinese,,0,0,0,,但是，只有我的条件成立，所以这就是为什么它被称为有条件的举动
Dialogue: 0,0:35:12.82,0:35:14.86,English,,0,0,0,,Then we'll see this is the code
Dialogue: 0,0:35:12.82,0:35:14.86,Chinese,,0,0,0,,然后我们会看到这是代码
Dialogue: 0,0:35:15.02,0:35:19.16,English,,0,0,0,,By the way you saw my original version starting to have to jump back
Dialogue: 0,0:35:15.02,0:35:19.16,Chinese,,0,0,0,,顺便说一句，你看到我原来的版本开始不得不跳回来
Dialogue: 0,0:35:19.84,0:35:26.92,English,,0,0,0,,I had to explicitly tell the GCC don't put use conditional moves
Dialogue: 0,0:35:19.84,0:35:26.92,Chinese,,0,0,0,,我不得不明确告诉GCC不要使用条件移动
Dialogue: 0,0:35:27.36,0:35:29.93,English,,0,0,0,,Because it really wants to a very badly
Dialogue: 0,0:35:27.36,0:35:29.93,Chinese,,0,0,0,,因为它真的非常想要
Dialogue: 0,0:35:30.28,0:35:34.26,English,,0,0,0,,And so you have to force it not to and I did that here
Dialogue: 0,0:35:30.28,0:35:34.26,Chinese,,0,0,0,,所以你必须强迫它不要，我在这里做了
Dialogue: 0,0:35:37.66,0:35:41.72,English,,0,0,0,,So here's the actual code then and again you'll see the the color coding
Dialogue: 0,0:35:37.66,0:35:41.72,Chinese,,0,0,0,,所以这是实际的代码，然后你会看到颜色编码
Dialogue: 0,0:35:42.40,0:35:45.44,English,,0,0,0,,That it's doing both subtractions
Dialogue: 0,0:35:42.40,0:35:45.44,Chinese,,0,0,0,,它正在进行两次减法
Dialogue: 0,0:35:45.44,0:35:47.88,English,,0,0,0,,It's actually doing the move and subtract
Dialogue: 0,0:35:45.44,0:35:47.88,Chinese,,0,0,0,,它实际上正在进行移动和减去
Dialogue: 0,0:35:48.54,0:35:54.16,English,,0,0,0,,Move and subtract so it's doing both the branches you saw before the then and the else branch
Dialogue: 0,0:35:48.54,0:35:54.16,Chinese,,0,0,0,,移动和减去，这样它就可以在then和else分支之前看到你所看到的分支
Dialogue: 0,0:35:55.26,0:36:00.18,English,,0,0,0,,It's doing a comparison and then here is the conditional mov instruction
Dialogue: 0,0:35:55.26,0:36:00.18,Chinese,,0,0,0,,它正在进行比较，然后是条件mov指令
Dialogue: 0,0:36:00.86,0:36:08.88,English,,0,0,0,,cmov in this case the l here is not a word size,it's the less than or equal to a direction
Dialogue: 0,0:36:00.86,0:36:08.88,Chinese,,0,0,0,,在这种情况下，这里的l不是字大小，而是小于或等于方向
Dialogue: 0,0:36:09.38,0:36:15.18,English,,0,0,0,,So in the case the that I need the red value basically
Dialogue: 0,0:36:09.38,0:36:15.18,Chinese,,0,0,0,,所以在我需要红色值的情况下
Dialogue: 0,0:36:15.78,0:36:19.18,English,,0,0,0,,You saw the the red value is stored in register %rdx
Dialogue: 0,0:36:15.78,0:36:19.18,Chinese,,0,0,0,,您看到红色值存储在寄存器％rdx中
Dialogue: 0,0:36:20.26,0:36:22.98,English,,0,0,0,,In that case I will copy it into the result register
Dialogue: 0,0:36:20.26,0:36:22.98,Chinese,,0,0,0,,在那种情况下，我会将其复制到结果寄存器中
Dialogue: 0,0:36:24.56,0:36:31.22,English,,0,0,0,,So again it's like this idea of just go ahead and do everything and then pick at the last end
Dialogue: 0,0:36:24.56,0:36:31.22,Chinese,,0,0,0,,所以再次就像这样的想法，继续做所有事情，然后在最后一端选择
Dialogue: 0,0:36:31.60,0:36:39.40,English,,0,0,0,,And the point is that this one instruction it looks just as far as for this processor execution
Dialogue: 0,0:36:31.60,0:36:39.40,Chinese,,0,0,0,,重点是这一条指令看起来就像这个处理器执行一样
Dialogue: 0,0:36:39.40,0:36:42.98,English,,0,0,0,,That's sort of like a a mov instruction that it's fairly straightforward to do
Dialogue: 0,0:36:39.40,0:36:42.98,Chinese,,0,0,0,,这有点像一个mov指令，它做起来相当简单
Dialogue: 0,0:36:47.90,0:36:51.94,English,,0,0,0,,Okay so why doesn't it do that all the time well there's a couple reasons
Dialogue: 0,0:36:47.90,0:36:51.94,Chinese,,0,0,0,,好吧，为什么它不能一直这么做，有几个原因
Dialogue: 0,0:36:52.36,0:36:57.68,English,,0,0,0,,One is that might be a really really bad idea to do both computations
Dialogue: 0,0:36:52.36,0:36:57.68,Chinese,,0,0,0,,一个是进行两种计算可能是一个非常糟糕的主意
Dialogue: 0,0:36:57.68,0:37:01.50,English,,0,0,0,,If you have to like crack a password in one and
Dialogue: 0,0:36:57.68,0:37:01.50,Chinese,,0,0,0,,如果你不得不在一个密码中破解密码
Dialogue: 0,0:37:01.98,0:37:06.26,English,,0,0,0,,You know find the nth prime number and another you probably don't want to do both of those
Dialogue: 0,0:37:01.98,0:37:06.26,Chinese,,0,0,0,,你知道找到第n个素数而另一个你可能不想做这两个
Dialogue: 0,0:37:06.98,0:37:11.18,English,,0,0,0,,So in general in that case
Dialogue: 0,0:37:06.98,0:37:11.18,Chinese,,0,0,0,,所以一般来说就是这种情况
Dialogue: 0,0:37:11.72,0:37:14.86,English,,0,0,0,,And so the and you'll notice GCC will only do this
Dialogue: 0,0:37:11.72,0:37:14.86,Chinese,,0,0,0,,所以你会注意到GCC只会这样做
Dialogue: 0,0:37:15.24,0:37:19.96,English,,0,0,0,,If both branches are fairly straightforward computations that they're trying to do
Dialogue: 0,0:37:15.24,0:37:19.96,Chinese,,0,0,0,,如果两个分支都是他们试图做的相当简单的计算
Dialogue: 0,0:37:20.90,0:37:23.32,English,,0,0,0,,And there's some times when you just plain can't do it
Dialogue: 0,0:37:20.90,0:37:23.32,Chinese,,0,0,0,,而有些时候，你只是平淡无法做到这一点
Dialogue: 0,0:37:23.92,0:37:27.34,English,,0,0,0,,So for example if you're using a conditional to guard
Dialogue: 0,0:37:23.92,0:37:27.34,Chinese,,0,0,0,,因此，例如，如果您使用条件保护
Dialogue: 0,0:37:27.88,0:37:33.58,English,,0,0,0,,Whether a pointer can be dereferenced or not because it's a null pointer potentially a null pointer
Dialogue: 0,0:37:27.88,0:37:33.58,Chinese,,0,0,0,,是否可以取消引用指针，因为它是一个空指针，可能是一个空指针
Dialogue: 0,0:37:34.00,0:37:37.56,English,,0,0,0,,Then you really don't want to try that null pointer dereference
Dialogue: 0,0:37:34.00,0:37:37.56,Chinese,,0,0,0,,那你真的不想尝试空指针解除引用
Dialogue: 0,0:37:39.96,0:37:44.22,English,,0,0,0,,Just for a way to save some time
Dialogue: 0,0:37:39.96,0:37:44.22,Chinese,,0,0,0,,只是为了节省一些时间
Dialogue: 0,0:37:44.94,0:37:48.12,English,,0,0,0,,And similarly if you could have a side-effect
Dialogue: 0,0:37:44.94,0:37:48.12,Chinese,,0,0,0,,同样，如果你有副作用
Dialogue: 0,0:37:48.20,0:37:54.50,English,,0,0,0,,If the result of executing either branch could be to change some other part of the program state
Dialogue: 0,0:37:48.20,0:37:54.50,Chinese,,0,0,0,,如果执行任一分支的结果可能是改变程序状态的某些其他部分
Dialogue: 0,0:37:55.10,0:37:56.85,English,,0,0,0,,Then you don't really want to do that either
Dialogue: 0,0:37:55.10,0:37:56.85,Chinese,,0,0,0,,那你也不想那样做
Dialogue: 0,0:37:57.42,0:38:03.58,English,,0,0,0,,And so the conditional mov only gets used then in this somewhat special case
Dialogue: 0,0:37:57.42,0:38:03.58,Chinese,,0,0,0,,因此，条件mov只能在这种特殊情况下使用
Dialogue: 0,0:38:03.58,0:38:08.74,English,,0,0,0,,That you have two computations relatively easy to do safe to do no side-effects
Dialogue: 0,0:38:03.58,0:38:08.74,Chinese,,0,0,0,,你有两个计算相对容易安全，没有副作用
Dialogue: 0,0:38:09.74,0:38:13.26,English,,0,0,0,,But that happens just often enough that this is actually a worthwhile thing
Dialogue: 0,0:38:09.74,0:38:13.26,Chinese,,0,0,0,,但这种情况经常发生，这实际上是一件有价值的事情
Dialogue: 0,0:38:16.70,0:38:19.48,English,,0,0,0,,Okay so that gets us conditionals
Dialogue: 0,0:38:16.70,0:38:19.48,Chinese,,0,0,0,,好的，这样才能让我们有条件
Dialogue: 0,0:38:20.04,0:38:26.34,English,,0,0,0,,And now let's look at loops that's a sort of next step up in control structures
Dialogue: 0,0:38:20.04,0:38:26.34,Chinese,,0,0,0,,现在让我们来看看循环，它们是控制结构的下一步
Dialogue: 0,0:38:28.14,0:38:30.90,English,,0,0,0,,And C actually has three different kinds of loops
Dialogue: 0,0:38:28.14,0:38:30.90,Chinese,,0,0,0,,而C实际上有三种不同的循环
Dialogue: 0,0:38:31.52,0:38:36.52,English,,0,0,0,,It has a a while-loop which you're familiar with and a for-loop which you're familiar with
Dialogue: 0,0:38:31.52,0:38:36.52,Chinese,,0,0,0,,它有一个你熟悉的while循环和一个你熟悉的for循环
Dialogue: 0,0:38:36.84,0:38:41.72,English,,0,0,0,,And it has a third one which in my whole life of writing and I've written a lot of C code in my life
Dialogue: 0,0:38:36.84,0:38:41.72,Chinese,,0,0,0,,它有第三个，在我的整个写作生涯中，我在我的生活中写了很多C代码
Dialogue: 0,0:38:42.42,0:38:44.70,English,,0,0,0,,I've used this like about 6 times
Dialogue: 0,0:38:42.42,0:38:44.70,Chinese,,0,0,0,,我用了大约6次
Dialogue: 0,0:38:45.64,0:38:49.28,English,,0,0,0,,So but it turns out it's the simplest one to implement so we'll go ahead and do it
Dialogue: 0,0:38:45.64,0:38:49.28,Chinese,,0,0,0,,所以但事实证明它是最简单的实现方式，所以我们将继续这样做
Dialogue: 0,0:38:49.86,0:38:52.34,English,,0,0,0,,So that the it's called the do-while loop
Dialogue: 0,0:38:49.86,0:38:52.34,Chinese,,0,0,0,,所以它被称为do-while循环
Dialogue: 0,0:38:53.00,0:38:59.26,English,,0,0,0,,And so the keyword is do,and then there's some stuff you do,that's the body of the do
Dialogue: 0,0:38:53.00,0:38:59.26,Chinese,,0,0,0,,所以关键字是do，然后你会做一些事情，那就是do的主体
Dialogue: 0,0:38:59.90,0:39:05.41,English,,0,0,0,,And then there's a test at the end that tells you whether to keep repeating this loop
Dialogue: 0,0:38:59.90,0:39:05.41,Chinese,,0,0,0,,然后在最后进行测试，告诉您是否继续重复此循环
Dialogue: 0,0:39:05.88,0:39:10.08,English,,0,0,0,,So it sort of flips a normal while loop you have the conditional test at the front
Dialogue: 0,0:39:05.88,0:39:10.08,Chinese,,0,0,0,,所以它有点翻转正常的while循环你在前面进行条件测试
Dialogue: 0,0:39:10.46,0:39:11.94,English,,0,0,0,,And here you have it at the end
Dialogue: 0,0:39:10.46,0:39:11.94,Chinese,,0,0,0,,在这里，你最后拥有它
Dialogue: 0,0:39:15.84,0:39:20.52,English,,0,0,0,,So it turns out if we think in terms of goto that's a pretty straightforward thing to replace this
Dialogue: 0,0:39:15.84,0:39:20.52,Chinese,,0,0,0,,因此，如果我们根据goto认为替换它是一件相当简单的事情
Dialogue: 0,0:39:22.14,0:39:28.54,English,,0,0,0,,With a code that will do a test and if the test holds it will jump back
Dialogue: 0,0:39:22.14,0:39:28.54,Chinese,,0,0,0,,使用代码进行测试，如果测试成功，它将跳回
Dialogue: 0,0:39:29.00,0:39:33.26,English,,0,0,0,,And say ok a reacts acute that part of the program I was just in
Dialogue: 0,0:39:29.00,0:39:33.26,Chinese,,0,0,0,,并且说好的是，我刚刚参与的程序部分反应非常强烈
Dialogue: 0,0:39:34.08,0:39:43.24,English,,0,0,0,,So it sets up a loop where you can think of it's literally a loop of control flow going round and round
Dialogue: 0,0:39:34.08,0:39:43.24,Chinese,,0,0,0,,所以它设置了一个循环，你可以想到它实际上是一个循环的控制流程
Dialogue: 0,0:39:46.44,0:39:51.48,English,,0,0,0,,And by the way this is actually a same useful function it's called pop count sometimes
Dialogue: 0,0:39:46.44,0:39:51.48,Chinese,,0,0,0,,顺便说一下，这实际上是一个相同的有用函数，它有时称为弹出计数
Dialogue: 0,0:39:51.96,0:39:59.16,English,,0,0,0,,How many ones are there in a in a word of data in this case 64-bit word
Dialogue: 0,0:39:51.96,0:39:59.16,Chinese,,0,0,0,,在这种情况下64位字中的数据字中有多少个
Dialogue: 0,0:39:59.56,0:40:02.38,English,,0,0,0,,There's been some generations of data lab
Dialogue: 0,0:39:59.56,0:40:02.38,Chinese,,0,0,0,,已有几代数据实验室
Dialogue: 0,0:40:02.38,0:40:06.96,English,,0,0,0,,Where you were required to write this function using all your favorite operations
Dialogue: 0,0:40:02.38,0:40:06.96,Chinese,,0,0,0,,您需要使用所有喜欢的操作编写此功能的地方
Dialogue: 0,0:40:09.68,0:40:14.80,English,,0,0,0,,And with a fairly small limit on operations but we're not doing that today
Dialogue: 0,0:40:09.68,0:40:14.80,Chinese,,0,0,0,,并且运营限制相当小，但我们今天没有这样做
Dialogue: 0,0:40:19.12,0:40:23.78,English,,0,0,0,,So here my point is you see that there's a fairly straightforward
Dialogue: 0,0:40:19.12,0:40:23.78,Chinese,,0,0,0,,所以我的观点是，你看到有一个相当简单
Dialogue: 0,0:40:24.40,0:40:30.08,English,,0,0,0,,Way of taking this particular loop and turning it into just a combination of conditional
Dialogue: 0,0:40:24.40,0:40:30.08,Chinese,,0,0,0,,采取这种特殊循环并将其转化为有条件的组合的方式
Dialogue: 0,0:40:30.46,0:40:33.91,English,,0,0,0,,That where you do is you jump back to where you were before
Dialogue: 0,0:40:30.46,0:40:33.91,Chinese,,0,0,0,,你去的地方就是你回到原来的位置
Dialogue: 0,0:40:34.60,0:40:36.28,English,,0,0,0,,And here's the actual code for it
Dialogue: 0,0:40:34.60,0:40:36.28,Chinese,,0,0,0,,这是它的实际代码
Dialogue: 0,0:40:37.84,0:40:44.62,English,,0,0,0,,I won't go through all of it,but you can believe from these annotations that it very closely follows the code here
Dialogue: 0,0:40:37.84,0:40:44.62,Chinese,,0,0,0,,我不会详细介绍它，但你可以从这些注释中相信它非常接近这里的代码
Dialogue: 0,0:40:45.18,0:40:54.48,English,,0,0,0,,And the main thing to see is, this jump if not equal(jne) to label l2 and that takes you back to here
Dialogue: 0,0:40:45.18,0:40:54.48,Chinese,,0,0,0,,最重要的是，如果不等于（jne）标记为l2，那么这会让你回到这里
Dialogue: 0,0:40:57.16,0:41:03.18,English,,0,0,0,,And so the general form of it then is you take a do
Dialogue: 0,0:40:57.16,0:41:03.18,Chinese,,0,0,0,,因此，它的一般形式是你采取做
Dialogue: 0,0:41:03.18,0:41:06.34,English,,0,0,0,,And then this part of it's called the body of the loop and this is the test
Dialogue: 0,0:41:03.18,0:41:06.34,Chinese,,0,0,0,,然后它的这部分称为循环体，这是测试
Dialogue: 0,0:41:06.96,0:41:11.88,English,,0,0,0,,And so now you set up some code where you can execute the body perform the test
Dialogue: 0,0:41:06.96,0:41:11.88,Chinese,,0,0,0,,所以现在你设置一些代码来执行身体执行测试
Dialogue: 0,0:41:12.30,0:41:14.40,English,,0,0,0,,And if the test holds you go back to the loop
Dialogue: 0,0:41:12.30,0:41:14.40,Chinese,,0,0,0,,如果测试成功，你就会回到循环中
Dialogue: 0,0:41:17.30,0:41:20.58,English,,0,0,0,,So a while loop is really just why I could do loop
Dialogue: 0,0:41:17.30,0:41:20.58,Chinese,,0,0,0,,所以一个while循环真的是我可以做循环的原因
Dialogue: 0,0:41:21.58,0:41:24.78,English,,0,0,0,,A do-while loop except that you move the test to the beginning
Dialogue: 0,0:41:21.58,0:41:24.78,Chinese,,0,0,0,,除了将测试移动到开头之外的do-while循环
Dialogue: 0,0:41:24.80,0:41:30.60,English,,0,0,0,,And the only difference therefore is with a d- loop you don't do the test it
Dialogue: 0,0:41:24.80,0:41:30.60,Chinese,,0,0,0,,因此，唯一的区别是d-loop你不进行测试
Dialogue: 0,0:41:30.70,0:41:36.06,English,,0,0,0,,The first time through you're guaranteed to do it the first time no matter what
Dialogue: 0,0:41:30.70,0:41:36.06,Chinese,,0,0,0,,无论如何，第一次通过你保证第一次这样做
Dialogue: 0,0:41:36.86,0:41:44.02,English,,0,0,0,,While a while loop will explicitly test even at the very beginning and skip over the loop if the condition doesn't hold
Dialogue: 0,0:41:36.86,0:41:44.02,Chinese,,0,0,0,,虽然while循环将在最开始时显式测试，但如果条件不成立则跳过循环
Dialogue: 0,0:41:45.50,0:41:50.72,English,,0,0,0,,So there's two ways to generate a code well there's more than two ways to generate code for a while loop
Dialogue: 0,0:41:45.50,0:41:50.72,Chinese,,0,0,0,,因此有两种方法可以很好地生成代码，有两种方法可以为while循环生成代码
Dialogue: 0,0:41:51.14,0:41:54.20,English,,0,0,0,,But you'll find GCC actually uses two different ways
Dialogue: 0,0:41:51.14,0:41:54.20,Chinese,,0,0,0,,但是你会发现GCC实际上使用了两种不同的方式
Dialogue: 0,0:41:54.80,0:42:01.12,English,,0,0,0,,A one is what we'll find when we use this optimization setting I talked about last time
Dialogue: 0,0:41:54.80,0:42:01.12,Chinese,,0,0,0,,当我们使用上次谈到的优化设置时，我们会发现一个
Dialogue: 0,0:42:01.12,0:42:04.16,English,,0,0,0,,Called -O which stands for optimized
Dialogue: 0,0:42:01.12,0:42:04.16,Chinese,,0,0,0,,被称为-O代表优化
Dialogue: 0,0:42:04.72,0:42:09.10,English,,0,0,0,,g which means debug of course as you've already know
Dialogue: 0,0:42:04.72,0:42:09.10,Chinese,,0,0,0,,g，这意味着你已经知道的调试当然
Dialogue: 0,0:42:10.44,0:42:14.26,English,,0,0,0,,There's some history to what the -g flags means
Dialogue: 0,0:42:10.44,0:42:14.26,Chinese,,0,0,0,,-g标志的含义有一些历史
Dialogue: 0,0:42:15.24,0:42:21.18,English,,0,0,0,,So and as I mentioned last time this turns out to be the perfect level of optimization for this course
Dialogue: 0,0:42:15.24,0:42:21.18,Chinese,,0,0,0,,因此，正如我上次提到的，这是本课程的完美优化水平
Dialogue: 0,0:42:21.80,0:42:27.36,English,,0,0,0,,Where you want to be able to look at machine code and understand it and how it relates to the C code
Dialogue: 0,0:42:21.80,0:42:27.36,Chinese,,0,0,0,,您希望能够查看机器代码并理解它以及它与C代码的关系
Dialogue: 0,0:42:27.36,0:42:30.42,English,,0,0,0,,Because it does some sort of simple optimizations
Dialogue: 0,0:42:27.36,0:42:30.42,Chinese,,0,0,0,,因为它做了某种简单的优化
Dialogue: 0,0:42:30.44,0:42:33.76,English,,0,0,0,,But it doesn't try to rewrite your whole program to make it run better
Dialogue: 0,0:42:30.44,0:42:33.76,Chinese,,0,0,0,,但它不会尝试重写整个程序以使其运行得更好
Dialogue: 0,0:42:35.20,0:42:39.44,English,,0,0,0,,Whereas even with -o1 one which is the next level in the optimization
Dialogue: 0,0:42:35.20,0:42:39.44,Chinese,,0,0,0,,即使使用-o1，它也是优化中的下一个级别
Dialogue: 0,0:42:39.78,0:42:42.88,English,,0,0,0,,You'll find sometimes it will do some pretty quirky stuff
Dialogue: 0,0:42:39.78,0:42:42.88,Chinese,,0,0,0,,你会发现有时它会做一些非常古怪的东西
Dialogue: 0,0:42:44.82,0:42:49.94,English,,0,0,0,,But when you actually as a program developer as a software developer out there
Dialogue: 0,0:42:44.82,0:42:49.94,Chinese,,0,0,0,,但是，当你真正作为软件开发人员作为程序开发人员在那里
Dialogue: 0,0:42:50.58,0:42:54.36,English,,0,0,0,,Or you talk to companies and you ask what optimization level do you use
Dialogue: 0,0:42:50.58,0:42:54.36,Chinese,,0,0,0,,或者您与公司交谈，并询问您使用的优化级别
Dialogue: 0,0:42:54.78,0:42:59.20,English,,0,0,0,,Those probably say -o2 that's sort of the common one
Dialogue: 0,0:42:54.78,0:42:59.20,Chinese,,0,0,0,,那些可能会说-o2这是常见的
Dialogue: 0,0:43:00.56,0:43:03.20,English,,0,0,0,,So usually there's higher levels optimization
Dialogue: 0,0:43:00.56,0:43:03.20,Chinese,,0,0,0,,所以通常有更高级别的优化
Dialogue: 0,0:43:03.48,0:43:07.30,English,,0,0,0,,And we're purposely backing off from that to make this code easier to understand
Dialogue: 0,0:43:03.48,0:43:07.30,Chinese,,0,0,0,,我们故意退出，以使这些代码更容易理解
Dialogue: 0,0:43:08.30,0:43:13.50,English,,0,0,0,,So anyways with the this default optimization we're using for this course
Dialogue: 0,0:43:08.30,0:43:13.50,Chinese,,0,0,0,,所以无论如何我们正在使用这个默认优化课程
Dialogue: 0,0:43:13.98,0:43:18.10,English,,0,0,0,,It does a transformation I call the jump to middle translation
Dialogue: 0,0:43:13.98,0:43:18.10,Chinese,,0,0,0,,它做了一个转换我称之为跳转到中间翻译
Dialogue: 0,0:43:18.48,0:43:22.40,English,,0,0,0,,These are by the way my own names you won't find them in any other document
Dialogue: 0,0:43:18.48,0:43:22.40,Chinese,,0,0,0,,这些是我自己的名字，你不会在任何其他文件中找到它们
Dialogue: 0,0:43:24.32,0:43:33.68,English,,0,0,0,,But what the idea of it is imagine again I have a while loop of this form where there's a test in the body to execute
Dialogue: 0,0:43:24.32,0:43:33.68,Chinese,,0,0,0,,但是它的想法再次想象我有一个这种形式的while循环，其中有一个测试在身体中执行
Dialogue: 0,0:43:34.26,0:43:40.38,English,,0,0,0,,Well what out the problem I have to do compared to before is some I've to execute the test before I start
Dialogue: 0,0:43:34.26,0:43:40.38,Chinese,,0,0,0,,那么与以前相比我需要做的问题是我要在开始之前执行测试
Dialogue: 0,0:43:41.13,0:43:42.68,English,,0,0,0,,The first iteration of the loop
Dialogue: 0,0:43:41.13,0:43:42.68,Chinese,,0,0,0,,循环的第一次迭代
Dialogue: 0,0:43:43.08,0:43:49.32,English,,0,0,0,,So the way I'll do it here,I'll just jump to the middle of the what was the old loop code
Dialogue: 0,0:43:43.08,0:43:49.32,Chinese,,0,0,0,,所以我在这里做的方式，我只是跳到旧循环代码的中间
Dialogue: 0,0:43:49.86,0:43:52.00,English,,0,0,0,,To the test portion of that loop
Dialogue: 0,0:43:49.86,0:43:52.00,Chinese,,0,0,0,,到该循环的测试部分
Dialogue: 0,0:43:52.70,0:43:57.74,English,,0,0,0,,And then let that test determine whether I actually enter the the loop itself
Dialogue: 0,0:43:52.70,0:43:57.74,Chinese,,0,0,0,,然后让该测试确定我是否实际进入循环本身
Dialogue: 0,0:43:59.72,0:44:09.34,English,,0,0,0,,And so this is an example of...a go to a code version of my pop count function
Dialogue: 0,0:43:59.72,0:44:09.34,Chinese,,0,0,0,,所以这是一个例子...转到我的流行计数功能的代码版本
Dialogue: 0,0:44:09.78,0:44:13.10,English,,0,0,0,,So I've written the pop count function using a while loop this time
Dialogue: 0,0:44:09.78,0:44:13.10,Chinese,,0,0,0,,所以我这次使用while循环编写了pop计数函数
Dialogue: 0,0:44:14.90,0:44:19.88,English,,0,0,0,,It turns out whether you use do-while or while loop, you'll get the same result in this particular function
Dialogue: 0,0:44:14.90,0:44:19.88,Chinese,,0,0,0,,事实证明，无论你使用do-while还是while循环，你都会在这个特定的函数中得到相同的结果
Dialogue: 0,0:44:21.18,0:44:29.84,English,,0,0,0,,And you'll see the way it looks is,it jumps to the test portion of the code
Dialogue: 0,0:44:21.18,0:44:29.84,Chinese,,0,0,0,,你会看到它看起来的样子，它会跳转到代码的测试部分
Dialogue: 0,0:44:30.38,0:44:35.67,English,,0,0,0,,And then if that holds it then actually starts in the first execution of the loop
Dialogue: 0,0:44:30.38,0:44:35.67,Chinese,,0,0,0,,然后，如果它保持它然后实际上开始在循环的第一次执行
Dialogue: 0,0:44:36.14,0:44:38.78,English,,0,0,0,,And then from there on it looks the same as the do-while loop
Dialogue: 0,0:44:36.14,0:44:38.78,Chinese,,0,0,0,,然后从那里看起来和do-while循环一样
Dialogue: 0,0:44:38.78,0:44:45.02,English,,0,0,0,,It just does the what was in the loop does the test jumps back to the beginning
Dialogue: 0,0:44:38.78,0:44:45.02,Chinese,,0,0,0,,它只是做了循环中的内容，测试跳回到开头
Dialogue: 0,0:44:49.26,0:44:53.72,English,,0,0,0,,Oh and then there's a second method which is in some ways more traditional
Dialogue: 0,0:44:49.26,0:44:53.72,Chinese,,0,0,0,,哦，然后有第二种方法在某些方面更传统
Dialogue: 0,0:44:54.42,0:45:00.28,English,,0,0,0,,And you'll find that if you use optimization one(-o1) which is a fairly useful thing to do in practice
Dialogue: 0,0:44:54.42,0:45:00.28,Chinese,,0,0,0,,你会发现，如果你使用优化（-o1），这在实践中是一件非常有用的事情
Dialogue: 0,0:45:00.48,0:45:06.90,English,,0,0,0,,So just to show you that,instead of deciding which one I was going to show you I decided to show you both
Dialogue: 0,0:45:00.48,0:45:06.90,Chinese,,0,0,0,,所以只是为了告诉你，我决定告诉你们两个，而不是决定我要向你展示哪一个
Dialogue: 0,0:45:09.30,0:45:15.64,English,,0,0,0,,And the idea of that is to do a essentially to take a while loop and turn it into a do-while loop
Dialogue: 0,0:45:09.30,0:45:15.64,Chinese,,0,0,0,,而这样做的想法是基本上做一个while循环并将其转换为do-while循环
Dialogue: 0,0:45:16.32,0:45:19.18,English,,0,0,0,,But introducing a conditional beforehand
Dialogue: 0,0:45:16.32,0:45:19.18,Chinese,,0,0,0,,但事先引入条件
Dialogue: 0,0:45:19.74,0:45:23.18,English,,0,0,0,,That would essentially guard your entrance to the loop
Dialogue: 0,0:45:19.74,0:45:23.18,Chinese,,0,0,0,,这基本上可以防止你进入循环
Dialogue: 0,0:45:24.10,0:45:25.96,English,,0,0,0,,So you do an initial test
Dialogue: 0,0:45:24.10,0:45:25.96,Chinese,,0,0,0,,所以你做了初步测试
Dialogue: 0,0:45:26.14,0:45:30.24,English,,0,0,0,,And if that's false then you skip over the loop all together
Dialogue: 0,0:45:26.14,0:45:30.24,Chinese,,0,0,0,,如果这是假的，那么你一起跳过循环
Dialogue: 0,0:45:30.48,0:45:32.78,English,,0,0,0,,Otherwise it's performed like a do-while loop
Dialogue: 0,0:45:30.48,0:45:32.78,Chinese,,0,0,0,,否则它就像do-while循环一样执行
Dialogue: 0,0:45:35.72,0:45:38.74,English,,0,0,0,,And so that has a fairly straightforward translation into code
Dialogue: 0,0:45:35.72,0:45:38.74,Chinese,,0,0,0,,因此，它具有相当直接的代码转换
Dialogue: 0,0:45:39.48,0:45:44.54,English,,0,0,0,,And that again it looks a little different from before that it has an initial test
Dialogue: 0,0:45:39.48,0:45:44.54,Chinese,,0,0,0,,而且它再次看起来与之前的初步测试有点不同
Dialogue: 0,0:45:45.28,0:45:47.78,English,,0,0,0,,But then it looks so I could do while loop
Dialogue: 0,0:45:45.28,0:45:47.78,Chinese,,0,0,0,,但后来看起来我可以做循环
Dialogue: 0,0:45:51.76,0:45:54.22,English,,0,0,0,,So I won't show you the assembly versions of those
Dialogue: 0,0:45:51.76,0:45:54.22,Chinese,,0,0,0,,所以我不会告诉你那些装配版本
Dialogue: 0,0:45:54.30,0:46:05.62,English,,0,0,0,,But if you look at it actually the code is all in directories that are linked to your the the class directory,the class webpage 
Dialogue: 0,0:45:54.30,0:46:05.62,Chinese,,0,0,0,,但是如果你看一下它实际上代码都在链接到你的类目录，类网页的目录中
Dialogue: 0,0:46:05.68,0:46:07.30,English,,0,0,0,,So you can actually look at the code
Dialogue: 0,0:46:05.68,0:46:07.30,Chinese,,0,0,0,,所以你可以看看代码
Dialogue: 0,0:46:07.66,0:46:10.96,English,,0,0,0,,And you'll see that it follows exactly the way I'm describing it
Dialogue: 0,0:46:07.66,0:46:10.96,Chinese,,0,0,0,,你会发现它完全符合我描述它的方式
Dialogue: 0,0:46:13.12,0:46:16.30,English,,0,0,0,,And then a third kind of loop is the for loop
Dialogue: 0,0:46:13.12,0:46:16.30,Chinese,,0,0,0,,然后第三种循环是for循环
Dialogue: 0,0:46:16.82,0:46:24.58,English,,0,0,0,,Which in C is actually a very powerful very general type of thing and so it's very commonly used
Dialogue: 0,0:46:16.82,0:46:24.58,Chinese,,0,0,0,,在C中实际上是一种非常强大的非常通用类型的东西，所以它是非常常用的
Dialogue: 0,0:46:25.12,0:46:30.26,English,,0,0,0,,But you can see that the for loop has four components to it
Dialogue: 0,0:46:25.12,0:46:30.26,Chinese,,0,0,0,,但是你可以看到for循环有四个组件
Dialogue: 0,0:46:30.36,0:46:38.36,English,,0,0,0,,(It) has an initialization,has a test,has a rule for doing an update in case as a way to continue the loop
Dialogue: 0,0:46:30.36,0:46:38.36,Chinese,,0,0,0,,（它）有一个初始化，有一个测试，有一个规则进行更新，以防止继续循环
Dialogue: 0,0:46:38.70,0:46:40.30,English,,0,0,0,,And then it has the body of the loop
Dialogue: 0,0:46:38.70,0:46:40.30,Chinese,,0,0,0,,然后它有循环的主体
Dialogue: 0,0:46:40.90,0:46:43.62,English,,0,0,0,,And so here's a version of my pop count function
Dialogue: 0,0:46:40.90,0:46:43.62,Chinese,,0,0,0,,所以这是我的流行计数功能的一个版本
Dialogue: 0,0:46:45.18,0:46:52.10,English,,0,0,0,,Where I'm just going through all the bits in the word extracting them out
Dialogue: 0,0:46:45.18,0:46:52.10,Chinese,,0,0,0,,我只是通过单词中的所有位来提取它们
Dialogue: 0,0:46:52.50,0:46:56.13,English,,0,0,0,,And adding them accumulating them to be the result
Dialogue: 0,0:46:52.50,0:46:56.13,Chinese,,0,0,0,,并添加它们累积它们作为结果
Dialogue: 0,0:46:57.08,0:47:00.10,English,,0,0,0,,So ripping apart this four 
Dialogue: 0,0:46:57.08,0:47:00.10,Chinese,,0,0,0,,所以撕掉这四个
Dialogue: 0,0:47:00.50,0:47:07.56,English,,0,0,0,,You see that these four blocks of the loop correspond to the initialization is to set equal to zero
Dialogue: 0,0:47:00.50,0:47:07.56,Chinese,,0,0,0,,您会看到循环的这四个块对应于初始化设置为等于零
Dialogue: 0,0:47:08.46,0:47:11.16,English,,0,0,0,,The test is to compare i to the word size
Dialogue: 0,0:47:08.46,0:47:11.16,Chinese,,0,0,0,,测试是将i与单词大小进行比较
Dialogue: 0,0:47:12.54,0:47:16.46,English,,0,0,0,,Which I've set here to be eight times
Dialogue: 0,0:47:12.54,0:47:16.46,Chinese,,0,0,0,,我在这里设置了8次
Dialogue: 0,0:47:16.56,0:47:22.08,English,,0,0,0,,So however many bytes there are in an int multiply that by 8 to get the word size
Dialogue: 0,0:47:16.56,0:47:22.08,Chinese,,0,0,0,,因此，无论多少字节都在int中乘以8乘以得到字大小
Dialogue: 0,0:47:23.30,0:47:25.20,English,,0,0,0,,And then the update is i++
Dialogue: 0,0:47:23.30,0:47:25.20,Chinese,,0,0,0,,然后更新是i ++
Dialogue: 0,0:47:25.70,0:47:28.66,English,,0,0,0,,And then the body is this stuff that's within the brackets here
Dialogue: 0,0:47:25.70,0:47:28.66,Chinese,,0,0,0,,然后身体就是这里的东西
Dialogue: 0,0:47:30.78,0:47:34.24,English,,0,0,0,,So I can think of that in general one
Dialogue: 0,0:47:30.78,0:47:34.24,Chinese,,0,0,0,,所以我一般可以想到这一点
Dialogue: 0,0:47:34.84,0:47:41.82,English,,0,0,0,,One general way to think about a for loop in C is by this rule
Dialogue: 0,0:47:34.84,0:47:41.82,Chinese,,0,0,0,,在C中考虑for循环的一种通用方法是通过这个规则
Dialogue: 0,0:47:43.34,0:47:45.28,English,,0,0,0,,That will turn a for loop into a while loop
Dialogue: 0,0:47:43.34,0:47:45.28,Chinese,,0,0,0,,这将把for循环变成while循环
Dialogue: 0,0:47:47.22,0:47:52.28,English,,0,0,0,,And so what it says is I first do the initialization
Dialogue: 0,0:47:47.22,0:47:52.28,Chinese,,0,0,0,,所以它说的是我首先进行初始化
Dialogue: 0,0:47:52.90,0:47:57.72,English,,0,0,0,,And then I do a loop where I guard it with this test
Dialogue: 0,0:47:52.90,0:47:57.72,Chinese,,0,0,0,,然后我做了一个循环，我用这个测试来保护它
Dialogue: 0,0:47:59.30,0:48:02.76,English,,0,0,0,,And then what I keep doing is executing the body
Dialogue: 0,0:47:59.30,0:48:02.76,Chinese,,0,0,0,,然后我一直在做的是执行身体
Dialogue: 0,0:48:03.50,0:48:07.70,English,,0,0,0,,And then performing whatever update there is and then continuing with the test
Dialogue: 0,0:48:03.50,0:48:07.70,Chinese,,0,0,0,,然后执行任何更新，然后继续测试
Dialogue: 0,0:48:08.66,0:48:14.90,English,,0,0,0,,So that's sort of the semantics the the definition of the behavior of a for loop in C
Dialogue: 0,0:48:08.66,0:48:14.90,Chinese,,0,0,0,,所以这就是语义中C语言中for循环行为的定义
Dialogue: 0,0:48:17.66,0:48:21.86,English,,0,0,0,,So I can take my different pieces of my for loop
Dialogue: 0,0:48:17.66,0:48:21.86,Chinese,,0,0,0,,所以我可以把我的不同部分用于循环
Dialogue: 0,0:48:22.66,0:48:29.46,English,,0,0,0,,And say well okay I'll take that rule and use it to pack them in  to form a while loop
Dialogue: 0,0:48:22.66,0:48:29.46,Chinese,,0,0,0,,并且说好吧我会采用该规则并使用它来打包它们以形成一个while循环
Dialogue: 0,0:48:30.10,0:48:33.58,English,,0,0,0,,And of course you know that you can sort of go between those two
Dialogue: 0,0:48:30.10,0:48:33.58,Chinese,,0,0,0,,当然，你知道你可以在这两者之间进行
Dialogue: 0,0:48:33.90,0:48:39.92,English,,0,0,0,,It's somewhat a matter of taste whether a given loop should be written using a for loop or a while loop
Dialogue: 0,0:48:33.90,0:48:39.92,Chinese,,0,0,0,,无论是使用for循环还是使用while循环来编写给定循环，这都是一种品味问题
Dialogue: 0,0:48:46.00,0:48:54.20,English,,0,0,0,,So one reason why it's actually useful to do this  -o1 one optimization I talked to you about is
Dialogue: 0,0:48:46.00,0:48:54.20,Chinese,,0,0,0,,因此，实际上有用的一个原因是-o1我与你谈过的一个优化是
Dialogue: 0,0:48:54.52,0:48:58.90,English,,0,0,0,,It's fairly common for the initial tests to be trivially true
Dialogue: 0,0:48:54.52,0:48:58.90,Chinese,,0,0,0,,对于初始测试而言，这是相当普遍的
Dialogue: 0,0:48:59.74,0:49:02.52,English,,0,0,0,,So for example in here if i=0
Dialogue: 0,0:48:59.74,0:49:02.52,Chinese,,0,0,0,,所以例如在这里，如果i = 0
Dialogue: 0,0:49:02.96,0:49:07.52,English,,0,0,0,,And I'm comparing it to the word size which would typically be 32
Dialogue: 0,0:49:02.96,0:49:07.52,Chinese,,0,0,0,,我将它与通常为32的字大小进行比较
Dialogue: 0,0:49:08.86,0:49:11.54,English,,0,0,0,,Well that test is true that's a certain thing
Dialogue: 0,0:49:08.86,0:49:11.54,Chinese,,0,0,0,,那个测试是真的，这是一个特定的事情
Dialogue: 0,0:49:11.92,0:49:15.14,English,,0,0,0,,And so what you'll see is that the compiler can figure that out
Dialogue: 0,0:49:11.92,0:49:15.14,Chinese,,0,0,0,,所以你会看到编译器可以解决这个问题
Dialogue: 0,0:49:15.86,0:49:22.12,English,,0,0,0,,And just throw away this guarding code would have to be there otherwise
Dialogue: 0,0:49:15.86,0:49:22.12,Chinese,,0,0,0,,然后扔掉这个保护代码必须在那里
Dialogue: 0,0:49:33.80,0:49:35.54,English,,0,0,0,,It doesn't need this initial test
Dialogue: 0,0:49:33.80,0:49:35.54,Chinese,,0,0,0,,它不需要这个初始测试
Dialogue: 0,0:49:40.64,0:49:48.94,English,,0,0,0,,Ok so now I'm going to finish up with what's in to me at least the loop stuff is sort of what you'd expect
Dialogue: 0,0:49:40.64,0:49:48.94,Chinese,,0,0,0,,好的，现在我要完成对我的了解至少循环的东西是你期望的那种
Dialogue: 0,0:49:50.80,0:49:54.34,English,,0,0,0,,If you were to have to you know turn
Dialogue: 0,0:49:50.80,0:49:54.34,Chinese,,0,0,0,,如果你不得不知道转身
Dialogue: 0,0:49:54.98,0:50:01.10,English,,0,0,0,,A C code into something very low level where all you could do is jumps and test
Dialogue: 0,0:49:54.98,0:50:01.10,Chinese,,0,0,0,,AC代码进入一个非常低的级别，你可以做的就是跳转和测试
Dialogue: 0,0:50:01.74,0:50:03.64,English,,0,0,0,,Well maybe that's obvious but maybe not
Dialogue: 0,0:50:01.74,0:50:03.64,Chinese,,0,0,0,,好吧也许这很明显，但也许不是
Dialogue: 0,0:50:04.26,0:50:07.32,English,,0,0,0,,The switch statement on the other hand is a totally different beast
Dialogue: 0,0:50:04.26,0:50:07.32,Chinese,,0,0,0,,另一方面，switch语句是一个完全不同的野兽
Dialogue: 0,0:50:07.98,0:50:14.76,English,,0,0,0,,And I want to show you that because there's no counterpart in normal C code of how you'd even think about it
Dialogue: 0,0:50:07.98,0:50:14.76,Chinese,,0,0,0,,而且我想告诉你，因为正常的C代码中没有对应的你如何考虑它
Dialogue: 0,0:50:16.24,0:50:21.10,English,,0,0,0,,And it's fairly a little bit harder to do cipher
Dialogue: 0,0:50:16.24,0:50:21.10,Chinese,,0,0,0,,密码管理起来相当困难
Dialogue: 0,0:50:21.58,0:50:23.42,English,,0,0,0,,And you're going to have to do it in the bomb lab
Dialogue: 0,0:50:21.58,0:50:23.42,Chinese,,0,0,0,,你将不得不在炸弹实验室里做这件事
Dialogue: 0,0:50:25.22,0:50:28.90,English,,0,0,0,,So here's an example of a switch statement that is of
Dialogue: 0,0:50:25.22,0:50:28.90,Chinese,,0,0,0,,所以这是一个switch语句的例子
Dialogue: 0,0:50:29.64,0:50:33.98,English,,0,0,0,,Nothing about this is useful except to demonstrate some principles of
Dialogue: 0,0:50:29.64,0:50:33.98,Chinese,,0,0,0,,除了展示一些原则外，没有什么比这更有用了
Dialogue: 0,0:50:34.00,0:50:37.48,English,,0,0,0,,How to turn a switch statement into a assembly code
Dialogue: 0,0:50:34.00,0:50:37.48,Chinese,,0,0,0,,如何将switch语句转换为汇编代码
Dialogue: 0,0:50:38.32,0:50:45.88,English,,0,0,0,,So the point of it is as you know in C you switch on a particular value some type of integer value
Dialogue: 0,0:50:38.32,0:50:45.88,Chinese,,0,0,0,,因此，正如您在C中所知，您可以在特定值上切换某种类型的整数值
Dialogue: 0,0:50:46.64,0:50:49.12,English,,0,0,0,,And then it will match different cases
Dialogue: 0,0:50:46.64,0:50:49.12,Chinese,,0,0,0,,然后它将匹配不同的情况
Dialogue: 0,0:50:49.66,0:50:53.74,English,,0,0,0,,Where each of these cases has to be some constant numeric value
Dialogue: 0,0:50:49.66,0:50:53.74,Chinese,,0,0,0,,其中每个案例都必须是一些常数数值
Dialogue: 0,0:50:54.58,0:50:57.44,English,,0,0,0,,Constant integer value
Dialogue: 0,0:50:54.58,0:50:57.44,Chinese,,0,0,0,,常数整数值
Dialogue: 0,0:50:58.94,0:51:01.74,English,,0,0,0,,And one of the weirdest features of C is
Dialogue: 0,0:50:58.94,0:51:01.74,Chinese,,0,0,0,,而C的最奇怪的特征之一是
Dialogue: 0,0:51:02.28,0:51:06.38,English,,0,0,0,,If you don't at the end of the case if you don't explicitly say break
Dialogue: 0,0:51:02.28,0:51:06.38,Chinese,,0,0,0,,如果你没有在案件结尾处没有明确说明休息
Dialogue: 0,0:51:07.30,0:51:09.52,English,,0,0,0,,It'll do what's known as falling through
Dialogue: 0,0:51:07.30,0:51:09.52,Chinese,,0,0,0,,它会做所谓的堕落
Dialogue: 0,0:51:10.12,0:51:15.30,English,,0,0,0,,So in this example here it will y/z
Dialogue: 0,0:51:10.12,0:51:15.30,Chinese,,0,0,0,,所以在这个例子中，它将是y / z
Dialogue: 0,0:51:16.02,0:51:21.47,English,,0,0,0,,And then it will just glide right into this statement that adds z to w
Dialogue: 0,0:51:16.02,0:51:21.47,Chinese,,0,0,0,,然后它会直接滑入这个将z添加到w的语句中
Dialogue: 0,0:51:22.10,0:51:28.70,English,,0,0,0,,This is by the way like one of the worst design decisions in the history of programming languages
Dialogue: 0,0:51:22.10,0:51:28.70,Chinese,,0,0,0,,这就像编程语言历史上最糟糕的设计决策之一
Dialogue: 0,0:51:28.70,0:51:31.42,English,,0,0,0,,And it's been the cause of more and more
Dialogue: 0,0:51:28.70,0:51:31.42,Chinese,,0,0,0,,这是越来越多的原因
Dialogue: 0,0:51:31.98,0:51:37.58,English,,0,0,0,,You know heartbreak and bugs that nobody could understand than any other single part of the language
Dialogue: 0,0:51:31.98,0:51:37.58,Chinese,,0,0,0,,你知道除了该语言的任何其他单一部分，没有人能理解的心碎和错误
Dialogue: 0,0:51:38.50,0:51:43.88,English,,0,0,0,,And for some bizarre reason they've kept it alive even into java and all these other languages
Dialogue: 0,0:51:38.50,0:51:43.88,Chinese,,0,0,0,,而且由于一些奇怪的原因，他们甚至将它保留在java和所有其他语言中
Dialogue: 0,0:51:44.80,0:51:49.12,English,,0,0,0,,That fixed a lot of the worst parts you know the most dangerous parts of C
Dialogue: 0,0:51:44.80,0:51:49.12,Chinese,,0,0,0,,这解决了你知道C中最危险部分的许多最糟糕的部分
Dialogue: 0,0:51:49.12,0:51:50.78,English,,0,0,0,,But somehow they kept this future
Dialogue: 0,0:51:49.12,0:51:50.78,Chinese,,0,0,0,,但不知怎的，他们保留了这个未来
Dialogue: 0,0:51:51.52,0:51:56.62,English,,0,0,0,,And so just as a advice as a programmer if you ever ever use this
Dialogue: 0,0:51:51.52,0:51:56.62,Chinese,,0,0,0,,因此，如果你曾经使用过它，那么就像程序员那样的建议
Dialogue: 0,0:51:57.32,0:52:01.08,English,,0,0,0,,Where you purposely want it to go from one case to another
Dialogue: 0,0:51:57.32,0:52:01.08,Chinese,,0,0,0,,你故意想要从一个案件到另一个案件的地方
Dialogue: 0,0:52:01.50,0:52:04.28,English,,0,0,0,,You should have to put a comment in there to say
Dialogue: 0,0:52:01.50,0:52:04.28,Chinese,,0,0,0,,你应该在那里发表评论
Dialogue: 0,0:52:05.04,0:52:07.50,English,,0,0,0,,Trust me I really did want it to fall through
Dialogue: 0,0:52:05.04,0:52:07.50,Chinese,,0,0,0,,相信我，我真的希望它能够落空
Dialogue: 0,0:52:07.50,0:52:10.98,English,,0,0,0,,I know you almost never want to do this but I do here
Dialogue: 0,0:52:07.50,0:52:10.98,Chinese,,0,0,0,,我知道你几乎不想这样做，但我在这里
Dialogue: 0,0:52:12.50,0:52:15.12,English,,0,0,0,,So that's a fairly common convention
Dialogue: 0,0:52:12.50,0:52:15.12,Chinese,,0,0,0,,所以这是一个相当普遍的惯例
Dialogue: 0,0:52:15.40,0:52:20.68,English,,0,0,0,,I don't know how many times I've had bugs that were because I forgot to put breaks
Dialogue: 0,0:52:15.40,0:52:20.68,Chinese,,0,0,0,,我不知道有多少次因为我忘了休息而犯了虫子
Dialogue: 0,0:52:22.20,0:52:25.22,English,,0,0,0,,Anyways enough of my editorializing
Dialogue: 0,0:52:22.20,0:52:25.22,Chinese,,0,0,0,,无论如何，我的社论足够了
Dialogue: 0,0:52:26.48,0:52:29.48,English,,0,0,0,,The other feature you see and in C is
Dialogue: 0,0:52:26.48,0:52:29.48,Chinese,,0,0,0,,您在C中看到的另一个功能是
Dialogue: 0,0:52:29.94,0:52:33.26,English,,0,0,0,,You can sort of a bunch up multiple cases
Dialogue: 0,0:52:29.94,0:52:33.26,Chinese,,0,0,0,,你可以对多个案例进行排序
Dialogue: 0,0:52:33.58,0:52:36.84,English,,0,0,0,,If you think of it that's just a special case of the fall through
Dialogue: 0,0:52:33.58,0:52:36.84,Chinese,,0,0,0,,如果你认为这只是堕落的一个特例
Dialogue: 0,0:52:37.18,0:52:40.89,English,,0,0,0,,Write the case five has nothing to do but to fall through to six
Dialogue: 0,0:52:37.18,0:52:40.89,Chinese,,0,0,0,,写下案例五无所事事，但要落到六
Dialogue: 0,0:52:41.12,0:52:44.32,English,,0,0,0,,But so that's the same general way and there's nothing 
Dialogue: 0,0:52:41.12,0:52:44.32,Chinese,,0,0,0,,但是，这是一般的方式，没有什么
Dialogue: 0,0:52:44.42,0:52:48.08,English,,0,0,0,,That's not bad and it doesn't require a comment
Dialogue: 0,0:52:44.42,0:52:48.08,Chinese,,0,0,0,,这不错，也不需要评论
Dialogue: 0,0:52:49.54,0:52:53.48,English,,0,0,0,,And the other one is that there's a default, so if none of these cases match either
Dialogue: 0,0:52:49.54,0:52:53.48,Chinese,,0,0,0,,而另一个是默认值，所以如果这些情况都不匹配
Dialogue: 0,0:52:54.12,0:52:58.34,English,,0,0,0,,Because x was 0 or smaller or x was a really big number
Dialogue: 0,0:52:54.12,0:52:58.34,Chinese,,0,0,0,,因为x是0或更小，或者x是一个非常大的数字
Dialogue: 0,0:52:58.86,0:53:00.64,English,,0,0,0,,Or in this case if x were 4
Dialogue: 0,0:52:58.86,0:53:00.64,Chinese,,0,0,0,,或者在这种情况下，如果x是4
Dialogue: 0,0:53:02.12,0:53:03.62,English,,0,0,0,,There's no matching case
Dialogue: 0,0:53:02.12,0:53:03.62,Chinese,,0,0,0,,没有匹配的案例
Dialogue: 0,0:53:04.30,0:53:08.38,English,,0,0,0,,And of course you also know that these cases don't have to be in any particular order either
Dialogue: 0,0:53:04.30,0:53:08.38,Chinese,,0,0,0,,当然，您也知道这些案例也不必按任何特定顺序排列
Dialogue: 0,0:53:09.72,0:53:17.80,English,,0,0,0,,So that's all the sort of features of a case statement, a switch statements.Sorry
Dialogue: 0,0:53:09.72,0:53:17.80,Chinese,,0,0,0,,所以这就是case语句的所有特性，一个switch语句.Sorry
Dialogue: 0,0:53:18.54,0:53:26.20,English,,0,0,0,,So normally if you write this in sort of if you were told thou shalt not use switch statements anymore
Dialogue: 0,0:53:18.54,0:53:26.20,Chinese,,0,0,0,,所以通常情况下，如果你被告知你不应该再使用switch语句了
Dialogue: 0,0:53:26.84,0:53:32.50,English,,0,0,0,,What you'd probably do is write this big long chain of if else,if else,if else right
Dialogue: 0,0:53:26.84,0:53:32.50,Chinese,,0,0,0,,你可能要做的就是写一个if if的大长链，如果不是的话，如果不对的话
Dialogue: 0,0:53:33.82,0:53:37.65,English,,0,0,0,,Uh and you'd expect that to be the machine code but it's not
Dialogue: 0,0:53:33.82,0:53:37.65,Chinese,,0,0,0,,呃，你希望它是机器码，但事实并非如此
Dialogue: 0,0:53:37.84,0:53:41.78,English,,0,0,0,,And so let me show you what the machine code does
Dialogue: 0,0:53:37.84,0:53:41.78,Chinese,,0,0,0,,所以让我告诉你机器代码的作用
Dialogue: 0,0:53:42.30,0:53:43.84,English,,0,0,0,,It's kind of a long story
Dialogue: 0,0:53:42.30,0:53:43.84,Chinese,,0,0,0,,这是一个很长的故事
Dialogue: 0,0:53:44.62,0:53:50.08,English,,0,0,0,,So think of the general form of it as being some blocks of code
Dialogue: 0,0:53:44.62,0:53:50.08,Chinese,,0,0,0,,因此，将它的一般形式视为一些代码块
Dialogue: 0,0:53:51.78,0:53:56.44,English,,0,0,0,,The entry points of which are labeled by these case values
Dialogue: 0,0:53:51.78,0:53:56.44,Chinese,,0,0,0,,其入口点由这些案例值标记
Dialogue: 0,0:53:57.06,0:54:01.22,English,,0,0,0,,And then the box you know string together in various different ways and do various things
Dialogue: 0,0:53:57.06,0:54:01.22,Chinese,,0,0,0,,然后你知道的盒子以各种不同的方式串起来并做各种各样的事情
Dialogue: 0,0:54:02.02,0:54:06.80,English,,0,0,0,,What I'm going to do is compile a code for all of those blocks
Dialogue: 0,0:54:02.02,0:54:06.80,Chinese,,0,0,0,,我要做的是为所有这些块编译代码
Dialogue: 0,0:54:07.60,0:54:14.52,English,,0,0,0,,And store them away in some part of memory load up memory to contain these code blocks
Dialogue: 0,0:54:07.60,0:54:14.52,Chinese,,0,0,0,,并将它们存储在内存的某些部分加载内存以包含这些代码块
Dialogue: 0,0:54:14.90,0:54:16.56,English,,0,0,0,,And then I'm going to build a table
Dialogue: 0,0:54:14.90,0:54:16.56,Chinese,,0,0,0,,然后我要建一张桌子
Dialogue: 0,0:54:17.24,0:54:24.60,English,,0,0,0,,And each entry of this table describes the starting location of one of these code blocks
Dialogue: 0,0:54:17.24,0:54:24.60,Chinese,,0,0,0,,此表的每个条目都描述了其中一个代码块的起始位置
Dialogue: 0,0:54:25.58,0:54:29.86,English,,0,0,0,,And I'll put them in order of my case labels if I have
Dialogue: 0,0:54:25.58,0:54:29.86,Chinese,,0,0,0,,如果我有的话，我会把它们按照我的案例标签的顺序排列
Dialogue: 0,0:54:30.74,0:54:37.52,English,,0,0,0,,You know I want to span a scope from well let's assume zero but typically that's not the case
Dialogue: 0,0:54:30.74,0:54:37.52,Chinese,,0,0,0,,你知道我想跨越一个范围，我们假设零，但通常情况并非如此
Dialogue: 0,0:54:37.96,0:54:40.94,English,,0,0,0,,Zero up to n-1
Dialogue: 0,0:54:37.96,0:54:40.94,Chinese,,0,0,0,,归零至n-1
Dialogue: 0,0:54:41.44,0:54:47.14,English,,0,0,0,,I'll have this table will have that many entries of addresses to tell me
Dialogue: 0,0:54:41.44,0:54:47.14,Chinese,,0,0,0,,我将有这个表将有许多地址条目告诉我
Dialogue: 0,0:54:48.76,0:54:52.00,English,,0,0,0,,Where these code blocks are located
Dialogue: 0,0:54:48.76,0:54:52.00,Chinese,,0,0,0,,这些代码块的位置
Dialogue: 0,0:54:53.58,0:54:56.62,English,,0,0,0,,And then I'm going to use this really cool instruction
Dialogue: 0,0:54:53.58,0:54:56.62,Chinese,,0,0,0,,然后我将使用这个非常酷的指令
Dialogue: 0,0:54:57.40,0:55:04.36,English,,0,0,0,,Which is a sort of like it's as if you...it's like a ray indexing
Dialogue: 0,0:54:57.40,0:55:04.36,Chinese,,0,0,0,,这有点像你......它就像一个光线索引
Dialogue: 0,0:55:04.54,0:55:13.46,English,,0,0,0,,So if you think of a ray indexing it means you can grab a value out of the middle of some you know array
Dialogue: 0,0:55:04.54,0:55:13.46,Chinese,,0,0,0,,因此，如果您考虑光线索引，则意味着您可以从某些已知数组的中间获取值
Dialogue: 0,0:55:13.52,0:55:18.48,English,,0,0,0,,Some set of values without having to step through them one by one
Dialogue: 0,0:55:13.52,0:55:18.48,Chinese,,0,0,0,,一些值集，无需逐个逐步执行
Dialogue: 0,0:55:19.30,0:55:27.30,English,,0,0,0,,And it's the same idea here that I will take my value and use that to figure out directly
Dialogue: 0,0:55:19.30,0:55:27.30,Chinese,,0,0,0,,这是同样的想法，我将采取我的价值，并用它来直接弄清楚
Dialogue: 0,0:55:27.92,0:55:31.16,English,,0,0,0,,Where I should jump to a block of code
Dialogue: 0,0:55:27.92,0:55:31.16,Chinese,,0,0,0,,我应该跳到一块代码
Dialogue: 0,0:55:31.62,0:55:34.58,English,,0,0,0,,Without having to step through a bunch of other conditions
Dialogue: 0,0:55:31.62,0:55:34.58,Chinese,,0,0,0,,无需通过一堆其他条件
Dialogue: 0,0:55:36.06,0:55:40.08,English,,0,0,0,,So and you can see the efficiency again from that it's the difference between
Dialogue: 0,0:55:36.06,0:55:40.08,Chinese,,0,0,0,,所以，你可以再次看到效率，因为它是两者之间的差异
Dialogue: 0,0:55:40.78,0:55:44.90,English,,0,0,0,,Sort of in one step knowing exactly where you want to be versus
Dialogue: 0,0:55:40.78,0:55:44.90,Chinese,,0,0,0,,一步到位，准确地知道你想要对的地方
Dialogue: 0,0:55:46.28,0:55:51.68,English,,0,0,0,,Stepping through you know on average n over two conditions to get to where I want to go
Dialogue: 0,0:55:46.28,0:55:51.68,Chinese,,0,0,0,,逐步通过你知道平均n超过两个条件到达我想去的地方
Dialogue: 0,0:55:54.48,0:55:57.06,English,,0,0,0,,So let's look at this at the assembly code level
Dialogue: 0,0:55:54.48,0:55:57.06,Chinese,,0,0,0,,那么让我们在汇编代码级别看一下
Dialogue: 0,0:56:00.22,0:56:05.02,English,,0,0,0,,And it's a little bit of a long thing because we have to build some machinery around this
Dialogue: 0,0:56:00.22,0:56:05.02,Chinese,,0,0,0,,这有点长，因为我们必须围绕这个建立一些机制
Dialogue: 0,0:56:06.96,0:56:10.56,English,,0,0,0,,So here's my example I've got three arguments
Dialogue: 0,0:56:06.96,0:56:10.56,Chinese,,0,0,0,,所以这是我的例子，我有三个论点
Dialogue: 0,0:56:11.00,0:56:19.70,English,,0,0,0,,So just remember I told you are %rdi and %rsi for the first two arguments,the third argument is in %rdx
Dialogue: 0,0:56:11.00,0:56:19.70,Chinese,,0,0,0,,所以请记住我告诉你前两个参数是％rdi和％rsi，第三个参数是％rdx
Dialogue: 0,0:56:21.48,0:56:25.70,English,,0,0,0,,And here's the beginning of the switch code
Dialogue: 0,0:56:21.48,0:56:25.70,Chinese,,0,0,0,,这是开关代码的开头
Dialogue: 0,0:56:26.80,0:56:31.00,English,,0,0,0,,It's just making a copy of argument z here for some reason
Dialogue: 0,0:56:26.80,0:56:31.00,Chinese,,0,0,0,,由于某种原因，它只是在这里复制参数z
Dialogue: 0,0:56:31.56,0:56:38.74,English,,0,0,0,,And then it's looking at comparing x to 6 and y is 6 an important number
Dialogue: 0,0:56:31.56,0:56:38.74,Chinese,,0,0,0,,然后它正在考虑比较x到6，y是6这是一个重要的数字
Dialogue: 0,0:56:40.62,0:56:47.70,English,,0,0,0,,Because you see 6 was the largest value of any of my cases
Dialogue: 0,0:56:40.62,0:56:47.70,Chinese,,0,0,0,,因为你看到6是我任何案件中最大的价值
Dialogue: 0,0:56:48.16,0:56:53.18,English,,0,0,0,,And now it's using a jump instruction to go to .L8
Dialogue: 0,0:56:48.16,0:56:53.18,Chinese,,0,0,0,,现在它正在使用跳转指令转到.L8
Dialogue: 0,0:56:53.18,0:56:57.48,English,,0,0,0,,What we'll find is that tells you what the default behavior should be
Dialogue: 0,0:56:53.18,0:56:57.48,Chinese,,0,0,0,,我们会发现它会告诉您默认行为应该是什么
Dialogue: 0,0:56:58.42,0:57:02.82,English,,0,0,0,,So it's sort of flushing away the default cases
Dialogue: 0,0:56:58.42,0:57:02.82,Chinese,,0,0,0,,所以它有点冲掉了默认情况
Dialogue: 0,0:57:02.82,0:57:06.82,English,,0,0,0,,The cases that are either x is too small or x is too large
Dialogue: 0,0:57:02.82,0:57:06.82,Chinese,,0,0,0,,x的情况太小或x太大
Dialogue: 0,0:57:07.34,0:57:13.64,English,,0,0,0,,And I should mention there's a clever trick there if you look at 'ja' means jump above
Dialogue: 0,0:57:07.34,0:57:13.64,Chinese,,0,0,0,,我应该提一下，如果你看'ja'意味着跳过上面就有一个聪明的伎俩
Dialogue: 0,0:57:13.98,0:57:17.16,English,,0,0,0,,That's the unsigned comparison
Dialogue: 0,0:57:13.98,0:57:17.16,Chinese,,0,0,0,,那是未签名的比较
Dialogue: 0,0:57:17.64,0:57:24.48,English,,0,0,0,,And what it's making use of is our result that you remember that if a number is negative
Dialogue: 0,0:57:17.64,0:57:24.48,Chinese,,0,0,0,,它正在利用的是我们的结果，你记得如果一个数字是负数
Dialogue: 0,0:57:25.08,0:57:29.64,English,,0,0,0,,If you think of it as an unsigned value it becomes very large positive value
Dialogue: 0,0:57:25.08,0:57:29.64,Chinese,,0,0,0,,如果您将其视为无符号值，则会变为非常大的正值
Dialogue: 0,0:57:30.42,0:57:38.14,English,,0,0,0,,So by doing the "ja" instead of a "jg" right. Jump greater than I'm doing jump above
Dialogue: 0,0:57:30.42,0:57:38.14,Chinese,,0,0,0,,所以通过做“ja”而不是“jg”吧。跳得比我跳得更高
Dialogue: 0,0:57:38.98,0:57:51.80,English,,0,0,0,,It's saying I want to jump to the default if either x is greater than 6
Dialogue: 0,0:57:38.98,0:57:51.80,Chinese,,0,0,0,,如果x大于6，我想跳转到默认值
Dialogue: 0,0:57:52.50,0:57:56.70,English,,0,0,0,,But also it will cause it to jump if x is less than 0
Dialogue: 0,0:57:52.50,0:57:56.70,Chinese,,0,0,0,,但如果x小于0，它也会导致跳跃
Dialogue: 0,0:57:57.84,0:57:58.30,English,,0,0,0,,Got it
Dialogue: 0,0:57:57.84,0:57:58.30,Chinese,,0,0,0,,得到它了
Dialogue: 0,0:57:58.88,0:58:04.00,English,,0,0,0,,So it's a clever trick of unsigned versus signed numbers it's taking advantage of
Dialogue: 0,0:57:58.88,0:58:04.00,Chinese,,0,0,0,,所以这是一个聪明的技巧，无人签名和签名数字，它正在利用
Dialogue: 0,0:58:05.02,0:58:12.64,English,,0,0,0,,And then the final part is,this is the real heart of the work,this is my very special  goto instruction
Dialogue: 0,0:58:05.02,0:58:12.64,Chinese,,0,0,0,,然后最后一部分是，这是工作的真正核心，这是我非常特别的goto指令
Dialogue: 0,0:58:14.14,0:58:22.10,English,,0,0,0,,That lets me index into a table and extract out of that an address  and then jump to that address
Dialogue: 0,0:58:14.14,0:58:22.10,Chinese,,0,0,0,,这让我可以索引到一个表并从中提取出一个地址，然后跳转到该地址
Dialogue: 0,0:58:22.72,0:58:30.22,English,,0,0,0,,So that's what lets me go directly up to some block of code
Dialogue: 0,0:58:22.72,0:58:30.22,Chinese,,0,0,0,,这就是让我直接进入某些代码块的原因
Dialogue: 0,0:58:30.64,0:58:36.74,English,,0,0,0,,Based on whether my values will we'll see will be in the range between 0 and 6
Dialogue: 0,0:58:30.64,0:58:36.74,Chinese,,0,0,0,,根据我们看到的值是否在0到6之间
Dialogue: 0,0:58:38.04,0:58:40.32,English,,0,0,0,,So there'll be seven entries in that table
Dialogue: 0,0:58:38.04,0:58:40.32,Chinese,,0,0,0,,因此该表中将有七个条目
Dialogue: 0,0:58:44.90,0:58:48.00,English,,0,0,0,,One thing just to keep track up for later
Dialogue: 0,0:58:44.90,0:58:48.00,Chinese,,0,0,0,,有一点只是为了以后跟踪
Dialogue: 0,0:58:48.62,0:58:53.12,English,,0,0,0,,You'll see that for some reason the GCC said you know
Dialogue: 0,0:58:48.62,0:58:53.12,Chinese,,0,0,0,,你会看到由于某些原因海湾合作委员会说你知道
Dialogue: 0,0:58:53.86,0:58:59.40,English,,0,0,0,,If I look at all the code I actually don't use w as initialized very much
Dialogue: 0,0:58:53.86,0:58:59.40,Chinese,,0,0,0,,如果我查看所有代码，我实际上不会使用w作为非常初始化
Dialogue: 0,0:58:59.58,0:59:02.46,English,,0,0,0,,So I won't bother doing it until somewhere within the code blocks
Dialogue: 0,0:58:59.58,0:59:02.46,Chinese,,0,0,0,,所以我不会在代码块中的某个地方做这件事
Dialogue: 0,0:59:03.18,0:59:05.68,English,,0,0,0,,So just we'll have to keep track of that here
Dialogue: 0,0:59:03.18,0:59:05.68,Chinese,,0,0,0,,所以我们必须在这里跟踪它
Dialogue: 0,0:59:06.56,0:59:10.90,English,,0,0,0,,Okay so this is the magic instruction
Dialogue: 0,0:59:06.56,0:59:10.90,Chinese,,0,0,0,,好的，这是魔术指令
Dialogue: 0,0:59:12.24,0:59:16.20,English,,0,0,0,,And now if we look...this is all assembly code
Dialogue: 0,0:59:12.24,0:59:16.20,Chinese,,0,0,0,,现在，如果我们看...这是所有汇编代码
Dialogue: 0,0:59:17.16,0:59:19.32,English,,0,0,0,,You'll see this is the actual jump table
Dialogue: 0,0:59:17.16,0:59:19.32,Chinese,,0,0,0,,你会看到这是实际的跳转表
Dialogue: 0,0:59:20.04,0:59:23.68,English,,0,0,0,,And it's constructed it's specified in assembly code
Dialogue: 0,0:59:20.04,0:59:23.68,Chinese,,0,0,0,,它的构造是在汇编代码中指定的
Dialogue: 0,0:59:23.70,0:59:27.42,English,,0,0,0,,And it's the job of the assembler to actually fill in the contents of this table
Dialogue: 0,0:59:23.70,0:59:27.42,Chinese,,0,0,0,,实际填写此表的内容是汇编程序的工作
Dialogue: 0,0:59:28.88,0:59:31.16,English,,0,0,0,,Excuse me
Dialogue: 0,0:59:28.88,0:59:31.16,Chinese,,0,0,0,,劳驾
Dialogue: 0,0:59:32.00,0:59:36.16,English,,0,0,0,,But what the assembly code is telling the assembler is
Dialogue: 0,0:59:32.00,0:59:36.16,Chinese,,0,0,0,,但汇编代码告诉汇编程序的是什么
Dialogue: 0,0:59:36.68,0:59:41.98,English,,0,0,0,,I need a quad is just a declaration to say I need an 8 byte value here
Dialogue: 0,0:59:36.68,0:59:41.98,Chinese,,0,0,0,,我需要一个四元组只是一个声明，说我需要一个8字节的值
Dialogue: 0,0:59:42.46,0:59:45.54,English,,0,0,0,,And that value should match whatever address
Dialogue: 0,0:59:42.46,0:59:45.54,Chinese,,0,0,0,,并且该值应该匹配任何地址
Dialogue: 0,0:59:46.02,0:59:49.42,English,,0,0,0,,You decide you later determine is the address of
Dialogue: 0,0:59:46.02,0:59:49.42,Chinese,,0,0,0,,你决定以后确定的是地址
Dialogue: 0,0:59:49.58,0:59:54.04,English,,0,0,0,,Where I'm going to stick and label 8  and all these other ones
Dialogue: 0,0:59:49.58,0:59:54.04,Chinese,,0,0,0,,我要坚持并标记8和所有其他标签
Dialogue: 0,0:59:54.44,0:59:58.54,English,,0,0,0,,And these are in the order as I mentioned from x equals 0 through 6
Dialogue: 0,0:59:54.44,0:59:58.54,Chinese,,0,0,0,,这些是我提到的从x等于0到6的顺序
Dialogue: 0,0:59:59.56,1:00:03.64,English,,0,0,0,,And we can already see a few cases that are interesting here
Dialogue: 0,0:59:59.56,1:00:03.64,Chinese,,0,0,0,,我们已经可以看到一些有趣的案例
Dialogue: 0,1:00:04.36,1:00:07.16,English,,0,0,0,,Let me see if I've got a picture on this
Dialogue: 0,1:00:04.36,1:00:07.16,Chinese,,0,0,0,,让我看看我是否有这方面的照片
Dialogue: 0,1:00:12.60,1:00:13.70,English,,0,0,0,,Yeah
Dialogue: 0,1:00:12.60,1:00:13.70,Chinese,,0,0,0,,是啊
Dialogue: 0,1:00:16.66,1:00:22.54,English,,0,0,0,,So we can actually already see some of the logic of this switch statement
Dialogue: 0,1:00:16.66,1:00:22.54,Chinese,,0,0,0,,所以我们实际上已经可以看到这个switch语句的一些逻辑
Dialogue: 0,1:00:22.96,1:00:25.68,English,,0,0,0,,Built into the ordering of entries in this table
Dialogue: 0,1:00:22.96,1:00:25.68,Chinese,,0,0,0,,内置于此表中条目的顺序
Dialogue: 0,1:00:26.90,1:00:29.20,English,,0,0,0,,So in particular there is no case zero here
Dialogue: 0,1:00:26.90,1:00:29.20,Chinese,,0,0,0,,所以特别是这里没有案例零
Dialogue: 0,1:00:30.04,1:00:31.70,English,,0,0,0,,So case zero should be the default
Dialogue: 0,1:00:30.04,1:00:31.70,Chinese,,0,0,0,,所以情况零应该是默认值
Dialogue: 0,1:00:32.56,1:00:34.30,English,,0,0,0,,There is no case for here
Dialogue: 0,1:00:32.56,1:00:34.30,Chinese,,0,0,0,,这里没有任何案例
Dialogue: 0,1:00:34.92,1:00:36.72,English,,0,0,0,,So case four should be the default
Dialogue: 0,1:00:34.92,1:00:36.72,Chinese,,0,0,0,,因此案例四应该是默认值
Dialogue: 0,1:00:37.22,1:00:42.04,English,,0,0,0,,And it turns out and we already saw before the 'ja' instruction going to .L8
Dialogue: 0,1:00:37.22,1:00:42.04,Chinese,,0,0,0,,事实证明，我们已经在'ja'指令前看到了.L8
Dialogue: 0,1:00:42.20,1:00:47.06,English,,0,0,0,,So .L8 is actually where the code block is going to be for the default case
Dialogue: 0,1:00:42.20,1:00:47.06,Chinese,,0,0,0,,因此.L8实际上是默认情况下代码块的位置
Dialogue: 0,1:00:47.64,1:00:53.90,English,,0,0,0,,So you see basically you can think of this as sometimes kept having holes in your switch statement
Dialogue: 0,1:00:47.64,1:00:53.90,Chinese,,0,0,0,,所以你基本上可以看到，因为有时候你的switch语句中有漏洞
Dialogue: 0,1:00:54.28,1:01:00.12,English,,0,0,0,,And we're going to just fill in those holes by saying those should go to the default case
Dialogue: 0,1:00:54.28,1:01:00.12,Chinese,,0,0,0,,而且我们只是填写那些漏洞，说那些应该是默认情况
Dialogue: 0,1:01:03.40,1:01:09.24,English,,0,0,0,,And here you'll notice that they're not put in any particularly logical order
Dialogue: 0,1:01:03.40,1:01:09.24,Chinese,,0,0,0,,在这里你会注意到它们没有按照任何特别合乎逻辑的顺序排列
Dialogue: 0,1:01:09.82,1:01:19.94,English,,0,0,0,,A one thing you'll see again is .L7 is repeated twice here
Dialogue: 0,1:01:09.82,1:01:19.94,Chinese,,0,0,0,,你将再次看到的一件事是.L7在这里重复两次
Dialogue: 0,1:01:20.80,1:01:24.06,English,,0,0,0,,Because it covers both cases five and six
Dialogue: 0,1:01:20.80,1:01:24.06,Chinese,,0,0,0,,因为它涵盖了五个和六个案例
Dialogue: 0,1:01:24.44,1:01:27.92,English,,0,0,0,,So again you'll see this sort of doubling up is handled automatically
Dialogue: 0,1:01:24.44,1:01:27.92,Chinese,,0,0,0,,所以你再次看到这种加倍是自动处理的
Dialogue: 0,1:01:28.56,1:01:33.76,English,,0,0,0,,By the jump table will give you the same address for multiple different cases
Dialogue: 0,1:01:28.56,1:01:33.76,Chinese,,0,0,0,,通过跳转表将为多个不同的情况提供相同的地址
Dialogue: 0,1:01:38.32,1:01:41.74,English,,0,0,0,,Okay and now the rest of it is to look at the various code box
Dialogue: 0,1:01:38.32,1:01:41.74,Chinese,,0,0,0,,好的，现在剩下的就是查看各种代码框
Dialogue: 0,1:01:41.74,1:01:48.43,English,,0,0,0,,And this by the way I'm showing you, I'm took a file you know extracted little bits of it
Dialogue: 0,1:01:41.74,1:01:48.43,Chinese,,0,0,0,,这就是我向你展示的方式，我拿了一个你知道提取它的文件
Dialogue: 0,1:01:48.48,1:01:52.00,English,,0,0,0,,But normally you're looking at this whole listing in one big order
Dialogue: 0,1:01:48.48,1:01:52.00,Chinese,,0,0,0,,但通常你会在一个大订单中查看整个列表
Dialogue: 0,1:01:53.06,1:01:57.62,English,,0,0,0,,So now we can look at the individual code blocks and see what's going on
Dialogue: 0,1:01:53.06,1:01:57.62,Chinese,,0,0,0,,所以现在我们可以查看各个代码块并查看发生了什么
Dialogue: 0,1:01:57.62,1:02:01.94,English,,0,0,0,,And you'll see for example case one told me to multiply two numbers
Dialogue: 0,1:01:57.62,1:02:01.94,Chinese,,0,0,0,,你会看到例如案例一告诉我要乘以两个数字
Dialogue: 0,1:02:02.54,1:02:03.94,English,,0,0,0,,And you'll see that the break
Dialogue: 0,1:02:02.54,1:02:03.94,Chinese,,0,0,0,,你会看到休息时间
Dialogue: 0,1:02:04.50,1:02:08.02,English,,0,0,0,,In general it's just going to be turned into returned instructions here
Dialogue: 0,1:02:04.50,1:02:08.02,Chinese,,0,0,0,,一般情况下，这里只会转换为返回的指令
Dialogue: 0,1:02:08.02,1:02:13.70,English,,0,0,0,,Because my function...let's go sorry to jump in code
Dialogue: 0,1:02:08.02,1:02:13.70,Chinese,,0,0,0,,因为我的功能...让我们很抱歉跳进代码
Dialogue: 0,1:02:13.76,1:02:17.86,English,,0,0,0,,You see this function did a switch statement and then whatever
Dialogue: 0,1:02:13.76,1:02:17.86,Chinese,,0,0,0,,你看到这个函数做了一个switch语句然后做了什么
Dialogue: 0,1:02:19.86,1:02:24.74,English,,0,0,0,,Whatever it gets computed within the switch statement gets returned as a result of this
Dialogue: 0,1:02:19.86,1:02:24.74,Chinese,,0,0,0,,无论在switch语句中计算什么，都会因此而返回
Dialogue: 0,1:02:25.50,1:02:32.24,English,,0,0,0,,So the compiler doesn't actually come to a single point and say okay everyone returned at this point
Dialogue: 0,1:02:25.50,1:02:32.24,Chinese,,0,0,0,,因此，编译器实际上并没有达到单点并且说好了每个人都返回了这一点
Dialogue: 0,1:02:32.24,1:02:36.60,English,,0,0,0,,It just sticks returns directly in wherever these breaks occur
Dialogue: 0,1:02:32.24,1:02:36.60,Chinese,,0,0,0,,它只会直接在这些中断发生的地方保持回报
Dialogue: 0,1:02:42.48,1:02:44.82,English,,0,0,0,,And so here it does a multiply and a return
Dialogue: 0,1:02:42.48,1:02:44.82,Chinese,,0,0,0,,所以这里有一个乘法和一个回报
Dialogue: 0,1:02:46.94,1:02:53.80,English,,0,0,0,,Here is actually a curious by the way I'm always somewhat surprised by what the compiler does
Dialogue: 0,1:02:46.94,1:02:53.80,Chinese,,0,0,0,,这实际上是一种奇怪的方式，我总是对编译器的作用感到有些惊讶
Dialogue: 0,1:02:55.26,1:02:57.54,English,,0,0,0,,It is never exactly what you'd expect
Dialogue: 0,1:02:55.26,1:02:57.54,Chinese,,0,0,0,,它永远不会是你期望的
Dialogue: 0,1:02:58.64,1:03:09.52,English,,0,0,0,,So in particular, it patched together this fall through case by two blocks of code
Dialogue: 0,1:02:58.64,1:03:09.52,Chinese,,0,0,0,,所以特别是，它通过两个代码块拼凑了这个秋天
Dialogue: 0,1:03:11.32,1:03:14.10,English,,0,0,0,,And it had to do these separately
Dialogue: 0,1:03:11.32,1:03:14.10,Chinese,,0,0,0,,它必须分开做这些
Dialogue: 0,1:03:14.12,1:03:22.84,English,,0,0,0,,Because remember w was not set before I entered the this these code blocks it deferred setting that
Dialogue: 0,1:03:14.12,1:03:22.84,Chinese,,0,0,0,,因为在我输入之前没有设置记住w这些代码阻止它延迟设置
Dialogue: 0,1:03:23.30,1:03:26.42,English,,0,0,0,,And here I hit case three and all of a sudden I actually need
Dialogue: 0,1:03:23.30,1:03:26.42,Chinese,,0,0,0,,在这里，我遇到了案例三，突然间我真的需要
Dialogue: 0,1:03:26.80,1:03:29.16,English,,0,0,0,,Whatever w was which was one
Dialogue: 0,1:03:26.80,1:03:29.16,Chinese,,0,0,0,,无论什么是哪一个
Dialogue: 0,1:03:29.68,1:03:36.24,English,,0,0,0,,And so I guess the compiler said well gosh I guess I better set w to one here before we continue
Dialogue: 0,1:03:29.68,1:03:36.24,Chinese,,0,0,0,,所以我想编译器说得很好，我想我最好在继续之前将w设置为一个
Dialogue: 0,1:03:36.96,1:03:39.48,English,,0,0,0,,So as the result it sort of creates two code blocks
Dialogue: 0,1:03:36.96,1:03:39.48,Chinese,,0,0,0,,因此，结果它创建了两个代码块
Dialogue: 0,1:03:39.50,1:03:43.18,English,,0,0,0,,But it jumps from the second one the
Dialogue: 0,1:03:39.50,1:03:43.18,Chinese,,0,0,0,,但是它从第二个跳了起来
Dialogue: 0,1:03:43.42,1:03:47.06,English,,0,0,0,,This block into partway through this other block
Dialogue: 0,1:03:43.42,1:03:47.06,Chinese,,0,0,0,,这个块进入了另一个块的中途
Dialogue: 0,1:03:51.20,1:03:56.30,English,,0,0,0,,Here's some actual,yeah so here's the actual code
Dialogue: 0,1:03:51.20,1:03:56.30,Chinese,,0,0,0,,这是一些实际的，是的，所以这是实际的代码
Dialogue: 0,1:03:57.28,1:04:01.96,English,,0,0,0,,This is the block that does the division it's very quirky how you have to write division
Dialogue: 0,1:03:57.28,1:04:01.96,Chinese,,0,0,0,,这是划分的区块，你必须写分区是非常古怪的
Dialogue: 0,1:04:02.50,1:04:04.84,English,,0,0,0,,It's covered in the book I won't go through it here
Dialogue: 0,1:04:02.50,1:04:04.84,Chinese,,0,0,0,,这本书的内容我不会在这里介绍它
Dialogue: 0,1:04:05.44,1:04:08.98,English,,0,0,0,,And then this jump .L6 is what I say go to merge
Dialogue: 0,1:04:05.44,1:04:08.98,Chinese,,0,0,0,,然后这个跳转.L6就是我说的合并
Dialogue: 0,1:04:09.50,1:04:12.30,English,,0,0,0,,And the merge is where you're bringing these two cases together
Dialogue: 0,1:04:09.50,1:04:12.30,Chinese,,0,0,0,,合并是你将这两个案例放在一起的地方
Dialogue: 0,1:04:12.86,1:04:15.00,English,,0,0,0,,Here is where it's setting l to one
Dialogue: 0,1:04:12.86,1:04:15.00,Chinese,,0,0,0,,这是它设置为1的地方
Dialogue: 0,1:04:17.22,1:04:22.88,English,,0,0,0,,Again it's making use of this feature and that the upper 32 bits get set to zeros
Dialogue: 0,1:04:17.22,1:04:22.88,Chinese,,0,0,0,,它再次使用此功能，并将高32位设置为零
Dialogue: 0,1:04:22.96,1:04:26.72,English,,0,0,0,,So I can use a movl instruction here
Dialogue: 0,1:04:22.96,1:04:26.72,Chinese,,0,0,0,,所以我可以在这里使用movl指令
Dialogue: 0,1:04:26.72,1:04:27.56,English,,0,0,0,,Yes question
Dialogue: 0,1:04:26.72,1:04:27.56,Chinese,,0,0,0,,是的问题
Dialogue: 0,1:04:27.72,1:04:33.94,English,,0,0,0,,[student speaking]
Dialogue: 0,1:04:27.72,1:04:33.94,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:33.98,1:04:39.24,English,,0,0,0,,Did not have the code for what...no the jump table is sort of embedded
Dialogue: 0,1:04:33.98,1:04:39.24,Chinese,,0,0,0,,没有代码...没有跳转表是嵌入式的
Dialogue: 0,1:04:39.94,1:04:41.34,English,,0,0,0,,Let me just show you real quick
Dialogue: 0,1:04:39.94,1:04:41.34,Chinese,,0,0,0,,让我快速向您展示
Dialogue: 0,1:04:44.08,1:04:45.14,English,,0,0,0,,No probably bad idea
Dialogue: 0,1:04:44.08,1:04:45.14,Chinese,,0,0,0,,不可能是坏主意
Dialogue: 0,1:04:48.10,1:04:52.30,English,,0,0,0,,The jump if you look at the the .s file the assembly code file
Dialogue: 0,1:04:48.10,1:04:52.30,Chinese,,0,0,0,,如果你查看汇编代码文件的.s文件，就会跳转
Dialogue: 0,1:04:52.98,1:04:56.84,English,,0,0,0,,Oh all this stuff I'm showing you i've extracted out of that
Dialogue: 0,1:04:52.98,1:04:56.84,Chinese,,0,0,0,,哦，所有这些东西，我告诉你，我已经从中提取出来了
Dialogue: 0,1:04:57.48,1:05:02.04,English,,0,0,0,,But it's all in there and so that the compiler generated these tables
Dialogue: 0,1:04:57.48,1:05:02.04,Chinese,,0,0,0,,但它都在那里，所以编译器生成了这些表
Dialogue: 0,1:05:02.48,1:05:05.12,English,,0,0,0,,At least the sort of framework for these tables
Dialogue: 0,1:05:02.48,1:05:05.12,Chinese,,0,0,0,,至少这些表的框架类型
Dialogue: 0,1:05:05.58,1:05:08.14,English,,0,0,0,,The details of which get filled in by the assembler
Dialogue: 0,1:05:05.58,1:05:08.14,Chinese,,0,0,0,,其中的详细信息由汇编程序填写
Dialogue: 0,1:05:08.82,1:05:11.06,English,,0,0,0,,So it is generated by the compiler
Dialogue: 0,1:05:08.82,1:05:11.06,Chinese,,0,0,0,,所以它是由编译器生成的
Dialogue: 0,1:05:16.66,1:05:23.34,English,,0,0,0,,Okay so that just shows you this one example of handling a particular way to handle the fall through case
Dialogue: 0,1:05:16.66,1:05:23.34,Chinese,,0,0,0,,好的，这只是向您展示了处理特定方法以处理坠落情况的这一个示例
Dialogue: 0,1:05:24.44,1:05:31.16,English,,0,0,0,,And then the remaining ones, again you'll see here I got, if I get to this case
Dialogue: 0,1:05:24.44,1:05:31.16,Chinese,,0,0,0,,然后剩下的那些，如果我接触到这个案子，你会再次看到我得到的
Dialogue: 0,1:05:31.30,1:05:34.04,English,,0,0,0,,I need the fact that w is initialized to 1
Dialogue: 0,1:05:31.30,1:05:34.04,Chinese,,0,0,0,,我需要w被初始化为1的事实
Dialogue: 0,1:05:34.68,1:05:35.88,English,,0,0,0,,So we'll do so here
Dialogue: 0,1:05:34.68,1:05:35.88,Chinese,,0,0,0,,所以我们在这里这样做
Dialogue: 0,1:05:37.20,1:05:41.06,English,,0,0,0,,In the default case it just assigns to 2w and so that's all it does
Dialogue: 0,1:05:37.20,1:05:41.06,Chinese,,0,0,0,,在默认情况下，它只分配给2w，所以它就是这样
Dialogue: 0,1:05:41.94,1:05:44.66,English,,0,0,0,,So anyways I've actually shown you all the code box
Dialogue: 0,1:05:41.94,1:05:44.66,Chinese,,0,0,0,,所以无论如何我实际上已经向你展示了所有的代码框
Dialogue: 0,1:05:44.88,1:05:50.62,English,,0,0,0,,But I've shown you one by one, but they're just all kind of strung in the file and in no particular order
Dialogue: 0,1:05:44.88,1:05:50.62,Chinese,,0,0,0,,但是我已经逐一向你展示了，但它们只是在文件中串起来，并没有特别的顺序
Dialogue: 0,1:05:51.14,1:05:52.93,English,,0,0,0,,It doesn't matter what order they are
Dialogue: 0,1:05:51.14,1:05:52.93,Chinese,,0,0,0,,它们的顺序无关紧要
Dialogue: 0,1:05:53.38,1:05:54.04,English,,0,0,0,,Yes
Dialogue: 0,1:05:53.38,1:05:54.04,Chinese,,0,0,0,,是
Dialogue: 0,1:05:55.34,1:06:02.24,English,,0,0,0,,[student speaking]
Dialogue: 0,1:05:55.34,1:06:02.24,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:06:02.24,1:06:06.00,English,,0,0,0,,Yes so that was the reason for that jump above(ja) at the beginning
Dialogue: 0,1:06:02.24,1:06:06.00,Chinese,,0,0,0,,是的，这就是在开始时跳过（ja）的原因
Dialogue: 0,1:06:10.10,1:06:17.76,English,,0,0,0,,So this jump above(ja) .L8 was a way that if x was either less than zero or greater than 6
Dialogue: 0,1:06:10.10,1:06:17.76,Chinese,,0,0,0,,所以这跳过（ja）.L8是一种方式，如果x小于零或大于6
Dialogue: 0,1:06:18.74,1:06:23.40,English,,0,0,0,,It would go to the default case and it will only do this indexing trick
Dialogue: 0,1:06:18.74,1:06:23.40,Chinese,,0,0,0,,它将转到默认情况，它只会执行此索引技巧
Dialogue: 0,1:06:24.48,1:06:31.36,English,,0,0,0,,If x is between 0 and 6
Dialogue: 0,1:06:24.48,1:06:31.36,Chinese,,0,0,0,,如果x介于0和6之间
Dialogue: 0,1:06:32.72,1:06:35.36,English,,0,0,0,,And that's typically the way this works that you'll see that
Dialogue: 0,1:06:32.72,1:06:35.36,Chinese,,0,0,0,,这通常是你看到的方式
Dialogue: 0,1:06:36.28,1:06:42.36,English,,0,0,0,,Whatever range of values you give it has to figure out the smallest and the largest one set up
Dialogue: 0,1:06:36.28,1:06:42.36,Chinese,,0,0,0,,无论您给出的值是多少，都必须找出最小和最大的值
Dialogue: 0,1:06:42.54,1:06:48.90,English,,0,0,0,,So it goes to the default case if it's out of that range and then set up a table for the values within that range
Dialogue: 0,1:06:42.54,1:06:48.90,Chinese,,0,0,0,,因此，如果它超出该范围，则进入默认情况，然后为该范围内的值设置表
Dialogue: 0,1:06:49.34,1:06:50.06,English,,0,0,0,,Question
Dialogue: 0,1:06:49.34,1:06:50.06,Chinese,,0,0,0,,题
Dialogue: 0,1:06:50.24,1:06:58.52,English,,0,0,0,,...number two...yeah...does it try to like do the index into it with that x some how...
Dialogue: 0,1:06:50.24,1:06:58.52,Chinese,,0,0,0,,......第二......是啊...它是否试图像使用那个x做索引一样...
Dialogue: 0,1:06:58.52,1:07:02.20,English,,0,0,0,,So the question I'm rose I should be repeating questions
Dialogue: 0,1:06:58.52,1:07:02.20,Chinese,,0,0,0,,所以我提出的问题应该是重复问题
Dialogue: 0,1:07:02.62,1:07:08.38,English,,0,0,0,,The question is of what if it's a negative number for your case which is perfectly legal
Dialogue: 0,1:07:02.62,1:07:08.38,Chinese,,0,0,0,,问题是如果你的案件的负数是完全合法的
Dialogue: 0,1:07:08.78,1:07:12.12,English,,0,0,0,,It will typically add a bias to it effectively
Dialogue: 0,1:07:08.78,1:07:12.12,Chinese,,0,0,0,,它通常会有效地增加偏见
Dialogue: 0,1:07:12.14,1:07:16.32,English,,0,0,0,,So that whatever your lowest value was become zero
Dialogue: 0,1:07:12.14,1:07:16.32,Chinese,,0,0,0,,所以无论你的最低价值是多少
Dialogue: 0,1:07:17.02,1:07:20.76,English,,0,0,0,,Or it'll do something like that to avoid having to do negative indexing
Dialogue: 0,1:07:17.02,1:07:20.76,Chinese,,0,0,0,,或者它会做类似的事情，以避免不得不做负面的索引
Dialogue: 0,1:07:21.74,1:07:25.02,English,,0,0,0,,Another question I see,yes
Dialogue: 0,1:07:21.74,1:07:25.02,Chinese,,0,0,0,,我看到的另一个问题，是的
Dialogue: 0,1:07:25.62,1:07:32.20,English,,0,0,0,,....yeah so you can go from zero to a million ....
Dialogue: 0,1:07:25.62,1:07:32.20,Chinese,,0,0,0,,....是的，所以你可以从零到百万......
Dialogue: 0,1:07:33.12,1:07:36.34,English,,0,0,0,,Yeah they could be you could go zero in a million and nothing in between right
Dialogue: 0,1:07:33.12,1:07:36.34,Chinese,,0,0,0,,是的，他们可能是你可以在百万分之一，而在两者之间没有任何东西
Dialogue: 0,1:07:36.86,1:07:42.10,English,,0,0,0,,So you'd have two cases you really don't want a million entry table for just two cases
Dialogue: 0,1:07:36.86,1:07:42.10,Chinese,,0,0,0,,所以你有两个案例你真的不想要一个百万条目表只有两个案例
Dialogue: 0,1:07:42.66,1:07:44.80,English,,0,0,0,,So it will turn it into if felts code
Dialogue: 0,1:07:42.66,1:07:44.80,Chinese,,0,0,0,,如果毛毡代码，它会变成它
Dialogue: 0,1:07:45.28,1:07:48.24,English,,0,0,0,,But the clever thing it will do if you know binary search
Dialogue: 0,1:07:45.28,1:07:48.24,Chinese,,0,0,0,,但是如果你知道二进制搜索它将会做的聪明的事情
Dialogue: 0,1:07:49.38,1:07:54.82,English,,0,0,0,,It relies on the fact that it knows in advance all the values and it will actually set up a tree of if felts is
Dialogue: 0,1:07:49.38,1:07:54.82,Chinese,,0,0,0,,它依赖于这样一个事实：它事先知道所有的值，它实际上会建立一个如果毛毡的树
Dialogue: 0,1:07:55.58,1:08:02.16,English,,0,0,0,,So really it will do it, if you want to thank algorithmically it does it with a logarithmic number of tests
Dialogue: 0,1:07:55.58,1:08:02.16,Chinese,,0,0,0,,所以它真的会这样做，如果你想在算法上感谢它用对数的测试来做到这一点
Dialogue: 0,1:08:02.88,1:08:07.16,English,,0,0,0,,Rather than a linear number of tests
Dialogue: 0,1:08:02.88,1:08:07.16,Chinese,,0,0,0,,而不是线性数量的测试
Dialogue: 0,1:08:07.16,1:08:09.16,English,,0,0,0,,Question
Dialogue: 0,1:08:07.16,1:08:09.16,Chinese,,0,0,0,,题
Dialogue: 0,1:08:09.30,1:08:19.74,English,,0,0,0,,Oh yes yeah so
Dialogue: 0,1:08:09.30,1:08:19.74,Chinese,,0,0,0,,哦，是的，是的
Dialogue: 0,1:08:20.62,1:08:22.26,English,,0,0,0,,So these two answers that
Dialogue: 0,1:08:20.62,1:08:22.26,Chinese,,0,0,0,,所以这两个答案就是这样
Dialogue: 0,1:08:22.26,1:08:25.46,English,,0,0,0,,One is if which I actually answered both now
Dialogue: 0,1:08:22.26,1:08:25.46,Chinese,,0,0,0,,一个是我现在实际回答的问题
Dialogue: 0,1:08:25.98,1:08:32.12,English,,0,0,0,,If one is what if there's some negative values or what if the lowest number is 5700 right
Dialogue: 0,1:08:25.98,1:08:32.12,Chinese,,0,0,0,,如果有一个负值，或者如果最低数字是5700，那么该怎么办？
Dialogue: 0,1:08:32.54,1:08:35.42,English,,0,0,0,,Well what it will typically do is put some bias
Dialogue: 0,1:08:32.54,1:08:35.42,Chinese,,0,0,0,,那么它通常会做些什么是偏见
Dialogue: 0,1:08:36.22,1:08:41.14,English,,0,0,0,,And you'll add or subtract some value so that the first case is at value 0
Dialogue: 0,1:08:36.22,1:08:41.14,Chinese,,0,0,0,,并且您将添加或减去某个值，以便第一个案例的值为0
Dialogue: 0,1:08:41.86,1:08:45.36,English,,0,0,0,,So that's why it handles you know ones that are just completely out of range
Dialogue: 0,1:08:41.86,1:08:45.36,Chinese,,0,0,0,,这就是为什么它处理你知道那些完全超出范围的原因
Dialogue: 0,1:08:45.62,1:08:50.98,English,,0,0,0,,And the other is what if it's a really big spread of values and relatively sparse
Dialogue: 0,1:08:45.62,1:08:50.98,Chinese,,0,0,0,,另一个是如果它是一个非常大的价值传播和相对稀疏的话
Dialogue: 0,1:08:51.50,1:08:55.58,English,,0,0,0,,How much you're using it and there will revert to if-else code
Dialogue: 0,1:08:51.50,1:08:55.58,Chinese,,0,0,0,,你使用它多少，并将恢复到if-else代码
Dialogue: 0,1:08:55.74,1:08:59.22,English,,0,0,0,,And the compiler has its own rules about how it does these things
Dialogue: 0,1:08:55.74,1:08:59.22,Chinese,,0,0,0,,编译器有自己的规则来处理这些事情
Dialogue: 0,1:08:59.22,1:09:02.34,English,,0,0,0,,You can sort of run experiments and try and reverse engineer
Dialogue: 0,1:08:59.22,1:09:02.34,Chinese,,0,0,0,,您可以进行运行实验并尝试逆向工程
Dialogue: 0,1:09:03.28,1:09:06.46,English,,0,0,0,,Those 0 these are all valid questions by the way appreciate
Dialogue: 0,1:09:03.28,1:09:06.46,Chinese,,0,0,0,,这些0都是有道理的问题
Dialogue: 0,1:09:11.98,1:09:15.86,English,,0,0,0,,Okay so we're going to get through this
Dialogue: 0,1:09:11.98,1:09:15.86,Chinese,,0,0,0,,好的，所以我们要完成这个
Dialogue: 0,1:09:17.48,1:09:26.26,English,,0,0,0,,Oh so anyways in like I said I think in my own experience you know understanding
Dialogue: 0,1:09:17.48,1:09:26.26,Chinese,,0,0,0,,哦，所以无论如何，就像我说的，我认为根据我自己的经验，你知道理解
Dialogue: 0,1:09:27.90,1:09:36.42,English,,0,0,0,,The conditionals you can kind of figure that out it's intuitive sort of feels like what you'd expect a program to do
Dialogue: 0,1:09:27.90,1:09:36.42,Chinese,,0,0,0,,条件你可以想象它的直观感觉就像你期望程序做的那样
Dialogue: 0,1:09:36.82,1:09:43.56,English,,0,0,0,,Whereas the switch statement is maybe unexpected,it's a way to do something
Dialogue: 0,1:09:36.82,1:09:43.56,Chinese,,0,0,0,,虽然switch语句可能是意料之外的，但它是一种做某事的方法
Dialogue: 0,1:09:44.00,1:09:50.94,English,,0,0,0,,That is not totally obvious but if then when you think about it and appreciate it
Dialogue: 0,1:09:44.00,1:09:50.94,Chinese,,0,0,0,,这并不是完全明显的，但如果你想到它并欣赏它的话
Dialogue: 0,1:09:50.94,1:09:54.68,English,,0,0,0,,Actually it gives you a good performance boost
Dialogue: 0,1:09:50.94,1:09:54.68,Chinese,,0,0,0,,实际上它可以为您带来良好的性能提升
Dialogue: 0,1:09:55.12,1:09:57.86,English,,0,0,0,,You know again algorithmically this jump table makes it
Dialogue: 0,1:09:55.12,1:09:57.86,Chinese,,0,0,0,,你在算法上再次知道这个跳转表
Dialogue: 0,1:09:58.34,1:10:06.28,English,,0,0,0,,So it's a constant time a constant number of steps to get to where you need to in the switch statement
Dialogue: 0,1:09:58.34,1:10:06.28,Chinese,,0,0,0,,因此，在switch语句中获取所需位置的常量步数是一个恒定的时间
Dialogue: 0,1:10:06.86,1:10:10.48,English,,0,0,0,,If you just did it linearly one after the other
Dialogue: 0,1:10:06.86,1:10:10.48,Chinese,,0,0,0,,如果你只是一个接一个线性地做
Dialogue: 0,1:10:10.92,1:10:16.10,English,,0,0,0,,Then that would be linear time and you'd expect on you know if everything's uniform and average
Dialogue: 0,1:10:10.92,1:10:16.10,Chinese,,0,0,0,,然后那将是线性时间，你会期望你知道一切都是统一的和平均的
Dialogue: 0,1:10:16.52,1:10:19.92,English,,0,0,0,,About how you'd be about halfway through on average
Dialogue: 0,1:10:16.52,1:10:19.92,Chinese,,0,0,0,,关于你平均到一半的方式
Dialogue: 0,1:10:20.74,1:10:25.10,English,,0,0,0,,If you...if it's sparse you'll see it will set up a tree of conditionals
Dialogue: 0,1:10:20.74,1:10:25.10,Chinese,,0,0,0,,如果你...如果它稀疏你会看到它会设置一个条件树
Dialogue: 0,1:10:25.60,1:10:27.76,English,,0,0,0,,So it can do in logarithmic time so
Dialogue: 0,1:10:25.60,1:10:27.76,Chinese,,0,0,0,,所以它可以在对数时间内完成
Dialogue: 0,1:10:28.08,1:10:32.66,English,,0,0,0,,No matter what it will be better than just what you'd get in the obvious form of your felts
Dialogue: 0,1:10:28.08,1:10:32.66,Chinese,,0,0,0,,无论什么比你毛毡的明显形式更好
Dialogue: 0,1:10:32.79,1:10:33.96,English,,0,0,0,,I saw a question over here
Dialogue: 0,1:10:32.79,1:10:33.96,Chinese,,0,0,0,,我在这看到一个问题
Dialogue: 0,1:10:34.00,1:10:37.90,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:34.00,1:10:37.90,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:10:37.90,1:10:44.58,English,,0,0,0,,Well the good news is,I don't set up the jump tree the compiler sets up the jump tree right
Dialogue: 0,1:10:37.90,1:10:44.58,Chinese,,0,0,0,,好消息是，我没有设置跳转树，编译器正确设置跳转树
Dialogue: 0,1:10:45.46,1:10:49.52,English,,0,0,0,,But if you're asking if I were a compiler how would I set up the jump tree right
Dialogue: 0,1:10:45.46,1:10:49.52,Chinese,,0,0,0,,但是，如果你问我是否是编译器，我将如何正确设置跳转树
Dialogue: 0,1:10:49.52,1:10:51.02,English,,0,0,0,,Which is a good question
Dialogue: 0,1:10:49.52,1:10:51.02,Chinese,,0,0,0,,这是个好问题
Dialogue: 0,1:10:51.44,1:10:53.28,English,,0,0,0,,If you know binary search right
Dialogue: 0,1:10:51.44,1:10:53.28,Chinese,,0,0,0,,如果你知道二进制搜索权利
Dialogue: 0,1:10:53.28,1:10:57.80,English,,0,0,0,,That you've got a range of values and you pick you compare it to the middle value
Dialogue: 0,1:10:53.28,1:10:57.80,Chinese,,0,0,0,,您有一系列值，并且您选择将其与中间值进行比较
Dialogue: 0,1:10:58.14,1:11:01.22,English,,0,0,0,,And it's either less or it's greater or equal
Dialogue: 0,1:10:58.14,1:11:01.22,Chinese,,0,0,0,,它要么更少，要么更大或更平等
Dialogue: 0,1:11:01.86,1:11:07.40,English,,0,0,0,,And if it's less than you sort of recursively handle the one set and if it's greater at the other hip
Dialogue: 0,1:11:01.86,1:11:07.40,Chinese,,0,0,0,,如果它小于你的递归处理一组，如果它在另一个臀部更大
Dialogue: 0,1:11:07.72,1:11:09.90,English,,0,0,0,,That's exactly what these trees look like
Dialogue: 0,1:11:07.72,1:11:09.90,Chinese,,0,0,0,,这正是这些树的样子
Dialogue: 0,1:11:10.58,1:11:13.90,English,,0,0,0,,So they're balanced binary trees and they're taking advantage of the fact
Dialogue: 0,1:11:10.58,1:11:13.90,Chinese,,0,0,0,,所以他们是平衡的二叉树，他们正在利用这个事实
Dialogue: 0,1:11:14.52,1:11:16.86,English,,0,0,0,,That in C which is not true in all languages
Dialogue: 0,1:11:14.52,1:11:16.86,Chinese,,0,0,0,,在C语言中，在所有语言中都不是这样
Dialogue: 0,1:11:17.30,1:11:23.98,English,,0,0,0,,That all the this case conditions you're looking at our constants they're determined
Dialogue: 0,1:11:17.30,1:11:23.98,Chinese,,0,0,0,,在所有这种情况下你都在考虑我们的常数，他们已经确定了
Dialogue: 0,1:11:24.74,1:11:28.16,English,,0,0,0,,When the compiler is doing the compilation those are constant values
Dialogue: 0,1:11:24.74,1:11:28.16,Chinese,,0,0,0,,当编译器进行编译时，这些是常量值
Dialogue: 0,1:11:28.26,1:11:33.02,English,,0,0,0,,So it can sort them figure out how many there are what range of values
Dialogue: 0,1:11:28.26,1:11:33.02,Chinese,,0,0,0,,因此，它可以对它们进行排序，以确定有多少值存在
Dialogue: 0,1:11:33.02,1:11:36.88,English,,0,0,0,,So there are decide which version to do the clang and generate the code
Dialogue: 0,1:11:33.02,1:11:36.88,Chinese,,0,0,0,,因此，决定使用哪个版本进行clang并生成代码
Dialogue: 0,1:11:38.44,1:11:39.32,English,,0,0,0,,Other questions
Dialogue: 0,1:11:38.44,1:11:39.32,Chinese,,0,0,0,,其他问题
Dialogue: 0,1:11:41.75,1:11:45.32,English,,0,0,0,,So these are all good and it's a very good question so
Dialogue: 0,1:11:41.75,1:11:45.32,Chinese,,0,0,0,,所以这些都很好，这是一个非常好的问题
Dialogue: 0,1:11:45.56,1:11:48.18,English,,0,0,0,,And you're starting to think about
Dialogue: 0,1:11:45.56,1:11:48.18,Chinese,,0,0,0,,你开始考虑了
Dialogue: 0,1:11:48.56,1:11:51.04,English,,0,0,0,,You know which is the way that computer scientists should think is
Dialogue: 0,1:11:48.56,1:11:51.04,Chinese,,0,0,0,,你知道计算机科学家应该考虑的是哪种方式
Dialogue: 0,1:11:51.04,1:11:53.66,English,,0,0,0,,How do you take some idea I've seen one case of
Dialogue: 0,1:11:51.04,1:11:53.66,Chinese,,0,0,0,,你怎么看待我见过的一个例子
Dialogue: 0,1:11:54.04,1:11:59.78,English,,0,0,0,,Well how do I handle condition x and condition y and you know what happens if this that's exactly
Dialogue: 0,1:11:54.04,1:11:59.78,Chinese,,0,0,0,,那么我如何处理条件x和条件y，你知道如果这恰好就会发生什么
Dialogue: 0,1:12:00.46,1:12:02.14,English,,0,0,0,,What we do we sort of
Dialogue: 0,1:12:00.46,1:12:02.14,Chinese,,0,0,0,,我们做的是什么
Dialogue: 0,1:12:02.66,1:12:06.12,English,,0,0,0,,We're never happy with a simple explanation we want to understand
Dialogue: 0,1:12:02.66,1:12:06.12,Chinese,,0,0,0,,我们对我们想要了解的简单解释感到满意
Dialogue: 0,1:12:06.12,1:12:09.40,English,,0,0,0,,How we could actually implement it as a program if we ever had to do so
Dialogue: 0,1:12:06.12,1:12:09.40,Chinese,,0,0,0,,如果我们不得不这样做，我们如何才能真正实现它
Dialogue: 0,1:12:13.84,1:12:15.94,English,,0,0,0,,So and
Dialogue: 0,1:12:13.84,1:12:15.94,Chinese,,0,0,0,,所以和
Dialogue: 0,1:12:17.42,1:12:23.38,English,,0,0,0,,So just in general that the main thing you see is that there's a fairly limited bag of tricks
Dialogue: 0,1:12:17.42,1:12:23.38,Chinese,,0,0,0,,所以一般来说，你看到的主要内容是有一套相当有限的技巧
Dialogue: 0,1:12:23.92,1:12:28.42,English,,0,0,0,,For which the program implements constructs
Dialogue: 0,1:12:23.92,1:12:28.42,Chinese,,0,0,0,,程序实现了构造
Dialogue: 0,1:12:28.50,1:12:30.76,English,,0,0,0,,You've seen basically three
Dialogue: 0,1:12:28.50,1:12:30.76,Chinese,,0,0,0,,你基本上看到了三个
Dialogue: 0,1:12:32.04,1:12:37.66,English,,0,0,0,,One is to use conditional jumps go to different parts of the code
Dialogue: 0,1:12:32.04,1:12:37.66,Chinese,,0,0,0,,一种是使用条件跳转到代码的不同部分
Dialogue: 0,1:12:38.22,1:12:40.54,English,,0,0,0,,Another to use conditional moves
Dialogue: 0,1:12:38.22,1:12:40.54,Chinese,,0,0,0,,另一个使用条件移动
Dialogue: 0,1:12:41.50,1:12:44.72,English,,0,0,0,,And the third is to use this jump table idea
Dialogue: 0,1:12:41.50,1:12:44.72,Chinese,,0,0,0,,第三是使用这种跳转表的想法
Dialogue: 0,1:12:45.14,1:12:51.00,English,,0,0,0,,And those are really that put plus a little bit to do of procedures 
Dialogue: 0,1:12:45.14,1:12:51.00,Chinese,,0,0,0,,这些实际上只是加上一些程序
Dialogue: 0,1:12:51.36,1:12:52.48,English,,0,0,0,,You see all there is
Dialogue: 0,1:12:51.36,1:12:52.48,Chinese,,0,0,0,,你看到了所有的一切
Dialogue: 0,1:12:52.92,1:12:57.72,English,,0,0,0,,And all the other stuff you see in a program that sort of changes
Dialogue: 0,1:12:52.92,1:12:57.72,Chinese,,0,0,0,,以及你在程序中看到的所有其他变化的东西
Dialogue: 0,1:12:58.42,1:13:04.90,English,,0,0,0,,The flow of execution or what gets executed -o built out of those basic primitives
Dialogue: 0,1:12:58.42,1:13:04.90,Chinese,,0,0,0,,执行流程或执行的内容 - 由这些基本原语构建
Dialogue: 0,1:13:05.94,1:13:08.36,English,,0,0,0,,And that's generally true that what we see is
Dialogue: 0,1:13:05.94,1:13:08.36,Chinese,,0,0,0,,我们所看到的情况通常都是正确的
Dialogue: 0,1:13:09.80,1:13:15.02,English,,0,0,0,,You know when you go from C code to machine code you often have to kind of piece together various
Dialogue: 0,1:13:09.80,1:13:15.02,Chinese,,0,0,0,,你知道当你从C代码转到机器代码时，你经常要把各种各样的东西拼凑起来
Dialogue: 0,1:13:15.70,1:13:19.38,English,,0,0,0,,Low-level instructions to implement some higher-level construct
Dialogue: 0,1:13:15.70,1:13:19.38,Chinese,,0,0,0,,实现某些更高级别构造的低级指令
Dialogue: 0,1:13:22.38,1:13:25.72,English,,0,0,0,,And so we've seen these all in different form stone
Dialogue: 0,1:13:22.38,1:13:25.72,Chinese,,0,0,0,,所以我们看到这些都是不同形式的石头
Dialogue: 0,1:13:26.84,1:13:29.46,English,,0,0,0,,And next time then we'll talk about procedures
Dialogue: 0,1:13:26.84,1:13:29.46,Chinese,,0,0,0,,然后我们将讨论程序
Dialogue: 0,1:13:29.48,1:13:32.88,English,,0,0,0,,And that's as you can imagine a fairly major topic
Dialogue: 0,1:13:29.48,1:13:32.88,Chinese,,0,0,0,,这就像你可以想象一个相当重要的话题
Dialogue: 0,1:13:32.88,1:13:35.92,English,,0,0,0,,Because it is worth one entire procedure
Dialogue: 0,1:13:32.88,1:13:35.92,Chinese,,0,0,0,,因为值得一整个程序
Dialogue: 0,1:13:36.42,1:13:39.96,English,,0,0,0,,Okay very good thank you
Dialogue: 0,1:13:36.42,1:13:39.96,Chinese,,0,0,0,,好的，非常感谢谢谢
