[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: csapp/Lecture 19  Dynamic Memory Allocation  Basic Concepts.mp4
Video File: csapp/Lecture 19  Dynamic Memory Allocation  Basic Concepts.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 1534
Active Line: 1537
Video Position: 118614

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,40,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:02.08,0:00:03.44,English,,0,0,0,,All right good afternoon everybody
Dialogue: 0,0:00:02.08,0:00:03.44,Chinese,,0,0,0,,大家下午好
Dialogue: 0,0:00:04.56,0:00:09.10,English,,0,0,0,,Welcome good to see you all, welcome also to our viewers on video
Dialogue: 0,0:00:04.56,0:00:09.10,Chinese,,0,0,0,,欢迎大家看到你们，也欢迎观众观看视频
Dialogue: 0,0:00:10.56,0:00:15.12,English,,0,0,0,,So last week we looked at this virtual memory mechanism
Dialogue: 0,0:00:10.56,0:00:15.12,Chinese,,0,0,0,,上周我们学习了虚拟内存机制
Dialogue: 0,0:00:17.44,0:00:21.40,English,,0,0,0,,And how it provides so many different useful functionalities to the system
Dialogue: 0,0:00:17.44,0:00:21.40,Chinese,,0,0,0,,以及它如何为系统提供如此多的有用功能
Dialogue: 0,0:00:22.94,0:00:30.40,English,,0,0,0,,Along with this sort of abstraction of having this large contiguous array of bytes
Dialogue: 0,0:00:22.94,0:00:30.40,Chinese,,0,0,0,,随着这种大型连续字节数组的抽象
Dialogue: 0,0:00:32.54,0:00:35.00,English,,0,0,0,,Now once we're given that large array of bytes
Dialogue: 0,0:00:32.54,0:00:35.00,Chinese,,0,0,0,,现在，一旦我们获得了大量的字节
Dialogue: 0,0:00:36.64,0:00:37.86,English,,0,0,0,,Now we have to manage it
Dialogue: 0,0:00:36.64,0:00:37.86,Chinese,,0,0,0,,现在我们必须管理它
Dialogue: 0,0:00:39.48,0:00:46.72,English,,0,0,0,,And we have to have some mechanism to manage and use that resource
Dialogue: 0,0:00:39.48,0:00:46.72,Chinese,,0,0,0,,我们必须有一些机制来管理和使用该资源
Dialogue: 0,0:00:47.20,0:00:47.50,English,,0,0,0,,Okay so
Dialogue: 0,0:00:47.20,0:00:47.50,Chinese,,0,0,0,,可以，然后呢
Dialogue: 0,0:00:48.36,0:00:54.46,English,,0,0,0,,That's the topic of a lectures this week is a storage allocation
Dialogue: 0,0:00:48.36,0:00:54.46,Chinese,,0,0,0,,本周讲座的主题是储存器分配
Dialogue: 0,0:00:54.80,0:00:57.04,English,,0,0,0,,And how storage allocators work
Dialogue: 0,0:00:54.80,0:00:57.04,Chinese,,0,0,0,,以及储存器分配器的工作原理
Dialogue: 0,0:00:57.12,0:01:02.28,English,,0,0,0,,And how you use them to manage the matter the virtual memory in your system
Dialogue: 0,0:00:57.12,0:01:02.28,Chinese,,0,0,0,,以及如何使用它们来管理系统中的虚拟内存
Dialogue: 0,0:01:06.30,0:01:10.48,English,,0,0,0,,So the basic idea of a dynamic memory allocator
Dialogue: 0,0:01:06.30,0:01:10.48,Chinese,,0,0,0,,所以动态储存器分配器的基本思想是
Dialogue: 0,0:01:10.60,0:01:21.48,English,,0,0,0,,Is that applications use it to to manipulate virtual memory to create to allocate and free chunks of virtual memory
Dialogue: 0,0:01:10.60,0:01:21.48,Chinese,,0,0,0,,应用程序使用它去操纵虚拟内存，去构造、分配以及释放虚拟存储器片
Dialogue: 0,0:01:21.72,0:01:22.94,English,,0,0,0,,That you need in your program
Dialogue: 0,0:01:21.72,0:01:22.94,Chinese,,0,0,0,,在你的程序中会需要这些虚拟存储器
Dialogue: 0,0:01:23.94,0:01:28.46,English,,0,0,0,,And this memory is maintained in an area of virtual memory called the heap
Dialogue: 0,0:01:23.94,0:01:28.46,Chinese,,0,0,0,,而且这个存储器在称为堆的虚拟存储器区域中被维护
Dialogue: 0,0:01:30.52,0:01:43.20,English,,0,0,0,,All languages have some mechanism for acquiring and manipulating this dynamic memory
Dialogue: 0,0:01:30.52,0:01:43.20,Chinese,,0,0,0,,所有语言都有一些用来分配和操纵动态存储器的机制
Dialogue: 0,0:01:44.04,0:01:45.64,English,,0,0,0,,So in C
Dialogue: 0,0:01:44.04,0:01:45.64,Chinese,,0,0,0,,所以在 C 中
Dialogue: 0,0:01:46.62,0:01:53.36,English,,0,0,0,,It's the malloc package. Languages like java have the new method
Dialogue: 0,0:01:46.62,0:01:53.36,Chinese,,0,0,0,,使用的是 malloc 的方式。但是像 java 这样的语言中使用的是new方法
Dialogue: 0,0:01:56.26,0:02:01.00,English,,0,0,0,,Now the allocator maintains the heap as a contiguous collection of blocks
Dialogue: 0,0:01:56.26,0:02:01.00,Chinese,,0,0,0,,分配器将堆维护为连续的块集合
Dialogue: 0,0:02:03.20,0:02:05.24,English,,0,0,0,,And blocks can be allocated or free
Dialogue: 0,0:02:03.20,0:02:05.24,Chinese,,0,0,0,,块可以被分配或者被释放
Dialogue: 0,0:02:05.96,0:02:11.34,English,,0,0,0,,Allocated meaning that they're being used by some program application
Dialogue: 0,0:02:05.96,0:02:11.34,Chinese,,0,0,0,,被分配意味着它们被某些应用程序使用
Dialogue: 0,0:02:13.08,0:02:17.86,English,,0,0,0,,Free meaning that there available to be for use by an application
Dialogue: 0,0:02:13.08,0:02:17.86,Chinese,,0,0,0,,空闲意味着可供应用程序使用
Dialogue: 0,0:02:19.46,0:02:25.34,English,,0,0,0,,And there's two types of allocators. The kind of allocator that you find in C such as the malloc package
Dialogue: 0,0:02:19.46,0:02:25.34,Chinese,,0,0,0,,有两种类型的分配器。你在C中找到的那种分配器，比如 malloc 包
Dialogue: 0,0:02:25.92,0:02:31.20,English,,0,0,0,,It's up to the application to both explicitly allocate the memory
Dialogue: 0,0:02:25.92,0:02:31.20,Chinese,,0,0,0,,这种分配器，应用程序将决定否是显式分配内存
Dialogue: 0,0:02:31.58,0:02:35.46,English,,0,0,0,,And explicitly free it when the application is finished with it
Dialogue: 0,0:02:31.58,0:02:35.46,Chinese,,0,0,0,,并在应用程序完成后是否显式地释放内存
Dialogue: 0,0:02:35.62,0:02:40.50,English,,0,0,0,,Okay so the system won't free up any memory that you allocate unless you do it
Dialogue: 0,0:02:35.62,0:02:40.50,Chinese,,0,0,0,,所以系统不会释放你分配的任何内存
Dialogue: 0,0:02:40.96,0:02:45.54,English,,0,0,0,,Explicitly by calling the free function
Dialogue: 0,0:02:40.96,0:02:45.54,Chinese,,0,0,0,,除非你通过调用 free 函数显示的释放内存
Dialogue: 0,0:02:46.40,0:02:51.62,English,,0,0,0,,But there's other languages that support implicit allocators
Dialogue: 0,0:02:46.40,0:02:51.62,Chinese,,0,0,0,,但是还有其他语言支持隐式分配器
Dialogue: 0,0:02:51.94,0:02:58.90,English,,0,0,0,,And in these implicit allocators the programmer explicitly allocates memory
Dialogue: 0,0:02:51.94,0:02:58.90,Chinese,,0,0,0,,在这些隐式分配器中，程序员显式地分配内存
Dialogue: 0,0:02:59.62,0:03:02.40,English,,0,0,0,,But then the system takes care of freeing the memory
Dialogue: 0,0:02:59.62,0:03:02.40,Chinese,,0,0,0,,但随后系统负责释放内存
Dialogue: 0,0:03:02.82,0:03:03.28,English,,0,0,0,,Okay so it's
Dialogue: 0,0:03:02.82,0:03:03.28,Chinese,,0,0,0,,好的，就是这样
Dialogue: 0,0:03:03.92,0:03:11.42,English,,0,0,0,,That the burden of freeing the memory is shifted from the application program to the system
Dialogue: 0,0:03:03.92,0:03:11.42,Chinese,,0,0,0,,释放内存的负担从应用程序转移到系统
Dialogue: 0,0:03:12.04,0:03:16.86,English,,0,0,0,,And it frees this memory implicitly sort of behind the scenes using a process called garbage collection
Dialogue: 0,0:03:12.04,0:03:16.86,Chinese,,0,0,0,,并且它使用称为垃圾收集的过程隐式地释放了这些内存
Dialogue: 0,0:03:18.24,0:03:26.18,English,,0,0,0,,Okay so languages like java,ML,Lisp they all do implicit they all support in close at allocators
Dialogue: 0,0:03:18.24,0:03:26.18,Chinese,,0,0,0,,所以像 Java, ML, Lisp 这样的语言都支持隐式分配器
Dialogue: 0,0:03:26.78,0:03:30.82,English,,0,0,0,,Now today we're going to discuss explicit memory allocators
Dialogue: 0,0:03:26.78,0:03:30.82,Chinese,,0,0,0,,今天我们要讨论一下显式分配器
Dialogue: 0,0:03:31.24,0:03:35.38,English,,0,0,0,,On Thursday we'll get into implicit allocators and how they work
Dialogue: 0,0:03:31.24,0:03:35.38,Chinese,,0,0,0,,星期四，我们将进入隐式分配器及其运作方式
Dialogue: 0,0:03:37.50,0:03:46.02,English,,0,0,0,,Now the allocators in C is provided it by the standard C library in a set of function called malloc package
Dialogue: 0,0:03:37.50,0:03:46.02,Chinese,,0,0,0,,现在，在 C 语言中的分配器由 C 语言标准库中一组叫做 malloc 包的函数提供
Dialogue: 0,0:03:48.34,0:03:51.34,English,,0,0,0,,The malloc function is used to allocate memory
Dialogue: 0,0:03:48.34,0:03:51.34,Chinese,,0,0,0,,malloc 函数用于分配内存
Dialogue: 0,0:03:52.08,0:03:55.38,English,,0,0,0,,And it takes as input a size argument which is in bytes
Dialogue: 0,0:03:52.08,0:03:55.38,Chinese,,0,0,0,,它把以字节作为单位的参数作为函数的输入参数
Dialogue: 0,0:03:57.44,0:04:04.16,English,,0,0,0,,And then it returns a pointer to a memory block that contains at least size bytes
Dialogue: 0,0:03:57.44,0:04:04.16,Chinese,,0,0,0,,然后它返回一个指向内存块的指针，该内存块至少包含所声明的大小的字节
Dialogue: 0,0:04:05.22,0:04:12.06,English,,0,0,0,,And that block is aligned on x86 systems to 8-byte on x86-64 systems to 16-byte
Dialogue: 0,0:04:05.22,0:04:12.06,Chinese,,0,0,0,,并且该块在 x86 系统上以 8 字节对齐，在 x86-64 系统上以 16 字节对齐
Dialogue: 0,0:04:13.02,0:04:16.74,English,,0,0,0,,If size is 0,it returns null
Dialogue: 0,0:04:13.02,0:04:16.74,Chinese,,0,0,0,,如果 size 为 0 ，则返回 null
Dialogue: 0,0:04:18.50,0:04:24.34,English,,0,0,0,,And then it returns -1 like most typical system calls
Dialogue: 0,0:04:18.50,0:04:24.34,Chinese,,0,0,0,,然后它像大多数典型的系统调用一样返回 -1
Dialogue: 0,0:04:25.68,0:04:30.02,English,,0,0,0,,The programmer frees memory by calling the free function
Dialogue: 0,0:04:25.68,0:04:30.02,Chinese,,0,0,0,,程序员通过调用 free  函数释放内存
Dialogue: 0,0:04:30.80,0:04:36.57,English,,0,0,0,,It takes an argument a pointer that was returned from some prior invocation of malloc
Dialogue: 0,0:04:30.80,0:04:36.57,Chinese,,0,0,0,,它以一个先前调用 malloc 时返回的指针作为参数
Dialogue: 0,0:04:37.06,0:04:38.92,English,,0,0,0,,And it returns nothing
Dialogue: 0,0:04:37.06,0:04:38.92,Chinese,,0,0,0,,并且没有任何返回值
Dialogue: 0,0:04:40.38,0:04:41.78,English,,0,0,0,,And it frees that
Dialogue: 0,0:04:40.38,0:04:41.78,Chinese,,0,0,0,,它释放了
Dialogue: 0,0:04:43.34,0:04:46.86,English,,0,0,0,,I've given this pointer that was returned by the prior indication of malloc
Dialogue: 0,0:04:43.34,0:04:46.86,Chinese,,0,0,0,,在之前调用 malloc 函数的时候返回的指针
Dialogue: 0,0:04:47.60,0:04:49.28,English,,0,0,0,,It frees the block at that address
Dialogue: 0,0:04:47.60,0:04:49.28,Chinese,,0,0,0,,它释放了该地址的块
Dialogue: 0,0:04:51.46,0:04:54.36,English,,0,0,0,,And then returns that block to the pool of available memory
Dialogue: 0,0:04:51.46,0:04:54.36,Chinese,,0,0,0,,然后将该块放到可用内存池
Dialogue: 0,0:04:55.50,0:04:57.72,English,,0,0,0,,Now there's some other functions
Dialogue: 0,0:04:55.50,0:04:57.72,Chinese,,0,0,0,,现在还有其他一些功能
Dialogue: 0,0:04:59.60,0:05:05.88,English,,0,0,0,,Calloc is a version of malloc that gives you an initialized block of memory that's initialized to 0
Dialogue: 0,0:04:59.60,0:05:05.88,Chinese,,0,0,0,,calloc 是 malloc 的另一个版本，它为你提供初始化为 0 的初始化内存块
Dialogue: 0,0:05:06.78,0:05:13.48,English,,0,0,0,,And realloc. You can malloc a block and then call realloc to change the size of that previously allocated block
Dialogue: 0,0:05:06.78,0:05:13.48,Chinese,,0,0,0,,你可以 malloc 一个块，然后调用 realloc 来改变以前分配的块的大小
Dialogue: 0,0:05:14.86,0:05:20.52,English,,0,0,0,,And then there's a function called 'sbrk' which is used internally by allocators to grow and shrink the heap
Dialogue: 0,0:05:14.86,0:05:20.52,Chinese,,0,0,0,,然后有一个名为 「sbrk」 的函数，分配器在内部使用它来增长和缩小堆
Dialogue: 0,0:05:20.88,0:05:22.62,English,,0,0,0,,So when an allocator needs more memory
Dialogue: 0,0:05:20.88,0:05:22.62,Chinese,,0,0,0,,所以当分配器需要更多内存时
Dialogue: 0,0:05:23.04,0:05:27.26,English,,0,0,0,,It calls sbrk to get that additional virtual memory
Dialogue: 0,0:05:23.04,0:05:27.26,Chinese,,0,0,0,,它调用「sbrk」来获得额外的虚拟内存
Dialogue: 0,0:05:27.54,0:05:30.60,English,,0,0,0,,And then that's added to the heap that the portion
Dialogue: 0,0:05:27.54,0:05:30.60,Chinese,,0,0,0,,然后那个部分添加到堆中
Dialogue: 0,0:05:31.16,0:05:36.52,English,,0,0,0,,That grows the heap and then it adds it to the memory that the allocator is manipulating
Dialogue: 0,0:05:31.16,0:05:36.52,Chinese,,0,0,0,,这会使堆增长，然后将其添加到分配器正在操作的内存中
Dialogue: 0,0:05:40.24,0:05:44.24,English,,0,0,0,,So here's an example of how we would use malloc in a simple program
Dialogue: 0,0:05:40.24,0:05:44.24,Chinese,,0,0,0,,所以这是一个如何在一个简单的程序中使用 malloc 的例子
Dialogue: 0,0:05:45.02,0:05:48.16,English,,0,0,0,,We have a pointer to an int 「p」
Dialogue: 0,0:05:45.02,0:05:48.16,Chinese,,0,0,0,,我们有一个指向整型的指针 「p」
Dialogue: 0,0:05:50.04,0:05:51.82,English,,0,0,0,,And we call malloc
Dialogue: 0,0:05:50.04,0:05:51.82,Chinese,,0,0,0,,我们调用 malloc
Dialogue: 0,0:05:52.56,0:05:54.92,English,,0,0,0,,And we want to allocate an array of n int
Dialogue: 0,0:05:52.56,0:05:54.92,Chinese,,0,0,0,,我们想要分配一个大小为 n 的整型数组
Dialogue: 0,0:05:55.66,0:05:58.66,English,,0,0,0,,So this is sort of the standard way you call it
Dialogue: 0,0:05:55.66,0:05:58.66,Chinese,,0,0,0,,这是我们调用它的标准方式
Dialogue: 0,0:05:59.24,0:06:03.70,English,,0,0,0,,We want n ints and so we call it with n*sizeof(int)
Dialogue: 0,0:05:59.24,0:06:03.70,Chinese,,0,0,0,,我们想要 n 个 int，所以我们用 「n * sizeof(int)」 来调用它
Dialogue: 0,0:06:04.48,0:06:06.38,English,,0,0,0,,Because remember the argument is in bytes
Dialogue: 0,0:06:04.48,0:06:06.38,Chinese,,0,0,0,,因为参数是以字节为单位
Dialogue: 0,0:06:08.00,0:06:09.58,English,,0,0,0,,Malloc returns a pointer
Dialogue: 0,0:06:08.00,0:06:09.58,Chinese,,0,0,0,,malloc 返回一个指针
Dialogue: 0,0:06:10.94,0:06:13.64,English,,0,0,0,,It returns that generic pointer , void* pointer so
Dialogue: 0,0:06:10.94,0:06:13.64,Chinese,,0,0,0,,它返回那个泛型指针  ——「void*」 指针
Dialogue: 0,0:06:14.86,0:06:19.66,English,,0,0,0,,We cast it to a pointer to an int to keep the compiler happy
Dialogue: 0,0:06:14.86,0:06:19.66,Chinese,,0,0,0,,我们将它转​​换为指向整型的指针，以便于编译器编译
Dialogue: 0,0:06:20.20,0:06:21.86,English,,0,0,0,,And then assign it to p
Dialogue: 0,0:06:20.20,0:06:21.86,Chinese,,0,0,0,,然后将其分配给 p
Dialogue: 0,0:06:24.46,0:06:28.10,English,,0,0,0,,We check for a null return value
Dialogue: 0,0:06:24.46,0:06:28.10,Chinese,,0,0,0,,我们检查返回值是否为空
Dialogue: 0,0:06:30.56,0:06:35.56,English,,0,0,0,,So I should point out the it returns 0 on error
Dialogue: 0,0:06:30.56,0:06:35.56,Chinese,,0,0,0,,所以我应该指出它在出错时返回 0
Dialogue: 0,0:06:35.56,0:06:40.76,English,,0,0,0,,So we recheck for this null pointer which is 0
Dialogue: 0,0:06:35.56,0:06:40.76,Chinese,,0,0,0,,所以我们重新检查这个指针是否为空指针
Dialogue: 0,0:06:43.02,0:06:44.36,English,,0,0,0,,In print an error if it's null
Dialogue: 0,0:06:43.02,0:06:44.36,Chinese,,0,0,0,,如果它为空，则打印错误
Dialogue: 0,0:06:45.68,0:06:49.46,English,,0,0,0,,Now once we've got that pointer now p we can treat it just like an array
Dialogue: 0,0:06:45.68,0:06:49.46,Chinese,,0,0,0,,现在，一旦我们得到了指针，我们就可以像对待数组一样对待它
Dialogue: 0,0:06:50.22,0:06:54.52,English,,0,0,0,,So inside the loop if we want to initialize it we loop
Dialogue: 0,0:06:50.22,0:06:54.52,Chinese,,0,0,0,,所以在循环内部如果我们想要初始化它
Dialogue: 0,0:06:55.98,0:07:00.20,English,,0,0,0,,Across the elements of the array initializing each one to some value
Dialogue: 0,0:06:55.98,0:07:00.20,Chinese,,0,0,0,,我们可以循环遍历数组的元素，将每个元素初始化为某个值
Dialogue: 0,0:07:01.10,0:07:09.56,English,,0,0,0,,When we're finished with this chunk of memory that we've allocated, then we free it by calling free with the pointer p
Dialogue: 0,0:07:01.10,0:07:09.56,Chinese,,0,0,0,,当我们完成了我们分配的这块内存时，我们通过使用指针 p 调用 free 来释放它
Dialogue: 0,0:07:12.62,0:07:13.24,English,,0,0,0,,Okay now the
Dialogue: 0,0:07:12.62,0:07:13.24,Chinese,,0,0,0,,好的，现在
Dialogue: 0,0:07:14.26,0:07:18.44,English,,0,0,0,,So we're going to look today at how functions like malloc and free are implemented
Dialogue: 0,0:07:14.26,0:07:18.44,Chinese,,0,0,0,,因此，我们今天将看看如何实现 malloc 和 free 等功能
Dialogue: 0,0:07:19.68,0:07:22.68,English,,0,0,0,,So we're going to make a few simplifying assumptions
Dialogue: 0,0:07:19.68,0:07:22.68,Chinese,,0,0,0,,所以我们将做一些简化的假设
Dialogue: 0,0:07:23.86,0:07:24.34,English,,0,0,0,,So I'm going to
Dialogue: 0,0:07:23.86,0:07:24.34,Chinese,,0,0,0,,所以我要去
Dialogue: 0,0:07:25.32,0:07:29.14,English,,0,0,0,,Memory it is byte address we know that
Dialogue: 0,0:07:25.32,0:07:29.14,Chinese,,0,0,0,,我们知道内存的地址是按照字节的地址
Dialogue: 0,0:07:29.26,0:07:32.78,English,,0,0,0,,But for the purposes of this lecture we're going to assume that it's word address
Dialogue: 0,0:07:29.26,0:07:32.78,Chinese,,0,0,0,,但是为了本讲座的目的，我们将假设它是字的地址
Dialogue: 0,0:07:32.96,0:07:35.00,English,,0,0,0,,Okay so we're just going to look at word size units
Dialogue: 0,0:07:32.96,0:07:35.00,Chinese,,0,0,0,,好的，我们只是关注以字为大小的单位
Dialogue: 0,0:07:38.76,0:07:42.02,English,,0,0,0,,And I'm going to assume that words are 4 bytes
Dialogue: 0,0:07:38.76,0:07:42.02,Chinese,,0,0,0,,而且我将假设字是 4 个字节
Dialogue: 0,0:07:44.60,0:07:47.82,English,,0,0,0,,So they basically are the size of an int
Dialogue: 0,0:07:44.60,0:07:47.82,Chinese,,0,0,0,,所以他们基本上是一个 int 的大小
Dialogue: 0,0:07:50.86,0:07:53.98,English,,0,0,0,,So this isn't actually, this isn't true, I need to fix that
Dialogue: 0,0:07:50.86,0:07:53.98,Chinese,,0,0,0,,所以这实际上这不是正确的，我需要修正它
Dialogue: 0,0:07:56.26,0:08:02.78,English,,0,0,0,,So basically we're going to think of words as four byte quantity sort of integer size quantities
Dialogue: 0,0:07:56.26,0:08:02.78,Chinese,,0,0,0,,所以基本上我们会将字视为四字节，这刚好是整数大小
Dialogue: 0,0:08:05.10,0:08:09.66,English,,0,0,0,,And then blocks or contiguous chunks of those words that can be either allocated or free
Dialogue: 0,0:08:05.10,0:08:09.66,Chinese,,0,0,0,,这些字所构成的块或者连续的片能够被分配或者被释放
Dialogue: 0,0:08:10.50,0:08:13.18,English,,0,0,0,,So here we have a portion of the heap
Dialogue: 0,0:08:10.50,0:08:13.18,Chinese,,0,0,0,,所以这里我们有一部分堆
Dialogue: 0,0:08:13.76,0:08:18.94,English,,0,0,0,,Which consists of a 4 words allocated block followed by a 2 words free block
Dialogue: 0,0:08:13.76,0:08:18.94,Chinese,,0,0,0,,其中包括 4 字大小的已被分配的块，后面跟着 2 个字大小的空闲块
Dialogue: 0,0:08:20.06,0:08:24.80,English,,0,0,0,,Followed by another a 4 words allocated block, followed by a 3 words free block
Dialogue: 0,0:08:20.06,0:08:24.80,Chinese,,0,0,0,,接下来是另一个 4 字大小的已被分配块，后跟 3 字大小的空闲块
Dialogue: 0,0:08:25.50,0:08:33.34,English,,0,0,0,,And we'll indicate these free blocks by white and will indicate allocated blocks with some shade of color
Dialogue: 0,0:08:25.50,0:08:33.34,Chinese,,0,0,0,,我们将使用白色表示这些空闲块，并用某种颜色的阴影来表示已分配块
Dialogue: 0,0:08:36.42,0:08:41.10,English,,0,0,0,,So let's look now how a sequence of allocations and freeze would work
Dialogue: 0,0:08:36.42,0:08:41.10,Chinese,,0,0,0,,那么现在让我们看一下一系列的分配和释放是如何工作的
Dialogue: 0,0:08:42.28,0:08:46.02,English,,0,0,0,,And now notice I'm calling malloc with the size of words
Dialogue: 0,0:08:42.28,0:08:46.02,Chinese,,0,0,0,,现在注意我正在调用具有字大小的 malloc
Dialogue: 0,0:08:46.72,0:08:47.26,English,,0,0,0,,Not bytes
Dialogue: 0,0:08:46.72,0:08:47.26,Chinese,,0,0,0,,不是字节
Dialogue: 0,0:08:47.42,0:08:51.14,English,,0,0,0,, Just to keep these pictures simpler
Dialogue: 0,0:08:47.42,0:08:51.14,Chinese,,0,0,0,,只是为了保持这些图片更简单
Dialogue: 0,0:08:55.04,0:09:00.88,English,,0,0,0,,So in this first we call malloc and allocate of a 4 word block
Dialogue: 0,0:08:55.04,0:09:00.88,Chinese,,0,0,0,,所以首先我们调用 malloc 并分配一个 4 字大小的块
Dialogue: 0,0:09:03.88,0:09:06.14,English,,0,0,0,,And that gives us a pointer p1
Dialogue: 0,0:09:03.88,0:09:06.14,Chinese,,0,0,0,,这给了我们一个指针「p1」
Dialogue: 0,0:09:06.14,0:09:09.32,English,,0,0,0,,Then we call malloc again to get a 5 words block
Dialogue: 0,0:09:06.14,0:09:09.32,Chinese,,0,0,0,,然后我们再次调用 malloc 来获得一个 5 字大小的块
Dialogue: 0,0:09:09.44,0:09:14.40,English,,0,0,0,,So it just takes it one of the free words and allocates it
Dialogue: 0,0:09:09.44,0:09:14.40,Chinese,,0,0,0,,所以它只需要空闲字中的一部分并分配它
Dialogue: 0,0:09:15.58,0:09:17.94,English,,0,0,0,,We call malloc again to get a 6 words block
Dialogue: 0,0:09:15.58,0:09:17.94,Chinese,,0,0,0,,我们再次调用 malloc 来获得一个 6 字大小的块
Dialogue: 0,0:09:19.76,0:09:24.28,English,,0,0,0,,And then we free the block that's pointed at by p2 this purple block
Dialogue: 0,0:09:19.76,0:09:24.28,Chinese,,0,0,0,,然后我们释放 「p2」 这个紫色块所指向的块
Dialogue: 0,0:09:26.24,0:09:28.56,English,,0,0,0,,Okay so now we free up that block
Dialogue: 0,0:09:26.24,0:09:28.56,Chinese,,0,0,0,,好的，现在我们释放了那块
Dialogue: 0,0:09:29.12,0:09:32.80,English,,0,0,0,,And then we do another allocation for a 2 words block
Dialogue: 0,0:09:29.12,0:09:32.80,Chinese,,0,0,0,,然后我们为 2 字大小的块进行另一次分配
Dialogue: 0,0:09:33.10,0:09:39.96,English,,0,0,0,,And so the the allocator looks to see if it can find a free block that has enough room and
Dialogue: 0,0:09:33.10,0:09:39.96,Chinese,,0,0,0,,所以分配器去查看否能找到一个有足够空间的空闲块
Dialogue: 0,0:09:40.28,0:09:45.34,English,,0,0,0,,It finds this free block here that has 5 free words and then it
Dialogue: 0,0:09:40.28,0:09:45.34,Chinese,,0,0,0,,它在这里找到这个有 5 个字大小的空闲块
Dialogue: 0,0:09:46.26,0:09:52.00,English,,0,0,0,,Allocates the the requested block inside of that free block
Dialogue: 0,0:09:46.26,0:09:52.00,Chinese,,0,0,0,,它在该空闲块内分配所请求的块
Dialogue: 0,0:09:55.62,0:10:00.74,English,,0,0,0,,Now allocators work under a lot of different constraints
Dialogue: 0,0:09:55.62,0:10:00.74,Chinese,,0,0,0,,现在分配器在很多不同的约束下工作
Dialogue: 0,0:10:01.30,0:10:04.00,English,,0,0,0,,Okay so it's hard to write an allocator because of all these constraints
Dialogue: 0,0:10:01.30,0:10:04.00,Chinese,,0,0,0,,因为所有这些限制，编写分配器变得很困难
Dialogue: 0,0:10:05.88,0:10:10.80,English,,0,0,0,,Applications can choose any combination of allocated and free blocks
Dialogue: 0,0:10:05.88,0:10:10.80,Chinese,,0,0,0,,应用程序可以将已分配块和空闲块的任意组合
Dialogue: 0,0:10:10.88,0:10:14.12,English,,0,0,0,,So you can't predict what an application is going to request
Dialogue: 0,0:10:10.88,0:10:14.12,Chinese,,0,0,0,,因此，你无法预测应用程序请求的内容
Dialogue: 0,0:10:15.54,0:10:22.06,English,,0,0,0,,And and the application is required to free a block when it frees a block to pass a pointer
Dialogue: 0,0:10:15.54,0:10:22.06,Chinese,,0,0,0,,在应用程序需要适当一个块的时候被要求去传递一个指针
Dialogue: 0,0:10:22.64,0:10:25.80,English,,0,0,0,,That was returned from a previous invocation of malloc
Dialogue: 0,0:10:22.64,0:10:25.80,Chinese,,0,0,0,,这个指针是从之前调用的 malloc 所返回的
Dialogue: 0,0:10:26.82,0:10:29.50,English,,0,0,0,,Okay so the application has a few constraints,  but
Dialogue: 0,0:10:26.82,0:10:29.50,Chinese,,0,0,0,,应用程序有一些限制
Dialogue: 0,0:10:31.08,0:10:34.50,English,,0,0,0,,But really the only one that it has is that the fact that the
Dialogue: 0,0:10:31.08,0:10:34.50,Chinese,,0,0,0,,但它真正唯一的一个事实是
Dialogue: 0,0:10:35.18,0:10:39.23,English,,0,0,0,,When it frees something, it has to be a pointer from a previous invocation of malloc
Dialogue: 0,0:10:35.18,0:10:39.23,Chinese,,0,0,0,,当它释放某些东西时，必须使用来自之前调用 malloc 时所返回的的指针
Dialogue: 0,0:10:39.68,0:10:45.66,English,,0,0,0,,Now the malloc operates or allocators like malloc operate under a lot of different constraints
Dialogue: 0,0:10:39.68,0:10:45.66,Chinese,,0,0,0,,malloc 运行或像 malloc 这样的分配器在很多不同的约束条件下运行
Dialogue: 0,0:10:46.36,0:10:49.56,English,,0,0,0,,They can't control the size or the number of the allocated blocks
Dialogue: 0,0:10:46.36,0:10:49.56,Chinese,,0,0,0,,它们无法控制分配块的大小或数量
Dialogue: 0,0:10:50.32,0:10:53.40,English,,0,0,0,,Because they have no control over the what the application is doing
Dialogue: 0,0:10:50.32,0:10:53.40,Chinese,,0,0,0,,因为他们无法控制应用程序正在做的事情
Dialogue: 0,0:10:54.92,0:10:58.66,English,,0,0,0,,If an application calls malloc, malloc has to respond right away
Dialogue: 0,0:10:54.92,0:10:58.66,Chinese,,0,0,0,,如果应用程序调用 malloc ，malloc 必须立即响应
Dialogue: 0,0:10:59.18,0:11:03.98,English,,0,0,0,,It might you might be able to do a better more efficient version by batching up requests
Dialogue: 0,0:10:59.18,0:11:03.98,Chinese,,0,0,0,,你可能可以通过批量处理请求来创建更高效​​的版本
Dialogue: 0,0:11:04.78,0:11:06.76,English,,0,0,0,,And then responding to all those requests at once
Dialogue: 0,0:11:04.78,0:11:06.76,Chinese,,0,0,0,,然后立即相应所有的请求
Dialogue: 0,0:11:07.45,0:11:12.98,English,,0,0,0,,But the allocator can't do it. When it gets called it has to process the request and then return right away
Dialogue: 0,0:11:07.45,0:11:12.98,Chinese,,0,0,0,,分配器无法做到这一点。当它被调用时，它必须处理请求然后立即返回
Dialogue: 0,0:11:14.80,0:11:17.32,English,,0,0,0,,It has to of course it has to allocate blocks from free memory
Dialogue: 0,0:11:14.80,0:11:17.32,Chinese,,0,0,0,,它当然必须从可用内存中分配块
Dialogue: 0,0:11:17.32,0:11:17.92,English,,0,0,0,,So it can't
Dialogue: 0,0:11:17.32,0:11:17.92,Chinese,,0,0,0,,所以它不能
Dialogue: 0,0:11:18.58,0:11:20.84,English,,0,0,0,,In general I can't touch any allocated block
Dialogue: 0,0:11:18.58,0:11:20.84,Chinese,,0,0,0,,一般来说，我无法触及任何已分配的块
Dialogue: 0,0:11:21.46,0:11:29.06,English,,0,0,0,,Right once it allocates a block,that block belongs to the application and the malloc package can't touch it
Dialogue: 0,0:11:21.46,0:11:29.06,Chinese,,0,0,0,,一旦它分配了一个块，那么该块就属于那个应用程序，而 malloc 包不能触及它
Dialogue: 0,0:11:29.34,0:11:31.30,English,,0,0,0,,Now this has a number of implications
Dialogue: 0,0:11:29.34,0:11:31.30,Chinese,,0,0,0,,这有很多含义
Dialogue: 0,0:11:31.92,0:11:38.94,English,,0,0,0,,So this means that the allocator can't move blocks around like it
Dialogue: 0,0:11:31.92,0:11:38.94,Chinese,,0,0,0,,这意味着分配器不能移动块
Dialogue: 0,0:11:38.94,0:11:44.26,English,,0,0,0,,It can't compress blocks like an allocator might want to take allocated blocks and smoosh them all together
Dialogue: 0,0:11:38.94,0:11:44.26,Chinese,,0,0,0,,比如分配器无法将已分配的块放到一起以达到压缩块的目的
Dialogue: 0,0:11:44.70,0:11:47.64,English,,0,0,0,,To create larger free blocks. hey! but it can't do that
Dialogue: 0,0:11:44.70,0:11:47.64,Chinese,,0,0,0,,这样能创建更大的空闲块。嘿！它不能这样做
Dialogue: 0,0:11:48.42,0:11:52.86,English,,0,0,0,,Okay so once you know in a language like C once an malloc
Dialogue: 0,0:11:48.42,0:11:52.86,Chinese,,0,0,0,,在一个语言中，比如 C 语言中的 malloc
Dialogue: 0,0:11:53.90,0:11:57.42,English,,0,0,0,,Gives a block to an application it can't touch it
Dialogue: 0,0:11:53.90,0:11:57.42,Chinese,,0,0,0,,为应用程序分配一个块，分配器就无法再触及它
Dialogue: 0,0:11:58.68,0:12:03.98,English,,0,0,0,,Okay because blocks are holding data structures like structs
Dialogue: 0,0:11:58.68,0:12:03.98,Chinese,,0,0,0,,因为块正在保存像结构一样的数据结构
Dialogue: 0,0:12:04.76,0:12:12.80,English,,0,0,0,,Or you know scalar objects it has to be aligned to the size of the largest object that can occur
Dialogue: 0,0:12:04.76,0:12:12.80,Chinese,,0,0,0,,或者标量对象必须与可能出现的最大对象的大小对齐
Dialogue: 0,0:12:13.46,0:12:19.54,English,,0,0,0,,Okay so for 64-bit systems that's 16 byte alignment. For 32-bit systems it's 8 byte alignment
Dialogue: 0,0:12:13.46,0:12:19.54,Chinese,,0,0,0,,所以对于 32 位系统需要 16 位字节对齐。64 位系统，需要 8 字节对齐
Dialogue: 0,0:12:24.06,0:12:27.90,English,,0,0,0,,Now allocator are really interesting objects
Dialogue: 0,0:12:24.06,0:12:27.90,Chinese,,0,0,0,,分配器真的很有趣
Dialogue: 0,0:12:27.90,0:12:35.50,English,,0,0,0,,Because they combine a trade-off of both running time sort of speed and space
Dialogue: 0,0:12:27.90,0:12:35.50,Chinese,,0,0,0,,因为它包含了时间和空间上的权衡
Dialogue: 0,0:12:35.90,0:12:38.50,English,,0,0,0,,So it's kind of a space and performance trade-off
Dialogue: 0,0:12:35.90,0:12:38.50,Chinese,,0,0,0,,所以这是一种空间和性能的权衡
Dialogue: 0,0:12:38.52,0:12:42.04,English,,0,0,0,,You're trying to optimize both you want it to run as quickly as possible
Dialogue: 0,0:12:38.52,0:12:42.04,Chinese,,0,0,0,,你正在尝试使其运行得尽可能块
Dialogue: 0,0:12:42.50,0:12:47.72,English,,0,0,0,,But you wanted to use the virtual memory in the heap as efficiently as possible
Dialogue: 0,0:12:42.50,0:12:47.72,Chinese,,0,0,0,,但是你希望尽可能高效地使用堆中的虚拟内存
Dialogue: 0,0:12:48.14,0:12:48.74,English,,0,0,0,,Okay so let's
Dialogue: 0,0:12:48.14,0:12:48.74,Chinese,,0,0,0,,好的，让我们
Dialogue: 0,0:12:50.28,0:12:59.50,English,,0,0,0,,We define these sort of speed and memory efficiency metrics
Dialogue: 0,0:12:50.28,0:12:59.50,Chinese,,0,0,0,,我们定义了这些速度和内存效率指标
Dialogue: 0,0:12:59.58,0:13:02.40,English,,0,0,0,,We have two metrics that we use, one is called throughput
Dialogue: 0,0:12:59.58,0:13:02.40,Chinese,,0,0,0,,我们使用了两个指标，一个称为吞吐量
Dialogue: 0,0:13:03.44,0:13:10.52,English,,0,0,0,,So given some sequence of malloc and free requests - R0 through R(n-1)
Dialogue: 0,0:13:03.44,0:13:10.52,Chinese,,0,0,0,,因此给出了 malloc 和 free 请求序列 —— R0 到 R(n-1)
Dialogue: 0,0:13:10.72,0:13:13.96,English,,0,0,0,,So just some where R is either a malloc or free
Dialogue: 0,0:13:10.72,0:13:13.96,Chinese,,0,0,0,,R 表示 malloc 或 free
Dialogue: 0,0:13:15.88,0:13:18.08,English,,0,0,0,,Our goal is to maximize throughput
Dialogue: 0,0:13:15.88,0:13:18.08,Chinese,,0,0,0,,我们的目标是最大化吞吐量
Dialogue: 0,0:13:19.10,0:13:21.28,English,,0,0,0,,And the peak memory utilization
Dialogue: 0,0:13:19.10,0:13:21.28,Chinese,,0,0,0,,并且峰值内存利用率
Dialogue: 0,0:13:22.40,0:13:27.72,English,,0,0,0,,And what makes malloc such a fascinating and interesting study is that these often conflict
Dialogue: 0,0:13:22.40,0:13:27.72,Chinese,,0,0,0,,而这些经常发生的冲突使得研究 malloc  如此令人着迷和有趣
Dialogue: 0,0:13:29.12,0:13:34.50,English,,0,0,0,,It's very easy to make a really fast malloc that has terrible memory utilization
Dialogue: 0,0:13:29.12,0:13:34.50,Chinese,,0,0,0,,编写一个具有很糟糕内存利用率但是很快速的 malloc 非常容易
Dialogue: 0,0:13:36.56,0:13:41.02,English,,0,0,0,,So throughput is just the number of complete requests per unit time
Dialogue: 0,0:13:36.56,0:13:41.02,Chinese,,0,0,0,,因此吞吐量只是每单位时间所有的请求的数量
Dialogue: 0,0:13:41.12,0:13:46.04,English,,0,0,0,,So if we have 5,000 malloc calls and 5,000 free calls in 10 seconds
Dialogue: 0,0:13:41.12,0:13:46.04,Chinese,,0,0,0,,因此，如果我们在 10 秒钟内调用 5,000 次 malloc 并调用 5,000 次 free
Dialogue: 0,0:13:46.78,0:13:49.70,English,,0,0,0,,Then a throughput is 1,000 operations/second
Dialogue: 0,0:13:46.78,0:13:49.70,Chinese,,0,0,0,,然后吞吐量为 1,000 次/秒
Dialogue: 0,0:13:51.66,0:13:57.62,English,,0,0,0,,So it's just measuring sort of how efficiently are a malloc can process these requests from an application
Dialogue: 0,0:13:51.66,0:13:57.62,Chinese,,0,0,0,,因此，它只是评价 malloc 处理来自应用程序的这些请求的效率
Dialogue: 0,0:14:00.56,0:14:02.20,English,,0,0,0,,Now peak memory utilization
Dialogue: 0,0:14:00.56,0:14:02.20,Chinese,,0,0,0,,峰值内存利用率
Dialogue: 0,0:14:05.42,0:14:10.44,English,,0,0,0,,Is a measure sort of how much useful space
Dialogue: 0,0:14:05.42,0:14:10.44,Chinese,,0,0,0,,是一种衡量多少有用空间的标准
Dialogue: 0,0:14:11.20,0:14:16.02,English,,0,0,0,,So how much it measured how efficiently the allocator uses the heap
Dialogue: 0,0:14:11.20,0:14:16.02,Chinese,,0,0,0,,它衡量分配器使用堆的效率有多大
Dialogue: 0,0:14:16.50,0:14:25.00,English,,0,0,0,,Sort of how much is wasted on sort of overheads in the data structures that the allocator has to uses to in the implementation
Dialogue: 0,0:14:16.50,0:14:25.00,Chinese,,0,0,0,,去衡量分配器在实现中必须使用的数据结构中的各种开销上浪费了多少
Dialogue: 0,0:14:26.16,0:14:27.68,English,,0,0,0,,So we'll define a payload
Dialogue: 0,0:14:26.16,0:14:27.68,Chinese,,0,0,0,,所以我们将定义一个有效载荷
Dialogue: 0,0:14:29.02,0:14:31.16,English,,0,0,0,,When malloc returns a block
Dialogue: 0,0:14:29.02,0:14:31.16,Chinese,,0,0,0,,当 malloc 返回一个块时
Dialogue: 0,0:14:31.66,0:14:38.14,English,,0,0,0,,I'm sorry,what an application makes a call to malloc it's requesting a certain size block
Dialogue: 0,0:14:31.66,0:14:38.14,Chinese,,0,0,0,,对不起，一个应用程序调用 malloc 以请求一定大小的块
Dialogue: 0,0:14:39.10,0:14:40.96,English,,0,0,0,,And that block is called the payload
Dialogue: 0,0:14:39.10,0:14:40.96,Chinese,,0,0,0,,该块称为有效载荷
Dialogue: 0,0:14:40.98,0:14:44.50,English,,0,0,0,,So if we call malloc with an argument of 10 bytes
Dialogue: 0,0:14:40.98,0:14:44.50,Chinese,,0,0,0,,因此，如果我们使用 10 个字节的参数调用 malloc
Dialogue: 0,0:14:45.12,0:14:50.10,English,,0,0,0,,We're requesting a block that has a payload that's at least size 10
Dialogue: 0,0:14:45.12,0:14:50.10,Chinese,,0,0,0,,我们要求一个有效载荷至少为 10 大小的块
Dialogue: 0,0:14:50.98,0:14:53.76,English,,0,0,0,,And the 10 bytes that we request that are called the payload
Dialogue: 0,0:14:50.98,0:14:53.76,Chinese,,0,0,0,,我们请求的 10 个字节称为有效负载
Dialogue: 0,0:14:54.18,0:14:57.06,English,,0,0,0,,Everything else in that block is overhead
Dialogue: 0,0:14:54.18,0:14:57.06,Chinese,,0,0,0,,该块中的其他所有内容都是开销
Dialogue: 0,0:15:00.74,0:15:04.66,English,,0,0,0,,So after we've run a sequence of requests
Dialogue: 0,0:15:00.74,0:15:04.66,Chinese,,0,0,0,,在我们运行一系列请求之后
Dialogue: 0,0:15:06.12,0:15:11.72,English,,0,0,0,,The aggregate payload is the sum of all the the payloads in the currently allocated blocks
Dialogue: 0,0:15:06.12,0:15:11.72,Chinese,,0,0,0,,聚合有效载荷是当前分配的块中所有有效载荷的总和
Dialogue: 0,0:15:13.26,0:15:14.84,English,,0,0,0,,So in a perfect allocator
Dialogue: 0,0:15:13.26,0:15:14.84,Chinese,,0,0,0,,在完美的分配器中
Dialogue: 0,0:15:15.80,0:15:21.46,English,,0,0,0,,The aggregate payload would equal the amount of memory
Dialogue: 0,0:15:15.80,0:15:21.46,Chinese,,0,0,0,,聚合有效负载等于内存量
Dialogue: 0,0:15:21.88,0:15:25.22,English,,0,0,0,,The total size of all the allocated blocks right because there'd be no overhead
Dialogue: 0,0:15:21.88,0:15:25.22,Chinese,,0,0,0,,等于所有已分配块的总大小，因为没有开销
Dialogue: 0,0:15:25.54,0:15:29.00,English,,0,0,0,,We just be pure every block would be pure payload
Dialogue: 0,0:15:25.54,0:15:29.00,Chinese,,0,0,0,,每个块都是有效载荷
Dialogue: 0,0:15:33.62,0:15:39.44,English,,0,0,0,,Now we're going to assume that the heap is monotonically non-decreasing so it always gets bigger
Dialogue: 0,0:15:33.62,0:15:39.44,Chinese,,0,0,0,,现在我们假设堆是单调非递减的，所以它总是变大
Dialogue: 0,0:15:39.98,0:15:45.00,English,,0,0,0,,Okay so are this is a simplifying assumption,it's not true in a real malloc package
Dialogue: 0,0:15:39.98,0:15:45.00,Chinese,,0,0,0,,这是一个简化的假设，在真正的 malloc 包中不是这样
Dialogue: 0,0:15:45.44,0:15:49.98,English,,0,0,0,,But we'll just assume that the allocator never decreases the size of the heap
Dialogue: 0,0:15:45.44,0:15:49.98,Chinese,,0,0,0,,我们假设分配器永远不会减小堆的大小
Dialogue: 0,0:15:50.04,0:15:52.40,English,,0,0,0,,It only increases the size of the heap okay
Dialogue: 0,0:15:50.04,0:15:52.40,Chinese,,0,0,0,,它只会增加堆的大小
Dialogue: 0,0:15:57.06,0:16:02.90,English,,0,0,0,,So the peak given those notions of aggregate payload and heap size
Dialogue: 0,0:15:57.06,0:16:02.90,Chinese,,0,0,0,,所以峰值给出了聚合有效载荷和堆大小的概念
Dialogue: 0,0:16:03.78,0:16:07.94,English,,0,0,0,,The peak memory utilization after k+1 requests
Dialogue: 0,0:16:03.78,0:16:07.94,Chinese,,0,0,0,,k + 1 个请求后的峰值内存利用率
Dialogue: 0,0:16:08.90,0:16:17.10,English,,0,0,0,,It's the sum of all the payloads divided by the total size of the heap
Dialogue: 0,0:16:08.90,0:16:17.10,Chinese,,0,0,0,,它是所有有效负载的总和除以堆的总大小
Dialogue: 0,0:16:19.98,0:16:21.40,English,,0,0,0,,So the in the best case
Dialogue: 0,0:16:19.98,0:16:21.40,Chinese,,0,0,0,,所以在最好的情况下
Dialogue: 0,0:16:22.64,0:16:27.28,English,,0,0,0,,Each block in the heap consists of pure payload
Dialogue: 0,0:16:22.64,0:16:27.28,Chinese,,0,0,0,,堆中的每个块的内容都是有效负载
Dialogue: 0,0:16:27.92,0:16:29.72,English,,0,0,0,,So the utilization would be 1
Dialogue: 0,0:16:27.92,0:16:29.72,Chinese,,0,0,0,,因此利用率为 1
Dialogue: 0,0:16:30.16,0:16:32.24,English,,0,0,0,,That's the best we can do
Dialogue: 0,0:16:30.16,0:16:32.24,Chinese,,0,0,0,,这是我们能做的最好的事情
Dialogue: 0,0:16:32.26,0:16:39.86,English,,0,0,0,,But in practice each block the allocator is going to place have data structures and padding inside of each block
Dialogue: 0,0:16:32.26,0:16:39.86,Chinese,,0,0,0,,但实际上，在分配器将要放置的每个块的内部，都有数据结构和其他内容
Dialogue: 0,0:16:40.44,0:16:45.78,English,,0,0,0,,That keep it from getting a perfect utilization
Dialogue: 0,0:16:40.44,0:16:45.78,Chinese,,0,0,0,,这使它无法获得完美的利用率
Dialogue: 0,0:16:46.22,0:16:49.64,English,,0,0,0,,Now one obvious thing is that since blocks have to be aligned
Dialogue: 0,0:16:46.22,0:16:49.64,Chinese,,0,0,0,,一个显而易见的事情是，因为块必须对齐
Dialogue: 0,0:16:50.78,0:16:56.14,English,,0,0,0,,To some you know if they're 16-byte aligned then blocks have to start on 16 byte boundaries
Dialogue: 0,0:16:50.78,0:16:56.14,Chinese,,0,0,0,,如果它们是 16 字节对齐的，那么块必须以 16 字节边界开始
Dialogue: 0,0:16:56.14,0:16:58.32,English,,0,0,0,,And they have to be at least 16 bytes
Dialogue: 0,0:16:56.14,0:16:58.32,Chinese,,0,0,0,,它们必须至少为 16 个字节
Dialogue: 0,0:16:58.96,0:17:01.64,English,,0,0,0,,So if you were to request a payload of 2 bytes
Dialogue: 0,0:16:58.96,0:17:01.64,Chinese,,0,0,0,,因此，如果你要请求 2 字节的有效负载
Dialogue: 0,0:17:01.76,0:17:06.78,English,,0,0,0,,You'd have a lot of wasted bytes right that would sort of decrease the utilization
Dialogue: 0,0:17:01.76,0:17:06.78,Chinese,,0,0,0,,你有很多浪费的字节，这会降低利用率
Dialogue: 0,0:17:07.56,0:17:11.90,English,,0,0,0,,So this is some of this some of this overhead is unavoidable
Dialogue: 0,0:17:07.56,0:17:11.90,Chinese,,0,0,0,,所以这是其中一些开销是不可避免的
Dialogue: 0,0:17:11.90,0:17:18.46,English,,0,0,0,,But your job as a someone who writes them implements malloc is to try to keep that as small as possible
Dialogue: 0,0:17:11.90,0:17:18.46,Chinese,,0,0,0,,但是你作为一个编写实现 malloc 人，你的的工作就是尽量使得这些浪费减小
Dialogue: 0,0:17:22.40,0:17:29.82,English,,0,0,0,,So poor memory utilization is this example that we just talked about is an example of what we call fragmentation
Dialogue: 0,0:17:22.40,0:17:29.82,Chinese,,0,0,0,,因此，我们刚才谈到的这个例子就是我们称之为 「碎片」 的一个例子
Dialogue: 0,0:17:30.54,0:17:32.88,English,,0,0,0,,And there's two types of fragmentation
Dialogue: 0,0:17:30.54,0:17:32.88,Chinese,,0,0,0,,而且有两种类型的碎片
Dialogue: 0,0:17:34.36,0:17:38.08,English,,0,0,0,,Internal fragmentation occurs if the payload is smaller than the block size
Dialogue: 0,0:17:34.36,0:17:38.08,Chinese,,0,0,0,,如果有效负载小于块大小，则会发生内部碎片
Dialogue: 0,0:17:38.10,0:17:40.20,English,,0,0,0,,So it's just what we're talking about
Dialogue: 0,0:17:38.10,0:17:40.20,Chinese,,0,0,0,,所以这正是我们所谈论的
Dialogue: 0,0:17:40.70,0:17:48.02,English,,0,0,0,,And this can be caused by either padding in the block or some kind of data structure in the block that the allocator needs
Dialogue: 0,0:17:40.70,0:17:48.02,Chinese,,0,0,0,,这可能是由块中的填充或分配器需要的块中的某种数据结构引起的
Dialogue: 0,0:17:50.82,0:17:54.06,English,,0,0,0,,Sometimes to it you might make a policy decision
Dialogue: 0,0:17:50.82,0:17:54.06,Chinese,,0,0,0,,有时，你可能会做出一个策略决定
Dialogue: 0,0:17:54.06,0:17:59.80,English,,0,0,0,,That if application requests a small block you might return a larger block just to keep
Dialogue: 0,0:17:54.06,0:17:59.80,Chinese,,0,0,0,,如果应用程序请求一个小块，你可能会返回一个更大的块来保持
Dialogue: 0,0:18:00.50,0:18:07.24,English,,0,0,0,,So the blocks don't get sort of splintered up into little chunks you might want to keep blocks at some minimum size
Dialogue: 0,0:18:00.50,0:18:07.24,Chinese,,0,0,0,,因此，这些块不会分裂成小块，你可能希望将块保持在某个最小尺寸
Dialogue: 0,0:18:12.60,0:18:17.56,English,,0,0,0,,Now internal fragmentation. You know given a series of requests
Dialogue: 0,0:18:12.60,0:18:17.56,Chinese,,0,0,0,,现在来谈论一下内部碎片。一系列给给予的请求
Dialogue: 0,0:18:19.54,0:18:21.68,English,,0,0,0,,We can just stop and freeze the heap
Dialogue: 0,0:18:19.54,0:18:21.68,Chinese,,0,0,0,,我们可以停止并冻结堆
Dialogue: 0,0:18:21.84,0:18:26.06,English,,0,0,0,,And it's very easy to sort of compute the amount of internal fragmentation
Dialogue: 0,0:18:21.84,0:18:26.06,Chinese,,0,0,0,,并且计算内部碎片的数量非常容易
Dialogue: 0,0:18:26.06,0:18:32.14,English,,0,0,0,,We can at any point in time we can just look at all the previous requests that we've made
Dialogue: 0,0:18:26.06,0:18:32.14,Chinese,,0,0,0,,在任何时候我们都可以查看我们之前提出的所有要求
Dialogue: 0,0:18:32.62,0:18:35.78,English,,0,0,0,,And look at the size of the payload for each one of those requests
Dialogue: 0,0:18:32.62,0:18:35.78,Chinese,,0,0,0,,并查看每个请求的有效负载大小
Dialogue: 0,0:18:36.86,0:18:39.22,English,,0,0,0,,And so we can
Dialogue: 0,0:18:36.86,0:18:39.22,Chinese,,0,0,0,,所以我们可以
Dialogue: 0,0:18:41.76,0:18:47.04,English,,0,0,0,,So we can determine the level you know get at a point in time,we can determine the level of internal fragmentation
Dialogue: 0,0:18:41.76,0:18:47.04,Chinese,,0,0,0,,因此，我们可以在某个时间点确定内部碎片的级别
Dialogue: 0,0:18:47.66,0:18:49.34,English,,0,0,0,,Just by looking at the previous request
Dialogue: 0,0:18:47.66,0:18:49.34,Chinese,,0,0,0,,只需查看之前的请求即可
Dialogue: 0,0:18:50.26,0:18:50.62,English,,0,0,0,,So
Dialogue: 0,0:18:50.26,0:18:50.62,Chinese,,0,0,0,,所以
Dialogue: 0,0:18:52.22,0:18:58.62,English,,0,0,0,,There's another form of fragmentation called external fragmentation which is a little more difficult to deal with
Dialogue: 0,0:18:52.22,0:18:58.62,Chinese,,0,0,0,,还有另一种形式的碎片称为 「外部碎片」，这种碎片更难处理
Dialogue: 0,0:18:59.50,0:19:04.20,English,,0,0,0,,So external fragmentation occurs when there's enough memory in the heap
Dialogue: 0,0:18:59.50,0:19:04.20,Chinese,,0,0,0,,外部碎片发生在堆中有足够的内存时
Dialogue: 0,0:19:05.12,0:19:09.42,English,,0,0,0,,But there's no single free block that can satisfy a particular request
Dialogue: 0,0:19:05.12,0:19:09.42,Chinese,,0,0,0,,但是没有一个可以满足特定请求的空闲块
Dialogue: 0,0:19:10.22,0:19:15.36,English,,0,0,0,,Ok so external fragmentation occurs when the application makes a request for a block
Dialogue: 0,0:19:10.22,0:19:15.36,Chinese,,0,0,0,,所以外部碎片发生在当应用程序发出块请求时
Dialogue: 0,0:19:16.70,0:19:23.02,English,,0,0,0,,But nowhere in the heap is a free block that's large enough to satisfy that request
Dialogue: 0,0:19:16.70,0:19:23.02,Chinese,,0,0,0,,但堆中没有一个足够大的空闲块来满足该请求
Dialogue: 0,0:19:26.22,0:19:28.46,English,,0,0,0,,So an example of this like suppose
Dialogue: 0,0:19:26.22,0:19:28.46,Chinese,,0,0,0,,所以这个例子就像假设一样
Dialogue: 0,0:19:28.72,0:19:30.58,English,,0,0,0,,Here's the previous example we looked at
Dialogue: 0,0:19:28.72,0:19:30.58,Chinese,,0,0,0,,这是我们上面看到的前一个例子
Dialogue: 0,0:19:30.58,0:19:35.38,English,,0,0,0,,Now where we have after a series of malloc and free calls
Dialogue: 0,0:19:30.58,0:19:35.38,Chinese,,0,0,0,,现在我们在一系列 malloc 和 free 调用之后
Dialogue: 0,0:19:36.40,0:19:38.10,English,,0,0,0,,We have two free blocks in the heap
Dialogue: 0,0:19:36.40,0:19:38.10,Chinese,,0,0,0,,我们在堆中有两个空闲块
Dialogue: 0,0:19:38.98,0:19:41.86,English,,0,0,0,,One containing 5 words and the other containing 2 words
Dialogue: 0,0:19:38.98,0:19:41.86,Chinese,,0,0,0,,一个包含 5 个字，另一个包含 2 个字
Dialogue: 0,0:19:41.96,0:19:47.02,English,,0,0,0,,So the total number of free words in our heap is 7 words
Dialogue: 0,0:19:41.96,0:19:47.02,Chinese,,0,0,0,,所以我们堆中的空闲的字总数是 7 个字
Dialogue: 0,0:19:47.90,0:19:51.10,English,,0,0,0,,And now we get a request for 6 words
Dialogue: 0,0:19:47.90,0:19:51.10,Chinese,,0,0,0,,现在我们收到 6 个字的请求
Dialogue: 0,0:19:52.34,0:19:56.22,English,,0,0,0,,Hey we have enough free blocks, we have enough free words in the heap
Dialogue: 0,0:19:52.34,0:19:56.22,Chinese,,0,0,0,,嘿，我们有足够的空闲块，我们在堆中有足够的空间
Dialogue: 0,0:19:57.42,0:19:59.30,English,,0,0,0,,But we can't satisfy that request
Dialogue: 0,0:19:57.42,0:19:59.30,Chinese,,0,0,0,,但我们无法满足这一要求
Dialogue: 0,0:20:00.76,0:20:05.92,English,,0,0,0,,And it's because of this phenomenon called external fragmentation
Dialogue: 0,0:20:00.76,0:20:05.92,Chinese,,0,0,0,,这是因为外部碎片这种现象
Dialogue: 0,0:20:06.26,0:20:11.42,English,,0,0,0,,For example if we'd have somehow allocated
Dialogue: 0,0:20:06.26,0:20:11.42,Chinese,,0,0,0,,例如，如果我们以某种方式分配
Dialogue: 0,0:20:15.27,0:20:16.54,English,,0,0,0,,Oh
Dialogue: 0,0:20:15.27,0:20:16.54,Chinese,,0,0,0,,哦
Dialogue: 0,0:20:18.52,0:20:22.34,English,,0,0,0,,Yeah I don't know in this case I don't think we could have avoided the external fragmentation
Dialogue: 0,0:20:18.52,0:20:22.34,Chinese,,0,0,0,,我认为我们不能避免外部碎片
Dialogue: 0,0:20:22.98,0:20:29.78,English,,0,0,0,,But nonetheless there's enough memory here. We just the way that a blocks are configured in the heap
Dialogue: 0,0:20:22.98,0:20:29.78,Chinese,,0,0,0,,但是，无庸置疑这里由足够的内存。我们配置堆中块的方式
Dialogue: 0,0:20:29.78,0:20:31.30,English,,0,0,0,,We can't satisfy the request
Dialogue: 0,0:20:29.78,0:20:31.30,Chinese,,0,0,0,,无法满足请求
Dialogue: 0,0:20:31.78,0:20:38.62,English,,0,0,0,,So in this case that the allocator has to go and get more virtual memory
Dialogue: 0,0:20:31.78,0:20:38.62,Chinese,,0,0,0,,所以在这种情况下，分配器必须去获得更多的虚拟内存
Dialogue: 0,0:20:39.62,0:20:42.80,English,,0,0,0,,It would have to get more virtual memory and extend the heap out this way
Dialogue: 0,0:20:39.62,0:20:42.80,Chinese,,0,0,0,,它必须获得更多虚拟内存，并在堆的这后面进行扩展
Dialogue: 0,0:20:44.10,0:20:45.64,English,,0,0,0,,And to get a large enough free block
Dialogue: 0,0:20:44.10,0:20:45.64,Chinese,,0,0,0,,并获得足够大的免空闲块
Dialogue: 0,0:20:47.26,0:20:53.00,English,,0,0,0,,So you know assessing and sort of understanding external fragmentation is difficult
Dialogue: 0,0:20:47.26,0:20:53.00,Chinese,,0,0,0,,因此，评估和理解外部碎片很困难
Dialogue: 0,0:20:53.88,0:20:58.58,English,,0,0,0,,Because unlike internal fragmentation which depended on the previous requests
Dialogue: 0,0:20:53.88,0:20:58.58,Chinese,,0,0,0,,因为不同于内部碎片，这取决于之前的要求
Dialogue: 0,0:20:59.08,0:21:01.92,English,,0,0,0,,External fragmentation depends on future requests
Dialogue: 0,0:20:59.08,0:21:01.92,Chinese,,0,0,0,,外部碎片取决于未来的要求
Dialogue: 0,0:21:03.00,0:21:04.44,English,,0,0,0,,So if we look back at this point
Dialogue: 0,0:21:03.00,0:21:04.44,Chinese,,0,0,0,,所以，如果我们回顾这一点
Dialogue: 0,0:21:04.78,0:21:07.92,English,,0,0,0,,We see is a heap externally fragmented
Dialogue: 0,0:21:04.78,0:21:07.92,Chinese,,0,0,0,,我们看到的是外部碎片堆
Dialogue: 0,0:21:08.72,0:21:10.84,English,,0,0,0,,Well we it depends right. we can't say ...
Dialogue: 0,0:21:08.72,0:21:10.84,Chinese,,0,0,0,,这取决于 … 我们不能说 …
Dialogue: 0,0:21:11.80,0:21:16.40,English,,0,0,0,,It turns out it is because the next request is for a block of size six
Dialogue: 0,0:21:11.80,0:21:16.40,Chinese,,0,0,0,,这是因为下一个请求是针对大小为 6 的块
Dialogue: 0,0:21:16.84,0:21:18.22,English,,0,0,0,,But if all of the future blocks
Dialogue: 0,0:21:16.84,0:21:18.22,Chinese,,0,0,0,,但如果所有的未来块
Dialogue: 0,0:21:18.70,0:21:22.88,English,,0,0,0,,Or future requests we're for blocks of you know say small blocks
Dialogue: 0,0:21:18.70,0:21:22.88,Chinese,,0,0,0,,或者未来我们对于小块的请求
Dialogue: 0,0:21:23.44,0:21:28.86,English,,0,0,0,,Then we be able to satisfy those than and we wouldn't suffer from external fragmentation
Dialogue: 0,0:21:23.44,0:21:28.86,Chinese,,0,0,0,,那我们能够满足那些请求，而且我们不会受到外部碎片的影响
Dialogue: 0,0:21:33.48,0:21:36.16,English,,0,0,0,,Okay now when we build an allocated
Dialogue: 0,0:21:33.48,0:21:36.16,Chinese,,0,0,0,,好的，现在我们建立一个分配的
Dialogue: 0,0:21:37.90,0:21:39.42,English,,0,0,0,,All kinds of issues come up
Dialogue: 0,0:21:37.90,0:21:39.42,Chinese,,0,0,0,,出现了各种各样的问题
Dialogue: 0,0:21:42.36,0:21:45.04,English,,0,0,0,,And that I've glossed over with my simple examples right
Dialogue: 0,0:21:42.36,0:21:45.04,Chinese,,0,0,0,,我用简单的例子对我进行了解释
Dialogue: 0,0:21:46.32,0:21:47.36,English,,0,0,0,,You know how do we know
Dialogue: 0,0:21:46.32,0:21:47.36,Chinese,,0,0,0,,我们怎么知道
Dialogue: 0,0:21:49.04,0:21:52.88,English,,0,0,0,,If we call free,how does free know how much memory to free up
Dialogue: 0,0:21:49.04,0:21:52.88,Chinese,,0,0,0,,如果我们调用了 free，free 如何知道要释放多少内存
Dialogue: 0,0:21:53.14,0:21:56.64,English,,0,0,0,,Right we don't call free with a block size we call it with a pointer
Dialogue: 0,0:21:53.14,0:21:56.64,Chinese,,0,0,0,,我们不用块大小调用 free，我们用指针调用它
Dialogue: 0,0:21:57.36,0:22:00.02,English,,0,0,0,,So how does free know how big that block is
Dialogue: 0,0:21:57.36,0:22:00.02,Chinese,,0,0,0,,free 如何知道该块有多大
Dialogue: 0,0:22:01.96,0:22:03.64,English,,0,0,0,,How do we keep track of all the free blocks
Dialogue: 0,0:22:01.96,0:22:03.64,Chinese,,0,0,0,,我们如何跟踪所有空闲块
Dialogue: 0,0:22:07.54,0:22:11.64,English,,0,0,0,,When we have you know when we're satisfying an allocation request
Dialogue: 0,0:22:07.54,0:22:11.64,Chinese,,0,0,0,,当满足分配请求时
Dialogue: 0,0:22:12.94,0:22:14.72,English,,0,0,0,,We're going to fight we're going to look for a free block
Dialogue: 0,0:22:12.94,0:22:14.72,Chinese,,0,0,0,,我们将寻找一个空闲块
Dialogue: 0,0:22:14.88,0:22:18.10,English,,0,0,0,,That is larger than the requested size
Dialogue: 0,0:22:14.88,0:22:18.10,Chinese,,0,0,0,,这个块大于请求的大小
Dialogue: 0,0:22:19.02,0:22:22.08,English,,0,0,0,,On that case what do we do with the extra space in the block
Dialogue: 0,0:22:19.02,0:22:22.08,Chinese,,0,0,0,,在那种情况下，我们如何处理块中的额外空间
Dialogue: 0,0:22:22.52,0:22:24.04,English,,0,0,0,,We do we just keep it in the block
Dialogue: 0,0:22:22.52,0:22:24.04,Chinese,,0,0,0,,我们只是将它保留在块中
Dialogue: 0,0:22:25.14,0:22:27.56,English,,0,0,0,,You know and and suffer some internal fragmentation
Dialogue: 0,0:22:25.14,0:22:27.56,Chinese,,0,0,0,,遭受一些内部碎片化
Dialogue: 0,0:22:27.96,0:22:30.76,English,,0,0,0,,Do we split that block into a smaller block
Dialogue: 0,0:22:27.96,0:22:30.76,Chinese,,0,0,0,,我们是否将该块拆分为较小的块
Dialogue: 0,0:22:33.68,0:22:36.72,English,,0,0,0,,There's a lot of free blocks in the heap
Dialogue: 0,0:22:33.68,0:22:36.72,Chinese,,0,0,0,,堆中有很多空闲块
Dialogue: 0,0:22:36.72,0:22:41.72,English,,0,0,0,,When the allocator gets a allocation request
Dialogue: 0,0:22:36.72,0:22:41.72,Chinese,,0,0,0,,当分配器获得分配请求时
Dialogue: 0,0:22:42.20,0:22:46.72,English,,0,0,0,,How does it pick from all of those different free blocks make as many choices
Dialogue: 0,0:22:42.20,0:22:46.72,Chinese,,0,0,0,,如何选择这些不同的空闲块
Dialogue: 0,0:22:49.04,0:22:53.90,English,,0,0,0,,And then once when free tries to insert a free block we're in the heap
Dialogue: 0,0:22:49.04,0:22:53.90,Chinese,,0,0,0,,当 free 尝试插入一个空闲块时，在堆中
Dialogue: 0,0:22:55.52,0:22:56.72,English,,0,0,0,,You know where does it insert
Dialogue: 0,0:22:55.52,0:22:56.72,Chinese,,0,0,0,,它在哪里插入
Dialogue: 0,0:22:57.68,0:22:59.00,English,,0,0,0,,It okay when it's freed
Dialogue: 0,0:22:57.68,0:22:59.00,Chinese,,0,0,0,,当它被释放时
Dialogue: 0,0:22:59.38,0:23:02.12,English,,0,0,0,,And how do we reinsert a free block what does that mean
Dialogue: 0,0:22:59.38,0:23:02.12,Chinese,,0,0,0,,我们如何重新插入一个空闲块，这意味着什么
Dialogue: 0,0:23:02.96,0:23:05.74,English,,0,0,0,,Okay so today we're going to look at all of these issues
Dialogue: 0,0:23:02.96,0:23:05.74,Chinese,,0,0,0,,今天我们要看看所有这些问题
Dialogue: 0,0:23:07.60,0:23:10.38,English,,0,0,0,,Starting with knowing how much to free
Dialogue: 0,0:23:07.60,0:23:10.38,Chinese,,0,0,0,,从知道要释放多少开始
Dialogue: 0,0:23:10.68,0:23:12.08,English,,0,0,0,,So how big our block sizes
Dialogue: 0,0:23:10.68,0:23:12.08,Chinese,,0,0,0,,那么我们的块大小有多大
Dialogue: 0,0:23:13.38,0:23:15.60,English,,0,0,0,,So the typical the standard method
Dialogue: 0,0:23:13.38,0:23:15.60,Chinese,,0,0,0,,典型的标准方法
Dialogue: 0,0:23:17.52,0:23:21.98,English,,0,0,0,,Is to keep sort of a word sized quantity at the beginning of each block
Dialogue: 0,0:23:17.52,0:23:21.98,Chinese,,0,0,0,,是在每个块的开头使用一个字大小的的区域
Dialogue: 0,0:23:22.28,0:23:26.84,English,,0,0,0,,That gives the size of that block in some units
Dialogue: 0,0:23:22.28,0:23:26.84,Chinese,,0,0,0,,它记录了某些单元中该块的大小
Dialogue: 0,0:23:27.62,0:23:29.68,English,,0,0,0,,I'm showing them here in word size units
Dialogue: 0,0:23:27.62,0:23:29.68,Chinese,,0,0,0,,我在这里用字大小单位显示它们
Dialogue: 0,0:23:30.74,0:23:39.16,English,,0,0,0,,Okay so that if the application malloc a payload of size wants to malloc a payload of size 4
Dialogue: 0,0:23:30.74,0:23:39.16,Chinese,,0,0,0,,如果应用程序想要 malloc 一个大小为 4 字的负载荷
Dialogue: 0,0:23:41.12,0:23:46.62,English,,0,0,0,,Then the allocator needs to find a block of size 5
Dialogue: 0,0:23:41.12,0:23:46.62,Chinese,,0,0,0,,分配器需要找到大小为 5 的块
Dialogue: 0,0:23:47.96,0:23:52.10,English,,0,0,0,,So consisting of 4 payload words at least 4 payload words
Dialogue: 0,0:23:47.96,0:23:52.10,Chinese,,0,0,0,,因此，由 4 个有效载荷字组成，至少 4 个有效载荷字
Dialogue: 0,0:23:52.84,0:24:01.28,English,,0,0,0,,And then a header block,a header word at the beginning that indicates the size,the total size of that block
Dialogue: 0,0:23:52.84,0:24:01.28,Chinese,,0,0,0,,头部字表示该块的总大小
Dialogue: 0,0:24:02.76,0:24:06.90,English,,0,0,0,,And then it returns a pointer p0 in this case to the beginning of the payload
Dialogue: 0,0:24:02.76,0:24:06.90,Chinese,,0,0,0,,在这种情况下它将返回指向有效负载荷开头指针 p0
Dialogue: 0,0:24:12.60,0:24:15.48,English,,0,0,0,,Okay so now we know how big each block is that's pretty simple
Dialogue: 0,0:24:12.60,0:24:15.48,Chinese,,0,0,0,,现在我们知道每个块有多大，这很简单
Dialogue: 0,0:24:15.82,0:24:19.40,English,,0,0,0,,And how we keep track of the free blocks and this is where it gets interesting
Dialogue: 0,0:24:15.82,0:24:19.40,Chinese,,0,0,0,,那以及我们如何跟踪空闲块，这就是它变得有趣的地方
Dialogue: 0,0:24:20.58,0:24:25.38,English,,0,0,0,,The simplest method is to use that we call an implicit list
Dialogue: 0,0:24:20.58,0:24:25.38,Chinese,,0,0,0,,最简单的方法是使用我们称为隐式列表的方法
Dialogue: 0,0:24:25.86,0:24:27.48,English,,0,0,0,,An implicit list of free blocks
Dialogue: 0,0:24:25.86,0:24:27.48,Chinese,,0,0,0,,一个隐式的空闲块列表
Dialogue: 0,0:24:28.74,0:24:34.26,English,,0,0,0,,And the idea here is to just put a header in the front of every block in the heap
Dialogue: 0,0:24:28.74,0:24:34.26,Chinese,,0,0,0,,它的思想是在堆中的每个块的前面放置一个头部
Dialogue: 0,0:24:34.26,0:24:36.10,English,,0,0,0,,Whether allocated or free
Dialogue: 0,0:24:34.26,0:24:36.10,Chinese,,0,0,0,,无论是被分配了还是空闲的
Dialogue: 0,0:24:38.86,0:24:44.76,English,,0,0,0,,And then we can use that starting at the beginning of the heap, we can use that size to walk the heap
Dialogue: 0,0:24:38.86,0:24:44.76,Chinese,,0,0,0,,然后我们可以在堆的开头使用它，我们可以使用头部记录的大小来访问堆
Dialogue: 0,0:24:47.14,0:24:50.20,English,,0,0,0,,Okay so here's a block of size 5 so we can we can jump
Dialogue: 0,0:24:47.14,0:24:50.20,Chinese,,0,0,0,,所以这是一个 5 个字大小的块，所以我们可以跳
Dialogue: 0,0:24:50.60,0:24:53.86,English,,0,0,0,,We know that the next block starts at an offset of 5
Dialogue: 0,0:24:50.60,0:24:53.86,Chinese,,0,0,0,,我们知道下一个块的偏移量为 5
Dialogue: 0,0:24:56.06,0:25:01.96,English,,0,0,0,,With the second block we know the next block starts at an offset of 4  and so on
Dialogue: 0,0:24:56.06,0:25:01.96,Chinese,,0,0,0,,对于第二个块，我们知道下一个块的偏移量为 4，依此类推
Dialogue: 0,0:25:02.58,0:25:05.00,English,,0,0,0,,Okay so we call it an implicit free list
Dialogue: 0,0:25:02.58,0:25:05.00,Chinese,,0,0,0,,我们称之为隐式空闲列表
Dialogue: 0,0:25:06.32,0:25:08.38,English,,0,0,0,,Because there's no real list of free blocks
Dialogue: 0,0:25:06.32,0:25:08.38,Chinese,,0,0,0,,因为没有真正的空闲块列表
Dialogue: 0,0:25:09.06,0:25:13.26,English,,0,0,0,,But we can trick an traverse that all of the free blocks in the heap
Dialogue: 0,0:25:09.06,0:25:13.26,Chinese,,0,0,0,,但是我们可以巧妙地遍历堆中的所有空闲块
Dialogue: 0,0:25:14.04,0:25:18.46,English,,0,0,0,,By traversing all of the blocks in the heap
Dialogue: 0,0:25:14.04,0:25:18.46,Chinese,,0,0,0,,通过在堆中遍历所有块
Dialogue: 0,0:25:18.56,0:25:21.74,English,,0,0,0,,And then just ignoring the allocated blocks okay so
Dialogue: 0,0:25:18.56,0:25:21.74,Chinese,,0,0,0,,只是忽略已分配的块就可以了
Dialogue: 0,0:25:25.84,0:25:27.10,English,,0,0,0,,Now another thing we could do is
Dialogue: 0,0:25:25.84,0:25:27.10,Chinese,,0,0,0,,现在我们可以做的另一件事是
Dialogue: 0,0:25:27.10,0:25:31.38,English,,0,0,0,,We could actually use some of the words in the block
Dialogue: 0,0:25:27.10,0:25:31.38,Chinese,,0,0,0,,我们实际上可以使用块中的一些字
Dialogue: 0,0:25:31.70,0:25:34.30,English,,0,0,0,,To create a linked list of some kind either us
Dialogue: 0,0:25:31.70,0:25:34.30,Chinese,,0,0,0,,去创建某种链接列表
Dialogue: 0,0:25:35.44,0:25:36.96,English,,0,0,0,,Singly or doubly linked lists
Dialogue: 0,0:25:35.44,0:25:36.96,Chinese,,0,0,0,,单链或双链表
Dialogue: 0,0:25:38.48,0:25:43.56,English,,0,0,0,,And in this case it's an explicit list of the free blocks
Dialogue: 0,0:25:38.48,0:25:43.56,Chinese,,0,0,0,,在这种情况下，这是一个明确的空闲块列表
Dialogue: 0,0:25:44.06,0:25:45.54,English,,0,0,0,,And we can just walk that list
Dialogue: 0,0:25:44.06,0:25:45.54,Chinese,,0,0,0,,我们可以访问这个列表
Dialogue: 0,0:25:48.56,0:25:50.50,English,,0,0,0,,So we here we visit the first free block
Dialogue: 0,0:25:48.56,0:25:50.50,Chinese,,0,0,0,,我们在这里访问第一个空闲区块
Dialogue: 0,0:25:51.50,0:25:55.26,English,,0,0,0,,And then there's a pointer to the next free block and so on
Dialogue: 0,0:25:51.50,0:25:55.26,Chinese,,0,0,0,,然后有一个指向下一个空闲块的指针，依此类推
Dialogue: 0,0:25:55.28,0:25:58.26,English,,0,0,0,,So this you can see this might be a little more efficient because
Dialogue: 0,0:25:55.28,0:25:58.26,Chinese,,0,0,0,,所以你可以看到这可能会更高效，因为
Dialogue: 0,0:25:59.14,0:26:00.62,English,,0,0,0,,If we want to traverse the free list
Dialogue: 0,0:25:59.14,0:26:00.62,Chinese,,0,0,0,,如果我们想要遍历空闲列表
Dialogue: 0,0:26:01.86,0:26:07.54,English,,0,0,0,,In this case it's going to be ordered the number of blocks in the list
Dialogue: 0,0:26:01.86,0:26:07.54,Chinese,,0,0,0,,在这种情况下，将按顺序排列列表中的块数
Dialogue: 0,0:26:08.06,0:26:10.84,English,,0,0,0,,Okay it's going to be linear in the total number of blocks in the heap
Dialogue: 0,0:26:08.06,0:26:10.84,Chinese,,0,0,0,,它将与堆中的块总数中呈线性
Dialogue: 0,0:26:11.24,0:26:14.84,English,,0,0,0,,Which might be quite large there could be lots of allocated blocks
Dialogue: 0,0:26:11.24,0:26:14.84,Chinese,,0,0,0,,这个列表可能很大，因为可能会有很多已分配的块
Dialogue: 0,0:26:15.88,0:26:17.76,English,,0,0,0,,In this case with an explicit list
Dialogue: 0,0:26:15.88,0:26:17.76,Chinese,,0,0,0,,在这种情况下有一个明确的列表
Dialogue: 0,0:26:18.98,0:26:23.64,English,,0,0,0,,Any traversal just just be linear in the size of the free list
Dialogue: 0,0:26:18.98,0:26:23.64,Chinese,,0,0,0,,任何遍历与空闲列表的大小线性相关
Dialogue: 0,0:26:24.18,0:26:24.66,English,,0,0,0,,Question
Dialogue: 0,0:26:24.18,0:26:24.66,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:26:25.92,0:26:29.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:26:29.76,0:26:33.02,English,,0,0,0,,Yeah that's the question is done we need a free bit and we do
Dialogue: 0,0:26:29.76,0:26:33.02,Chinese,,0,0,0,,是的，问题已经解决了，我们需要一个空闲的位，我们也是这么做的
Dialogue: 0,0:26:33.62,0:26:35.96,English,,0,0,0,,And I'll we have that's the next question
Dialogue: 0,0:26:33.62,0:26:35.96,Chinese,,0,0,0,,我接下来会问这个问题
Dialogue: 0,0:26:45.68,0:26:49.66,English,,0,0,0,,Now another method a more sophisticated method instead of having one free list
Dialogue: 0,0:26:45.68,0:26:49.66,Chinese,,0,0,0,,现在另一种方法是一种更复杂的方法，而不是一个空闲列表
Dialogue: 0,0:26:50.38,0:26:51.74,English,,0,0,0,,We can have multiple free lists
Dialogue: 0,0:26:50.38,0:26:51.74,Chinese,,0,0,0,,我们可以有多个空闲列表
Dialogue: 0,0:26:52.52,0:26:58.88,English,,0,0,0,,Where each free list contains blocks of a certain size or certain range of sizes
Dialogue: 0,0:26:52.52,0:26:58.88,Chinese,,0,0,0,,每个空闲列表包含特定大小或特定大小范围的块
Dialogue: 0,0:27:03.42,0:27:08.20,English,,0,0,0,,Or we can get really fancy and use some kind of a balance tree
Dialogue: 0,0:27:03.42,0:27:08.20,Chinese,,0,0,0,,或者我们可以非常喜欢使用某种平衡树
Dialogue: 0,0:27:09.76,0:27:13.76,English,,0,0,0,,To sort the blocks to use the tree to sort them by size order
Dialogue: 0,0:27:09.76,0:27:13.76,Chinese,,0,0,0,,使用树将块按照大小来排序
Dialogue: 0,0:27:16.32,0:27:18.78,English,,0,0,0,,Now today we're going to look at the implicit list
Dialogue: 0,0:27:16.32,0:27:18.78,Chinese,,0,0,0,,今天我们要看看隐式列表
Dialogue: 0,0:27:19.56,0:27:21.22,English,,0,0,0,,The simplest kind of free list
Dialogue: 0,0:27:19.56,0:27:21.22,Chinese,,0,0,0,,最简单的空闲列表
Dialogue: 0,0:27:21.90,0:27:27.72,English,,0,0,0,,And this will identify a lot of basic concepts that are used in the more sophisticated free list
Dialogue: 0,0:27:21.90,0:27:27.72,Chinese,,0,0,0,,这里将定义许多更复杂的在空闲列表中使用的基本概念
Dialogue: 0,0:27:28.54,0:27:29.04,English,,0,0,0,,Question
Dialogue: 0,0:27:28.54,0:27:29.04,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:27:29.42,0:27:33.42,English,,0,0,0,,[student speaking]
Dialogue: 0,0:27:33.42,0:27:38.06,English,,0,0,0,,Okay the question is what do you what do we mean by different free lists for different size classes
Dialogue: 0,0:27:33.42,0:27:38.06,Chinese,,0,0,0,,好的问题是，对于不同大小的块有不同的空闲列表是什么意思？
Dialogue: 0,0:27:39.32,0:27:44.80,English,,0,0,0,,So what I mean is that you identify a range of sizes
Dialogue: 0,0:27:39.32,0:27:44.80,Chinese,,0,0,0,,我的意思是你确定了一系列尺寸
Dialogue: 0,0:27:45.96,0:27:50.10,English,,0,0,0,,And you associate that range with each of these individual free lists
Dialogue: 0,0:27:45.96,0:27:50.10,Chinese,,0,0,0,,并且你将该范围与每个单独的空闲列表相关联
Dialogue: 0,0:27:50.88,0:27:54.40,English,,0,0,0,,Okay so one free list might hold blocks of size 0 to 8
Dialogue: 0,0:27:50.88,0:27:54.40,Chinese,,0,0,0,,好的，所以一个空闲列表可能包含 0 到 8 字大小的块
Dialogue: 0,0:27:55.42,0:27:58.64,English,,0,0,0,,And another free list might hold blocks of size 9 to 16
Dialogue: 0,0:27:55.42,0:27:58.64,Chinese,,0,0,0,,另一个空闲列表可能包含大小为 9 到 16 字大小的块
Dialogue: 0,0:27:59.72,0:28:04.06,English,,0,0,0,,And the other another free list may be 17 to 32 you know some
Dialogue: 0,0:27:59.72,0:28:04.06,Chinese,,0,0,0,,而另一个空闲列表可能是 17 到 32 字的块
Dialogue: 0,0:28:06.12,0:28:08.02,English,,0,0,0,,And so you're guaranteed you now know
Dialogue: 0,0:28:06.12,0:28:08.02,Chinese,,0,0,0,,所以这保证了你现在知道了
Dialogue: 0,0:28:10.44,0:28:15.50,English,,0,0,0,,When you're traversing a certain list you know the range of sizes of the blocks in that list
Dialogue: 0,0:28:10.44,0:28:15.50,Chinese,,0,0,0,,当你遍历某个列表时，你知道该列表中块的大小范围
Dialogue: 0,0:28:18.50,0:28:20.58,English,,0,0,0,,The reason you might want to do that
Dialogue: 0,0:28:18.50,0:28:20.58,Chinese,,0,0,0,,你可能想要这样做的原因
Dialogue: 0,0:28:20.88,0:28:27.26,English,,0,0,0,,By the way is that imagine you had an infinite number of these lists
Dialogue: 0,0:28:20.88,0:28:27.26,Chinese,,0,0,0,,顺便说一句，想象一下，你有无数的这些列表
Dialogue: 0,0:28:28.06,0:28:29.70,English,,0,0,0,,One for each possible size
Dialogue: 0,0:28:28.06,0:28:29.70,Chinese,,0,0,0,,每个列表对应一个大小
Dialogue: 0,0:28:31.54,0:28:33.64,English,,0,0,0,,Then every time you allocated a block
Dialogue: 0,0:28:31.54,0:28:33.64,Chinese,,0,0,0,,然后每次你分配一个块
Dialogue: 0,0:28:34.12,0:28:36.26,English,,0,0,0,,You'd get a block of exactly the size you needed
Dialogue: 0,0:28:34.12,0:28:36.26,Chinese,,0,0,0,,你会得到一个与你需要的尺寸完全相同的块
Dialogue: 0,0:28:37.52,0:28:43.86,English,,0,0,0,,So there'd be a minimum amount of fragmentation if you had an infinite number of these size classes
Dialogue: 0,0:28:37.52,0:28:43.86,Chinese,,0,0,0,,因此，如果各个不同大小的块都有很多个，会有最少的碎片
Dialogue: 0,0:28:44.78,0:28:47.42,English,,0,0,0,,Now if we of course we can't have an infinite number but
Dialogue: 0,0:28:44.78,0:28:47.42,Chinese,,0,0,0,,我们当然不能拥有无限个，但是
Dialogue: 0,0:28:48.14,0:28:52.26,English,,0,0,0,,The more of these size classes we have the closer we get to that ideal
Dialogue: 0,0:28:48.14,0:28:52.26,Chinese,,0,0,0,,这些尺寸大小的类别越多，我们越接近理想的情况
Dialogue: 0,0:28:55.56,0:28:59.80,English,,0,0,0,,All right so let's look at how we would build implicit free lists
Dialogue: 0,0:28:55.56,0:28:59.80,Chinese,,0,0,0,,好的，让我们来看看如何构建隐式空闲列表
Dialogue: 0,0:29:01.20,0:29:03.54,English,,0,0,0,,So as you correctly point it out for each
Dialogue: 0,0:29:01.20,0:29:03.54,Chinese,,0,0,0,,你可以看出
Dialogue: 0,0:29:04.42,0:29:08.08,English,,0,0,0,,Each block we need both size and the allocation status
Dialogue: 0,0:29:04.42,0:29:08.08,Chinese,,0,0,0,,每个块我们都需要大小和分配状态
Dialogue: 0,0:29:08.96,0:29:09.54,English,,0,0,0,,Question
Dialogue: 0,0:29:08.96,0:29:09.54,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:29:09.84,0:29:17.00,English,,0,0,0,,[student speaking]
Dialogue: 0,0:29:17.42,0:29:19.40,English,,0,0,0,,Why can't we map every size class
Dialogue: 0,0:29:17.42,0:29:19.40,Chinese,,0,0,0,,我们为什么不能映射每个大小的类
Dialogue: 0,0:29:19.56,0:29:32.40,English,,0,0,0,,[student speaking]
Dialogue: 0,0:29:32.40,0:29:35.44,English,,0,0,0,,Yeah that's so why can't we have an infinite number of size classes
Dialogue: 0,0:29:32.40,0:29:35.44,Chinese,,0,0,0,,是的，为什么我们不能拥有无限数量的不同大小的类
Dialogue: 0,0:29:43.62,0:29:48.40,English,,0,0,0,,I suppose you know that'd be an interesting strategy to think about
Dialogue: 0,0:29:43.62,0:29:48.40,Chinese,,0,0,0,,这是一个值得思考的有趣策略
Dialogue: 0,0:29:48.92,0:29:51.24,English,,0,0,0,,So you can't have an infinite number of size classes
Dialogue: 0,0:29:48.92,0:29:51.24,Chinese,,0,0,0,,你不能拥有无限数量的大小类
Dialogue: 0,0:29:51.50,0:29:56.10,English,,0,0,0,,But you could create a new size class for every new size that you get
Dialogue: 0,0:29:51.50,0:29:56.10,Chinese,,0,0,0,,但是你可以为你得到的每个新尺寸创建一个新的尺寸类
Dialogue: 0,0:29:57.04,0:30:02.64,English,,0,0,0,,And that might work but it just depends on the range of these size classes
Dialogue: 0,0:29:57.04,0:30:02.64,Chinese,,0,0,0,,这可能会奏效，但这取决于这些大小类的范围
Dialogue: 0,0:30:03.40,0:30:09.00,English,,0,0,0,,And the frequency and one problem you might have is that you would get
Dialogue: 0,0:30:03.40,0:30:09.00,Chinese,,0,0,0,,你可能会遇一些问题
Dialogue: 0,0:30:10.76,0:30:15.60,English,,0,0,0,,Maybe it depends on the distribution of your sizes that you get
Dialogue: 0,0:30:10.76,0:30:15.60,Chinese,,0,0,0,,也许它取决于你得到的尺寸分布
Dialogue: 0,0:30:15.60,0:30:20.58,English,,0,0,0,,If you're getting an equal number, if your distribution of sizes is fairly uniform
Dialogue: 0,0:30:15.60,0:30:20.58,Chinese,,0,0,0,,如果你得到一个相同的数字，如果你的尺寸分布相当均匀
Dialogue: 0,0:30:20.94,0:30:22.20,English,,0,0,0,,That would probably work pretty well
Dialogue: 0,0:30:20.94,0:30:22.20,Chinese,,0,0,0,,这可能会很好
Dialogue: 0,0:30:22.90,0:30:33.40,English,,0,0,0,,If you have a lot of requests for different size classes,you'd have a lot of sort of wasted free lists I think
Dialogue: 0,0:30:22.90,0:30:33.40,Chinese,,0,0,0,,如果你对很多不同大小的类请求，我认为你会有很多浪费的空闲列表
Dialogue: 0,0:30:35.28,0:30:39.06,English,,0,0,0,,So it's a good question,it depends on your workload
Dialogue: 0,0:30:35.28,0:30:39.06,Chinese,,0,0,0,,所以这是一个很好的问题，这取决于你的工作量
Dialogue: 0,0:30:39.90,0:30:46.56,English,,0,0,0,,And  that is a really useful strategy for
Dialogue: 0,0:30:39.90,0:30:46.56,Chinese,,0,0,0,,这是一个非常有用的策略
Dialogue: 0,0:30:47.48,0:30:51.44,English,,0,0,0,,So you if you have really popular size classes in your request
Dialogue: 0,0:30:47.48,0:30:51.44,Chinese,,0,0,0,,如果你在请求中有非常常用的大小类
Dialogue: 0,0:30:52.38,0:30:58.46,English,,0,0,0,,Then you could just make you know special case free lists to handle those requests
Dialogue: 0,0:30:52.38,0:30:58.46,Chinese,,0,0,0,,然后你可以让特殊情况下的空闲列表来处理这些请求
Dialogue: 0,0:30:59.68,0:31:03.26,English,,0,0,0,,And then let the other free list sort of handle a wider range
Dialogue: 0,0:30:59.68,0:31:03.26,Chinese,,0,0,0,,然后让其他空闲列表处理更广的范围
Dialogue: 0,0:31:04.26,0:31:07.24,English,,0,0,0,,And imagine if you had a free list where all the blocks were the same
Dialogue: 0,0:31:04.26,0:31:07.24,Chinese,,0,0,0,,想象一下，如果你有一个空闲列表，其中所有块都是相同的
Dialogue: 0,0:31:07.72,0:31:09.70,English,,0,0,0,,It could be a lot more efficient right because
Dialogue: 0,0:31:07.72,0:31:09.70,Chinese,,0,0,0,,它可能效率更高，因为
Dialogue: 0,0:31:10.60,0:31:12.80,English,,0,0,0,,You only need like a bit vector
Dialogue: 0,0:31:10.60,0:31:12.80,Chinese,,0,0,0,,你只需要一点矢量
Dialogue: 0,0:31:13.68,0:31:17.62,English,,0,0,0,,1 bit for each potential block to tell you whether it's allocated or free
Dialogue: 0,0:31:13.68,0:31:17.62,Chinese,,0,0,0,,每个潜在块只需要 1 位就能确定它是已分配的还是空闲
Dialogue: 0,0:31:18.66,0:31:23.16,English,,0,0,0,,So it could be very efficient you wouldn't need to walk any lists or anything
Dialogue: 0,0:31:18.66,0:31:23.16,Chinese,,0,0,0,,所以这是非常高效，你不需要去遍历任何列表
Dialogue: 0,0:31:26.88,0:31:32.04,English,,0,0,0,,That's a good question and that's the kind of thing you'll be thinking about when you do your malloc lab
Dialogue: 0,0:31:26.88,0:31:32.04,Chinese,,0,0,0,,这是一个很好的问题，这是你在做 malloc 实验时会想到的事情
Dialogue: 0,0:31:34.22,0:31:38.50,English,,0,0,0,,The there's a huge design space in implementing malloc function
Dialogue: 0,0:31:34.22,0:31:38.50,Chinese,,0,0,0,,实现 malloc 功能有一个巨大的设计空间
Dialogue: 0,0:31:39.16,0:31:42.14,English,,0,0,0,,And we just explored a one tiny part of it just now
Dialogue: 0,0:31:39.16,0:31:42.14,Chinese,,0,0,0,,我们刚刚探讨了它的一小部分
Dialogue: 0,0:31:44.68,0:31:50.82,English,,0,0,0,,So with this implicit list we're going to need both the size of the block
Dialogue: 0,0:31:44.68,0:31:50.82,Chinese,,0,0,0,,因此，使用这个隐式列表，我们将需要块的大小
Dialogue: 0,0:31:50.82,0:31:53.66,English,,0,0,0,,And then its allocation status whether it's allocated or free
Dialogue: 0,0:31:50.82,0:31:53.66,Chinese,,0,0,0,,也需要它的分配状态 —— 块是已分配还是空闲的
Dialogue: 0,0:31:54.28,0:31:57.24,English,,0,0,0,,Now we could do this in 2 words right but that would be wasteful
Dialogue: 0,0:31:54.28,0:31:57.24,Chinese,,0,0,0,,现在我们可以用 2 个字来做到这一点，但那将是浪费
Dialogue: 0,0:31:58.10,0:32:02.80,English,,0,0,0,,So the standard trick is to take advantage of the fact that blocks have to be aligned
Dialogue: 0,0:31:58.10,0:32:02.80,Chinese,,0,0,0,,因此，标准技巧是利用块必须对齐的事实
Dialogue: 0,0:32:04.42,0:32:08.02,English,,0,0,0,,Okay so this is actually it's kind of a pain in the neck to always have to align these blocks
Dialogue: 0,0:32:04.42,0:32:08.02,Chinese,,0,0,0,,总是必须对齐这些块实际上是痛苦的瓶颈
Dialogue: 0,0:32:08.72,0:32:10.58,English,,0,0,0,,But we can take advantage of it in this case
Dialogue: 0,0:32:08.72,0:32:10.58,Chinese,,0,0,0,,但在这种情况下我们可以利用它
Dialogue: 0,0:32:11.84,0:32:17.32,English,,0,0,0,,And the reason is that if a block is aligned to some say 8 byte or 16 byte boundary
Dialogue: 0,0:32:11.84,0:32:17.32,Chinese,,0,0,0,,原因是如果一个块与 8 字节或 16 字节边界对齐
Dialogue: 0,0:32:17.96,0:32:20.10,English,,0,0,0,,Then the lower order bits are always going to be 0
Dialogue: 0,0:32:17.96,0:32:20.10,Chinese,,0,0,0,,然后低位总是为 0
Dialogue: 0,0:32:20.80,0:32:22.56,English,,0,0,0,,So if it's aligned to an 8 byte boundary
Dialogue: 0,0:32:20.80,0:32:22.56,Chinese,,0,0,0,,因此，如果它与 8 字节边界对齐
Dialogue: 0,0:32:23.30,0:32:27.48,English,,0,0,0,,The 3 low order bits will always be 0
Dialogue: 0,0:32:23.30,0:32:27.48,Chinese,,0,0,0,,低 3 位始终为 0
Dialogue: 0,0:32:28.08,0:32:30.78,English,,0,0,0,,Right 8 is 1000
Dialogue: 0,0:32:28.08,0:32:30.78,Chinese,,0,0,0,,8 是 1000
Dialogue: 0,0:32:31.62,0:32:34.14,English,,0,0,0,,16 (=) 10000
Dialogue: 0,0:32:31.62,0:32:34.14,Chinese,,0,0,0,,16 (=) 10000
Dialogue: 0,0:32:35.72,0:32:38.50,English,,0,0,0,,24 (=) 11000
Dialogue: 0,0:32:35.72,0:32:38.50,Chinese,,0,0,0,,24 (=) 11000
Dialogue: 0,0:32:38.64,0:32:40.58,English,,0,0,0,,Right so there any 8 byte
Dialogue: 0,0:32:38.64,0:32:40.58,Chinese,,0,0,0,,所以任何 8 字节
Dialogue: 0,0:32:42.80,0:32:50.38,English,,0,0,0,,Any 8 byte aligned block has to be size 8 and it has to start on address that's a multiple of 8 all right
Dialogue: 0,0:32:42.80,0:32:50.38,Chinese,,0,0,0,,任何 8 字节对齐的块必须是大小为 8，它的地址必须是 8 的倍数
Dialogue: 0,0:32:51.28,0:32:57.00,English,,0,0,0,,So the size of that block will always have
Dialogue: 0,0:32:51.28,0:32:57.00,Chinese,,0,0,0,,所以这些块的大小一直有
Dialogue: 0,0:32:59.20,0:33:02.96,English,,0,0,0,,3 or 4 a low-order bits set to 0
Dialogue: 0,0:32:59.20,0:33:02.96,Chinese,,0,0,0,,3 或 4 个低位设置为 0
Dialogue: 0,0:33:03.88,0:33:05.85,English,,0,0,0,,So we can take advantage of that
Dialogue: 0,0:33:03.88,0:33:05.85,Chinese,,0,0,0,,所以我们可以利用这一点
Dialogue: 0,0:33:06.42,0:33:11.84,English,,0,0,0,,And we will just have 1 header word
Dialogue: 0,0:33:06.42,0:33:11.84,Chinese,,0,0,0,,我们只需要一个字大小的头部
Dialogue: 0,0:33:13.20,0:33:17.18,English,,0,0,0,,And we'll use the lower order bit to store the allocation status
Dialogue: 0,0:33:13.20,0:33:17.18,Chinese,,0,0,0,,我们将使用低位来存储分配状态
Dialogue: 0,0:33:18.34,0:33:21.48,English,,0,0,0,,Okay and we can do that because we know it's always zero
Dialogue: 0,0:33:18.34,0:33:21.48,Chinese,,0,0,0,,好的，我们可以做到这一点，因为我们知道它始终为零
Dialogue: 0,0:33:21.96,0:33:26.92,English,,0,0,0,,So we use that low order bit to store the allocation status
Dialogue: 0,0:33:21.96,0:33:26.92,Chinese,,0,0,0,,因此，我们使用该低位来存储分配状态
Dialogue: 0,0:33:26.98,0:33:30.54,English,,0,0,0,,And then the remaining bits correspond to the size
Dialogue: 0,0:33:26.98,0:33:30.54,Chinese,,0,0,0,,然后剩余的位对应于大小
Dialogue: 0,0:33:31.24,0:33:37.22,English,,0,0,0,,And then whenever we want to extract the size we just mask out this allocation status and always set it to zero
Dialogue: 0,0:33:31.24,0:33:37.22,Chinese,,0,0,0,,然后，只要我们想要提取大小，我们就会掩饰掉这个分配状态并始终将其设置为零
Dialogue: 0,0:33:37.76,0:33:38.64,English,,0,0,0,,Because we know that it's zero
Dialogue: 0,0:33:37.76,0:33:38.64,Chinese,,0,0,0,,因为我们知道它是零
Dialogue: 0,0:33:48.88,0:33:53.76,English,,0,0,0,,So let's look in detail what given this form of implicit list
Dialogue: 0,0:33:48.88,0:33:53.76,Chinese,,0,0,0,,让我们详细了解一下这种隐式列表的形式
Dialogue: 0,0:33:54.62,0:33:56.08,English,,0,0,0,,How we might set things up
Dialogue: 0,0:33:54.62,0:33:56.08,Chinese,,0,0,0,,我们如何设置
Dialogue: 0,0:33:58.10,0:34:04.46,English,,0,0,0,,So in this case we're going to assume for byte words okay in sized words
Dialogue: 0,0:33:58.10,0:34:04.46,Chinese,,0,0,0,,因此，在这种情况下，我们将假设字节大小可以用字来表示
Dialogue: 0,0:34:05.66,0:34:07.78,English,,0,0,0,,And we're going to align on 8 byte boundaries
Dialogue: 0,0:34:05.66,0:34:07.78,Chinese,,0,0,0,,我们将在 8 字节边界上对齐
Dialogue: 0,0:34:10.46,0:34:15.56,English,,0,0,0,,Okay so remember the payload of a blocks always has to start on an 8 byte boundary
Dialogue: 0,0:34:10.46,0:34:15.56,Chinese,,0,0,0,,好的，记住块的有效负载总是必须从 8 字节边界开始
Dialogue: 0,0:34:16.58,0:34:20.68,English,,0,0,0,,So the way we do that is we create this unused word at the beginning of the heap
Dialogue: 0,0:34:16.58,0:34:20.68,Chinese,,0,0,0,,所以我们这样做的方法是在堆的开头创建这个未使用的字
Dialogue: 0,0:34:21.08,0:34:24.02,English,,0,0,0,,That's aligned on this 8 byte boundary
Dialogue: 0,0:34:21.08,0:34:24.02,Chinese,,0,0,0,,它在 8 字节边界上对齐
Dialogue: 0,0:34:25.02,0:34:33.28,English,,0,0,0,,And then the first block and the heap starts at an offset of 4 from the beginning of the heap
Dialogue: 0,0:34:25.02,0:34:33.28,Chinese,,0,0,0,,然后第一个块从堆的开头偏移 4 开始
Dialogue: 0,0:34:34.26,0:34:37.48,English,,0,0,0,,So we have the header which is is not aligned
Dialogue: 0,0:34:34.26,0:34:37.48,Chinese,,0,0,0,,所以头部没有对齐
Dialogue: 0,0:34:39.40,0:34:41.56,English,,0,0,0,,And then we have the payload which follows
Dialogue: 0,0:34:39.40,0:34:41.56,Chinese,,0,0,0,,然后接下来的部分有了有效负载荷
Dialogue: 0,0:34:42.18,0:34:46.52,English,,0,0,0,,In this case it's a payload of one word and that starts on this
Dialogue: 0,0:34:42.18,0:34:46.52,Chinese,,0,0,0,,在这种情况下，它是一个字大小的有效负载
Dialogue: 0,0:34:48.46,0:34:50.74,English,,0,0,0,,That begins on this 8 word boundary
Dialogue: 0,0:34:48.46,0:34:50.74,Chinese,,0,0,0,,它从这个 8 字大小的边界开始
Dialogue: 0,0:34:50.74,0:34:58.88,English,,0,0,0,,And then the next block and and here we're indicating a free block consisting of 8 bytes
Dialogue: 0,0:34:50.74,0:34:58.88,Chinese,,0,0,0,,然后是下一个块，一个由 8 个字节组成的空闲块
Dialogue: 0,0:35:01.50,0:35:03.64,English,,0,0,0,,And then that's followed by an allocated block
Dialogue: 0,0:35:01.50,0:35:03.64,Chinese,,0,0,0,,然后是一个已分配的块
Dialogue: 0,0:35:04.24,0:35:08.28,English,,0,0,0,,The one here of 16 bytes or 4 words
Dialogue: 0,0:35:04.24,0:35:08.28,Chinese,,0,0,0,,这里的一个是 16 字节或者说 4 个字
Dialogue: 0,0:35:11.88,0:35:18.02,English,,0,0,0,,And now the payload is only 2 words so we have to pad right all of a block
Dialogue: 0,0:35:11.88,0:35:18.02,Chinese,,0,0,0,,现在有效载荷只有 2 个字，所以我们必须填充块的所有其他部分
Dialogue: 0,0:35:18.32,0:35:21.28,English,,0,0,0,,Because we're assuming that they're aligned on 8 byte boundary
Dialogue: 0,0:35:18.32,0:35:21.28,Chinese,,0,0,0,,因为我们假设它们在 8 字节对齐
Dialogue: 0,0:35:21.74,0:35:25.40,English,,0,0,0,,All of a blocks have to be a multiple of size multiple of 8
Dialogue: 0,0:35:21.74,0:35:25.40,Chinese,,0,0,0,,所有块的大小必须是 8 的倍数
Dialogue: 0,0:35:26.38,0:35:29.56,English,,0,0,0,,Okay so here's the case of internal fragmentation where we have this extra
Dialogue: 0,0:35:26.38,0:35:29.56,Chinese,,0,0,0,,好的，所以这里是内部碎片的情况
Dialogue: 0,0:35:30.42,0:35:33.14,English,,0,0,0,,This extra block in order to maintain the alignment requirement
Dialogue: 0,0:35:30.42,0:35:33.14,Chinese,,0,0,0,,这种情况中额外的块是为了保持对齐要求
Dialogue: 0,0:35:33.76,0:35:42.16,English,,0,0,0,,So that ensures that the next block payload starts at an 8 byte aligned boundary and so on
Dialogue: 0,0:35:33.76,0:35:42.16,Chinese,,0,0,0,,这样可以确保下一个块有效负载从 8 字节对齐的边界开始，依此类推
Dialogue: 0,0:35:43.70,0:35:48.24,English,,0,0,0,,And so we can walk this heap by just following these headers masking out the allocation bits
Dialogue: 0,0:35:43.70,0:35:48.24,Chinese,,0,0,0,,因此，我们可以使用掩码，从头部中获得分配信息位，然后可以通过头部来遍历此堆
Dialogue: 0,0:35:49.50,0:35:54.00,English,,0,0,0,,And then we have this special epilogue block
Dialogue: 0,0:35:49.50,0:35:54.00,Chinese,,0,0,0,,然后我们有这个特殊的结局块
Dialogue: 0,0:35:55.00,0:35:59.62,English,,0,0,0,,Which is a zero,it's a block of with a zero sized payload
Dialogue: 0,0:35:55.00,0:35:59.62,Chinese,,0,0,0,,这是一个零，它是一个零大小的有效载荷块
Dialogue: 0,0:36:00.86,0:36:02.96,English,,0,0,0,,It's an allocated block of size 0
Dialogue: 0,0:36:00.86,0:36:02.96,Chinese,,0,0,0,,它是一个大小为 0 的已分配块
Dialogue: 0,0:36:04.26,0:36:06.44,English,,0,0,0,,And this is a trick
Dialogue: 0,0:36:04.26,0:36:06.44,Chinese,,0,0,0,,这是一个技巧
Dialogue: 0,0:36:06.84,0:36:08.38,English,,0,0,0,,This is a trick you should use to
Dialogue: 0,0:36:06.84,0:36:08.38,Chinese,,0,0,0,,这是你应该使用的技巧
Dialogue: 0,0:36:09.14,0:36:13.56,English,,0,0,0,,So this and we'll see when we look at coalescing why this helps
Dialogue: 0,0:36:09.14,0:36:13.56,Chinese,,0,0,0,,当我们考虑合并时我们会知道为什么这会有所帮助
Dialogue: 0,0:36:13.70,0:36:16.64,English,,0,0,0,,But this allocated block at the very end
Dialogue: 0,0:36:13.70,0:36:16.64,Chinese,,0,0,0,,但是这个分配的块在最后
Dialogue: 0,0:36:17.16,0:36:21.72,English,,0,0,0,,Eliminates some sort of special cases when we start to coalesce free blocks
Dialogue: 0,0:36:17.16,0:36:21.72,Chinese,,0,0,0,,当我们开始合并空闲块时，消除某种特殊情况
Dialogue: 0,0:36:22.52,0:36:25.16,English,,0,0,0,,We'll talk about that in just a just a moment
Dialogue: 0,0:36:22.52,0:36:25.16,Chinese,,0,0,0,,我们等下将讨论这个问题
Dialogue: 0,0:36:26.16,0:36:27.96,English,,0,0,0,,But you can finish your
Dialogue: 0,0:36:26.16,0:36:27.96,Chinese,,0,0,0,,但你可以完成你的搜索时
Dialogue: 0,0:36:28.64,0:36:34.22,English,,0,0,0,,This allocated block of size zero is also helpful in terminating
Dialogue: 0,0:36:28.64,0:36:34.22,Chinese,,0,0,0,,这个已分配的大小为零的块也有助于终止访问
Dialogue: 0,0:36:34.82,0:36:36.00,English,,0,0,0,,When you're walking this list
Dialogue: 0,0:36:34.82,0:36:36.00,Chinese,,0,0,0,,当你遍历这个名单时
Dialogue: 0,0:36:36.00,0:36:40.46,English,,0,0,0,,You can check for a size allocated block of size zero to terminate your search
Dialogue: 0,0:36:36.00,0:36:40.46,Chinese,,0,0,0,,你可以检查大小为零的块大小以终止搜索
Dialogue: 0,0:36:44.06,0:36:47.28,English,,0,0,0,,Okay so given this kind of structure then how do we find a free block
Dialogue: 0,0:36:44.06,0:36:47.28,Chinese,,0,0,0,,好吧，鉴于这种结构，我们如何找到一个空闲块
Dialogue: 0,0:36:48.36,0:36:50.02,English,,0,0,0,,Okay there's a number of different ways
Dialogue: 0,0:36:48.36,0:36:50.02,Chinese,,0,0,0,,好吧，有很多不同的方式
Dialogue: 0,0:36:50.74,0:36:57.98,English,,0,0,0,,The first way which is called first fit is to search the free list from the beginning
Dialogue: 0,0:36:50.74,0:36:57.98,Chinese,,0,0,0,,第一种称为 「首次适配」 的方法是从头开始搜索空闲列表
Dialogue: 0,0:36:58.38,0:37:03.04,English,,0,0,0,,And just look for the first block we can find that satisfies the request
Dialogue: 0,0:36:58.38,0:37:03.04,Chinese,,0,0,0,,只需查找我们可以找到满足请求的第一个块
Dialogue: 0,0:37:07.06,0:37:10.74,English,,0,0,0,,So we're allocating we're asking for a block of size 10
Dialogue: 0,0:37:07.06,0:37:10.74,Chinese,,0,0,0,,所以我们要分配的块大小为 10
Dialogue: 0,0:37:11.20,0:37:15.36,English,,0,0,0,,We start at the beginning of the heap and we walked a list we walk the heap
Dialogue: 0,0:37:11.20,0:37:15.36,Chinese,,0,0,0,,我们从堆的开头开始，然后我们遍历一个列表
Dialogue: 0,0:37:17.12,0:37:20.60,English,,0,0,0,,Looking for a free block that's at least size 10
Dialogue: 0,0:37:17.12,0:37:20.60,Chinese,,0,0,0,,寻找一个至少 10 字大小的空闲块
Dialogue: 0,0:37:23.08,0:37:26.88,English,,0,0,0,,And we needs to be actually it needs to be 10 plus the size of our header 2
Dialogue: 0,0:37:23.08,0:37:26.88,Chinese,,0,0,0,,而且我们需要实际上需要 10 加上头部大小 2 的总大小
Dialogue: 0,0:37:29.68,0:37:34.64,English,,0,0,0,,So that's a simple idea now
Dialogue: 0,0:37:29.68,0:37:34.64,Chinese,,0,0,0,,所以现在这是一个简单的想法
Dialogue: 0,0:37:35.12,0:37:38.10,English,,0,0,0,,Some people have proposed an alternative called next fit
Dialogue: 0,0:37:35.12,0:37:38.10,Chinese,,0,0,0,,有些人提出了一种称为 「下一次适配」 的替代品
Dialogue: 0,0:37:38.72,0:37:44.78,English,,0,0,0,,So the idea here is that instead of starting over each time from the beginning of the heap to find a block that fits
Dialogue: 0,0:37:38.72,0:37:44.78,Chinese,,0,0,0,,其的想法是，不是从堆的开头每次开始去找到适合的块
Dialogue: 0,0:37:45.62,0:37:47.90,English,,0,0,0,,We just pick up where we left off the last time
Dialogue: 0,0:37:45.62,0:37:47.90,Chinese,,0,0,0,,我们从最后一次离开的地方开始
Dialogue: 0,0:37:48.50,0:37:50.78,English,,0,0,0,,Okay so we look,we scan the heap
Dialogue: 0,0:37:48.50,0:37:50.78,Chinese,,0,0,0,,我们扫描堆
Dialogue: 0,0:37:51.72,0:37:55.08,English,,0,0,0,,And we find a block that's big enough to satisfy the request
Dialogue: 0,0:37:51.72,0:37:55.08,Chinese,,0,0,0,,我们找到一个足以满足请求的块
Dialogue: 0,0:37:55.16,0:37:57.48,English,,0,0,0,,And then we remember where we left off
Dialogue: 0,0:37:55.16,0:37:57.48,Chinese,,0,0,0,,然后我们记住我们离开的地方
Dialogue: 0,0:37:58.82,0:38:02.98,English,,0,0,0,,And the next time the request comes in we pick up the search starting where we left off
Dialogue: 0,0:37:58.82,0:38:02.98,Chinese,,0,0,0,,下次响应请求时，我们从上次离开的地方开始搜索
Dialogue: 0,0:38:04.04,0:38:08.76,English,,0,0,0,,Now this seems like would be a good idea but peer studies that people have done
Dialogue: 0,0:38:04.04,0:38:08.76,Chinese,,0,0,0,,现在这似乎是一个好主意，但人们所做的研究
Dialogue: 0,0:38:09.26,0:38:13.02,English,,0,0,0,,Have shown that this actually results in worse fragmentation
Dialogue: 0,0:38:09.26,0:38:13.02,Chinese,,0,0,0,,已经证明这实际上会导致更糟糕的碎片
Dialogue: 0,0:38:13.74,0:38:18.26,English,,0,0,0,,So you know you can consider it but it generally
Dialogue: 0,0:38:13.74,0:38:18.26,Chinese,,0,0,0,,所以你可以考虑它
Dialogue: 0,0:38:19.06,0:38:21.14,English,,0,0,0,,It's generally probably not the best thing to do
Dialogue: 0,0:38:19.06,0:38:21.14,Chinese,,0,0,0,,这通常可能不是最好的方法
Dialogue: 0,0:38:22.86,0:38:32.52,English,,0,0,0,,Now another alternative is to find a free block in the heap that's the best fit
Dialogue: 0,0:38:22.86,0:38:32.52,Chinese,,0,0,0,,现在另一种方法是在堆中找到最佳适配的块
Dialogue: 0,0:38:33.30,0:38:40.40,English,,0,0,0,,So in general look at all the blocks in the heap and find the block that fits the best
Dialogue: 0,0:38:33.30,0:38:40.40,Chinese,,0,0,0,,所以一般查看堆中的所有块，找到最佳适配的块
Dialogue: 0,0:38:41.50,0:38:43.08,English,,0,0,0,,If we ask for 10 bytes
Dialogue: 0,0:38:41.50,0:38:43.08,Chinese,,0,0,0,,如果我们要求 10 个字节
Dialogue: 0,0:38:44.58,0:38:48.40,English,,0,0,0,,Try to scan the heap for the block that has the closest to 10 bytes in it
Dialogue: 0,0:38:44.58,0:38:48.40,Chinese,,0,0,0,,尝试扫描堆中最接近 10 个字节的块
Dialogue: 0,0:38:49.34,0:38:50.52,English,,0,0,0,,Okay so that's called best fit
Dialogue: 0,0:38:49.34,0:38:50.52,Chinese,,0,0,0,,所以这被称为 「最佳适配」
Dialogue: 0,0:38:51.34,0:38:57.42,English,,0,0,0,,And best fit you can see it might be more it sounds like it would be a lot more expensive right
Dialogue: 0,0:38:51.34,0:38:57.42,Chinese,,0,0,0,,最佳适配可能看起来会带来更大的消耗
Dialogue: 0,0:38:57.74,0:39:00.54,English,,0,0,0,,Because you'd have to look instead of just looking until you find a fit
Dialogue: 0,0:38:57.74,0:39:00.54,Chinese,,0,0,0,,因为在你找到合适的东西之前，你必须一直寻找
Dialogue: 0,0:39:00.90,0:39:03.70,English,,0,0,0,,You'd have to scan all the free blocks and then pick the best one
Dialogue: 0,0:39:00.90,0:39:03.70,Chinese,,0,0,0,,你必须扫描所有空闲块，然后选择最好的区块
Dialogue: 0,0:39:04.82,0:39:08.02,English,,0,0,0,,Okay but it has a nice property that it improves memory utilization
Dialogue: 0,0:39:04.82,0:39:08.02,Chinese,,0,0,0,,但它有一个很好的属性，它提高了内存利用率
Dialogue: 0,0:39:09.48,0:39:12.72,English,,0,0,0,,Okay so this is a classic example the space time trade-off
Dialogue: 0,0:39:09.48,0:39:12.72,Chinese,,0,0,0,,这是一个典型时空权衡的例子
Dialogue: 0,0:39:13.44,0:39:18.74,English,,0,0,0,,So it's slower but it improves a use of the efficiency of the way we use memory
Dialogue: 0,0:39:13.44,0:39:18.74,Chinese,,0,0,0,,它的速度较慢，但​​它提高了我们使用内存的效率
Dialogue: 0,0:39:24.04,0:39:24.82,English,,0,0,0,,And there's
Dialogue: 0,0:39:24.04,0:39:24.82,Chinese,,0,0,0,,还有
Dialogue: 0,0:39:26.68,0:39:33.46,English,,0,0,0,,Now we mentioned an alternative way to organize the free list using multiple free lists for different size classes
Dialogue: 0,0:39:26.68,0:39:33.46,Chinese,,0,0,0,,现在我们提到了一种使用多个不同大小类的空闲列表来组织空闲列表的替代方法
Dialogue: 0,0:39:34.74,0:39:38.20,English,,0,0,0,,Now going back to that example again if we had an infinite number of size classes
Dialogue: 0,0:39:34.74,0:39:38.20,Chinese,,0,0,0,,我们回到之前的例子，如果我们有无限数量的各个大小的类
Dialogue: 0,0:39:38.22,0:39:42.16,English,,0,0,0,,One for each size that would implement best fit
Dialogue: 0,0:39:38.22,0:39:42.16,Chinese,,0,0,0,,每种类对应一种大小，它们都可以实现最佳配合适配
Dialogue: 0,0:39:42.66,0:39:47.56,English,,0,0,0,,With a constant time search we'd know exactly which free list to get the block from
Dialogue: 0,0:39:42.66,0:39:47.56,Chinese,,0,0,0,,通过一定的时间的搜索，我们可以确切地知道从哪个空闲列表中获取块
Dialogue: 0,0:39:49.58,0:39:54.02,English,,0,0,0,,The problem of course is how much memory such a organization would use
Dialogue: 0,0:39:49.58,0:39:54.02,Chinese,,0,0,0,,问题是这样一个组织会使用多少内存
Dialogue: 0,0:39:55.42,0:39:59.32,English,,0,0,0,,But the interesting thing about using multiple free lists
Dialogue: 0,0:39:55.42,0:39:59.32,Chinese,,0,0,0,,关于使用多个空闲列表有趣的点是
Dialogue: 0,0:39:59.90,0:40:06.28,English,,0,0,0,,Is that the more of these free lists you have the closer you get to it to a true best fit
Dialogue: 0,0:39:59.90,0:40:06.28,Chinese,,0,0,0,,你拥有的这些空闲列表越多，就越接近真正的最佳状态
Dialogue: 0,0:40:07.42,0:40:09.04,English,,0,0,0,,Okay so you can approach best fit
Dialogue: 0,0:40:07.42,0:40:09.04,Chinese,,0,0,0,,好的，你可以接近最佳适配
Dialogue: 0,0:40:09.70,0:40:12.22,English,,0,0,0,,And then at some point you begin to get diminishing returns
Dialogue: 0,0:40:09.70,0:40:12.22,Chinese,,0,0,0,,然后在某些时候你会开始收益递减
Dialogue: 0,0:40:12.78,0:40:18.26,English,,0,0,0,,So that's another sort of design decision is how many of these multiple free lists do you need and what
Dialogue: 0,0:40:12.78,0:40:18.26,Chinese,,0,0,0,,因此，另一种设计决策是你需要多少个空闲列表
Dialogue: 0,0:40:18.48,0:40:22.00,English,,0,0,0,,What's sort of what should be the size ranges associated with them
Dialogue: 0,0:40:18.48,0:40:22.00,Chinese,,0,0,0,,以及它们所关联的块的大小的范围是多少
Dialogue: 0,0:40:25.50,0:40:27.98,English,,0,0,0,,Okay another question now once we found a block
Dialogue: 0,0:40:25.50,0:40:27.98,Chinese,,0,0,0,,另一个问题是，一旦我们找了一个块
Dialogue: 0,0:40:28.06,0:40:30.60,English,,0,0,0,,So the application is made a call to malloc
Dialogue: 0,0:40:28.06,0:40:30.60,Chinese,,0,0,0,,应用程序调用 malloc
Dialogue: 0,0:40:32.86,0:40:36.98,English,,0,0,0,,The malloc package is look in the free list that somehow using some
Dialogue: 0,0:40:32.86,0:40:36.98,Chinese,,0,0,0,,malloc 包访问一些的空闲列表
Dialogue: 0,0:40:37.50,0:40:40.80,English,,0,0,0,,Some policy it's identified a block that
Dialogue: 0,0:40:37.50,0:40:40.80,Chinese,,0,0,0,,使用一些政策以确定了一个块
Dialogue: 0,0:40:41.08,0:40:44.34,English,,0,0,0,,In which the requested block a free block in which the requested block will fit
Dialogue: 0,0:40:41.08,0:40:44.34,Chinese,,0,0,0,,这个块是空闲的，并且适配所请求的块
Dialogue: 0,0:40:45.94,0:40:51.00,English,,0,0,0,,Okay so now what does it do, the malloc package has to allocate
Dialogue: 0,0:40:45.94,0:40:51.00,Chinese,,0,0,0,,现在它做了什么，malloc 包必须去分配
Dialogue: 0,0:40:52.48,0:40:53.64,English,,0,0,0,,It has to sort of take that
Dialogue: 0,0:40:52.48,0:40:53.64,Chinese,,0,0,0,,它必须采取这种方式
Dialogue: 0,0:40:57.14,0:41:00.82,English,,0,0,0,,So there's a question how does...it could allocate the whole block
Dialogue: 0,0:40:57.14,0:41:00.82,Chinese,,0,0,0,,但是有一个问题是它如何分配整个块
Dialogue: 0,0:41:02.28,0:41:06.98,English,,0,0,0,,And return that back to the programmer or it could choose to split out
Dialogue: 0,0:41:02.28,0:41:06.98,Chinese,,0,0,0,,然后将其返回给程序员，或者选择拆分
Dialogue: 0,0:41:07.70,0:41:11.72,English,,0,0,0,,Just only the portion of block that's needed and then create a smaller free block
Dialogue: 0,0:41:07.70,0:41:11.72,Chinese,,0,0,0,,只是块所需的一部分，然后创建一个较小的空闲块
Dialogue: 0,0:41:14.06,0:41:19.46,English,,0,0,0,,Okay so for example if we...
Dialogue: 0,0:41:14.06,0:41:19.46,Chinese,,0,0,0,,好的，例如，如果我们......
Dialogue: 0,0:41:20.54,0:41:24.98,English,,0,0,0,,If our application is has requested a block of size 4
Dialogue: 0,0:41:20.54,0:41:24.98,Chinese,,0,0,0,,如果我们的应用程序请求大小为 4 的块
Dialogue: 0,0:41:26.14,0:41:26.90,English,,0,0,0,,Or I'm sorry
Dialogue: 0,0:41:26.14,0:41:26.90,Chinese,,0,0,0,,我很抱歉
Dialogue: 0,0:41:27.64,0:41:32.87,English,,0,0,0,,If the malloc package is determined that it in order to satisfy the application request
Dialogue: 0,0:41:27.64,0:41:32.87,Chinese,,0,0,0,,如果 malloc 包确定它需要满足应用程序的请求
Dialogue: 0,0:41:32.87,0:41:34.50,English,,0,0,0,,It needs a block of size 4
Dialogue: 0,0:41:32.87,0:41:34.50,Chinese,,0,0,0,,它需要一个大小为 4 的块
Dialogue: 0,0:41:36.16,0:41:37.58,English,,0,0,0,,Okay including the header
Dialogue: 0,0:41:36.16,0:41:37.58,Chinese,,0,0,0,,包括头部
Dialogue: 0,0:41:39.28,0:41:45.28,English,,0,0,0,,Then it would try to find a free block of at least size 4
Dialogue: 0,0:41:39.28,0:41:45.28,Chinese,,0,0,0,,然后它会尝试找到大小至少为 4 的块
Dialogue: 0,0:41:45.36,0:41:50.20,English,,0,0,0,,So let's say it chooses this block for some reason
Dialogue: 0,0:41:45.36,0:41:50.20,Chinese,,0,0,0,,所以我们说它出于某种原因选择了这个块
Dialogue: 0,0:41:50.78,0:41:54.10,English,,0,0,0,,Maybe because it was a next fit picked up here
Dialogue: 0,0:41:50.78,0:41:54.10,Chinese,,0,0,0,,也许是因为这是下一次适配
Dialogue: 0,0:41:55.50,0:41:57.26,English,,0,0,0,,So this free block is actually six
Dialogue: 0,0:41:55.50,0:41:57.26,Chinese,,0,0,0,,所以这个空闲块的大小实际上是 6
Dialogue: 0,0:42:00.25,0:42:01.98,English,,0,0,0,,Contains six words
Dialogue: 0,0:42:00.25,0:42:01.98,Chinese,,0,0,0,,包含六个字
Dialogue: 0,0:42:04.38,0:42:08.00,English,,0,0,0,,So the allocator has to decide whether just to keep this block of size 6
Dialogue: 0,0:42:04.38,0:42:08.00,Chinese,,0,0,0,,所以分配器必须决定是否只保留这个大小为 6 的块
Dialogue: 0,0:42:08.06,0:42:12.02,English,,0,0,0,,And just return that back to the application
Dialogue: 0,0:42:08.06,0:42:12.02,Chinese,,0,0,0,,然后将其返回给应用程序
Dialogue: 0,0:42:12.98,0:42:18.06,English,,0,0,0,,Or whether to split that block into 2 blocks into an allocated block of size 4
Dialogue: 0,0:42:12.98,0:42:18.06,Chinese,,0,0,0,,或者是否将该块分成 2 个块，分成一个大小为 4 的已分配的块
Dialogue: 0,0:42:18.82,0:42:24.62,English,,0,0,0,,Which it then returns to the application followed by a free block of of size 2
Dialogue: 0,0:42:18.82,0:42:24.62,Chinese,,0,0,0,,然后返回到应用程序，其后面是大小为 2 的空闲块
Dialogue: 0,0:42:30.96,0:42:34.38,English,,0,0,0,,Okay now another question is how to free a block
Dialogue: 0,0:42:30.96,0:42:34.38,Chinese,,0,0,0,,现在另一个问题是如何释放一个块
Dialogue: 0,0:42:34.38,0:42:39.82,English,,0,0,0,,So the application calls free and it's asked the allocator to free up a particular block
Dialogue: 0,0:42:34.38,0:42:39.82,Chinese,,0,0,0,,应用程序调用来 free， 它要求分配器去释放一个特定的块
Dialogue: 0,0:42:41.88,0:42:43.22,English,,0,0,0,,So this is pretty simple
Dialogue: 0,0:42:41.88,0:42:43.22,Chinese,,0,0,0,,所以这很简单
Dialogue: 0,0:42:48.06,0:42:51.32,English,,0,0,0,,So if we want to free up this block you just clear the allocated flag
Dialogue: 0,0:42:48.06,0:42:51.32,Chinese,,0,0,0,,如果我们要释放此块，你只需清除已分配的标志即可
Dialogue: 0,0:42:52.92,0:42:54.94,English,,0,0,0,,So if we want to free up the block we just created
Dialogue: 0,0:42:52.92,0:42:54.94,Chinese,,0,0,0,,所以，如果我们想要释放我们刚创建的块
Dialogue: 0,0:42:55.80,0:42:58.84,English,,0,0,0,,You just set the allocated bit to zero
Dialogue: 0,0:42:55.80,0:42:58.84,Chinese,,0,0,0,,你只需将分配的位设置为零即可
Dialogue: 0,0:42:59.64,0:43:01.08,English,,0,0,0,,And you're done, it's really simple
Dialogue: 0,0:42:59.64,0:43:01.08,Chinese,,0,0,0,,你已经完成了，它非常简单
Dialogue: 0,0:43:01.76,0:43:05.68,English,,0,0,0,,But the problem now is this creates external fragmentation
Dialogue: 0,0:43:01.76,0:43:05.68,Chinese,,0,0,0,,但现在的问题是这会造成外部碎片化
Dialogue: 0,0:43:07.50,0:43:11.92,English,,0,0,0,,So here now if we just free that block of size 4
Dialogue: 0,0:43:07.50,0:43:11.92,Chinese,,0,0,0,,所以现在，如果我们只是释放大小为 4 的块
Dialogue: 0,0:43:13.06,0:43:15.04,English,,0,0,0,,What used to be a block of size 6
Dialogue: 0,0:43:13.06,0:43:15.04,Chinese,,0,0,0,,它曾经是大小为 6 的块
Dialogue: 0,0:43:16.24,0:43:21.48,English,,0,0,0,,Now consists of 2 contiguous smaller blocks one of size 4 and one of size 2
Dialogue: 0,0:43:16.24,0:43:21.48,Chinese,,0,0,0,,现在由 2 个连续的较小块组成，其中一个大小为 4，其中一个大小为 2
Dialogue: 0,0:43:24.08,0:43:27.14,English,,0,0,0,,And so now if that's followed by a request for 5 blocks
Dialogue: 0,0:43:24.08,0:43:27.14,Chinese,,0,0,0,,所以现在如果之后是5块的请求
Dialogue: 0,0:43:27.90,0:43:29.32,English,,0,0,0,,Now we're stuck right so this
Dialogue: 0,0:43:27.90,0:43:29.32,Chinese,,0,0,0,,现在我们被困住了
Dialogue: 0,0:43:30.96,0:43:33.82,English,,0,0,0,,But we've got plenty of memory and it's even worse in this case
Dialogue: 0,0:43:30.96,0:43:33.82,Chinese,,0,0,0,,但是我们有足够的内存，在这种情况下甚至更糟
Dialogue: 0,0:43:34.96,0:43:37.16,English,,0,0,0,,That memory is all contiguous just because
Dialogue: 0,0:43:34.96,0:43:37.16,Chinese,,0,0,0,,内存是完全连续的
Dialogue: 0,0:43:38.72,0:43:42.62,English,,0,0,0,,But just because we just oh we just cleared the free block
Dialogue: 0,0:43:38.72,0:43:42.62,Chinese,,0,0,0,,但仅仅因为我们只是清除了空闲块
Dialogue: 0,0:43:43.30,0:43:46.92,English,,0,0,0,,We didn't really notice that it was contiguous
Dialogue: 0,0:43:43.30,0:43:46.92,Chinese,,0,0,0,,我们并没有真正注意到它是连续的
Dialogue: 0,0:43:46.94,0:43:50.56,English,,0,0,0,,And so we ended up in with the situation where we have these two contiguous free blocks
Dialogue: 0,0:43:46.94,0:43:50.56,Chinese,,0,0,0,,因此我们最终得到了两个连续的空闲块的情况
Dialogue: 0,0:43:54.82,0:43:56.62,English,,0,0,0,,So this suggests that
Dialogue: 0,0:43:54.82,0:43:56.62,Chinese,,0,0,0,,所以这表明了
Dialogue: 0,0:43:57.32,0:43:59.10,English,,0,0,0,,When we free up blocks
Dialogue: 0,0:43:57.32,0:43:59.10,Chinese,,0,0,0,,当我们释放块时
Dialogue: 0,0:44:00.04,0:44:03.66,English,,0,0,0,,That we somehow need to coalesce any neighboring blocks
Dialogue: 0,0:44:00.04,0:44:03.66,Chinese,,0,0,0,,我们需要合并任何相邻的块
Dialogue: 0,0:44:04.28,0:44:06.74,English,,0,0,0,,To keep blocks as big as possible right so we cannot
Dialogue: 0,0:44:04.28,0:44:06.74,Chinese,,0,0,0,,尽以量保持块尽可能大
Dialogue: 0,0:44:08.00,0:44:11.62,English,,0,0,0,,One of the invariance of any decent allocator is that
Dialogue: 0,0:44:08.00,0:44:11.62,Chinese,,0,0,0,,任何优秀的分配器的不变性之一就是
Dialogue: 0,0:44:12.94,0:44:15.86,English,,0,0,0,,They're never contiguous free blocks like this
Dialogue: 0,0:44:12.94,0:44:15.86,Chinese,,0,0,0,,它们永远不会使得多个连续的空闲块存在
Dialogue: 0,0:44:16.32,0:44:19.82,English,,0,0,0,,It's always a free block followed by an allocated block
Dialogue: 0,0:44:16.32,0:44:19.82,Chinese,,0,0,0,,它始终是一个空闲块后跟一个已分配的块
Dialogue: 0,0:44:22.72,0:44:28.00,English,,0,0,0,,Okay so the idea is that if we free a particular so here we have this allocated block
Dialogue: 0,0:44:22.72,0:44:28.00,Chinese,,0,0,0,,所以我的想法是，如果我们释放一个特定的已分配的块
Dialogue: 0,0:44:29.78,0:44:34.22,English,,0,0,0,,And if we free that block and we somehow have to check
Dialogue: 0,0:44:29.78,0:44:34.22,Chinese,,0,0,0,,如果我们释放该块，我们必须检查
Dialogue: 0,0:44:34.22,0:44:38.68,English,,0,0,0,,And see if there's any adjacent free blocks either following
Dialogue: 0,0:44:34.22,0:44:38.68,Chinese,,0,0,0,,查看是否存在任何相邻的空闲块
Dialogue: 0,0:44:39.64,0:44:43.20,English,,0,0,0,,Either next in memory or previous in memory
Dialogue: 0,0:44:39.64,0:44:43.20,Chinese,,0,0,0,,这个空闲块可能是下一个内存块或前一个内存块
Dialogue: 0,0:44:44.26,0:44:48.14,English,,0,0,0,,And if there are we need to as part of the freeing process
Dialogue: 0,0:44:44.26,0:44:48.14,Chinese,,0,0,0,,作为解放过程的一部分
Dialogue: 0,0:44:48.14,0:44:54.00,English,,0,0,0,,We need to coalesce those 2 blocks into a into the largest possible block possible
Dialogue: 0,0:44:48.14,0:44:54.00,Chinese,,0,0,0,,我们需要将这两个块合并为一个尽可能最大的块
Dialogue: 0,0:44:55.24,0:45:01.36,English,,0,0,0,,Now it's pretty easy if we're asked to free this block this green block
Dialogue: 0,0:44:55.24,0:45:01.36,Chinese,,0,0,0,,如果我们被要求释放这个绿色区块
Dialogue: 0,0:45:02.78,0:45:05.80,English,,0,0,0,,It's pretty easy to check the next block because you just
Dialogue: 0,0:45:02.78,0:45:05.80,Chinese,,0,0,0,,可以很容易地检查下一个区块
Dialogue: 0,0:45:06.36,0:45:08.04,English,,0,0,0,,We have the size we have this header
Dialogue: 0,0:45:06.36,0:45:08.04,Chinese,,0,0,0,,我们有头部记录了这个块的大小
Dialogue: 0,0:45:08.94,0:45:11.66,English,,0,0,0,,So we know that the next block starts at an offset of 4
Dialogue: 0,0:45:08.94,0:45:11.66,Chinese,,0,0,0,,所以我们知道下一个块的偏移量为 4
Dialogue: 0,0:45:13.06,0:45:16.08,English,,0,0,0,,So we just check
Dialogue: 0,0:45:13.06,0:45:16.08,Chinese,,0,0,0,,所以我们只是检查
Dialogue: 0,0:45:16.84,0:45:19.72,English,,0,0,0,,And we know that the header for that block is at offset of 4
Dialogue: 0,0:45:16.84,0:45:19.72,Chinese,,0,0,0,,我们知道该块的头部位于你的偏移量 4 处
Dialogue: 0,0:45:20.20,0:45:24.10,English,,0,0,0,,So we just check the allocated status of that next block using the
Dialogue: 0,0:45:20.20,0:45:24.10,Chinese,,0,0,0,,所以我们需要检查下一个块的分配状态
Dialogue: 0,0:45:24.46,0:45:27.40,English,,0,0,0,,Using the size field in our header
Dialogue: 0,0:45:24.46,0:45:27.40,Chinese,,0,0,0,,使用头部中的 size 字段
Dialogue: 0,0:45:27.94,0:45:29.16,English,,0,0,0,,But what about the previous block
Dialogue: 0,0:45:27.94,0:45:29.16,Chinese,,0,0,0,,但是前一个块呢
Dialogue: 0,0:45:30.86,0:45:32.64,English,,0,0,0,,What about this block how do we check that
Dialogue: 0,0:45:30.86,0:45:32.64,Chinese,,0,0,0,,我们如何检测那个块
Dialogue: 0,0:45:34.86,0:45:37.40,English,,0,0,0,,Well given all that we've talked about
Dialogue: 0,0:45:34.86,0:45:37.40,Chinese,,0,0,0,,考虑到我们所谈论的所有内容
Dialogue: 0,0:45:37.40,0:45:41.14,English,,0,0,0,,Now the only thing,the only way we could do it would be to start at the beginning of the heap
Dialogue: 0,0:45:37.40,0:45:41.14,Chinese,,0,0,0,,现在唯一的事情，我们能做到的唯一方法就是从堆的开头开始
Dialogue: 0,0:45:42.22,0:45:48.98,English,,0,0,0,,And now walk the free list until we get to this current block remembering the previous block
Dialogue: 0,0:45:42.22,0:45:48.98,Chinese,,0,0,0,,遍历空闲列表，直到我们到达当前块记住前一个块
Dialogue: 0,0:45:49.35,0:45:53.54,English,,0,0,0,,So each time we traverse we remember the previous block
Dialogue: 0,0:45:49.35,0:45:53.54,Chinese,,0,0,0,,因此，每次我们遍历时，我们都会记住上一个块
Dialogue: 0,0:45:54.66,0:45:57.14,English,,0,0,0,,Okay so that would be very inefficient right
Dialogue: 0,0:45:54.66,0:45:57.14,Chinese,,0,0,0,,好的，所以这样效率非常低
Dialogue: 0,0:45:57.16,0:46:02.06,English,,0,0,0,,That would make free linear in the size of the heap
Dialogue: 0,0:45:57.16,0:46:02.06,Chinese,,0,0,0,,这会使得 free 的过程与堆的大小呈线形的关系
Dialogue: 0,0:46:02.62,0:46:07.06,English,,0,0,0,,Because we'd have to in order to check the previous block we'd have to walk starting at the very beginning
Dialogue: 0,0:46:02.62,0:46:07.06,Chinese,,0,0,0,,因为我们必须要检查前一个区块，所以我们必须从头开始遍历
Dialogue: 0,0:46:07.42,0:46:08.64,English,,0,0,0,,And walk the entire heap
Dialogue: 0,0:46:07.42,0:46:08.64,Chinese,,0,0,0,,遍历整个堆
Dialogue: 0,0:46:10.72,0:46:17.44,English,,0,0,0,,So the solution for that is was proposed by a famous computer scientist Don Knuth in 1973
Dialogue: 0,0:46:10.72,0:46:17.44,Chinese,,0,0,0,,对于这个问题的解决方案是由着名计算机科学家 Don Knuth 在 1973 年提出的
Dialogue: 0,0:46:17.96,0:46:21.12,English,,0,0,0,,It's very clever,it very simple like all really good ideas
Dialogue: 0,0:46:17.96,0:46:21.12,Chinese,,0,0,0,,它非常聪明，非常简单，就像所有非常好的想法一样
Dialogue: 0,0:46:21.76,0:46:29.24,English,,0,0,0,,It seems obvious that when you see it but it turns out to be very clever and a very useful technique
Dialogue: 0,0:46:21.76,0:46:29.24,Chinese,,0,0,0,,很明显，事实证明它非常聪明并且是一种非常有用的技术
Dialogue: 0,0:46:29.76,0:46:33.58,English,,0,0,0,,And the idea is just to replicate for each block
Dialogue: 0,0:46:29.76,0:46:33.58,Chinese,,0,0,0,,而这个想法只是
Dialogue: 0,0:46:33.62,0:46:37.96,English,,0,0,0,,Replicate the header block at the end of the block
Dialogue: 0,0:46:33.62,0:46:37.96,Chinese,,0,0,0,,将块的头部复制到块的脚部
Dialogue: 0,0:46:38.70,0:46:43.90,English,,0,0,0,,Okay so each block now contains a header and a footer identical header and footer
Dialogue: 0,0:46:38.70,0:46:43.90,Chinese,,0,0,0,,好的，所以每个块现在包含一个头部和一个相同的脚部
Dialogue: 0,0:46:45.70,0:46:49.96,English,,0,0,0,,And then this creates sort of an implicit backwards
Dialogue: 0,0:46:45.70,0:46:49.96,Chinese,,0,0,0,,然后这会产生一种隐含的回溯
Dialogue: 0,0:46:51.88,0:46:53.18,English,,0,0,0,,Backwards link that we can use
Dialogue: 0,0:46:51.88,0:46:53.18,Chinese,,0,0,0,,我们可以使用的向后链接
Dialogue: 0,0:46:55.22,0:46:58.46,English,,0,0,0,,So now given some block
Dialogue: 0,0:46:55.22,0:46:58.46,Chinese,,0,0,0,,所以现在给出一些块
Dialogue: 0,0:46:58.52,0:47:03.08,English,,0,0,0,,Given some block that we want to free
Dialogue: 0,0:46:58.52,0:47:03.08,Chinese,,0,0,0,,给出一些我们想要释放的块
Dialogue: 0,0:47:04.62,0:47:11.96,English,,0,0,0,,We knew the size of that block will just be one word previous in memory so
Dialogue: 0,0:47:04.62,0:47:11.96,Chinese,,0,0,0,,我们知道这个块的大小只是内存中的一个字
Dialogue: 0,0:47:12.86,0:47:16.78,English,,0,0,0,,So it's always a fixed offset of one word
Dialogue: 0,0:47:12.86,0:47:16.78,Chinese,,0,0,0,,它始终是一个字大小的固定偏移量
Dialogue: 0,0:47:18.64,0:47:22.60,English,,0,0,0,,So given you know given a pointer to the header of this block
Dialogue: 0,0:47:18.64,0:47:22.60,Chinese,,0,0,0,,所以给出一个指向这个块的头部的指针
Dialogue: 0,0:47:22.70,0:47:27.84,English,,0,0,0,,We can look one word back to see the size and the allocation status of the previous block
Dialogue: 0,0:47:22.70,0:47:27.84,Chinese,,0,0,0,,我们可以回过头来查看前一个块的大小和分配状态
Dialogue: 0,0:47:28.86,0:47:31.92,English,,0,0,0,,Okay so and so that allows us to do that in constant time
Dialogue: 0,0:47:28.86,0:47:31.92,Chinese,,0,0,0,,好吧，这样我们就可以在常数的时间内做到这一点
Dialogue: 0,0:47:33.30,0:47:38.98,English,,0,0,0,,And so this footer is sometimes called the boundary tag  and Knuth call that a boundary tag
Dialogue: 0,0:47:33.30,0:47:38.98,Chinese,,0,0,0,,所以这个脚部有时被称为边界标记，而 Knuth 称之为边界标记
Dialogue: 0,0:47:38.98,0:47:46.62,English,,0,0,0,,But we can call it a footer to be sort of parallel with the notion of a header
Dialogue: 0,0:47:38.98,0:47:46.62,Chinese,,0,0,0,,但我们可以把它称为脚部，与头部的概念并行
Dialogue: 0,0:47:47.26,0:47:51.88,English,,0,0,0,,But the key thing is that it's just identical has the identical size and allocation status
Dialogue: 0,0:47:47.26,0:47:51.88,Chinese,,0,0,0,,但关键是它完全相同，具有相同的大小和分配状态
Dialogue: 0,0:47:55.56,0:47:57.78,English,,0,0,0,,Question
Dialogue: 0,0:47:55.56,0:47:57.78,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:48:02.50,0:48:06.68,English,,0,0,0,,[student speaking]
Dialogue: 0,0:48:06.68,0:48:08.58,English,,0,0,0,,So the question is if we want to have a boundary tag
Dialogue: 0,0:48:06.68,0:48:08.58,Chinese,,0,0,0,,所以问题是我们是否想要一个边界标签
Dialogue: 0,0:48:08.58,0:48:12.26,English,,0,0,0,,When we allocate a block do we need to set aside space for it and the answer is yes
Dialogue: 0,0:48:08.58,0:48:12.26,Chinese,,0,0,0,,当我们分配一个块时，我们需要为它留出空间吗？答案是肯定的
Dialogue: 0,0:48:15.38,0:48:20.84,English,,0,0,0,,Most of the time I'll show you one optimization in a bit
Dialogue: 0,0:48:15.38,0:48:20.84,Chinese,,0,0,0,,我会稍微向你展示一个优化
Dialogue: 0,0:48:24.54,0:48:29.86,English,,0,0,0,,Okay so given this idea of a over the boundary tag
Dialogue: 0,0:48:24.54,0:48:29.86,Chinese,,0,0,0,,所以给出了一个跨越边界标签的想法
Dialogue: 0,0:48:34.36,0:48:38.31,English,,0,0,0,,And given that we have some allocated block that we want to free
Dialogue: 0,0:48:34.36,0:48:38.31,Chinese,,0,0,0,,这里有一些有一些我们想要释放的分配块
Dialogue: 0,0:48:39.24,0:48:40.04,English,,0,0,0,,This yellow block
Dialogue: 0,0:48:39.24,0:48:40.04,Chinese,,0,0,0,,这个黄色块
Dialogue: 0,0:48:41.18,0:48:41.74,English,,0,0,0,,Yes question
Dialogue: 0,0:48:41.18,0:48:41.74,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:48:41.74,0:48:52.24,English,,0,0,0,,[student speaking]
Dialogue: 0,0:48:52.24,0:48:57.52,English,,0,0,0,,So just to summarize the question
Dialogue: 0,0:48:52.24,0:48:57.52,Chinese,,0,0,0,,总结一下这个问题
Dialogue: 0,0:48:59.60,0:49:02.76,English,,0,0,0,,When you're looking for blocks that fit
Dialogue: 0,0:48:59.60,0:49:02.76,Chinese,,0,0,0,,当你正在寻找适合的块时
Dialogue: 0,0:49:02.76,0:49:06.64,English,,0,0,0,,You have to include the the size of the header and the boundary tag
Dialogue: 0,0:49:02.76,0:49:06.64,Chinese,,0,0,0,,你必须包括头部的大小和边界标记
Dialogue: 0,0:49:06.64,0:49:11.34,English,,0,0,0,,[student speaking]
Dialogue: 0,0:49:11.34,0:49:17.60,English,,0,0,0,,Then you'd have to insert padding to get a total block size
Dialogue: 0,0:49:11.34,0:49:17.60,Chinese,,0,0,0,,那么你需要插入填充以获得总块的大小
Dialogue: 0,0:49:17.72,0:49:22.44,English,,0,0,0,,That's a multiple that satisfies your alignment requirement
Dialogue: 0,0:49:17.72,0:49:22.44,Chinese,,0,0,0,,这是满足你的字节对齐的要求
Dialogue: 0,0:49:24.04,0:49:24.78,English,,0,0,0,,Sorry
Dialogue: 0,0:49:24.04,0:49:24.78,Chinese,,0,0,0,,抱歉
Dialogue: 0,0:49:28.26,0:49:30.08,English,,0,0,0,,Yeah I mean it can yeah
Dialogue: 0,0:49:28.26,0:49:30.08,Chinese,,0,0,0,,是的我的意思是它可以
Dialogue: 0,0:49:30.74,0:49:36.80,English,,0,0,0,,The question is wouldn't I use a lot of memory and it can again it depends on the requests
Dialogue: 0,0:49:30.74,0:49:36.80,Chinese,,0,0,0,,问题是这是否会使用大量内存，它可以取决于请求
Dialogue: 0,0:49:37.70,0:49:41.60,English,,0,0,0,,The request pattern if the application is requesting lots of small payloads then
Dialogue: 0,0:49:37.70,0:49:41.60,Chinese,,0,0,0,,请求模式，如果应用程序正在请求大量的小有效负载
Dialogue: 0,0:49:42.38,0:49:44.20,English,,0,0,0,,Then it's going to waste a lot of memory
Dialogue: 0,0:49:42.38,0:49:44.20,Chinese,,0,0,0,,然后它会浪费大量的内存
Dialogue: 0,0:49:44.50,0:49:47.40,English,,0,0,0,,If it's requesting big payloads not so bad
Dialogue: 0,0:49:44.50,0:49:47.40,Chinese,,0,0,0,,如果它要求大的有效载荷不是那么糟糕
Dialogue: 0,0:49:52.44,0:49:55.34,English,,0,0,0,,Okay so given that we have some block that we want to free
Dialogue: 0,0:49:52.44,0:49:55.34,Chinese,,0,0,0,,我们有一些我们想要释放的块
Dialogue: 0,0:49:55.88,0:49:59.94,English,,0,0,0,,There's 4 cases that we need to consider when coalescing
Dialogue: 0,0:49:55.88,0:49:59.94,Chinese,,0,0,0,,合并时我们需要考虑 4 种情况
Dialogue: 0,0:50:00.86,0:50:05.86,English,,0,0,0,,The case where the next block is allocated and the previous block is free is allocated
Dialogue: 0,0:50:00.86,0:50:05.86,Chinese,,0,0,0,,下一个块被分配，前一个块也被分配的情况
Dialogue: 0,0:50:08.66,0:50:11.84,English,,0,0,0,,A case where the next block is free and the previous block is allocated
Dialogue: 0,0:50:08.66,0:50:11.84,Chinese,,0,0,0,,下一个块空闲且前一个块被分配的情况
Dialogue: 0,0:50:13.26,0:50:15.26,English,,0,0,0,,A case where the previous block is free
Dialogue: 0,0:50:13.26,0:50:15.26,Chinese,,0,0,0,,前一个块是空闲
Dialogue: 0,0:50:15.28,0:50:19.76,English,,0,0,0,,And the next block is allocated in the case where both the previous and next block are free
Dialogue: 0,0:50:15.28,0:50:19.76,Chinese,,0,0,0,,但后一个块被分配了，前后两个块都是空闲的情况
Dialogue: 0,0:50:22.56,0:50:25.54,English,,0,0,0,,Okay so in case one where we have an allocated block
Dialogue: 0,0:50:22.56,0:50:25.54,Chinese,,0,0,0,,在情况一中，我们有一个想要被释放的被分配的块
Dialogue: 0,0:50:26.70,0:50:29.86,English,,0,0,0,,That we want to free surrounded by two allocated blocks
Dialogue: 0,0:50:26.70,0:50:29.86,Chinese,,0,0,0,,它被两个被分配的块包围
Dialogue: 0,0:50:30.68,0:50:33.32,English,,0,0,0,,We don't do anything right because we only call us free memory
Dialogue: 0,0:50:30.68,0:50:33.32,Chinese,,0,0,0,,我们没有做任何事情，因为我们只需要调用 free
Dialogue: 0,0:50:35.34,0:50:41.46,English,,0,0,0,,So so in this case we just set keep the size of the header and footer stays the same
Dialogue: 0,0:50:35.34,0:50:41.46,Chinese,,0,0,0,,所以在这种情况下我们只是保持页眉和页脚的大小保持不变
Dialogue: 0,0:50:41.48,0:50:45.64,English,,0,0,0,,And we just set the allocation status to shift free
Dialogue: 0,0:50:41.48,0:50:45.64,Chinese,,0,0,0,,我们只是将分配状态设置为空闲
Dialogue: 0,0:50:49.84,0:50:55.16,English,,0,0,0,,Now if the next block is free and the previous block is allocated
Dialogue: 0,0:50:49.84,0:50:55.16,Chinese,,0,0,0,,如果下一个块是空闲的，而分配前一个块
Dialogue: 0,0:50:56.58,0:51:01.76,English,,0,0,0,,What we do is we check the boundary tag of the previous block
Dialogue: 0,0:50:56.58,0:51:01.76,Chinese,,0,0,0,,我们要做的是检查前一个块的边界标记
Dialogue: 0,0:51:01.76,0:51:04.26,English,,0,0,0,,And we see that it's allocated so there's nothing to do there
Dialogue: 0,0:51:01.76,0:51:04.26,Chinese,,0,0,0,,我们看到它被分配，所以没有什么可做的
Dialogue: 0,0:51:06.12,0:51:09.72,English,,0,0,0,,We use the size to check the allocation status of the next block
Dialogue: 0,0:51:06.12,0:51:09.72,Chinese,,0,0,0,,我们使用大小来检查下一个块的分配状态
Dialogue: 0,0:51:10.72,0:51:13.70,English,,0,0,0,,We use n to jump to the header of the next block
Dialogue: 0,0:51:10.72,0:51:13.70,Chinese,,0,0,0,,我们使用 n 跳转到下一个块的头部
Dialogue: 0,0:51:14.62,0:51:17.84,English,,0,0,0,,We see that it's allocations status is free
Dialogue: 0,0:51:14.62,0:51:17.84,Chinese,,0,0,0,,我们看到它的分配状态是空闲的
Dialogue: 0,0:51:18.86,0:51:21.28,English,,0,0,0,,So these two blocks need to be coalesced
Dialogue: 0,0:51:18.86,0:51:21.28,Chinese,,0,0,0,,所以这两个块需要合并
Dialogue: 0,0:51:23.06,0:51:30.08,English,,0,0,0,,So we do that by just adding the two sizes together to create this larger coalesce block
Dialogue: 0,0:51:23.06,0:51:30.08,Chinese,,0,0,0,,所以我们只需将两个大小相加就可以创建更大的合并块
Dialogue: 0,0:51:30.12,0:51:32.68,English,,0,0,0,,And setting its allocation status to zero
Dialogue: 0,0:51:30.12,0:51:32.68,Chinese,,0,0,0,,并将其分配状态设置为零
Dialogue: 0,0:51:35.30,0:51:38.56,English,,0,0,0,,Now in the case where the previous block is free
Dialogue: 0,0:51:35.30,0:51:38.56,Chinese,,0,0,0,,现在，前一个块是空闲的
Dialogue: 0,0:51:39.82,0:51:45.26,English,,0,0,0,,Again we check the boundary tech footer when we see that it's we see it it's free
Dialogue: 0,0:51:39.82,0:51:45.26,Chinese,,0,0,0,,当我们看到它是空闲的时候，我们再次检查脚部
Dialogue: 0,0:51:46.66,0:51:49.34,English,,0,0,0,,So in this case we create
Dialogue: 0,0:51:46.66,0:51:49.34,Chinese,,0,0,0,,所以在这种情况下
Dialogue: 0,0:51:50.64,0:51:52.02,English,,0,0,0,,We have to update the size
Dialogue: 0,0:51:50.64,0:51:52.02,Chinese,,0,0,0,,我们必须更新大小
Dialogue: 0,0:51:53.56,0:51:59.78,English,,0,0,0,,The header of the old previous block to create this now new larger coalesce block
Dialogue: 0,0:51:53.56,0:51:59.78,Chinese,,0,0,0,,旧的前一个块的头部创建了这个新的更大的合并块
Dialogue: 0,0:52:00.16,0:52:03.84,English,,0,0,0,,And we update the header and the boundary check footer accordingly
Dialogue: 0,0:52:00.16,0:52:03.84,Chinese,,0,0,0,,我们相应地更新头部和边界脚步
Dialogue: 0,0:52:07.18,0:52:09.78,English,,0,0,0,,And then in the case where both the previous
Dialogue: 0,0:52:07.18,0:52:09.78,Chinese,,0,0,0,,然后在这种情况下
Dialogue: 0,0:52:10.48,0:52:12.42,English,,0,0,0,,And the next block are free
Dialogue: 0,0:52:10.48,0:52:12.42,Chinese,,0,0,0,,前一个和后一个块都是空闲的
Dialogue: 0,0:52:16.08,0:52:17.30,English,,0,0,0,,We create a single block
Dialogue: 0,0:52:16.08,0:52:17.30,Chinese,,0,0,0,,我们创建一个块
Dialogue: 0,0:52:20.84,0:52:24.10,English,,0,0,0,,A single block that's the sum of all 3 of those sizes
Dialogue: 0,0:52:20.84,0:52:24.10,Chinese,,0,0,0,,这个单个块是3个大小的总和
Dialogue: 0,0:52:27.92,0:52:29.54,English,,0,0,0,,Okay so is that ,is that clear to everybody?
Dialogue: 0,0:52:27.92,0:52:29.54,Chinese,,0,0,0,,好的，那对每个人都清楚吗？
Dialogue: 0,0:52:36.54,0:52:38.78,English,,0,0,0,,Now as you pointed out correctly pointed out that
Dialogue: 0,0:52:36.54,0:52:38.78,Chinese,,0,0,0,,正如正确地指出的
Dialogue: 0,0:52:39.32,0:52:42.36,English,,0,0,0,,Boundary tags can create additional internal fragmentation
Dialogue: 0,0:52:39.32,0:52:42.36,Chinese,,0,0,0,,边界标记可以造成额外的内部碎片
Dialogue: 0,0:52:42.72,0:52:45.88,English,,0,0,0,,Because they're not part of payload so by definition
Dialogue: 0,0:52:42.72,0:52:45.88,Chinese,,0,0,0,,因为根据定义它们不是有效载荷的一部分
Dialogue: 0,0:52:46.50,0:52:47.50,English,,0,0,0,,They're overhead
Dialogue: 0,0:52:46.50,0:52:47.50,Chinese,,0,0,0,,它们是开销
Dialogue: 0,0:52:48.84,0:52:55.24,English,,0,0,0,,And so you might ask yourself are there any cases where
Dialogue: 0,0:52:48.84,0:52:55.24,Chinese,,0,0,0,,所以你可能会问自己
Dialogue: 0,0:52:56.94,0:52:58.38,English,,0,0,0,,You don't need a boundary tag
Dialogue: 0,0:52:56.94,0:52:58.38,Chinese,,0,0,0,,是否有某一种情况不需要边界标记
Dialogue: 0,0:53:06.78,0:53:08.42,English,,0,0,0,,So which blocks need
Dialogue: 0,0:53:06.78,0:53:08.42,Chinese,,0,0,0,,那么哪些块需要
Dialogue: 0,0:53:10.64,0:53:12.40,English,,0,0,0,,Which blocks need a boundary tag
Dialogue: 0,0:53:10.64,0:53:12.40,Chinese,,0,0,0,,哪些块需要边界标记
Dialogue: 0,0:53:29.50,0:53:31.56,English,,0,0,0,,Could you get away with does an allocated block need one?
Dialogue: 0,0:53:29.50,0:53:31.56,Chinese,,0,0,0,,分配的块不需要吗？
Dialogue: 0,0:53:37.36,0:53:47.72,English,,0,0,0,,[student speaking]
Dialogue: 0,0:53:47.82,0:53:52.56,English,,0,0,0,,Yeah if you don't need to coalesce
Dialogue: 0,0:53:47.82,0:53:52.56,Chinese,,0,0,0,,是的，如果你不需要合并
Dialogue: 0,0:53:54.08,0:53:57.62,English,,0,0,0,,And you don't need to that footer and what kind of blocks don't you coalesce
Dialogue: 0,0:53:54.08,0:53:57.62,Chinese,,0,0,0,,而且你不需要那个脚部，什么块不需要合并呢？
Dialogue: 0,0:54:00.06,0:54:01.00,English,,0,0,0,,Allocated blocks
Dialogue: 0,0:54:00.06,0:54:01.00,Chinese,,0,0,0,,已分配的块
Dialogue: 0,0:54:05.40,0:54:06.14,English,,0,0,0,,So what
Dialogue: 0,0:54:05.40,0:54:06.14,Chinese,,0,0,0,,所以呢
Dialogue: 0,0:54:09.18,0:54:14.76,English,,0,0,0,,So maybe we don't need those at those boundary tech footers on allocated blocks
Dialogue: 0,0:54:09.18,0:54:14.76,Chinese,,0,0,0,,所以也许在那些已分配的快上我们不需要边界标记技术
Dialogue: 0,0:54:15.30,0:54:16.48,English,,0,0,0,,Right just on free blocks
Dialogue: 0,0:54:15.30,0:54:16.48,Chinese,,0,0,0,,只在空闲块上需要
Dialogue: 0,0:54:18.40,0:54:23.10,English,,0,0,0,,But then how are we going to determine that the previous block is allocated or free
Dialogue: 0,0:54:18.40,0:54:23.10,Chinese,,0,0,0,,但那么我们如何确定前一个块是已分配还是空闲的
Dialogue: 0,0:54:24.38,0:54:28.08,English,,0,0,0,,If an allocated block doesn't have a boundary tag footer
Dialogue: 0,0:54:24.38,0:54:28.08,Chinese,,0,0,0,,如果已分配的块没有边界标记页脚脚部
Dialogue: 0,0:54:30.22,0:54:30.54,English,,0,0,0,,Yes
Dialogue: 0,0:54:30.22,0:54:30.54,Chinese,,0,0,0,,是
Dialogue: 0,0:54:30.54,0:54:36.60,English,,0,0,0,,[student speaking]
Dialogue: 0,0:54:36.60,0:54:38.64,English,,0,0,0,,Well yeah you would give it one when you free it
Dialogue: 0,0:54:36.60,0:54:38.64,Chinese,,0,0,0,,是的，当你释放它时，你会给它一个
Dialogue: 0,0:54:39.44,0:54:43.32,English,,0,0,0,,But somehow when we're doing coalescing we need to check somehow that previous block
Dialogue: 0,0:54:39.44,0:54:43.32,Chinese,,0,0,0,,但当我们进行合并时，我们需要以某种方式检查前一个块
Dialogue: 0,0:54:44.00,0:54:46.08,English,,0,0,0,,Whether it's allocated or free okay
Dialogue: 0,0:54:44.00,0:54:46.08,Chinese,,0,0,0,,无论是分配还是空闲的
Dialogue: 0,0:54:50.10,0:54:52.66,English,,0,0,0,,But how does it know it's whether it's a boundary tag
Dialogue: 0,0:54:50.10,0:54:52.66,Chinese,,0,0,0,,但它是如何知道它是否是边界标签
Dialogue: 0,0:54:55.66,0:54:58.66,English,,0,0,0,,Or not sure no that's okay
Dialogue: 0,0:54:55.66,0:54:58.66,Chinese,,0,0,0,,或者不确定。没关系
Dialogue: 0,0:54:59.28,0:55:06.14,English,,0,0,0,,Okay yes
Dialogue: 0,0:54:59.28,0:55:06.14,Chinese,,0,0,0,,好的，是的
Dialogue: 0,0:55:06.20,0:55:11.22,English,,0,0,0,,Bingo you got it.So remember this remember because of our alignment
Dialogue: 0,0:55:06.20,0:55:11.22,Chinese,,0,0,0,,对了，你懂了。所以记住这一点，因为字节对齐
Dialogue: 0,0:55:13.06,0:55:18.44,English,,0,0,0,,We've got multiple at least three bits in three or four bits that are always zero
Dialogue: 0,0:55:13.06,0:55:18.44,Chinese,,0,0,0,,至少有三位或者四位总是 0
Dialogue: 0,0:55:19.96,0:55:21.08,English,,0,0,0,,We're only using one of them
Dialogue: 0,0:55:19.96,0:55:21.08,Chinese,,0,0,0,,我们只使用其中一个
Dialogue: 0,0:55:22.32,0:55:26.96,English,,0,0,0,,So why not use another one to contain the allocation status of the previous block
Dialogue: 0,0:55:22.32,0:55:26.96,Chinese,,0,0,0,,那么为什么不使用另一个来包含前一个块的分配状态
Dialogue: 0,0:55:28.50,0:55:32.02,English,,0,0,0,,Okay so very good that was
Dialogue: 0,0:55:28.50,0:55:32.02,Chinese,,0,0,0,,好的，非常好
Dialogue: 0,0:55:39.72,0:55:40.72,English,,0,0,0,,It's so the idea
Dialogue: 0,0:55:39.72,0:55:40.72,Chinese,,0,0,0,,这是个主意
Dialogue: 0,0:55:45.08,0:55:46.70,English,,0,0,0,,So here's the block that we want to free
Dialogue: 0,0:55:45.08,0:55:46.70,Chinese,,0,0,0,,所以这是我们想要释放的块
Dialogue: 0,0:55:48.00,0:55:48.96,English,,0,0,0,,And here's its header
Dialogue: 0,0:55:48.00,0:55:48.96,Chinese,,0,0,0,,这是它的头部
Dialogue: 0,0:55:51.34,0:55:53.92,English,,0,0,0,,And we pass the p to it and we want to free it
Dialogue: 0,0:55:51.34,0:55:53.92,Chinese,,0,0,0,,我们将 p 传递给它，我们想要释放它
Dialogue: 0,0:55:54.68,0:55:57.42,English,,0,0,0,,And we've got one bit we know that
Dialogue: 0,0:55:54.68,0:55:57.42,Chinese,,0,0,0,,而且我们知道
Dialogue: 0,0:55:58.72,0:56:00.78,English,,0,0,0,,If we have a 8 byte alignment
Dialogue: 0,0:55:58.72,0:56:00.78,Chinese,,0,0,0,,如果我们有 8 字节对齐
Dialogue: 0,0:56:01.56,0:56:03.54,English,,0,0,0,,We know that these are all implicitly zero
Dialogue: 0,0:56:01.56,0:56:03.54,Chinese,,0,0,0,,我们知道这些都隐含为零
Dialogue: 0,0:56:04.82,0:56:11.82,English,,0,0,0,,So we're using this is a allocated block that we want to free so it has an allocation status of 1
Dialogue: 0,0:56:04.82,0:56:11.82,Chinese,,0,0,0,,这是一个我们想要释放的已分配块，因此它的分配状态为 1
Dialogue: 0,0:56:14.98,0:56:18.72,English,,0,0,0,,And let's use one of these spare bits
Dialogue: 0,0:56:14.98,0:56:18.72,Chinese,,0,0,0,,让我们使用其中另一个位
Dialogue: 0,0:56:19.92,0:56:22.96,English,,0,0,0,,To indicate the allocation status of the previous block
Dialogue: 0,0:56:19.92,0:56:22.96,Chinese,,0,0,0,,指示前一个块的分配状态
Dialogue: 0,0:56:24.72,0:56:25.60,English,,0,0,0,,Okay so far
Dialogue: 0,0:56:24.72,0:56:25.60,Chinese,,0,0,0,,好的，到目前为止
Dialogue: 0,0:56:28.04,0:56:32.26,English,,0,0,0,,If the previous block is allocated
Dialogue: 0,0:56:28.04,0:56:32.26,Chinese,,0,0,0,,如果分配了前一个块
Dialogue: 0,0:56:34.36,0:56:35.44,English,,0,0,0,,And this would be a 1
Dialogue: 0,0:56:34.36,0:56:35.44,Chinese,,0,0,0,,这将是 1
Dialogue: 0,0:56:37.54,0:56:40.20,English,,0,0,0,,And when we're checking to see whether we need to coalesce
Dialogue: 0,0:56:37.54,0:56:40.20,Chinese,,0,0,0,,当我们检查是否需要合并时
Dialogue: 0,0:56:40.70,0:56:43.14,English,,0,0,0,,We just check that we just check that
Dialogue: 0,0:56:40.70,0:56:43.14,Chinese,,0,0,0,,我们只是检查一下
Dialogue: 0,0:56:43.86,0:56:47.40,English,,0,0,0,,That that's 2nd allocated bit the allocated bit of the previous block
Dialogue: 0,0:56:43.86,0:56:47.40,Chinese,,0,0,0,,第二个分配位，它表示前一个块的分配位
Dialogue: 0,0:56:48.48,0:56:51.78,English,,0,0,0,,And if it's 1 we don't need to know what its size is
Dialogue: 0,0:56:48.48,0:56:51.78,Chinese,,0,0,0,,如果它是 1，我们不需要知道它的大小
Dialogue: 0,0:56:52.42,0:56:55.28,English,,0,0,0,,Okay we don't need to know where that block is because we're not going to coalesce it
Dialogue: 0,0:56:52.42,0:56:55.28,Chinese,,0,0,0,,我们不需要知道那个块在哪里，因为我们不打算合并它
Dialogue: 0,0:56:56.42,0:56:58.42,English,,0,0,0,,Okay so in that we don't need
Dialogue: 0,0:56:56.42,0:56:58.42,Chinese,,0,0,0,,好的，我们不需要
Dialogue: 0,0:56:59.08,0:57:02.82,English,,0,0,0,,So here we don't need a boundary tag for an allocated block
Dialogue: 0,0:56:59.08,0:57:02.82,Chinese,,0,0,0,,所以在已分配的块中我们不需要边界标记
Dialogue: 0,0:57:04.32,0:57:07.76,English,,0,0,0,,But now if that block is free
Dialogue: 0,0:57:04.32,0:57:07.76,Chinese,,0,0,0,,但现在，如果该块是空闲的
Dialogue: 0,0:57:09.78,0:57:10.92,English,,0,0,0,,It'll have a boundary tag
Dialogue: 0,0:57:09.78,0:57:10.92,Chinese,,0,0,0,,它将有一个边界标记
Dialogue: 0,0:57:13.58,0:57:15.58,English,,0,0,0,,So we'll check if that block is free
Dialogue: 0,0:57:13.58,0:57:15.58,Chinese,,0,0,0,,所以我们将检查该块是否是空闲的
Dialogue: 0,0:57:18.06,0:57:24.62,English,,0,0,0,,Then the allocation status will indicate free
Dialogue: 0,0:57:18.06,0:57:24.62,Chinese,,0,0,0,,然后分配状态将表示空闲
Dialogue: 0,0:57:25.50,0:57:28.06,English,,0,0,0,,And then we know we need to, we need to coalesce
Dialogue: 0,0:57:25.50,0:57:28.06,Chinese,,0,0,0,,然后我们知道我们需要，我们需要合并
Dialogue: 0,0:57:28.92,0:57:29.78,English,,0,0,0,,And we're going to need
Dialogue: 0,0:57:28.92,0:57:29.78,Chinese,,0,0,0,,而我们将需要
Dialogue: 0,0:57:31.66,0:57:36.24,English,,0,0,0,,We're going to need a boundary tag, because we need to know where that block starts we need to know its size
Dialogue: 0,0:57:31.66,0:57:36.24,Chinese,,0,0,0,,我们需要一个边界标记，因为我们需要知道该块开始的位置，我们需要知道它的大小
Dialogue: 0,0:57:37.16,0:57:39.76,English,,0,0,0,,So that we can go back and
Dialogue: 0,0:57:37.16,0:57:39.76,Chinese,,0,0,0,,这样我们就可以回去了
Dialogue: 0,0:57:40.22,0:57:45.88,English,,0,0,0,,And update this size to include the you know the total coalesce size of those two blocks
Dialogue: 0,0:57:40.22,0:57:45.88,Chinese,,0,0,0,,并更新此大小为两个块的总合并大小
Dialogue: 0,0:57:48.88,0:57:51.90,English,,0,0,0,,So is that clear yes
Dialogue: 0,0:57:48.88,0:57:51.90,Chinese,,0,0,0,,清楚吗
Dialogue: 0,0:57:55.54,0:57:58.24,English,,0,0,0,,Oh it's just the allocated bit so
Dialogue: 0,0:57:55.54,0:57:58.24,Chinese,,0,0,0,,哦，它只是分配的位
Dialogue: 0,0:57:58.66,0:58:01.16,English,,0,0,0,,Zero means not allocated one means allocated
Dialogue: 0,0:57:58.66,0:58:01.16,Chinese,,0,0,0,,0 意味着没有分配，1 表示已分配
Dialogue: 0,0:58:01.28,0:58:09.80,English,,0,0,0,,[student speaking]
Dialogue: 0,0:58:09.80,0:58:13.22,English,,0,0,0,,Oh why are those bits that are why are the bits always zero why
Dialogue: 0,0:58:09.80,0:58:13.22,Chinese,,0,0,0,,哦，为什么这些位为什么位总是为零
Dialogue: 0,0:58:14.38,0:58:19.66,English,,0,0,0,,Okay so blocks have to be aligned to 8 byte boundaries
Dialogue: 0,0:58:14.38,0:58:19.66,Chinese,,0,0,0,,好的，所以块必须与 8 字节边界对齐
Dialogue: 0,0:58:20.60,0:58:23.44,English,,0,0,0,,Okay payloads have to be aligned to 8 byte boundaries
Dialogue: 0,0:58:20.60,0:58:23.44,Chinese,,0,0,0,,有效载荷必须与 8 字节边界对齐
Dialogue: 0,0:58:24.72,0:58:31.74,English,,0,0,0,,Okay that means that blocks have to be the size of blocks has to be a multiple of 8
Dialogue: 0,0:58:24.72,0:58:31.74,Chinese,,0,0,0,,这意味着块的大小必须是 8 的倍数
Dialogue: 0,0:58:33.20,0:58:37.08,English,,0,0,0,,Because it's the same thing as when we were doing padding alignment instructs
Dialogue: 0,0:58:33.20,0:58:37.08,Chinese,,0,0,0,,因为它与我们进行填充对齐指示时的情况相同
Dialogue: 0,0:58:37.82,0:58:42.40,English,,0,0,0,,The next each block has to be a size has to be a multiple of eight
Dialogue: 0,0:58:37.82,0:58:42.40,Chinese,,0,0,0,,每个块的大小必须是八的倍数
Dialogue: 0,0:58:42.80,0:58:48.08,English,,0,0,0,,So that the block that follows that in memory is aligned properly
Dialogue: 0,0:58:42.80,0:58:48.08,Chinese,,0,0,0,,这样在内存中的块就可以正确对齐
Dialogue: 0,0:58:48.24,0:58:51.42,English,,0,0,0,,Okay so you're guaranteed because of the alignment requirement
Dialogue: 0,0:58:48.24,0:58:51.42,Chinese,,0,0,0,,因为你需要保证字节对齐
Dialogue: 0,0:58:51.42,0:58:58.74,English,,0,0,0,,You're guaranteed that of 8 or 16, you're guaranteed that the size of the blocks are always multiples of either 8 or 16
Dialogue: 0,0:58:51.42,0:58:58.74,Chinese,,0,0,0,,你需要保证块的大小总是 8 或 16 的倍数
Dialogue: 0,0:58:59.90,0:59:05.28,English,,0,0,0,,So that because that size is always a multiple of 8 or 16
Dialogue: 0,0:58:59.90,0:59:05.28,Chinese,,0,0,0,,因此，因为该大小始终是 8 或 16 的倍数
Dialogue: 0,0:59:05.76,0:59:12.52,English,,0,0,0,,You're guaranteed that either 3 or 4 bits are all zeros
Dialogue: 0,0:59:05.76,0:59:12.52,Chinese,,0,0,0,,你可以保证 3 位或 4 位都是零
Dialogue: 0,0:59:17.22,0:59:18.14,English,,0,0,0,,Okay
Dialogue: 0,0:59:17.22,0:59:18.14,Chinese,,0,0,0,,好的
Dialogue: 0,0:59:23.18,0:59:24.10,English,,0,0,0,,Any other questions
Dialogue: 0,0:59:23.18,0:59:24.10,Chinese,,0,0,0,,还有其他问题吗
Dialogue: 0,0:59:32.50,0:59:35.22,English,,0,0,0,,Okay let me summarize then some key policies
Dialogue: 0,0:59:32.50,0:59:35.22,Chinese,,0,0,0,,好吧，让我总结一些关键策略
Dialogue: 0,0:59:37.48,0:59:39.28,English,,0,0,0,,When implementing an allocator
Dialogue: 0,0:59:37.48,0:59:39.28,Chinese,,0,0,0,,实现分配器时
Dialogue: 0,0:59:39.56,0:59:44.66,English,,0,0,0,,And I mentioned that there's the design spaces for these things is really large and really interesting
Dialogue: 0,0:59:39.56,0:59:44.66,Chinese,,0,0,0,,我提到这些东西的设计空间非常大而且非常有趣
Dialogue: 0,0:59:45.36,0:59:50.72,English,,0,0,0,,There's a lot of things that you a lot of decisions that you have to make about various policies
Dialogue: 0,0:59:45.36,0:59:50.72,Chinese,,0,0,0,,你需要做出很多关于各种策略的决定
Dialogue: 0,0:59:51.64,0:59:53.82,English,,0,0,0,,So the first is the placement policy where
Dialogue: 0,0:59:51.64,0:59:53.82,Chinese,,0,0,0,,首先是「放置策略」
Dialogue: 0,0:59:54.70,0:59:59.12,English,,0,0,0,,When we're trying to find,when we're trying to place a free block
Dialogue: 0,0:59:54.70,0:59:59.12,Chinese,,0,0,0,,当我们试图找到，当我们试图放置一个空闲块时
Dialogue: 0,1:00:00.12,1:00:01.02,English,,0,0,0,,I mean and out
Dialogue: 0,1:00:00.12,1:00:01.02,Chinese,,0,0,0,,我的意思是
Dialogue: 0,1:00:01.60,1:00:05.72,English,,0,0,0,,When we're trying to place an allocated block somewhere in a free block somewhere in the list
Dialogue: 0,1:00:01.60,1:00:05.72,Chinese,,0,0,0,,当我们尝试将已分配的块放在列表中某个空闲块中的位置时
Dialogue: 0,1:00:06.34,1:00:10.08,English,,0,0,0,,What policy do we use first fit next fit or best fit
Dialogue: 0,1:00:06.34,1:00:10.08,Chinese,,0,0,0,,我们使用的策略有 「首次适配」、「下一次适配」以及「最佳适配」
Dialogue: 0,1:00:11.24,1:00:16.62,English,,0,0,0,,And generally these things they trade-off throughput for fragmentation
Dialogue: 0,1:00:11.24,1:00:16.62,Chinese,,0,0,0,,通常这些东西权衡碎片的吞吐量
Dialogue: 0,1:00:17.54,1:00:23.18,English,,0,0,0,,All right so the faster versions like
Dialogue: 0,1:00:17.54,1:00:23.18,Chinese,,0,0,0,,所以更快的版本
Dialogue: 0,1:00:27.68,1:00:32.06,English,,0,0,0,,If you're willing to deal with lower throughput like in the case of best fit
Dialogue: 0,1:00:27.68,1:00:32.06,Chinese,,0,0,0,,如果你愿意像最佳适配的情况那样处理较低的吞吐量
Dialogue: 0,1:00:33.42,1:00:35.28,English,,0,0,0,,Then you can get better memory utilization
Dialogue: 0,1:00:33.42,1:00:35.28,Chinese,,0,0,0,,然后你可以获得更好的内存利用率
Dialogue: 0,1:00:38.46,1:00:43.94,English,,0,0,0,,Now there are interesting ways to improve the performance of best fit
Dialogue: 0,1:00:38.46,1:00:43.94,Chinese,,0,0,0,,有一些有趣的方法可以提高最佳适配的性能
Dialogue: 0,1:00:44.78,1:00:47.20,English,,0,0,0,,You might consider something like good fit
Dialogue: 0,1:00:44.78,1:00:47.20,Chinese,,0,0,0,,你可能会考虑一些如「不错的适配」的方案
Dialogue: 0,1:00:48.28,1:00:51.42,English,,0,0,0,,Which is sort of a mix of first fit and best fit so maybe
Dialogue: 0,1:00:48.28,1:00:51.42,Chinese,,0,0,0,,这可能首次适配和最佳适配的混合
Dialogue: 0,1:00:51.86,1:00:53.28,English,,0,0,0,,Maybe you only search the first
Dialogue: 0,1:00:51.86,1:00:53.28,Chinese,,0,0,0,,也许你只搜索第一个
Dialogue: 0,1:00:55.38,1:00:58.08,English,,0,0,0,,You know a portion of the heap and then identify the best fit
Dialogue: 0,1:00:55.38,1:00:58.08,Chinese,,0,0,0,,搜索堆的一部分，然后确定最合适的
Dialogue: 0,1:00:58.40,1:01:00.54,English,,0,0,0,,You know maybe instead of searching the entire heap
Dialogue: 0,1:00:58.40,1:01:00.54,Chinese,,0,0,0,,也许不是搜索整个堆
Dialogue: 0,1:01:01.14,1:01:03.30,English,,0,0,0,,You just search some portion of the heap
Dialogue: 0,1:01:01.14,1:01:03.30,Chinese,,0,0,0,,你只需搜索堆的某些部分
Dialogue: 0,1:01:03.70,1:01:08.72,English,,0,0,0,,And then cut off the search and then within that region that you search do you pick the best block
Dialogue: 0,1:01:03.70,1:01:08.72,Chinese,,0,0,0,,然后切断搜索，然后在你搜索的区域内选择最佳区块
Dialogue: 0,1:01:10.94,1:01:13.24,English,,0,0,0,,So that's something that called good fit
Dialogue: 0,1:01:10.94,1:01:13.24,Chinese,,0,0,0,,所以这就是所谓的「不错的适配」
Dialogue: 0,1:01:15.04,1:01:17.02,English,,0,0,0,,So that kind of approximates best fit
Dialogue: 0,1:01:15.04,1:01:17.02,Chinese,,0,0,0,,所以这种接近于最佳适配
Dialogue: 0,1:01:18.88,1:01:22.22,English,,0,0,0,,Or you can use these multiple free lists to approximate best fit
Dialogue: 0,1:01:18.88,1:01:22.22,Chinese,,0,0,0,,或者你可以使用多个空闲列表来近似你和最佳适配
Dialogue: 0,1:01:22.88,1:01:28.82,English,,0,0,0,,And the real advantage of using multiple free lists
Dialogue: 0,1:01:22.88,1:01:28.82,Chinese,,0,0,0,,而且使用多个空闲列表的真正优势
Dialogue: 0,1:01:29.90,1:01:32.66,English,,0,0,0,,Is that it not only improves memory utilization
Dialogue: 0,1:01:29.90,1:01:32.66,Chinese,,0,0,0,,是它不仅提高了内存利用率
Dialogue: 0,1:01:32.68,1:01:37.22,English,,0,0,0,,But it improves performance too because the individual lists that you're looking for
Dialogue: 0,1:01:32.68,1:01:37.22,Chinese,,0,0,0,,它也提高了性能，因为你正在寻找的特定的列表
Dialogue: 0,1:01:37.74,1:01:41.48,English,,0,0,0,,You know that they contain blocks that are close to what you're asking for
Dialogue: 0,1:01:37.74,1:01:41.48,Chinese,,0,0,0,,你知道它们包含的块与你要求的块接近
Dialogue: 0,1:01:42.74,1:01:48.98,English,,0,0,0,,And since you're dividing all the free blocks up among multiple free lists
Dialogue: 0,1:01:42.74,1:01:48.98,Chinese,,0,0,0,,而且，因为你将所有的空闲块分割到多个空闲列表中
Dialogue: 0,1:01:49.64,1:01:50.86,English,,0,0,0,,Those free lists will be shorter
Dialogue: 0,1:01:49.64,1:01:50.86,Chinese,,0,0,0,,那些空闲列表会更短
Dialogue: 0,1:01:51.84,1:01:53.68,English,,0,0,0,,Okay so your searches will take less time
Dialogue: 0,1:01:51.84,1:01:53.68,Chinese,,0,0,0,,好的，所以你的搜索将花费更少的时间
Dialogue: 0,1:01:54.40,1:01:58.26,English,,0,0,0,,And your probability of finding a block that fits goes up
Dialogue: 0,1:01:54.40,1:01:58.26,Chinese,,0,0,0,,你找到适合的块的概率会上升
Dialogue: 0,1:01:59.18,1:02:02.18,English,,0,0,0,,Because you're segregating these different size classes
Dialogue: 0,1:01:59.18,1:02:02.18,Chinese,,0,0,0,,因为你要隔离这些不同大小的类
Dialogue: 0,1:02:05.34,1:02:09.84,English,,0,0,0,,Now we also have to decide on some splitting policy so
Dialogue: 0,1:02:05.34,1:02:09.84,Chinese,,0,0,0,,.我们还必须决定一些分裂策略
Dialogue: 0,1:02:10.82,1:02:13.40,English,,0,0,0,,We find a free block that's big enough
Dialogue: 0,1:02:10.82,1:02:13.40,Chinese,,0,0,0,,我们找到一个足够大的空闲块时
Dialogue: 0,1:02:14.14,1:02:17.92,English,,0,0,0,,What do we do with the leftover part of that block
Dialogue: 0,1:02:14.14,1:02:17.92,Chinese,,0,0,0,,我们如何处理该块的剩余部分
Dialogue: 0,1:02:18.14,1:02:22.86,English,,0,0,0,,You know once we placed an allocated block into that free block
Dialogue: 0,1:02:18.14,1:02:22.86,Chinese,,0,0,0,,一旦我们将一个已分配的块放入该空闲块中
Dialogue: 0,1:02:23.38,1:02:26.12,English,,0,0,0,,What do we do with the leftovers do we just leave the leftover part
Dialogue: 0,1:02:23.38,1:02:26.12,Chinese,,0,0,0,,我们如何处理剩下的部分。我们丢下剩下的部分不管？
Dialogue: 0,1:02:26.70,1:02:29.63,English,,0,0,0,,In the block itself and return that back to the application
Dialogue: 0,1:02:26.70,1:02:29.63,Chinese,,0,0,0,,在块本身并将其返回给应用程序
Dialogue: 0,1:02:30.18,1:02:34.38,English,,0,0,0,,You know avoiding so that  sort of keeping larger blocks
Dialogue: 0,1:02:30.18,1:02:34.38,Chinese,,0,0,0,,你知道避免这种情况以便保持更大的块
Dialogue: 0,1:02:35.28,1:02:38.40,English,,0,0,0,,Or do we go ahead and split it like I showed before
Dialogue: 0,1:02:35.28,1:02:38.40,Chinese,,0,0,0,,或者我们继续像以前一样分开它
Dialogue: 0,1:02:38.96,1:02:46.42,English,,0,0,0,,And splitting we go ahead and splitting that block and creating the original free block
Dialogue: 0,1:02:38.96,1:02:46.42,Chinese,,0,0,0,,然后我们继续拆分该块并创建原始空闲块
Dialogue: 0,1:02:47.32,1:02:50.66,English,,0,0,0,,Allocating a portion of it and then creating a smaller free block
Dialogue: 0,1:02:47.32,1:02:50.66,Chinese,,0,0,0,,分配一部分，然后创建一个较小的空闲块
Dialogue: 0,1:02:51.58,1:02:55.22,English,,0,0,0,,So that's you know that's a policy we may you may want to
Dialogue: 0,1:02:51.58,1:02:55.22,Chinese,,0,0,0,,所以这是我们可能想要的策略
Dialogue: 0,1:02:55.76,1:02:59.64,English,,0,0,0,,You may want to for small requests for small payloads
Dialogue: 0,1:02:55.76,1:02:59.64,Chinese,,0,0,0,,以针对小型有效负载的小请求
Dialogue: 0,1:02:59.64,1:03:06.92,English,,0,0,0,,You may up to a certain size,you may not want to split,so you may not you may decide not to split blocks smaller
Dialogue: 0,1:02:59.64,1:03:06.92,Chinese,,0,0,0,,以达到块的大小有一定的下限，不把块继续分割成更小的块的目的
Dialogue: 0,1:03:08.08,1:03:13.86,English,,0,0,0,,You may decide not to create free blocks that are smaller than some threshold
Dialogue: 0,1:03:08.08,1:03:13.86,Chinese,,0,0,0,,你可能决定不创建小于某个阈值的空闲块
Dialogue: 0,1:03:15.18,1:03:18.46,English,,0,0,0,,And only splitting for requests for larger blocks
Dialogue: 0,1:03:15.18,1:03:18.46,Chinese,,0,0,0,,并且仅针对更大块的请求进行拆分
Dialogue: 0,1:03:20.28,1:03:22.80,English,,0,0,0,,And then the there's a coalescing policy
Dialogue: 0,1:03:20.28,1:03:22.80,Chinese,,0,0,0,,然后是一个合并政策
Dialogue: 0,1:03:25.02,1:03:31.52,English,,0,0,0,,Now we've seen freeing is pretty quick now it's constant time because of the boundary tag footers
Dialogue: 0,1:03:25.02,1:03:31.52,Chinese,,0,0,0,,现在我们已经看到释放非常快，因为边界标记，这个过程是常数时间
Dialogue: 0,1:03:32.44,1:03:34.74,English,,0,0,0,,But you may want to
Dialogue: 0,1:03:32.44,1:03:34.74,Chinese,,0,0,0,,但你可能想要
Dialogue: 0,1:03:35.56,1:03:40.82,English,,0,0,0,,You may want to try to just speed that up even more by deferring the coalescing
Dialogue: 0,1:03:35.56,1:03:40.82,Chinese,,0,0,0,,你可能希望通过延迟合并来尝试加快速度
Dialogue: 0,1:03:42.28,1:03:46.16,English,,0,0,0,,So you can do coalescing it
Dialogue: 0,1:03:42.28,1:03:46.16,Chinese,,0,0,0,,所以你可以
Dialogue: 0,1:03:47.70,1:03:50.64,English,,0,0,0,,Every time the free is called like we just looked at
Dialogue: 0,1:03:47.70,1:03:50.64,Chinese,,0,0,0,,和我们刚才看到的一样，当每次 free 被调用时就进行合并
Dialogue: 0,1:03:51.92,1:03:54.86,English,,0,0,0,,Or you could defer coalescing to some later time
Dialogue: 0,1:03:51.92,1:03:54.86,Chinese,,0,0,0,,或者你可以推迟到某个时间再进行合并
Dialogue: 0,1:03:55.12,1:03:57.60,English,,0,0,0,,You know maybe when you're scanning the free list
Dialogue: 0,1:03:55.12,1:03:57.60,Chinese,,0,0,0,,当你在扫描空闲列表时
Dialogue: 0,1:03:58.52,1:04:00.04,English,,0,0,0,,When you're scanning the free list looking
Dialogue: 0,1:03:58.52,1:04:00.04,Chinese,,0,0,0,,当你正在扫描空闲列表时
Dialogue: 0,1:04:00.88,1:04:05.34,English,,0,0,0,,Trying to find, trying to place an allocated block in response to a malloc call
Dialogue: 0,1:04:00.88,1:04:05.34,Chinese,,0,0,0,,尝试查找，尝试放置已分配的块以响应 malloc 调用
Dialogue: 0,1:04:06.04,1:04:11.16,English,,0,0,0,,Maybe as you scan that free list you could go ahead and do the coalescing at that time
Dialogue: 0,1:04:06.04,1:04:11.16,Chinese,,0,0,0,,也许当你扫描该空闲列表时，你可以继续进行当时的合并
Dialogue: 0,1:04:13.78,1:04:17.74,English,,0,0,0,,Right so I'm not saying which one is better it's really hard to argue for
Dialogue: 0,1:04:13.78,1:04:17.74,Chinese,,0,0,0,,所以我不是说哪一个更好，这真的很难争辩
Dialogue: 0,1:04:18.18,1:04:26.22,English,,0,0,0,,Deferred coalescing and giving the constant time performance of a boundary tag-based coalescing
Dialogue: 0,1:04:18.18,1:04:26.22,Chinese,,0,0,0,,延迟合并以及给出基于边界标签的合并的恒定时间性能
Dialogue: 0,1:04:26.22,1:04:27.37,English,,0,0,0,,But it is an option
Dialogue: 0,1:04:26.22,1:04:27.37,Chinese,,0,0,0,,但这是一种选择
Dialogue: 0,1:04:31.12,1:04:33.30,English,,0,0,0,,Okay so here's the summary then of implicit lists
Dialogue: 0,1:04:31.12,1:04:33.30,Chinese,,0,0,0,,好的，这里是隐式列表的总结
Dialogue: 0,1:04:34.62,1:04:36.52,English,,0,0,0,,This is the simplest well
Dialogue: 0,1:04:34.62,1:04:36.52,Chinese,,0,0,0,,这是最简单
Dialogue: 0,1:04:38.06,1:04:40.26,English,,0,0,0,,It's a very simple kind of allocator
Dialogue: 0,1:04:38.06,1:04:40.26,Chinese,,0,0,0,,这是一种非常简单的分配器
Dialogue: 0,1:04:41.02,1:04:44.14,English,,0,0,0,,It's...
Dialogue: 0,1:04:41.02,1:04:44.14,Chinese,,0,0,0,,它的...
Dialogue: 0,1:04:44.98,1:04:50.72,English,,0,0,0,,The cost to allocate is linear in the size of the heap worst case
Dialogue: 0,1:04:44.98,1:04:50.72,Chinese,,0,0,0,,在最坏情况下，分配器的成本是与堆的大小呈线形关系的
Dialogue: 0,1:04:52.14,1:04:56.12,English,,0,0,0,,That the cost of free is constant time even with coalescing
Dialogue: 0,1:04:52.14,1:04:56.12,Chinese,,0,0,0,,即使合并，free 的成本也是恒定的时间
Dialogue: 0,1:04:57.24,1:05:02.18,English,,0,0,0,,Memory usage will depend on the placement policy first fit ,next fit or best fit
Dialogue: 0,1:04:57.24,1:05:02.18,Chinese,,0,0,0,,内存使用情况取决于放置策略 —— 「首次适配」、「下一次适配」以及「最佳适配」
Dialogue: 0,1:05:03.28,1:05:05.46,English,,0,0,0,,Um it's not used in practice
Dialogue: 0,1:05:03.28,1:05:05.46,Chinese,,0,0,0,,它没有在实践中使用
Dialogue: 0,1:05:06.54,1:05:11.10,English,,0,0,0,,Because of the linear time, the linear time cost of allocation
Dialogue: 0,1:05:06.54,1:05:11.10,Chinese,,0,0,0,,由于分配的线性时间成本
Dialogue: 0,1:05:12.18,1:05:15.90,English,,0,0,0,,Okay but it can be used in sort of special-purpose
Dialogue: 0,1:05:12.18,1:05:15.90,Chinese,,0,0,0,,好的，但它可以用于某种特殊目的
Dialogue: 0,1:05:16.18,1:05:20.14,English,,0,0,0,,Allocators where you have a small number of size classes maybe or
Dialogue: 0,1:05:16.18,1:05:20.14,Chinese,,0,0,0,,你可以选择具有少量尺寸等级的分配器
Dialogue: 0,1:05:20.18,1:05:24.04,English,,0,0,0,,You have a very you know that you have a very small or a fairly small free list
Dialogue: 0,1:05:20.18,1:05:24.04,Chinese,,0,0,0,,或者你有一个非常小或相当小的空闲列表
Dialogue: 0,1:05:25.86,1:05:31.08,English,,0,0,0,,But the ideas of splitting and coalescing that we looked at are general to all allocators
Dialogue: 0,1:05:25.86,1:05:31.08,Chinese,,0,0,0,,但是进行了分割和合并的想法对于所有的分配器都适用
Dialogue: 0,1:05:31.36,1:05:34.46,English,,0,0,0,,Okay so the idea of a boundary tag boundary tag-based coalescing
Dialogue: 0,1:05:31.36,1:05:34.46,Chinese,,0,0,0,,基于边界标签边界的合并的想法
Dialogue: 0,1:05:34.98,1:05:40.30,English,,0,0,0,,Is used regardless of the structure of your free list
Dialogue: 0,1:05:34.98,1:05:40.30,Chinese,,0,0,0,,无论你的空闲列表的结构如何都会被使用
Dialogue: 0,1:05:41.58,1:05:43.60,English,,0,0,0,,So implicit lists are useful to study
Dialogue: 0,1:05:41.58,1:05:43.60,Chinese,,0,0,0,,所以隐式列表对于学习非常有用
Dialogue: 0,1:05:44.86,1:05:47.52,English,,0,0,0,,Because they introduce some important concepts
Dialogue: 0,1:05:44.86,1:05:47.52,Chinese,,0,0,0,,因为他们介绍了一些重要概念
Dialogue: 0,1:05:47.58,1:05:52.42,English,,0,0,0,,But generally they're not that useful
Dialogue: 0,1:05:47.58,1:05:52.42,Chinese,,0,0,0,,但一般来说它们并没有那么有用
Dialogue: 0,1:05:53.80,1:06:00.46,English,,0,0,0,,So next class we'll look at some more sophisticated organizations of free list
Dialogue: 0,1:05:53.80,1:06:00.46,Chinese,,0,0,0,,所以下一节课我们将看一些更复杂的空闲列表
Dialogue: 0,1:06:00.68,1:06:05.40,English,,0,0,0,,The explicit list and multiple free lists in particular
Dialogue: 0,1:06:00.68,1:06:05.40,Chinese,,0,0,0,,显示列表和特别是多个空闲列表
Dialogue: 0,1:06:06.98,1:06:10.52,English,,0,0,0,,Alright so we'll see you then, good luck on your shell lab due tonight
Dialogue: 0,1:06:06.98,1:06:10.52,Chinese,,0,0,0,,好吧，所以我们会见到你，祝你今晚的 shell 实验好运
Dialogue: 0,1:06:11.52,1:06:13.86,English,,0,0,0,,And we'll see you on Thursday
Dialogue: 0,1:06:11.52,1:06:13.86,Chinese,,0,0,0,,我们星期四见
