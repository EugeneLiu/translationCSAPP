[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 03  Bits, Bytes, and Integers cont.mp4
Video File: ../../../../Desktop/csapp/Lecture 03  Bits, Bytes, and Integers cont.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 1143
Active Line: 1045
Video Position: 1257

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.04,English,,0,0,0,,I guess one thing I and the rest of the staff request is that you
Dialogue: 0,0:00:00.00,0:00:05.04,Chinese,,0,0,0,,我和其他老师对你们有一点要求
Dialogue: 0,0:00:05.72,0:00:08.90,English,,0,0,0,, Whenever you have a question you first read the book
Dialogue: 0,0:00:05.72,0:00:08.90,Chinese,,0,0,0,,每当你们有问题时，你们首先要阅读课本
Dialogue: 0,0:00:08.90,0:00:14.44,English,,0,0,0,,Then you reread the assignment and you maybe reread it again and then you ask us
Dialogue: 0,0:00:08.90,0:00:14.44,Chinese,,0,0,0,,然后你们要一遍再一遍的读题目，之后再来问我们
Dialogue: 0,0:00:14.44,0:00:18.02,English,,0,0,0,,Because a lot of the questions we're getting are ones
Dialogue: 0,0:00:14.44,0:00:18.02,Chinese,,0,0,0,,因为每次我们收到问题的时候
Dialogue: 0,0:00:18.02,0:00:21.32,English,,0,0,0,,Where we just say look at this page of the book
Dialogue: 0,0:00:18.02,0:00:21.32,Chinese,,0,0,0,,我们只是会告诉你看课本的哪一页
Dialogue: 0,0:00:21.56,0:00:23.76,English,,0,0,0,,look at this paragraph of the assignment
Dialogue: 0,0:00:21.56,0:00:23.76,Chinese,,0,0,0,,看一下题目的某一段
Dialogue: 0,0:00:24.34,0:00:27.86,English,,0,0,0,,look at this part of the file that you were given
Dialogue: 0,0:00:24.34,0:00:27.86,Chinese,,0,0,0,,看一下你们提供的文件的某一部分
Dialogue: 0,0:00:28.40,0:00:35.70,English,,0,0,0,,And so I mean, there's a lot of stuff and I understand how sometimes it's easy to miss things
Dialogue: 0,0:00:28.40,0:00:35.70,Chinese,,0,0,0,,我的意思是有很多东西我和其他老师已经懂了但是有时比较容易忽略
Dialogue: 0,0:00:35.82,0:00:41.90,English,,0,0,0,,So not saying don't ever ask questions but just before you ask your questions try and figure out
Dialogue: 0,0:00:35.82,0:00:41.90,Chinese,,0,0,0,,所以不是不要问问题，而是在你提出问题之前尝试去弄懂
Dialogue: 0,0:00:41.90,0:00:46.84,English,,0,0,0,,If I really should have come through the resources I have available to see
Dialogue: 0,0:00:41.90,0:00:46.84,Chinese,,0,0,0,,如果你可以通过你可以获得的资源
Dialogue: 0,0:00:46.84,0:00:49.62,English,,0,0,0,, If the answer to my question is can be found there
Dialogue: 0,0:00:46.84,0:00:49.62,Chinese,,0,0,0,,或者问题的答案可以在哪里找到
Dialogue: 0,0:00:50.38,0:00:54.54,English,,0,0,0,, So anyways enjoy the lab
Dialogue: 0,0:00:50.38,0:00:54.54,Chinese,,0,0,0,,所以不管如何都要享受课堂
Dialogue: 0,0:00:55.38,0:01:02.32,English,,0,0,0,,So today is a suit a second part of a two-part lecture on integers and integer arithmetic
Dialogue: 0,0:00:55.38,0:01:02.32,Chinese,,0,0,0,,今天是关于整数和整数运算的第二堂课
Dialogue: 0,0:01:02.32,0:01:12.52,English,,0,0,0,, Last time we looked at representations about  how bit patterns can be interpreted is either of unsigned numbers meaning
Dialogue: 0,0:01:02.32,0:01:12.52,Chinese,,0,0,0,,上次我们讲到位模式可以被表示成无符号整数
Dialogue: 0,0:01:12.52,0:01:17.94,English,,0,0,0,, They range between 0 and 2^(w-1)
Dialogue: 0,0:01:12.52,0:01:17.94,Chinese,,0,0,0,,它们的范围在0到2 ^（w-1）之间
Dialogue: 0,0:01:18.62,0:01:26.16,English,,0,0,0,,Or as two's complement numbers which is the most compliment usual way to represent what are sometimes called signed numbers
Dialogue: 0,0:01:18.62,0:01:26.16,Chinese,,0,0,0,,或者作为补码数，这是表示有符号数的最常用的补码方式
Dialogue: 0,0:01:26.54,0:01:28.56,English,,0,0,0,,Ones it can be either negative or positive
Dialogue: 0,0:01:26.54,0:01:28.56,Chinese,,0,0,0,,它可以是正的或负的
Dialogue: 0,0:01:29.08,0:01:33.00,English,,0,0,0,,And by the way there are other ways to represent signed numbers out there but
Dialogue: 0,0:01:29.08,0:01:33.00,Chinese,,0,0,0,,顺便说一下，还有其他方法来表示有符号数
Dialogue: 0,0:01:33.38,0:01:40.40,English,,0,0,0,,Two's complement is so overwhelmingly the most used system that that's what we concentrate on
Dialogue: 0,0:01:33.38,0:01:40.40,Chinese,,0,0,0,,但是这补码表示法被绝大多数常用的系统使用，所以我们只关心这个
Dialogue: 0,0:01:41.50,0:01:43.26,English,,0,0,0,,Today what we'll do is that
Dialogue: 0,0:01:41.50,0:01:43.26,Chinese,,0,0,0,,今天我们要做的是
Dialogue: 0,0:01:43.26,0:01:51.08,English,,0,0,0,,Now go beyond the representations of these values to talk about arithmetic operations on them and some of their properties
Dialogue: 0,0:01:43.26,0:01:51.08,Chinese,,0,0,0,,超越这些值的表示来讨论它们的算术运算和它们的一些特性
Dialogue: 0,0:01:52.50,0:01:56.12,English,,0,0,0,, And what we'll do in general is talk about the unsigned case
Dialogue: 0,0:01:52.50,0:01:56.12,Chinese,,0,0,0,,总体来说，我们做的是讨论无符号整数
Dialogue: 0,0:01:56.12,0:01:59.90,English,,0,0,0,, Which is in some ways easier to understand and more intuitive
Dialogue: 0,0:01:56.12,0:01:59.90,Chinese,,0,0,0,,这更容易理解，更直观
Dialogue: 0,0:02:00.16,0:02:02.24,English,,0,0,0,, And then talk about the two's complement case
Dialogue: 0,0:02:00.16,0:02:02.24,Chinese,,0,0,0,,然后谈谈两个补充案例
Dialogue: 0,0:02:02.96,0:02:05.52,English,,0,0,0,, So the basic rule on this is
Dialogue: 0,0:02:02.96,0:02:05.52,Chinese,,0,0,0,,所以对此的基本规则是
Dialogue: 0,0:02:05.88,0:02:14.40,English,,0,0,0,,If you take two numbers that range between up to the maximum value of an unsigned number value add them
Dialogue: 0,0:02:05.88,0:02:14.40,Chinese,,0,0,0,,如果你取两个数字，其范围介于无符号数值的最大值之间，把它们相加
Dialogue: 0,0:02:14.94,0:02:20.10,English,,0,0,0,,That in principle you might need to get an extra bit to represent that sum
Dialogue: 0,0:02:14.94,0:02:20.10,Chinese,,0,0,0,,理论上来说，你可能需要额外的１比特来表示该总和
Dialogue: 0,0:02:20.10,0:02:24.70,English,,0,0,0,,If you want to represent the true sum the sort of integer sum of those two numbers
Dialogue: 0,0:02:20.10,0:02:24.70,Chinese,,0,0,0,,如果你要表示这两个整数的真实总和
Dialogue: 0,0:02:25.32,0:02:27.02,English,,0,0,0,,Because you've doubling it
Dialogue: 0,0:02:25.32,0:02:27.02,Chinese,,0,0,0,,因为你加倍了
Dialogue: 0,0:02:27.18,0:02:33.68,English,,0,0,0,,And unfortunately we can't just go out and add more bits to your computer indefinitely
Dialogue: 0,0:02:27.18,0:02:33.68,Chinese,,0,0,0,,不幸的是，我们不能无限地向你的计算机添加更多位
Dialogue: 0,0:02:33.68,0:02:36.66,English,,0,0,0,,So we just stop it at some point and say
Dialogue: 0,0:02:33.68,0:02:36.66,Chinese,,0,0,0,,我们只是在某个时候停下来说
Dialogue: 0,0:02:37.04,0:02:42.38,English,,0,0,0,, Well whatever bit happened to be in that sort of next bit position
Dialogue: 0,0:02:37.04,0:02:42.38,Chinese,,0,0,0,,无论下一个比特上有什么
Dialogue: 0,0:02:42.38,0:02:45.04,English,,0,0,0,, We're just going to drop it and pretend it doesn't exist
Dialogue: 0,0:02:42.38,0:02:45.04,Chinese,,0,0,0,,我们将放弃它并假装它不存在
Dialogue: 0,0:02:45.66,0:02:50.86,English,,0,0,0,, And say that the result of addition is just whatever the w bit pattern you get
Dialogue: 0,0:02:45.66,0:02:50.86,Chinese,,0,0,0,,并且说加法的结果就是你获得的w位模式
Dialogue: 0,0:02:51.26,0:02:54.06,English,,0,0,0,,If you only consider the first w bits out of it
Dialogue: 0,0:02:51.26,0:02:54.06,Chinese,,0,0,0,,如果你只考虑它的w位
Dialogue: 0,0:02:54.80,0:03:00.64,English,,0,0,0,,With no warning no messages no error or anything
Dialogue: 0,0:02:54.80,0:03:00.64,Chinese,,0,0,0,,没有警告没有提示没有错误或任何东西
Dialogue: 0,0:03:00.64,0:03:02.74,English,,0,0,0,,This is just it happens silently
Dialogue: 0,0:03:00.64,0:03:02.74,Chinese,,0,0,0,,它只会静悄悄地发生
Dialogue: 0,0:03:04.68,0:03:12.68,English,,0,0,0,, So for, two's complement this is not such a hard thing to understand
Dialogue: 0,0:03:04.68,0:03:12.68,Chinese,,0,0,0,,因此，对于补码，这并不是一件难以理解的事情
Dialogue: 0,0:03:12.88,0:03:18.40,English,,0,0,0,, It can be thought of as just modular arithmetic computing modulo the two to the word size
Dialogue: 0,0:03:12.88,0:03:18.40,Chinese,,0,0,0,,它可以被认为是整数运算模两个字大小
Dialogue: 0,0:03:18.88,0:03:23.04,English,,0,0,0,,I'm going to use some examples and this time I've got them worked out a little more carefully
Dialogue: 0,0:03:18.88,0:03:23.04,Chinese,,0,0,0,,我将使用一些例子，这次我把他们更小心地算出来
Dialogue: 0,0:03:23.04,0:03:25.54,English,,0,0,0,,So I won't get mixed up as much
Dialogue: 0,0:03:23.04,0:03:25.54,Chinese,,0,0,0,,所以我不会混淆他们
Dialogue: 0,0:03:25.90,0:03:28.74,English,,0,0,0,,And we'll use a word size of 4 here
Dialogue: 0,0:03:25.90,0:03:28.74,Chinese,,0,0,0,,我们在这里使用4比特的大小
Dialogue: 0,0:03:29.02,0:03:30.64,English,,0,0,0,,And as I mentioned last time
Dialogue: 0,0:03:29.02,0:03:30.64,Chinese,,0,0,0,,正如我上次提到的那样
Dialogue: 0,0:03:31.26,0:03:35.98,English,,0,0,0,,It really helps with this to work do the examples with small word sizes
Dialogue: 0,0:03:31.26,0:03:35.98,Chinese,,0,0,0,,这对于小的数的示例来说非常有用
Dialogue: 0,0:03:36.44,0:03:44.62,English,,0,0,0,,To get you intuition for it rather than trying to write out 32-bit numbers or 64-bit numbers is something like that
Dialogue: 0,0:03:36.44,0:03:44.62,Chinese,,0,0,0,,让你得到感觉而不是让你去写出像32位数字或64位数字
Dialogue: 0,0:03:45.16,0:03:47.42,English,,0,0,0,, So if you think about in the unsigned case
Dialogue: 0,0:03:45.16,0:03:47.42,Chinese,,0,0,0,,所以如果你考虑无符号整数
Dialogue: 0,0:03:52.24,0:04:03.32,English,,0,0,0,, A 4-bit number means that it will range between 0 and 2^(4-1) or 15 right
Dialogue: 0,0:03:52.24,0:04:03.32,Chinese,,0,0,0,,4位的数表示它的范围在0到2 ^（4-1）或15之间
Dialogue: 0,0:04:04.00,0:04:09.44,English,,0,0,0,,So let's just do a few examples of cases where it overflows
Dialogue: 0,0:04:04.00,0:04:09.44,Chinese,,0,0,0,,所以，让我们举几个溢出的例子
Dialogue: 0,0:04:10.83,0:04:14.68,English,,0,0,0,, So if you add 13 to 5
Dialogue: 0,0:04:10.83,0:04:14.68,Chinese,,0,0,0,,如果你算13+5
Dialogue: 0,0:04:20.80,0:04:23.38,English,,0,0,0,,First of all you know I assume already that
Dialogue: 0,0:04:20.80,0:04:23.38,Chinese,,0,0,0,,首先你知道我已经假设了
Dialogue: 0,0:04:23.38,0:04:26.32,English,,0,0,0,,You just add binary numbers the way you learned in school
Dialogue: 0,0:04:23.38,0:04:26.32,Chinese,,0,0,0,,你只需按照在学校学习的方式将二进制数加起来
Dialogue: 0,0:04:26.80,0:04:31.38,English,,0,0,0,,Just doing carries and so forth except it's all modulo two
Dialogue: 0,0:04:26.80,0:04:31.38,Chinese,,0,0,0,,做这些加法，之后将它模2
Dialogue: 0,0:04:31.38,0:04:41.74,English,,0,0,0,,So this is 0 carry 1 1, 0  carry 1,0 carry 1
Dialogue: 0,0:04:31.38,0:04:41.74,Chinese,,0,0,0,,所以这是0进1，0进1，0进1
Dialogue: 0,0:04:42.56,0:04:48.66,English,,0,0,0,,So in principle to represent the sum which is this is 5, so to represent 18
Dialogue: 0,0:04:42.56,0:04:48.66,Chinese,,0,0,0,,理论上要用５比特来表示的总和，所以这等于18
Dialogue: 0,0:04:49.46,0:04:51.56,English,,0,0,0,,You need 5 bits, not 4
Dialogue: 0,0:04:49.46,0:04:51.56,Chinese,,0,0,0,,你需要5比特，而不是4比特
Dialogue: 0,0:04:52.54,0:04:58.96,English,,0,0,0,,But we're just going to conveniently drop that number and say that this is actually a 2
Dialogue: 0,0:04:52.54,0:04:58.96,Chinese,,0,0,0,,但我们只是简单地丢弃这个数字并说这实际上是2
Dialogue: 0,0:04:59.78,0:05:03.48,English,,0,0,0,,Which of course is what 18 modules of 16 is
Dialogue: 0,0:04:59.78,0:05:03.48,Chinese,,0,0,0,,当然，这是18模16
Dialogue: 0,0:05:04.76,0:05:07.44,English,,0,0,0,,So the unsigned case is really pretty straightforward
Dialogue: 0,0:05:04.76,0:05:07.44,Chinese,,0,0,0,,因此，无符号整数是真的简单
Dialogue: 0,0:05:12.80,0:05:15.98,English,,0,0,0,,And we can visualize this in this pictures in the book too
Dialogue: 0,0:05:12.80,0:05:15.98,Chinese,,0,0,0,,我们也可以在书中的这些图片中看到这一点
Dialogue: 0,0:05:16.64,0:05:23.96,English,,0,0,0,, By seeing if you are representing on the x and y axis what they call U and V
Dialogue: 0,0:05:16.64,0:05:23.96,Chinese,,0,0,0,,通过观察在x和y轴上他们表示为U和V
Dialogue: 0,0:05:25.88,0:05:29.92,English,,0,0,0,,Values between 0 and 15 the range of possible unsigned numbers
Dialogue: 0,0:05:25.88,0:05:29.92,Chinese,,0,0,0,,0到15之间的值是无符号数的范围
Dialogue: 0,0:05:30.24,0:05:34.68,English,,0,0,0,,And if we add those we could get a sum that's up to as much as 30
Dialogue: 0,0:05:30.24,0:05:34.68,Chinese,,0,0,0,,如果我们将无符号数加起来，我们可以获得高达30的总和
Dialogue: 0,0:05:35.88,0:05:39.52,English,,0,0,0,,Which would in principle require 5 bits to represent
Dialogue: 0,0:05:35.88,0:05:39.52,Chinese,,0,0,0,,理论上需要5位来表示
Dialogue: 0,0:05:40.72,0:05:45.16,English,,0,0,0,, But what we'll do is we'll just by dropping that most significant bit
Dialogue: 0,0:05:40.72,0:05:45.16,Chinese,,0,0,0,,但我们要做的就是放弃最高的一位
Dialogue: 0,0:05:45.16,0:05:47.00,English,,0,0,0,,What we do is sort of create a cliff
Dialogue: 0,0:05:45.16,0:05:47.00,Chinese,,0,0,0,,我们所做的就是创造悬崖
Dialogue: 0,0:05:47.52,0:05:53.84,English,,0,0,0,,That when you roll over from 15 to 16  instead it drops all the way down to 0
Dialogue: 0,0:05:47.52,0:05:53.84,Chinese,,0,0,0,,当你从15跨越到16时，它会直接掉到0
Dialogue: 0,0:05:54.34,0:05:56.58,English,,0,0,0,,And that's referred to as an overflow
Dialogue: 0,0:05:54.34,0:05:56.58,Chinese,,0,0,0,,这被称为溢出
Dialogue: 0,0:05:57.24,0:06:06.06,English,,0,0,0,, And then from there we'll build up to the maximum value here will be 14,which is 30-16
Dialogue: 0,0:05:57.24,0:06:06.06,Chinese,,0,0,0,,然后从那里我们将建立最大到14的值，即30-16
Dialogue: 0,0:06:06.28,0:06:10.24,English,,0,0,0,,So what we've done is basically as this picture shows when we overflow
Dialogue: 0,0:06:06.28,0:06:10.24,Chinese,,0,0,0,,在溢出时我们所做的基本上都在这张图中展示了
Dialogue: 0,0:06:10.78,0:06:15.18,English,,0,0,0,,We effectively subtract off 2^w from the sum
Dialogue: 0,0:06:10.78,0:06:15.18,Chinese,,0,0,0,,我们从总和中减去2 ^ w
Dialogue: 0,0:06:15.70,0:06:20.20,English,,0,0,0,, And keep it within the representable range of w bit numbers
Dialogue: 0,0:06:15.70,0:06:20.20,Chinese,,0,0,0,,并将其保持在w位数的可表示范围内
Dialogue: 0,0:06:21.26,0:06:22.96,English,,0,0,0,, So that's an unsigned
Dialogue: 0,0:06:21.26,0:06:22.96,Chinese,,0,0,0,,所以这是无符号整数
Dialogue: 0,0:06:24.16,0:06:25.02,English,,0,0,0,,Two's complement
Dialogue: 0,0:06:24.16,0:06:25.02,Chinese,,0,0,0,,补码
Dialogue: 0,0:06:25.74,0:06:34.92,English,,0,0,0,,The first thing I want to convince you of is it two's complement addition looks just like a regular edition
Dialogue: 0,0:06:25.74,0:06:34.92,Chinese,,0,0,0,,我想说服你的第一件事就是两个补码的加法看起来就像普通的加法
Dialogue: 0,0:06:36.02,0:06:39.94,English,,0,0,0,, In other words I can perform a subtraction
Dialogue: 0,0:06:36.02,0:06:39.94,Chinese,,0,0,0,,换句话说，我可以执行减法
Dialogue: 0,0:06:41.06,0:06:47.24,English,,0,0,0,,And addition of subtraction of numbers by using this two's complement representation for negative numbers
Dialogue: 0,0:06:41.06,0:06:47.24,Chinese,,0,0,0,,并通过使用负数的补码来表示负数的加法
Dialogue: 0,0:06:48.04,0:06:51.40,English,,0,0,0,,So well let me just show you some examples of that
Dialogue: 0,0:06:48.04,0:06:51.40,Chinese,,0,0,0,,那么，让我向你展示一些例子
Dialogue: 0,0:06:57.54,0:07:00.52,English,,0,0,0,,So first of all remember that what range of values
Dialogue: 0,0:06:57.54,0:07:00.52,Chinese,,0,0,0,,首先要记住值的范围
Dialogue: 0,0:07:00.52,0:07:03.80,English,,0,0,0,,What's the smallest number that could be representatively the 4 bit
Dialogue: 0,0:07:00.52,0:07:03.80,Chinese,,0,0,0,,可以用4位表示的最小数字是多少
Dialogue: 0,0:07:04.32,0:07:07.60,English,,0,0,0,,The most negative number 4 bit two's complement number
Dialogue: 0,0:07:04.32,0:07:07.60,Chinese,,0,0,0,,4位二进制补码的最小负数
Dialogue: 0,0:07:09.10,0:07:10.10,English,,0,0,0,, -8
Dialogue: 0,0:07:09.10,0:07:10.10,Chinese,,0,0,0,,-8
Dialogue: 0,0:07:12.18,0:07:15.88,English,,0,0,0,,And the largest 　　　plus 7 thank you
Dialogue: 0,0:07:12.18,0:07:15.88,Chinese,,0,0,0,,最大的　　　7谢谢
Dialogue: 0,0:07:18.70,0:07:21.96,English,,0,0,0,,So let's just do some examples if we took
Dialogue: 0,0:07:18.70,0:07:21.96,Chinese,,0,0,0,,所以让我们做一些实验吧,  取个数字
Dialogue: 0,0:07:26.64,0:07:33.98,English,,0,0,0,,This number 1101, as a two's complement number is -3
Dialogue: 0,0:07:26.64,0:07:33.98,Chinese,,0,0,0,,1101，作为二进制补码是-3
Dialogue: 0,0:07:35.12,0:07:43.26,English,,0,0,0,,And we add it to 5. We'll get what we got before
Dialogue: 0,0:07:35.12,0:07:43.26,Chinese,,0,0,0,,我们将它加5.我们将获得之前得到的东西
Dialogue: 0,0:07:51.50,0:07:56.26,English,,0,0,0,,And we're not good at we're going to ignore whatever carry bit it is and so the result is 2
Dialogue: 0,0:07:51.50,0:07:56.26,Chinese,,0,0,0,,而且我们不擅长忽略进位，因此结果为2
Dialogue: 0,0:07:58.06,0:08:00.40,English,,0,0,0,, I'm going behold that's what 5-3
Dialogue: 0,0:07:58.06,0:08:00.40,Chinese,,0,0,0,,我发现那是5-3
Dialogue: 0,0:08:00.40,0:08:04.00,English,,0,0,0,,So it seems like magic because it is
Dialogue: 0,0:08:00.40,0:08:04.00,Chinese,,0,0,0,,所以看起来很神奇，因为它是
Dialogue: 0,0:08:05.98,0:08:12.46,English,,0,0,0,,( Two's )And that's why part of the reason why I choose complement is to  the most commonly used way of representing signed numbers
Dialogue: 0,0:08:05.98,0:08:12.46,Chinese,,0,0,0,,（二）所以我选择补码的部分原因是因为它是最常用的表示有符号数的方法
Dialogue: 0,0:08:12.46,0:08:17.14,English,,0,0,0,,Because the same hardware the same algorithms that are used for doing
Dialogue: 0,0:08:12.46,0:08:17.14,Chinese,,0,0,0,,因为相同的硬件使用相同的算法
Dialogue: 0,0:08:18.23,0:08:23.42,English,,0,0,0,,Addition in work for either unsigned or two's complement numbers
Dialogue: 0,0:08:18.23,0:08:23.42,Chinese,,0,0,0,,执行无符号或补码的加法
Dialogue: 0,0:08:31.70,0:08:36.40,English,,0,0,0,,And this works as well just to show you
Dialogue: 0,0:08:31.70,0:08:36.40,Chinese,,0,0,0,,这也适用于向你展示
Dialogue: 0,0:08:36.84,0:08:42.28,English,,0,0,0,,If the overflow goes if the resulting thumb is goes the other way
Dialogue: 0,0:08:36.84,0:08:42.28,Chinese,,0,0,0,,如果溢出，产生的结果是另一种形式的
Dialogue: 0,0:08:45.86,0:08:50.28,English,,0,0,0,, So if I have -3, and -5 + 3
Dialogue: 0,0:08:45.86,0:08:50.28,Chinese,,0,0,0,,所以，如果我有-5，和+ 3
Dialogue: 0,0:08:51.10,0:08:53.06,English,,0,0,0,,And I add those together
Dialogue: 0,0:08:51.10,0:08:53.06,Chinese,,0,0,0,,我把它们加在一起
Dialogue: 0,0:09:03.58,0:09:07.64,English,,0,0,0,,ok,1110 which is -2
Dialogue: 0,0:09:03.58,0:09:07.64,Chinese,,0,0,0,,好的，1110是-2
Dialogue: 0,0:09:10.16,0:09:16.56,English,,0,0,0,,So again if you use the same patterns for the same rule for addition
Dialogue: 0,0:09:10.16,0:09:16.56,Chinese,,0,0,0,,因此，如果你使用类似的加法推理模式
Dialogue: 0,0:09:17.62,0:09:22.10,English,,0,0,0,,As you do with the unsigned case you'll get two's complement arithmetic
Dialogue: 0,0:09:17.62,0:09:22.10,Chinese,,0,0,0,,与你做无符号整数时一样，你将获得补码的算法
Dialogue: 0,0:09:24.10,0:09:29.18,English,,0,0,0,, So what smoke in a few cases where the two's complement overflows
Dialogue: 0,0:09:24.10,0:09:29.18,Chinese,,0,0,0,,那么在补码溢出的情况下会发生什么
Dialogue: 0,0:09:36.04,0:09:55.02,English,,0,0,0,,So if we take -3 and -6
Dialogue: 0,0:09:36.04,0:09:55.02,Chinese,,0,0,0,,如果我们取-3和-6
Dialogue: 0,0:09:55.86,0:10:00.22,English,,0,0,0,,And we add them together we'll get 1110
Dialogue: 0,0:09:55.86,0:10:00.22,Chinese,,0,0,0,,我们将它们加在一起，我们将获得1110
Dialogue: 0,0:10:00.22,0:10:03.92,English,,0,0,0,,We're going to drop off the carry, which is what?
Dialogue: 0,0:10:00.22,0:10:03.92,Chinese,,0,0,0,,我们去掉多余位，这是什么？
Dialogue: 0,0:10:05.14,0:10:05.96,English,,0,0,0,,7
Dialogue: 0,0:10:05.14,0:10:05.96,Chinese,,0,0,0,,7
Dialogue: 0,0:10:08.84,0:10:11.18,English,,0,0,0,,So we've added two negative numbers
Dialogue: 0,0:10:08.84,0:10:11.18,Chinese,,0,0,0,,所以我们让两个负数相加
Dialogue: 0,0:10:11.70,0:10:16.46,English,,0,0,0,,And it's become positive and that's referred to as a negative overflow
Dialogue: 0,0:10:11.70,0:10:16.46,Chinese,,0,0,0,,它变成了正数，这被称为负溢出
Dialogue: 0,0:10:23.20,0:10:26.22,English,,0,0,0,, And the reason of course is the number -9
Dialogue: 0,0:10:23.20,0:10:26.22,Chinese,,0,0,0,,当然，结果应该是数字-9
Dialogue: 0,0:10:26.90,0:10:32.72,English,,0,0,0,,I can't be represented in a 4-bit two's complement number so
Dialogue: 0,0:10:26.90,0:10:32.72,Chinese,,0,0,0,,我不能用4位二进制补码表示
Dialogue: 0,0:10:34.12,0:10:35.96,English,,0,0,0,,It  overflowed
Dialogue: 0,0:10:34.12,0:10:35.96,Chinese,,0,0,0,,它溢出了
Dialogue: 0,0:10:37.34,0:10:44.88,English,,0,0,0,,You'll notice that the +7 of cause differs from -9 by 16 and that's not next
Dialogue: 0,0:10:37.34,0:10:44.88,Chinese,,0,0,0,,你会注意到结果是7的原因不同于-9模16
Dialogue: 0,0:10:46.30,0:10:48.96,English,,0,0,0,,And then going the other direction
Dialogue: 0,0:10:46.30,0:10:48.96,Chinese,,0,0,0,,然后讨论另一个问题
Dialogue: 0,0:10:49.26,0:11:09.20,English,,0,0,0,, If we had two large positive numbers so if we had 7 and 5
Dialogue: 0,0:10:49.26,0:11:09.20,Chinese,,0,0,0,,如果我们有两个很大的正数，比如我们有7和5
Dialogue: 0,0:11:09.54,0:11:11.86,English,,0,0,0,,We'll get -6
Dialogue: 0,0:11:09.54,0:11:11.86,Chinese,,0,0,0,,我们会得到-6(-4)
Dialogue: 0,0:11:12.82,0:11:22.34,English,,0,0,0,,So this was 7 + 5 = -4
Dialogue: 0,0:11:12.82,0:11:22.34,Chinese,,0,0,0,,所以这是7 + 5 = -4
Dialogue: 0,0:11:26.50,0:11:28.94,English,,0,0,0,,And so this is referred to as positive overflow
Dialogue: 0,0:11:26.50,0:11:28.94,Chinese,,0,0,0,,这被称为正溢出
Dialogue: 0,0:11:28.94,0:11:42.14,English,,0,0,0,,We've taken two positive numbers and added them together and gotten a negative result
Dialogue: 0,0:11:28.94,0:11:42.14,Chinese,,0,0,0,,我们将两个正数加在了一起得到了负的结果
Dialogue: 0,0:11:42.44,0:11:49.20,English,,0,0,0,, And you could see this  by the way if you think about this addition we took 7 and 5 would be 12
Dialogue: 0,0:11:42.44,0:11:49.20,Chinese,,0,0,0,,顺便说一下，如果你把这个结果看成无符号整数，我们可以看到7+5将是12
Dialogue: 0,0:11:49.54,0:11:53.22,English,,0,0,0,,And this is the bit level representation of 12
Dialogue: 0,0:11:49.54,0:11:53.22,Chinese,,0,0,0,,这是12的位级表示
Dialogue: 0,0:11:53.74,0:11:56.66,English,,0,0,0,, It's just that because this is now the sign bit
Dialogue: 0,0:11:53.74,0:11:56.66,Chinese,,0,0,0,,只是因为这现在是标志位
Dialogue: 0,0:11:57.72,0:12:01.04,English,,0,0,0,,We think of that as -4 not +12
Dialogue: 0,0:11:57.72,0:12:01.04,Chinese,,0,0,0,,我们认为这是-4而不是+12
Dialogue: 0,0:12:04.56,0:12:08.90,English,,0,0,0,,And so that's the the idea of two's complement overflow
Dialogue: 0,0:12:04.56,0:12:08.90,Chinese,,0,0,0,,这就是补码溢出
Dialogue: 0,0:12:09.66,0:12:12.62,English,,0,0,0,,And you can see there's two different cases here
Dialogue: 0,0:12:09.66,0:12:12.62,Chinese,,0,0,0,,你可以看到这里有两种不同的情况
Dialogue: 0,0:12:13.48,0:12:20.28,English,,0,0,0,,One is where the number that the sum was if we looked at the true sum
Dialogue: 0,0:12:13.48,0:12:20.28,Chinese,,0,0,0,,一种当你看二进制和时你会发现它就是真实总和
Dialogue: 0,0:12:20.90,0:12:25.82,English,,0,0,0,,The number that you'd get for example 12 is too big to represent
Dialogue: 0,0:12:20.90,0:12:25.82,Chinese,,0,0,0,,你给的样例数字12因为太大而无法表示
Dialogue: 0,0:12:25.82,0:12:30.22,English,,0,0,0,,So when we think of that as a two's complement number it becomes now a negative number
Dialogue: 0,0:12:25.82,0:12:30.22,Chinese,,0,0,0,,因此，当我们将其视为二进制补码时，它变为负数
Dialogue: 0,0:12:30.50,0:12:32.08,English,,0,0,0,, So that's positive overflow
Dialogue: 0,0:12:30.50,0:12:32.08,Chinese,,0,0,0,,这是正溢出
Dialogue: 0,0:12:32.60,0:12:36.54,English,,0,0,0,, Similarly if we have two negative numbers and we add them together
Dialogue: 0,0:12:32.60,0:12:36.54,Chinese,,0,0,0,,同样，如果我们有两个负数，我们将它们加在一起
Dialogue: 0,0:12:36.54,0:12:40.84,English,,0,0,0,, So that the sum is too small to negative to represent
Dialogue: 0,0:12:36.54,0:12:40.84,Chinese,,0,0,0,,因为总和太小而表示不了负数
Dialogue: 0,0:12:41.26,0:12:44.52,English,,0,0,0,,Then those become positive numbers that's negative overflow
Dialogue: 0,0:12:41.26,0:12:44.52,Chinese,,0,0,0,,然后这些变成负数,  这就是负溢出
Dialogue: 0,0:12:45.24,0:12:47.22,English,,0,0,0,, And you can see that in this picture
Dialogue: 0,0:12:45.24,0:12:47.22,Chinese,,0,0,0,,你可以在这张照片中看到
Dialogue: 0,0:12:47.86,0:12:51.26,English,,0,0,0,, The same idea as before except there's three regions
Dialogue: 0,0:12:47.86,0:12:51.26,Chinese,,0,0,0,,和之前的思一样除了这有三个区域
Dialogue: 0,0:12:51.86,0:12:59.58,English,,0,0,0,,This is the and by the way now you'll see our numbers range between -8 and +7
Dialogue: 0,0:12:51.86,0:12:59.58,Chinese,,0,0,0,,顺便说一下，现在你将看到我们的数字介于-8和+7之间
Dialogue: 0,0:13:00.54,0:13:08.40,English,,0,0,0,,And the sum of two's complement also range between -8 and +7
Dialogue: 0,0:13:00.54,0:13:08.40,Chinese,,0,0,0,,而且补码和的范围也正好介于-8和+7之间
Dialogue: 0,0:13:09.56,0:13:14.86,English,,0,0,0,,But there's these three regions one is the where everything is fine
Dialogue: 0,0:13:09.56,0:13:14.86,Chinese,,0,0,0,,这三个地区就是一切都正常的地方
Dialogue: 0,0:13:15.86,0:13:18.64,English,,0,0,0,,It's within the representable range
Dialogue: 0,0:13:15.86,0:13:18.64,Chinese,,0,0,0,,它在可表示的范围内
Dialogue: 0,0:13:18.98,0:13:25.72,English,,0,0,0,,The other is where the sum was so far toward the negative side that it becomes positive
Dialogue: 0,0:13:18.98,0:13:25.72,Chinese,,0,0,0,,另一个是总和太小的地方，它就会变成正的
Dialogue: 0,0:13:26.16,0:13:30.60,English,,0,0,0,, Or where it's so high on the positive side that it becomes negative
Dialogue: 0,0:13:26.16,0:13:30.60,Chinese,,0,0,0,,或者正的太多，它就会变负
Dialogue: 0,0:13:34.06,0:13:42.86,English,,0,0,0,,And so part of data lab you'll learn to understand these in quite precisely
Dialogue: 0,0:13:34.06,0:13:42.86,Chinese,,0,0,0,,因此，你们将要学的这些算法是十分准确的
Dialogue: 0,0:13:43.26,0:13:46.54,English,,0,0,0,, But then let's see idea it's a little bit counterintuitive to say
Dialogue: 0,0:13:43.26,0:13:46.54,Chinese,,0,0,0,,但是，这个算法有点违反直觉
Dialogue: 0,0:13:47.14,0:13:52.10,English,,0,0,0,,You know somehow I can accept the idea that modular arithmetic for unsigned numbers
Dialogue: 0,0:13:47.14,0:13:52.10,Chinese,,0,0,0,,我们可以接受无符号数的模运算的算法
Dialogue: 0,0:13:52.10,0:13:57.02,English,,0,0,0,,There's some sort of mathematical beauty to a modular arithmetic
Dialogue: 0,0:13:52.10,0:13:57.02,Chinese,,0,0,0,,模运算具有某种数学美
Dialogue: 0,0:13:57.50,0:14:08.30,English,,0,0,0,, And this is looks like kind of useless right  from a from operational characteristic
Dialogue: 0,0:13:57.50,0:14:08.30,Chinese,,0,0,0,,从运算性质来看，这看起来有点无用
Dialogue: 0,0:14:08.66,0:14:13.70,English,,0,0,0,,But it's the way it is and we're stuck with it
Dialogue: 0,0:14:08.66,0:14:13.70,Chinese,,0,0,0,,但它就是这样，并且坚持下去
Dialogue: 0,0:14:15.90,0:14:19.36,English,,0,0,0,,And multiplication is basically the same idea
Dialogue: 0,0:14:15.90,0:14:19.36,Chinese,,0,0,0,,而乘法基本上是相同的算法
Dialogue: 0,0:14:19.36,0:14:22.56,English,,0,0,0,, In fact all the operations are the basically the same idea that
Dialogue: 0,0:14:19.36,0:14:22.56,Chinese,,0,0,0,,事实上，所有的运算法则基本上都是相同的
Dialogue: 0,0:14:22.98,0:14:28.04,English,,0,0,0,, If you can't represent it within the word size you just take the lower w bits
Dialogue: 0,0:14:22.98,0:14:28.04,Chinese,,0,0,0,,如果你无法在给定比特中表示它，则只需使用较低的w位
Dialogue: 0,0:14:28.58,0:14:34.76,English,,0,0,0,,So all this complicated notation here is just a way of saying
Dialogue: 0,0:14:28.58,0:14:34.76,Chinese,,0,0,0,,所以这里所有的表示法只是其中一种说法
Dialogue: 0,0:14:34.76,0:14:38.76,English,,0,0,0,, In principle if you take two W bit numbers and multiply them together
Dialogue: 0,0:14:34.76,0:14:38.76,Chinese,,0,0,0,,如果你取两个W位的数并将它们相乘
Dialogue: 0,0:14:39.32,0:14:45.66,English,,0,0,0,, You may need a the result may require as much as 2w bits to represent
Dialogue: 0,0:14:39.32,0:14:45.66,Chinese,,0,0,0,,你可能需要一个2w位的数来保存结果
Dialogue: 0,0:14:46.36,0:14:48.89,English,,0,0,0,, Before addition its w+1
Dialogue: 0,0:14:46.36,0:14:48.89,Chinese,,0,0,0,,之前加法是w+1
Dialogue: 0,0:14:49.38,0:14:51.40,English,,0,0,0,,Multiplication you actually have to double
Dialogue: 0,0:14:49.38,0:14:51.40,Chinese,,0,0,0,,乘法你需要两倍的位数
Dialogue: 0,0:14:51.40,0:14:54.64,English,,0,0,0,, Because you're potentially squaring the largest number
Dialogue: 0,0:14:51.40,0:14:54.64,Chinese,,0,0,0,,因为你可能平方了最大的数
Dialogue: 0,0:14:55.02,0:15:03.92,English,,0,0,0,,And so again we don't want to just keep doubling our word size over and over again we'll run out of bits very quickly that way
Dialogue: 0,0:14:55.02,0:15:03.92,Chinese,,0,0,0,,我们不想一遍又一遍地翻倍位数,用这个方法我们会很快用完内存的
Dialogue: 0,0:15:04.20,0:15:07.08,English,,0,0,0,,And so we just truncate it at w bits
Dialogue: 0,0:15:04.20,0:15:07.08,Chinese,,0,0,0,,所以我们只是将其截断为w位
Dialogue: 0,0:15:13.66,0:15:18.32,English,,0,0,0,,For the unsigned case it's again modular arithmetic
Dialogue: 0,0:15:13.66,0:15:18.32,Chinese,,0,0,0,,对于无符号数，它就是模运算
Dialogue: 0,0:15:18.32,0:15:21.92,English,,0,0,0,, It's something that you can kind of understand and believe
Dialogue: 0,0:15:18.32,0:15:21.92,Chinese,,0,0,0,,这是你可以理解和相信的东西
Dialogue: 0,0:15:22.50,0:15:23.66,English,,0,0,0,,But for...
Dialogue: 0,0:15:22.50,0:15:23.66,Chinese,,0,0,0,,但对于...
Dialogue: 0,0:15:25.94,0:15:35.32,English,,0,0,0,,And so again let's just do a few examples and I won't try and work out multiplying in binary is like multiplying in decimal
Dialogue: 0,0:15:25.94,0:15:35.32,Chinese,,0,0,0,,所以再次让我们做几个例子，我不会尝试在二进制中做乘法与在十进制中的一样
Dialogue: 0,0:15:35.76,0:15:39.72,English,,0,0,0,,You do a big table and it takes a long time so I won't try to do that
Dialogue: 0,0:15:35.76,0:15:39.72,Chinese,,0,0,0,,你做了一个很大的表，这需要很长时间，所以我不会尝试这样做
Dialogue: 0,0:15:40.30,0:15:44.30,English,,0,0,0,,But let me just show a few examples
Dialogue: 0,0:15:40.30,0:15:44.30,Chinese,,0,0,0,,但是，让我举几个例子
Dialogue: 0,0:15:53.68,0:15:59.20,English,,0,0,0,,So if I multiply 3 * 5 is of cause equal to 15
Dialogue: 0,0:15:53.68,0:15:59.20,Chinese,,0,0,0,,因此，如果我做3 * 5，它等于15
Dialogue: 0,0:16:00.06,0:16:06.22,English,,0,0,0,,And in an unsigned number I can represent that right
Dialogue: 0,0:16:00.06,0:16:06.22,Chinese,,0,0,0,,在无符号整数中，我可以正确的表示它
Dialogue: 0,0:16:06.80,0:16:08.46,English,,0,0,0,,So that's okay
Dialogue: 0,0:16:06.80,0:16:08.46,Chinese,,0,0,0,,所以这没关系
Dialogue: 0,0:16:13.60,0:16:16.32,English,,0,0,0,,But if I multiply a 5*5
Dialogue: 0,0:16:13.60,0:16:16.32,Chinese,,0,0,0,,但如果我做5 * 5
Dialogue: 0,0:16:22.40,0:16:25.40,English,,0,0,0,,Then that would have representation
Dialogue: 0,0:16:22.40,0:16:25.40,Chinese,,0,0,0,,这将具有代表性
Dialogue: 0,0:16:28.04,0:16:31.26,English,,0,0,0,,If I were to think about it as possibly as many as 8 bits
Dialogue: 0,0:16:28.04,0:16:31.26,Chinese,,0,0,0,,如果我认为它可以有8位
Dialogue: 0,0:16:31.26,0:16:39.80,English,,0,0,0,,It would have a representation with an extra bit
Dialogue: 0,0:16:31.26,0:16:39.80,Chinese,,0,0,0,,它会有一个额外的位
Dialogue: 0,0:16:40.50,0:16:42.42,English,,0,0,0,,And I'm going to throw this part away
Dialogue: 0,0:16:40.50,0:16:42.42,Chinese,,0,0,0,,我会把这部分扔掉
Dialogue: 0,0:16:42.74,0:16:44.40,English,,0,0,0,,And so I'd call that 9
Dialogue: 0,0:16:42.74,0:16:44.40,Chinese,,0,0,0,,我称之为9
Dialogue: 0,0:16:45.28,0:16:47.98,English,,0,0,0,,Which of cause is equal to 25 mod 16
Dialogue: 0,0:16:45.28,0:16:47.98,Chinese,,0,0,0,,它等于25 模 16
Dialogue: 0,0:16:54.84,0:17:01.16,English,,0,0,0,,And so that's the general idea of it is regardless of whatever's in this upper part of the word
Dialogue: 0,0:16:54.84,0:17:01.16,Chinese,,0,0,0,,这就是它的算法，不管这个数多出来的部分是什么
Dialogue: 0,0:17:01.30,0:17:05.26,English,,0,0,0,,The product I'm just going to discard that and only look at the lower one
Dialogue: 0,0:17:01.30,0:17:05.26,Chinese,,0,0,0,,我们将丢弃这些并只关心低位
Dialogue: 0,0:17:05.78,0:17:09.70,English,,0,0,0,,And life gets a little more interesting with the two's complement case
Dialogue: 0,0:17:05.78,0:17:09.70,Chinese,,0,0,0,,补码让生活变得更加有趣
Dialogue: 0,0:17:10.60,0:17:12.28,English,,0,0,0,, So let's look at what that does
Dialogue: 0,0:17:10.60,0:17:12.28,Chinese,,0,0,0,,那么让我们来看看它做了什么
Dialogue: 0,0:17:14.98,0:17:16.86,English,,0,0,0,,And the answer is
Dialogue: 0,0:17:14.98,0:17:16.86,Chinese,,0,0,0,,答案是
Dialogue: 0,0:17:18.24,0:17:19.94,English,,0,0,0,,Even a little bit stranger
Dialogue: 0,0:17:18.24,0:17:19.94,Chinese,,0,0,0,,可能有点陌生
Dialogue: 0,0:17:19.94,0:17:25.88,English,,0,0,0,,That you're not only trunk throw away whatever high order bits happen to be there
Dialogue: 0,0:17:19.94,0:17:25.88,Chinese,,0,0,0,,你要抛弃所有的高位
Dialogue: 0,0:17:26.34,0:17:32.42,English,,0,0,0,, But whatever bit gets left in this position will determine whether it's a positive or a negative result
Dialogue: 0,0:17:26.34,0:17:32.42,Chinese,,0,0,0,,但无论在这个位置留下什么，都将决定它是正的还是负的
Dialogue: 0,0:17:33.45,0:17:39.88,English,,0,0,0,,Even though with completely irrespective of the signs of the original two operands
Dialogue: 0,0:17:33.45,0:17:39.88,Chinese,,0,0,0,,完全不需要考虑原始两个操作数的符号
Dialogue: 0,0:17:40.96,0:17:44.46,English,,0,0,0,,So that can make you go all over the place
Dialogue: 0,0:17:40.96,0:17:44.46,Chinese,,0,0,0,,这样可以让你完全理解
Dialogue: 0,0:18:02.60,0:18:07.70,English,,0,0,0,,so if we had 5*4 of 20
Dialogue: 0,0:18:02.60,0:18:07.70,Chinese,,0,0,0,,所以，如果我们算5 * 4等于20
Dialogue: 0,0:18:08.94,0:18:24.08,English,,0,0,0,,That would be represented in this 8-bit form like so
Dialogue: 0,0:18:08.94,0:18:24.08,Chinese,,0,0,0,,像这样我们要用8位来表示
Dialogue: 0,0:18:24.68,0:18:28.92,English,,0,0,0,,And we just call that 4 right
Dialogue: 0,0:18:24.68,0:18:28.92,Chinese,,0,0,0,,但是我们只能叫它4
Dialogue: 0,0:18:29.40,0:18:30.84,English,,0,0,0,,Because we throwing this away
Dialogue: 0,0:18:29.40,0:18:30.84,Chinese,,0,0,0,,因为我们把这些扔了
Dialogue: 0,0:18:31.34,0:18:41.64,English,,0,0,0,,But if we did 5*5 as we saw before that's represented like this
Dialogue: 0,0:18:31.34,0:18:41.64,Chinese,,0,0,0,,但是，如果我们做像之前那样的5 * 5
Dialogue: 0,0:18:50.22,0:18:51.38,English,,0,0,0,,And that's sum...
Dialogue: 0,0:18:50.22,0:18:51.38,Chinese,,0,0,0,,总和......
Dialogue: 0,0:18:52.72,0:18:54.08,English,,0,0,0,, Now becomes...
Dialogue: 0,0:18:52.72,0:18:54.08,Chinese,,0,0,0,,现在变成......
Dialogue: 0,0:18:54.28,0:18:55.64,English,,0,0,0,,So we're throwing away this
Dialogue: 0,0:18:54.28,0:18:55.64,Chinese,,0,0,0,,我们扔掉了这个
Dialogue: 0,0:18:56.08,0:19:02.08,English,,0,0,0,,And this becomes our sign bit so the result is a -8 + 1= -7
Dialogue: 0,0:18:56.08,0:19:02.08,Chinese,,0,0,0,,这成为我们的符号位，因此结果为-8 + 1 = -7
Dialogue: 0,0:19:05.70,0:19:11.60,English,,0,0,0,,So you see this is a similar to an example we showed at the beginning of the first lecture
Dialogue: 0,0:19:05.70,0:19:11.60,Chinese,,0,0,0,,所以你看到的与我们在第一堂课开始时展示的例子类似
Dialogue: 0,0:19:11.62,0:19:16.18,English,,0,0,0,,You can have two positive numbers and multiply them and get a negative result
Dialogue: 0,0:19:11.62,0:19:16.18,Chinese,,0,0,0,,你有两个正数并将它们相乘得到负的结果
Dialogue: 0,0:19:18.08,0:19:20.94,English,,0,0,0,,Because of the sort of quirks of this overflow
Dialogue: 0,0:19:18.08,0:19:20.94,Chinese,,0,0,0,,因为这种溢出的诡异现象
Dialogue: 0,0:19:20.94,0:19:21.66,English,,0,0,0,, Question that
Dialogue: 0,0:19:20.94,0:19:21.66,Chinese,,0,0,0,,开始提问
Dialogue: 0,0:19:21.66,0:19:23.66,English,,0,0,0,,[student speaking]
Dialogue: 0,0:19:21.66,0:19:23.66,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:19:24.80,0:19:27.98,English,,0,0,0,,Oh I'm just taking 25 and writing it in binary
Dialogue: 0,0:19:24.80,0:19:27.98,Chinese,,0,0,0,,哦，我只需要25，然后用二进制写出
Dialogue: 0,0:19:28.04,0:19:30.38,English,,0,0,0,,[student speaking]
Dialogue: 0,0:19:28.04,0:19:30.38,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:19:30.38,0:19:34.68,English,,0,0,0,,Yeah if you want to you know you start with the two numbers
Dialogue: 0,0:19:30.38,0:19:34.68,Chinese,,0,0,0,,是的，如果你想知道，你从这两个数字开始
Dialogue: 0,0:19:36.82,0:19:40.62,English,,0,0,0,,I'm not going to do well actually this one's an easy one there's a trick for this
Dialogue: 0,0:19:36.82,0:19:40.62,Chinese,,0,0,0,,我做得不是很好，这个就挺容易的了
Dialogue: 0,0:19:41.20,0:19:44.00,English,,0,0,0,,If you want to know multiply a number by a power-of-2
Dialogue: 0,0:19:41.20,0:19:44.00,Chinese,,0,0,0,,如果你想知道一个数乘以2的幂会发生什么
Dialogue: 0,0:19:44.50,0:19:49.94,English,,0,0,0,,We're going to show that later you just shift it left by two positions
Dialogue: 0,0:19:44.50,0:19:49.94,Chinese,,0,0,0,,我们以后将证明你只需将它左移两个位置
Dialogue: 0,0:19:54.92,0:19:56.22,English,,0,0,0,, So that one's an easy one
Dialogue: 0,0:19:54.92,0:19:56.22,Chinese,,0,0,0,,这是一个很容易的例子
Dialogue: 0,0:19:56.22,0:20:00.86,English,,0,0,0,,Otherwise you have to write out the table and sum all the results and all that stuff
Dialogue: 0,0:19:56.22,0:20:00.86,Chinese,,0,0,0,,否则你必须在纸上写出并计算出所有的和
Dialogue: 0,0:20:02.42,0:20:06.32,English,,0,0,0,,I prefer to what computers do that
Dialogue: 0,0:20:02.42,0:20:06.32,Chinese,,0,0,0,,我更喜欢让计算机去这样做
Dialogue: 0,0:20:14.40,0:20:22.84,English,,0,0,0,,And again this two's complement stuff one interesting feature is that it works for our negative numbers too
Dialogue: 0,0:20:14.40,0:20:22.84,Chinese,,0,0,0,,一个有趣的事实是这对负的补码来说也是对的
Dialogue: 0,0:20:23.82,0:20:27.56,English,,0,0,0,,If you do this trick of throwing away the high-order bits
Dialogue: 0,0:20:23.82,0:20:27.56,Chinese,,0,0,0,,如果你扔掉了多出来的高位
Dialogue: 0,0:20:28.24,0:20:33.10,English,,0,0,0,,And you'll have overflow cases like before because you're throwing away information
Dialogue: 0,0:20:28.24,0:20:33.10,Chinese,,0,0,0,,这会发生和之前一样的溢出现象，因为你丢失了信息
Dialogue: 0,0:20:33.10,0:20:38.74,English,,0,0,0,,But the lower bits if the number is representable you'll get the right result
Dialogue: 0,0:20:33.10,0:20:38.74,Chinese,,0,0,0,,但如果数字可以用低位来表示就可以得到正确的结果
Dialogue: 0,0:20:38.74,0:20:41.64,English,,0,0,0,,So let me just demonstrate to that to you
Dialogue: 0,0:20:38.74,0:20:41.64,Chinese,,0,0,0,,所以，让我向你们展示一下
Dialogue: 0,0:20:45.26,0:20:47.32,English,,0,0,0,, So this is -3
Dialogue: 0,0:20:45.26,0:20:47.32,Chinese,,0,0,0,,所以这是-3
Dialogue: 0,0:20:48.18,0:20:53.40,English,,0,0,0,,But you remember that this is equivalent to 13 as an unsigned number
Dialogue: 0,0:20:48.18,0:20:53.40,Chinese,,0,0,0,,但作为无符号数时这是13
Dialogue: 0,0:20:54.78,0:21:05.78,English,,0,0,0,,And this is -2 which is equivalent to 14 as an unsigned number
Dialogue: 0,0:20:54.78,0:21:05.78,Chinese,,0,0,0,,这是-2，作为无符号数时它等于14
Dialogue: 0,0:21:06.78,0:21:13.54,English,,0,0,0,,So now if we multiply 13*14, you get 182
Dialogue: 0,0:21:06.78,0:21:13.54,Chinese,,0,0,0,,所以如果我们做13 * 14，你就会得到182
Dialogue: 0,0:21:15.24,0:21:18.60,English,,0,0,0,, And that has a hex representation of 0xb6
Dialogue: 0,0:21:15.24,0:21:18.60,Chinese,,0,0,0,,并且它的十六进制表示是0xb6
Dialogue: 0,0:21:28.76,0:21:34.24,English,,0,0,0,,And so just looking at the low-order for bits are 0110 is 6
Dialogue: 0,0:21:28.76,0:21:34.24,Chinese,,0,0,0,,因此，仅看低位0110它是6
Dialogue: 0,0:21:34.90,0:21:39.44,English,,0,0,0,,And indeed that's -3*-2 is 6
Dialogue: 0,0:21:34.90,0:21:39.44,Chinese,,0,0,0,,事实上，-3 * -2是6
Dialogue: 0,0:21:39.72,0:21:43.98,English,,0,0,0,,So the point being oh and I'm waving my hands here
Dialogue: 0,0:21:39.72,0:21:43.98,Chinese,,0,0,0,,我挥手的地方是重点
Dialogue: 0,0:21:43.98,0:21:46.60,English,,0,0,0,,Because I don't want to go through all the details
Dialogue: 0,0:21:43.98,0:21:46.60,Chinese,,0,0,0,,因为我不想详细介绍所有细节
Dialogue: 0,0:21:46.92,0:21:50.80,English,,0,0,0,,But two's complement multiplication also gives you
Dialogue: 0,0:21:46.92,0:21:50.80,Chinese,,0,0,0,,但是这补码乘法也给你一点想法
Dialogue: 0,0:21:51.88,0:21:54.70,English,,0,0,0,,If you can do it using the exact same rules
Dialogue: 0,0:21:51.88,0:21:54.70,Chinese,,0,0,0,,你可以使用完全相同的规则
Dialogue: 0,0:21:55.48,0:21:59.39,English,,0,0,0,, And as you do for unsigned multiplication the exact same hardware
Dialogue: 0,0:21:55.48,0:21:59.39,Chinese,,0,0,0,,正如你对无符号乘法所做的那样，完全相同的硬件
Dialogue: 0,0:21:59.74,0:22:04.88,English,,0,0,0,,I should mention that and there are instructions in the computer
Dialogue: 0,0:21:59.74,0:22:04.88,Chinese,,0,0,0,,我应该提一下，计算机中有说明
Dialogue: 0,0:22:04.88,0:22:09.10,English,,0,0,0,,In ways that you can get the upper word of a multiplication too
Dialogue: 0,0:22:04.88,0:22:09.10,Chinese,,0,0,0,,通过这种方式，你也可以获得乘积的高位
Dialogue: 0,0:22:09.50,0:22:12.70,English,,0,0,0,,And those the bit patterns are different depending on whether
Dialogue: 0,0:22:09.50,0:22:12.70,Chinese,,0,0,0,,这些位模式是不同的通过
Dialogue: 0,0:22:13.72,0:22:16.46,English,,0,0,0,,it's treated as a two's complement number versus unsigned
Dialogue: 0,0:22:13.72,0:22:16.46,Chinese,,0,0,0,,被看作是二进制补码或无符号整数
Dialogue: 0,0:22:16.46,0:22:20.64,English,,0,0,0,,So these typically different instructions for doing that computation
Dialogue: 0,0:22:16.46,0:22:20.64,Chinese,,0,0,0,,所以表示这个乘积有不同的表示法
Dialogue: 0,0:22:20.94,0:22:27.72,English,,0,0,0,, But 99% of the time or more you just are looking at this lower part of the product
Dialogue: 0,0:22:20.94,0:22:27.72,Chinese,,0,0,0,,但是99％的时间或者更多你只是在看这个乘积的低位
Dialogue: 0,0:22:27.72,0:22:31.36,English,,0,0,0,,And that's the same whether it's a two's complement or an unsigned
Dialogue: 0,0:22:27.72,0:22:31.36,Chinese,,0,0,0,,无论是补码还是无符号数都是一样的
Dialogue: 0,0:22:33.42,0:22:38.12,English,,0,0,0,, And it handles negative numbers positive but it has these overflow characteristics
Dialogue: 0,0:22:33.42,0:22:38.12,Chinese,,0,0,0,,它把负数变成正数，但它具有这些溢出特征
Dialogue: 0,0:22:43.42,0:22:50.38,English,,0,0,0,,So as I was talking about there's a trick we can do for multiplying by a power-of-2
Dialogue: 0,0:22:43.42,0:22:50.38,Chinese,,0,0,0,,当我在谈论乘以２的幂的技巧时
Dialogue: 0,0:22:50.80,0:22:52.98,English,,0,0,0,,Which is just to shift the number to the left
Dialogue: 0,0:22:50.80,0:22:52.98,Chinese,,0,0,0,,这只是将数字向左移动
Dialogue: 0,0:22:53.32,0:22:56.42,English,,0,0,0,,And you'll often see that when you have in your code
Dialogue: 0,0:22:53.32,0:22:56.42,Chinese,,0,0,0,,当你看你的代码时，你会经常看到这个操作
Dialogue: 0,0:22:56.76,0:23:01.16,English,,0,0,0,, I want to multiply some number by 4 you'll write it in your C code
Dialogue: 0,0:22:56.76,0:23:01.16,Chinese,,0,0,0,,我想将一些数字乘以4，你将它写在你的C代码中
Dialogue: 0,0:23:01.44,0:23:04.12,English,,0,0,0,,If you look at the assembly code you'll see that what
Dialogue: 0,0:23:01.44,0:23:04.12,Chinese,,0,0,0,,如果你看看汇编代码，你会看到
Dialogue: 0,0:23:04.18,0:23:08.42,English,,0,0,0,,The compiler generated is just says oh just shift it left by 2
Dialogue: 0,0:23:04.18,0:23:08.42,Chinese,,0,0,0,,编译器就会说哦，只需将它向左移2
Dialogue: 0,0:23:09.22,0:23:11.98,English,,0,0,0,,So in general and you could see why this is true
Dialogue: 0,0:23:09.22,0:23:11.98,Chinese,,0,0,0,,你可以看出为什么这是对的
Dialogue: 0,0:23:11.98,0:23:34.04,English,,0,0,0,,By the way if you think of the number as the sum of the bits
Dialogue: 0,0:23:11.98,0:23:34.04,Chinese,,0,0,0,,通过认为乘积是和
Dialogue: 0,0:23:34.04,0:23:38.32,English,,0,0,0,,Where X sub I is the if--but and X is the number it represents
Dialogue: 0,0:23:34.04,0:23:38.32,Chinese,,0,0,0,,其中２的Ｉ次幂是位代表的数，X是位上的数字
Dialogue: 0,0:23:38.88,0:23:43.92,English,,0,0,0,,If I want to if I shift everything left by 2
Dialogue: 0,0:23:38.88,0:23:43.92,Chinese,,0,0,0,,如果我把所有数字都向左移２位
Dialogue: 0,0:23:44.12,0:23:50.30,English,,0,0,0,,What I'm effectively doing is increasing their weight by that number of positions
Dialogue: 0,0:23:44.12,0:23:50.30,Chinese,,0,0,0,,我实际上做的是增加他们的权重
Dialogue: 0,0:23:51.16,0:23:55.98,English,,0,0,0,,So let's just shift by one if I shift everything to the left by one
Dialogue: 0,0:23:51.16,0:23:55.98,Chinese,,0,0,0,,如果我将数向左移一位，就是把所有的数字一个一个地向左移
Dialogue: 0,0:24:01.26,0:24:05.90,English,,0,0,0,,Which we write like this and see two left two less symbols
Dialogue: 0,0:24:01.26,0:24:05.90,Chinese,,0,0,0,,我们这样写，看到它就是乘了一个２
Dialogue: 0,0:24:10.36,0:24:15.72,English,,0,0,0,,It's like taking that sum but now weighting the bits by two to the i+1 by one more
Dialogue: 0,0:24:10.36,0:24:15.72,Chinese,,0,0,0,,看这个乘积，就是将原来的权重变成i + 1
Dialogue: 0,0:24:16.12,0:24:20.90,English,,0,0,0,,And of cause that's equal to twice what the original sum was
Dialogue: 0,0:24:16.12,0:24:20.90,Chinese,,0,0,0,,当然相当于原始和的两倍
Dialogue: 0,0:24:23.72,0:24:25.12,English,,0,0,0,, And so we double the number
Dialogue: 0,0:24:23.72,0:24:25.12,Chinese,,0,0,0,,我们乘上了2
Dialogue: 0,0:24:27.48,0:24:34.88,English,,0,0,0,,And that works also even if you shift things
Dialogue: 0,0:24:27.48,0:24:34.88,Chinese,,0,0,0,,即使你移别的数字，这也有效
Dialogue: 0,0:24:35.06,0:24:38.62,English,,0,0,0,,So that you lose some bits right they they shift off to the left
Dialogue: 0,0:24:35.06,0:24:38.62,Chinese,,0,0,0,,但你可能失去正确值，因为他们会向左移动
Dialogue: 0,0:24:39.10,0:24:45.58,English,,0,0,0,,All you're doing is the way multiplication works anyhow of truncating to w bit product
Dialogue: 0,0:24:39.10,0:24:45.58,Chinese,,0,0,0,,你要做的是把乘积截断到w位
Dialogue: 0,0:24:45.76,0:24:52.64,English,,0,0,0,,So you'll see this as I mentioned quite often in in compiled code machine level code
Dialogue: 0,0:24:45.76,0:24:52.64,Chinese,,0,0,0,,以后，我会在编译后的机器级代码中经常提到这一点
Dialogue: 0,0:24:52.64,0:24:56.70,English,,0,0,0,,That they're doing shifts where you might expect them to be doing multiplications
Dialogue: 0,0:24:52.64,0:24:56.70,Chinese,,0,0,0,,当你希望做乘法时，编译器可能会解释为移位
Dialogue: 0,0:24:57.14,0:25:05.12,English,,0,0,0,,And the reason for that as an optimization is historically the multiplication instruction took a lot longer than a shift instruction
Dialogue: 0,0:24:57.14,0:25:05.12,Chinese,,0,0,0,,而这样优化的原因在于乘法指令比起移位指令会花更长的时间
Dialogue: 0,0:25:05.80,0:25:09.00,English,,0,0,0,,Say one clock cycle to do a shift
Dialogue: 0,0:25:05.80,0:25:09.00,Chinese,,0,0,0,,比如一个时钟周期做一次移位
Dialogue: 0,0:25:09.54,0:25:15.60,English,,0,0,0,,And it used to be like 11,12,13 clock cycles to do a multiplication
Dialogue: 0,0:25:09.54,0:25:15.60,Chinese,,0,0,0,,乘法运算却需要11，12，13个时钟周期
Dialogue: 0,0:25:15.92,0:25:18.46,English,,0,0,0,,Nowadays like on computers
Dialogue: 0,0:25:15.92,0:25:18.46,Chinese,,0,0,0,,像在现代计算机上
Dialogue: 0,0:25:20.28,0:25:24.44,English,,0,0,0,,We use the shark machines it only takes three clock cycles to do multiplication
Dialogue: 0,0:25:20.28,0:25:24.44,Chinese,,0,0,0,,我们只需要三个时钟周期来进行乘法运算
Dialogue: 0,0:25:24.44,0:25:27.46,English,,0,0,0,,Because they added a lot of hardware to do that
Dialogue: 0,0:25:24.44,0:25:27.46,Chinese,,0,0,0,,因为他们添加了很多硬件来做到这一点
Dialogue: 0,0:25:27.96,0:25:31.78,English,,0,0,0,,But three clock cycles is still more time than one
Dialogue: 0,0:25:27.96,0:25:31.78,Chinese,,0,0,0,,但是三个时钟周期仍然比一个时钟周期更长
Dialogue: 0,0:25:32.18,0:25:36.42,English,,0,0,0,,And so when you can get away with a shift it's generally a better idea
Dialogue: 0,0:25:32.18,0:25:36.42,Chinese,,0,0,0,,因此，当你能够用移位运算符时，通常是一个更好的主意
Dialogue: 0,0:25:36.42,0:25:41.20,English,,0,0,0,,And the compiler has its own kind of judgment calls on
Dialogue: 0,0:25:36.42,0:25:41.20,Chinese,,0,0,0,,编译器有自己的判断关于
Dialogue: 0,0:25:41.20,0:25:46.36,English,,0,0,0,,When is it more efficient to substitute one up for another
Dialogue: 0,0:25:41.20,0:25:46.36,Chinese,,0,0,0,,何时执行替换会更有效
Dialogue: 0,0:25:51.36,0:25:53.54,English,,0,0,0,, Did we, did I lose ground here?
Dialogue: 0,0:25:51.36,0:25:53.54,Chinese,,0,0,0,,我搞错了吗
Dialogue: 0,0:26:00.74,0:26:10.14,English,,0,0,0,, Okay so the idea that if we want to multiply something by 2^k
Dialogue: 0,0:26:00.74,0:26:10.14,Chinese,,0,0,0,,好吧，如果我们想要将数字乘以2 ^ k
Dialogue: 0,0:26:10.44,0:26:12.58,English,,0,0,0,,We just shift it left by k bit
Dialogue: 0,0:26:10.44,0:26:12.58,Chinese,,0,0,0,,我们只需将它左移k位
Dialogue: 0,0:26:19.04,0:26:24.78,English,,0,0,0,, It turns out that the same almost works for dividing by 2 as well
Dialogue: 0,0:26:19.04,0:26:24.78,Chinese,,0,0,0,,事实上，除以2也可以这样做
Dialogue: 0,0:26:24.80,0:26:32.98,English,,0,0,0,,That if you want to divide something by a power-of-2 you can shift it right by this in the same general
Dialogue: 0,0:26:24.80,0:26:32.98,Chinese,,0,0,0,,如果你想用某个数字除以2的幂，你可以右移数字用同样的方式
Dialogue: 0,0:26:33.52,0:26:36.56,English,,0,0,0,,The only thing that becomes a little bit quirky is
Dialogue: 0,0:26:33.52,0:26:36.56,Chinese,,0,0,0,,唯一变得有点奇怪的是
Dialogue: 0,0:26:36.92,0:26:42.12,English,,0,0,0,,Well what if the number you have is not actually divisible by that power-of-2
Dialogue: 0,0:26:36.92,0:26:42.12,Chinese,,0,0,0,,如果你写出的数字实际上不能被2的幂整除
Dialogue: 0,0:26:51.36,0:26:55.02,English,,0,0,0,,So for example if we had the number 01
Dialogue: 0,0:26:51.36,0:26:55.02,Chinese,,0,0,0,,例如，如果我们有数字01
Dialogue: 0,0:26:58.14,0:27:01.58,English,,0,0,0,,I want. I'm going to use this
Dialogue: 0,0:26:58.14,0:27:01.58,Chinese,,0,0,0,,我打算用这个
Dialogue: 0,0:27:07.48,0:27:09.74,English,,0,0,0,,Yeah so that's 6
Dialogue: 0,0:27:07.48,0:27:09.74,Chinese,,0,0,0,,是的，这是6
Dialogue: 0,0:27:10.90,0:27:17.46,English,,0,0,0,,So if we shift it right by one we'll get 0010
Dialogue: 0,0:27:10.90,0:27:17.46,Chinese,,0,0,0,,因此，如果我们将它右移一位，我们将获得0010
Dialogue: 0,0:27:19.88,0:27:21.26,English,,0,0,0,, (00)11 thank you
Dialogue: 0,0:27:19.88,0:27:21.26,Chinese,,0,0,0,,（00）11谢谢你
Dialogue: 0,0:27:22.12,0:27:26.06,English,,0,0,0,,Which is 3 and that's 6/3=2
Dialogue: 0,0:27:22.12,0:27:26.06,Chinese,,0,0,0,,这是3，那是6/3 = 2
Dialogue: 0,0:27:26.28,0:27:27.76,English,,0,0,0,, If we shift that again
Dialogue: 0,0:27:26.28,0:27:27.76,Chinese,,0,0,0,,如果我们再次移位它
Dialogue: 0,0:27:32.10,0:27:37.78,English,,0,0,0,,We'll get 1.But of cause you know that three-halves or 1.5
Dialogue: 0,0:27:32.10,0:27:37.78,Chinese,,0,0,0,,我们会得到1.但是结果应该是三分之一或1.5
Dialogue: 0,0:27:39.24,0:27:46.08,English,,0,0,0,,The rule on integer division is you round it down round it toward 0
Dialogue: 0,0:27:39.24,0:27:46.08,Chinese,,0,0,0,,整数除法的规则是将它向０向下舍入
Dialogue: 0,0:27:47.40,0:27:49.96,English,,0,0,0,,And so that goes to 1 so
Dialogue: 0,0:27:47.40,0:27:49.96,Chinese,,0,0,0,,所以这应该是1
Dialogue: 0,0:27:50.90,0:27:54.40,English,,0,0,0,,This is what the unsigned case works fine
Dialogue: 0,0:27:50.90,0:27:54.40,Chinese,,0,0,0,,这是无符号整数正常工作的情况
Dialogue: 0,0:27:55.30,0:28:00.80,English,,0,0,0,, The signed case which I don't have a slide for
Dialogue: 0,0:27:55.30,0:28:00.80,Chinese,,0,0,0,,补码的情况，我没有幻灯片
Dialogue: 0,0:28:05.84,0:28:09.80,English,,0,0,0,, Is a little bit less of pretty
Dialogue: 0,0:28:05.84,0:28:09.80,Chinese,,0,0,0,,有点不太漂亮
Dialogue: 0,0:28:11.34,0:28:17.28,English,,0,0,0,,Well first of all you notice if it's a positive number the shifting rights going to be the right
Dialogue: 0,0:28:11.34,0:28:17.28,Chinese,,0,0,0,,首先，你注意到，如果这是一个正数，那么移位会是正确的
Dialogue: 0,0:28:18.44,0:28:20.20,English,,0,0,0,,Just as is for unsigned
Dialogue: 0,0:28:18.44,0:28:20.20,Chinese,,0,0,0,,就像无符号整数的一样
Dialogue: 0,0:28:20.34,0:28:28.08,English,,0,0,0,,But let's take a number that is negative
Dialogue: 0,0:28:20.34,0:28:28.08,Chinese,,0,0,0,,但是，当我们用一个负数时
Dialogue: 0,0:28:28.52,0:28:34.70,English,,0,0,0,,So this is -6 right
Dialogue: 0,0:28:28.52,0:28:34.70,Chinese,,0,0,0,,所以这是-6
Dialogue: 0,0:28:34.82,0:28:40.42,English,,0,0,0,,Now here's where remember I told you in the previous lecture
Dialogue: 0,0:28:34.82,0:28:40.42,Chinese,,0,0,0,,这里我记得在上一堂课中告诉过你们
Dialogue: 0,0:28:40.42,0:28:45.80,English,,0,0,0,, There's two ways to do shifting there is logical shifting where you fill in with 0
Dialogue: 0,0:28:40.42,0:28:45.80,Chinese,,0,0,0,,有两种进行移位的方法，逻辑移位，用０来填充
Dialogue: 0,0:28:46.22,0:28:49.80,English,,0,0,0,,And arithmetic shifting where you fill in with ones
Dialogue: 0,0:28:46.22,0:28:49.80,Chinese,,0,0,0,,算术移位用１来填充   (对这个数来说)
Dialogue: 0,0:28:50.68,0:28:56.92,English,,0,0,0,,And guess where arithmetic shifting comes in this is it
Dialogue: 0,0:28:50.68,0:28:56.92,Chinese,,0,0,0,,猜猜看算术转移用来干什么
Dialogue: 0,0:28:57.42,0:29:00.68,English,,0,0,0,,When you want to preserve the sign of a number
Dialogue: 0,0:28:57.42,0:29:00.68,Chinese,,0,0,0,,当你想要保留数字的符号时
Dialogue: 0,0:29:00.88,0:29:04.92,English,,0,0,0,,while you're dividing it by power-of-2 you want arithmetic shifts
Dialogue: 0,0:29:00.88,0:29:04.92,Chinese,,0,0,0,,当你将它除以2的幂时，你需要用算术移位
Dialogue: 0,0:29:05.64,0:29:09.94,English,,0,0,0,,So if we shift this by one we'll keep that sign bit
Dialogue: 0,0:29:05.64,0:29:09.94,Chinese,,0,0,0,,如果我们将其移动一位，我们必须保持符号位
Dialogue: 0,0:29:10.64,0:29:15.48,English,,0,0,0,,And then copy the other ones over right
Dialogue: 0,0:29:10.64,0:29:15.48,Chinese,,0,0,0,,然后将其他的数字移到到右边
Dialogue: 0,0:29:15.50,0:29:21.16,English,,0,0,0,,So we just preserve this bit here and copied the other ones over
Dialogue: 0,0:29:15.50,0:29:21.16,Chinese,,0,0,0,,所以我们保留这个比特并复制其他的比特
Dialogue: 0,0:29:22.36,0:29:28.10,English,,0,0,0,, And this is -3.And so that's good
Dialogue: 0,0:29:22.36,0:29:28.10,Chinese,,0,0,0,,这是-3。所以这很好
Dialogue: 0,0:29:28.84,0:29:31.32,English,,0,0,0,,But now if we shift again arithmetic
Dialogue: 0,0:29:28.84,0:29:31.32,Chinese,,0,0,0,,但现在如果我们再次使用算术右移
Dialogue: 0,0:29:34.44,0:29:42.24,English,,0,0,0,, We will get what? -２
Dialogue: 0,0:29:34.44,0:29:42.24,Chinese,,0,0,0,,我们会得到什么？ -2
Dialogue: 0,0:29:42.64,0:29:46.52,English,,0,0,0,,I can see you guys need to know how to negate numbers right
Dialogue: 0,0:29:42.64,0:29:46.52,Chinese,,0,0,0,,我可以看到你们想知道如何正确的对负数执行运算
Dialogue: 0,0:29:46.52,0:29:49.46,English,,0,0,0,,You don't know that so I'll show you in a second
Dialogue: 0,0:29:46.52,0:29:49.46,Chinese,,0,0,0,,你不知道，所以我会在一秒钟内告诉你
Dialogue: 0,0:29:50.02,0:29:53.94,English,,0,0,0,,So here is a little bit problematic that we shifted
Dialogue: 0,0:29:50.02,0:29:53.94,Chinese,,0,0,0,,这里的移位出了一点问题
Dialogue: 0,0:29:54.88,0:29:56.86,English,,0,0,0,,We want to divide by two
Dialogue: 0,0:29:54.88,0:29:56.86,Chinese,,0,0,0,,我们想要除以2
Dialogue: 0,0:29:58.08,0:30:01.76,English,,0,0,0,,But the rule should be the same that you should round toward zero
Dialogue: 0,0:29:58.08,0:30:01.76,Chinese,,0,0,0,,规则应该是相同的，你应该向零舍入
Dialogue: 0,0:30:02.10,0:30:04.86,English,,0,0,0,,And what this is doing is it's rounding toward
Dialogue: 0,0:30:02.10,0:30:04.86,Chinese,,0,0,0,,而它正在做的是向
Dialogue: 0,0:30:05.32,0:30:11.04,English,,0,0,0,,Minus infinity it's rounding toward a more negative number than the the true thing
Dialogue: 0,0:30:05.32,0:30:11.04,Chinese,,0,0,0,,负无穷舍入，它向一个比真的结果更小的数舍入
Dialogue: 0,0:30:12.76,0:30:15.10,English,,0,0,0,,And so there's a little cute little trick
Dialogue: 0,0:30:12.76,0:30:15.10,Chinese,,0,0,0,,所以这里有一个小技巧
Dialogue: 0,0:30:17.08,0:30:23.08,English,,0,0,0,, That says before you shift before you divide by a power-of-2 before you do the shift
Dialogue: 0,0:30:17.08,0:30:23.08,Chinese,,0,0,0,,就是说，你在执行除以2的幂的移位之前
Dialogue: 0,0:30:23.90,0:30:25.22,English,,0,0,0,,You should add a bias
Dialogue: 0,0:30:23.90,0:30:25.22,Chinese,,0,0,0,,你应该加一个偏移量
Dialogue: 0,0:30:31.64,0:30:34.00,English,,0,0,0,,Which in this case would just be one
Dialogue: 0,0:30:31.64,0:30:34.00,Chinese,,0,0,0,,在这种情况下，这只能是一个
Dialogue: 0,0:30:34.00,0:30:36.06,English,,0,0,0,,You know and I'll tell you where that comes from
Dialogue: 0,0:30:34.00,0:30:36.06,Chinese,,0,0,0,,我会告诉你它是从哪里得到的
Dialogue: 0,0:30:36.48,0:30:45.70,English,,0,0,0,, And so if we add those numbers together we'll get 1110 right
Dialogue: 0,0:30:36.48,0:30:45.70,Chinese,,0,0,0,,因此，如果我们将这些数字加在一起，我们将获得1110
Dialogue: 0,0:30:46.10,0:30:52.78,English,,0,0,0,,And now when we do the shift on that we'll get 1111
Dialogue: 0,0:30:46.10,0:30:52.78,Chinese,,0,0,0,,然后我们再做移位，我们将获得1111
Dialogue: 0,0:30:53.74,0:30:55.24,English,,0,0,0,,And that's -1
Dialogue: 0,0:30:53.74,0:30:55.24,Chinese,,0,0,0,,得到-1
Dialogue: 0,0:30:55.64,0:30:59.30,English,,0,0,0,,So there's a trick and you'll again you'll see the compiler doing this where
Dialogue: 0,0:30:55.64,0:30:59.30,Chinese,,0,0,0,,这里有一个现象，你会看到编译器在
Dialogue: 0,0:31:00.00,0:31:04.14,English,,0,0,0,,You have in your code divided by 16 and we'll add a bias
Dialogue: 0,0:31:00.00,0:31:04.14,Chinese,,0,0,0,,除以16的时候，会先添加偏移值
Dialogue: 0,0:31:04.38,0:31:07.60,English,,0,0,0,,And then it will do a right shift instead of calling division
Dialogue: 0,0:31:04.38,0:31:07.60,Chinese,,0,0,0,,然后它将进行右移而不是调用除法
Dialogue: 0,0:31:07.72,0:31:13.68,English,,0,0,0,,And by the way division really really is slow even on a modern computer like what you have
Dialogue: 0,0:31:07.72,0:31:13.68,Chinese,,0,0,0,,顺便说一句，即使在现代计算机上，除法仍然很慢
Dialogue: 0,0:31:13.98,0:31:19.00,English,,0,0,0,,The shark machines it takes 30 plus Hawk cycles
Dialogue: 0,0:31:13.98,0:31:19.00,Chinese,,0,0,0,,计算机需要用30个计算周期
Dialogue: 0,0:31:19.44,0:31:23.14,English,,0,0,0,,So anytime the compiler can avoid figure out a trick
Dialogue: 0,0:31:19.44,0:31:23.14,Chinese,,0,0,0,,因此编译器可以尽力避免这种现象
Dialogue: 0,0:31:23.14,0:31:26.86,English,,0,0,0,,That does it with shifting and tweaking things around it will
Dialogue: 0,0:31:23.14,0:31:26.86,Chinese,,0,0,0,,它可以通过移位和其他调整来实现
Dialogue: 0,0:31:28.14,0:31:31.38,English,,0,0,0,,Oh so I realize I should tell you
Dialogue: 0,0:31:28.14,0:31:31.38,Chinese,,0,0,0,,哦，我应该告诉你
Dialogue: 0,0:31:31.38,0:31:36.86,English,,0,0,0,,There's a couple ways you can negate a number
Dialogue: 0,0:31:31.38,0:31:36.86,Chinese,,0,0,0,,有几种方法可以对一个数字取负
Dialogue: 0,0:31:36.86,0:31:41.58,English,,0,0,0,,That are handy to know if you ever have to do it in your head or on paper
Dialogue: 0,0:31:36.86,0:31:41.58,Chinese,,0,0,0,,这很简单，你可以在纸上或在脑中去做它
Dialogue: 0,0:31:43.70,0:31:46.74,English,,0,0,0,, And the standard way is what's called complement and increment
Dialogue: 0,0:31:43.70,0:31:46.74,Chinese,,0,0,0,,最常用的方式是对数取反再加１
Dialogue: 0,0:31:47.26,0:31:51.88,English,,0,0,0,,So this is how do I go from X to -X
Dialogue: 0,0:31:47.26,0:31:51.88,Chinese,,0,0,0,,这就是把ｘ变为－ｘ的方法
Dialogue: 0,0:31:52.68,0:31:59.44,English,,0,0,0,,So if I have a number and I want to negate it
Dialogue: 0,0:31:52.68,0:31:59.44,Chinese,,0,0,0,,如果我有一个数字，我想对它取负
Dialogue: 0,0:31:59.48,0:32:04.82,English,,0,0,0,,Whether it's currently a negative number or it's a positive number the same trick works
Dialogue: 0,0:31:59.48,0:32:04.82,Chinese,,0,0,0,,无论它目前是负数还是正数，都可以用同样的方法去做
Dialogue: 0,0:32:05.08,0:32:07.86,English,,0,0,0,,What I'll do is complement it meaning I'll flip all the bits
Dialogue: 0,0:32:05.08,0:32:07.86,Chinese,,0,0,0,,我要做的就是对它取反，意味着我将反转所有的位
Dialogue: 0,0:32:11.64,0:32:18.98,English,,0,0,0,,And then I'll add one to that
Dialogue: 0,0:32:11.64,0:32:18.98,Chinese,,0,0,0,,然后我会加一个１
Dialogue: 0,0:32:18.98,0:32:25.32,English,,0,0,0,, And do the regular sum
Dialogue: 0,0:32:18.98,0:32:25.32,Chinese,,0,0,0,,在做常规求和
Dialogue: 0,0:32:25.32,0:32:30.61,English,,0,0,0,, And so this is 6,this is -6
Dialogue: 0,0:32:25.32,0:32:30.61,Chinese,,0,0,0,,这是6，这是-6
Dialogue: 0,0:32:31.48,0:32:33.24,English,,0,0,0,,So if you ever have to do it by hand
Dialogue: 0,0:32:31.48,0:32:33.24,Chinese,,0,0,0,,如果你曾经做过
Dialogue: 0,0:32:33.24,0:32:36.54,English,,0,0,0,,That's the way to do it complement and increment  and it goes the other way
Dialogue: 0,0:32:33.24,0:32:36.54,Chinese,,0,0,0,,这是用取反和增量的方式，那再做一次
Dialogue: 0,0:32:37.02,0:32:38.62,English,,0,0,0,,You'll see if I compliment this
Dialogue: 0,0:32:37.02,0:32:38.62,Chinese,,0,0,0,,你会看到我非常喜欢这一点
Dialogue: 0,0:32:44.58,0:32:51.84,English,,0,0,0,,And I increment it I'll get back to my previous number
Dialogue: 0,0:32:44.58,0:32:51.84,Chinese,,0,0,0,,我对它加１，我会得到之前的值
Dialogue: 0,0:32:52.14,0:32:53.44,English,,0,0,0,,So that's a trick
Dialogue: 0,0:32:52.14,0:32:53.44,Chinese,,0,0,0,,所以这是一个奇特的现象
Dialogue: 0,0:32:56.28,0:32:59.68,English,,0,0,0,,That is pretty much only useful when you do things on the blackboard
Dialogue: 0,0:32:56.28,0:32:59.68,Chinese,,0,0,0,,只有当你在纸上写时，这才会非常有帮助
Dialogue: 0,0:32:59.88,0:33:02.60,English,,0,0,0,,Or when you have to solve a problem in data lab
Dialogue: 0,0:32:59.88,0:33:02.60,Chinese,,0,0,0,,或者当你必须解决lab中的某些问题时
Dialogue: 0,0:33:13.02,0:33:21.36,English,,0,0,0,,Anyways the this idea of doing a using up shifting to the right to do power-of-2 division
Dialogue: 0,0:33:13.02,0:33:21.36,Chinese,,0,0,0,,无论如何，这个想法是用向右的移位来表示除以2的幂
Dialogue: 0,0:33:21.36,0:33:25.58,English,,0,0,0,, is actually that's the whole justification for arithmetic shifting in the first place
Dialogue: 0,0:33:21.36,0:33:25.58,Chinese,,0,0,0,,这就是用算术右移的第一个理由
Dialogue: 0,0:33:25.98,0:33:31.68,English,,0,0,0,,Which by the way in and see there's no fixed requirement
Dialogue: 0,0:33:25.98,0:33:31.68,Chinese,,0,0,0,,顺便说一下，在C语言中没有明确的要求
Dialogue: 0,0:33:31.68,0:33:35.88,English,,0,0,0,,For how shifting works in c for signed numbers
Dialogue: 0,0:33:31.68,0:33:35.88,Chinese,,0,0,0,,对有符号数执行什么移位
Dialogue: 0,0:33:35.88,0:33:38.20,English,,0,0,0,,For unsigned it has to be a logical shift
Dialogue: 0,0:33:35.88,0:33:38.20,Chinese,,0,0,0,,对于无符号，它必须是一个逻辑移位
Dialogue: 0,0:33:38.74,0:33:43.50,English,,0,0,0,,Sign numbers the C standard says there's no fixed definition
Dialogue: 0,0:33:38.74,0:33:43.50,Chinese,,0,0,0,,对于有符号数字,C标准没有明确的规定
Dialogue: 0,0:33:43.74,0:33:48.56,English,,0,0,0,, The reality is on our machines most machines just about every machine out there
Dialogue: 0,0:33:43.74,0:33:48.56,Chinese,,0,0,0,,事实上在我们的机器上，大多数机器上
Dialogue: 0,0:33:49.24,0:33:55.14,English,,0,0,0,,When it's a two's complement number when it's a negative where it's the signed number it's two's complement
Dialogue: 0,0:33:49.24,0:33:55.14,Chinese,,0,0,0,,当它是一个补码时，它是一个负数时，代表有符号数时
Dialogue: 0,0:33:55.40,0:33:58.12,English,,0,0,0,,And when you do a shift it will be an earth metic shift
Dialogue: 0,0:33:55.40,0:33:58.12,Chinese,,0,0,0,,当你做一次移位时，这将是一个巨大的变化
Dialogue: 0,0:34:07.22,0:34:11.44,English,,0,0,0,,So getting back to them summarizing this integer arithmetic
Dialogue: 0,0:34:07.22,0:34:11.44,Chinese,,0,0,0,,所以回到之前，总结整数运算
Dialogue: 0,0:34:11.90,0:34:15.79,English,,0,0,0,,You see that first of all whether it's signed your unsigned
Dialogue: 0,0:34:11.90,0:34:15.79,Chinese,,0,0,0,,你首先要看它是无符号数还是有符号数
Dialogue: 0,0:34:16.22,0:34:21.64,English,,0,0,0,,The addition or multiplication operations are the same
Dialogue: 0,0:34:16.22,0:34:21.64,Chinese,,0,0,0,,加法或乘法运算是相同的
Dialogue: 0,0:34:22.00,0:34:25.84,English,,0,0,0,,Whether it's a unsigned number or two's complement
Dialogue: 0,0:34:22.00,0:34:25.84,Chinese,,0,0,0,,无论是无符号数还是有符号数
Dialogue: 0,0:34:27.06,0:34:31.02,English,,0,0,0,,And it works the negative stuff works out
Dialogue: 0,0:34:27.06,0:34:31.02,Chinese,,0,0,0,,它不会起负作用
Dialogue: 0,0:34:31.58,0:34:33.98,English,,0,0,0,,As long as you don't have an overflow
Dialogue: 0,0:34:31.58,0:34:33.98,Chinese,,0,0,0,,只要你没有溢出
Dialogue: 0,0:34:34.38,0:34:36.56,English,,0,0,0,,And you can end up with an overflow
Dialogue: 0,0:34:34.38,0:34:36.56,Chinese,,0,0,0,,而你最终可能会溢出
Dialogue: 0,0:34:38.48,0:34:43.02,English,,0,0,0,,Only one type of overflow for unsigned and two types for signed numbers
Dialogue: 0,0:34:38.48,0:34:43.02,Chinese,,0,0,0,,无符号数只有一种溢出而有符号数有两种溢出
Dialogue: 0,0:34:43.64,0:34:48.26,English,,0,0,0,, But it's not like they just overflow on generate random numbers
Dialogue: 0,0:34:43.64,0:34:48.26,Chinese,,0,0,0,,但它们并不是溢出就生成随机数
Dialogue: 0,0:34:48.26,0:34:54.24,English,,0,0,0,,There is some a pattern to what result what they are and how they can be interpreted
Dialogue: 0,0:34:48.26,0:34:54.24,Chinese,,0,0,0,,这有一些规则说明他们是如何变化的
Dialogue: 0,0:35:01.72,0:35:07.46,English,,0,0,0,,So we I talked about this a little bit last time and gave this example similar to this
Dialogue: 0,0:35:01.72,0:35:07.46,Chinese,,0,0,0,,所以我们上次谈了一小点，并给出了与此类似的例子
Dialogue: 0,0:35:07.46,0:35:09.58,English,,0,0,0,,But let me go over it a little bit more
Dialogue: 0,0:35:07.46,0:35:09.58,Chinese,,0,0,0,,但是让我再多谈一下
Dialogue: 0,0:35:10.94,0:35:17.42,English,,0,0,0,,One thing you might think of wow if this unsigned and signed stuff gets so murky
Dialogue: 0,0:35:10.94,0:35:17.42,Chinese,,0,0,0,,你可能会认为是既然无符号整数这么复杂
Dialogue: 0,0:35:17.46,0:35:19.98,English,,0,0,0,,And we saw some funny examples last time
Dialogue: 0,0:35:17.46,0:35:19.98,Chinese,,0,0,0,,并且我们上次也看到了一些奇怪的例子
Dialogue: 0,0:35:20.34,0:35:24.92,English,,0,0,0,, Maybe we should just banished unsigned numbers from the universe
Dialogue: 0,0:35:20.34,0:35:24.92,Chinese,,0,0,0,,那我们就应该消除无符号数
Dialogue: 0,0:35:25.40,0:35:27.12,English,,0,0,0,, And only allow two's complement
Dialogue: 0,0:35:25.40,0:35:27.12,Chinese,,0,0,0,,并且只允许补码存在
Dialogue: 0,0:35:27.44,0:35:31.92,English,,0,0,0,,And that's exactly the rule that was adopted for example in Java
Dialogue: 0,0:35:27.44,0:35:31.92,Chinese,,0,0,0,,而这已经被Java采用
Dialogue: 0,0:35:31.92,0:35:34.24,English,,0,0,0,,They said is too weird
Dialogue: 0,0:35:31.92,0:35:34.24,Chinese,,0,0,0,,他们说太奇怪了
Dialogue: 0,0:35:35.98,0:35:38.86,English,,0,0,0,,What let's just say every number is two's complement
Dialogue: 0,0:35:35.98,0:35:38.86,Chinese,,0,0,0,,每个数字都应该是补码
Dialogue: 0,0:35:39.22,0:35:47.92,English,,0,0,0,, The only trick they did was they put in a triple right shift
Dialogue: 0,0:35:39.22,0:35:47.92,Chinese,,0,0,0,,他们做的唯一改变是他们把>>>
Dialogue: 0,0:35:51.18,0:35:54.52,English,,0,0,0,,Means logical shift this is Java this is not C
Dialogue: 0,0:35:51.18,0:35:54.52,Chinese,,0,0,0,,认为是逻辑右移，这是Java不是ｃ
Dialogue: 0,0:36:02.16,0:36:12.40,English,,0,0,0,, Whereas the double is a arithmetic
Dialogue: 0,0:36:02.16,0:36:12.40,Chinese,,0,0,0,,而把>>认为是算术右移
Dialogue: 0,0:36:13.74,0:36:18.00,English,,0,0,0,,So because they realized there's a lot of cute little times
Dialogue: 0,0:36:13.74,0:36:18.00,Chinese,,0,0,0,,因为他们意识到有很多有趣的小问题
Dialogue: 0,0:36:18.00,0:36:20.18,English,,0,0,0,,When you want to play tricks with things
Dialogue: 0,0:36:18.00,0:36:20.18,Chinese,,0,0,0,,当你想搞点花哨的东西时
Dialogue: 0,0:36:20.50,0:36:22.94,English,,0,0,0,,And you need that logical right shift
Dialogue: 0,0:36:20.50,0:36:22.94,Chinese,,0,0,0,,你需要逻辑右移
Dialogue: 0,0:36:23.96,0:36:29.52,English,,0,0,0,,So that's actually one approach or other more modern languages and C are saying
Dialogue: 0,0:36:23.96,0:36:29.52,Chinese,,0,0,0,,所以这实际上是一种方法，其他的现代语言和c
Dialogue: 0,0:36:29.82,0:36:31.92,English,,0,0,0,,It's okay to have signed and unsigned
Dialogue: 0,0:36:29.82,0:36:31.92,Chinese,,0,0,0,,说有符号数和无符号数都是可以的
Dialogue: 0,0:36:32.16,0:36:35.96,English,,0,0,0,,But we don't want them sort of mysteriously being cast back and forth
Dialogue: 0,0:36:32.16,0:36:35.96,Chinese,,0,0,0,,但是我们不希望他们以一种诡异的方式搞来搞去
Dialogue: 0,0:36:35.96,0:36:38.82,English,,0,0,0,,In ways that the programmer might not recognize
Dialogue: 0,0:36:35.96,0:36:38.82,Chinese,,0,0,0,,可能无法被程序员所理解
Dialogue: 0,0:36:38.82,0:36:43.70,English,,0,0,0,, And so you have to explicitly do a cast rather than implicitly
Dialogue: 0,0:36:38.82,0:36:43.70,Chinese,,0,0,0,,所以你必须做一个明确的映射而不是暗示
Dialogue: 0,0:36:44.24,0:36:45.86,English,,0,0,0,, And I think that's the better approach
Dialogue: 0,0:36:44.24,0:36:45.86,Chinese,,0,0,0,,我认为这是一个更好的方法
Dialogue: 0,0:36:45.86,0:36:49.74,English,,0,0,0,, But C as I mentioned does this implicit casting
Dialogue: 0,0:36:45.86,0:36:49.74,Chinese,,0,0,0,,但正如我所提到的那样C是隐式投射
Dialogue: 0,0:36:50.00,0:36:55.28,English,,0,0,0,,And so as we saw for last time what happens with this program when you run it
Dialogue: 0,0:36:50.00,0:36:55.28,Chinese,,0,0,0,,正如我们上次看到的那样，当你运行它时，这个程序会做什么
Dialogue: 0,0:36:59.15,0:37:08.89,English,,0,0,0,,To count down through an array do you remember?
Dialogue: 0,0:36:59.15,0:37:08.89,Chinese,,0,0,0,,是通过数组来做倒计时，你们还记得吗？
Dialogue: 0,0:37:09.24,0:37:14.94,English,,0,0,0,,Well as I if it's unsigned what will happen with this test
Dialogue: 0,0:37:09.24,0:37:14.94,Chinese,,0,0,0,,好吧，如果它是无符号整数，这个程序会发生什么
Dialogue: 0,0:37:16.58,0:37:19.64,English,,0,0,0,,It always succeeds so the thing will be in an infinite loop
Dialogue: 0,0:37:16.58,0:37:19.64,Chinese,,0,0,0,,它总是成功，所以程序将处于无限循环中
Dialogue: 0,0:37:20.18,0:37:22.68,English,,0,0,0,,Actually what will happen is it will try to access
Dialogue: 0,0:37:20.18,0:37:22.68,Chinese,,0,0,0,,实际上不管发生什么，它总会尝试访问
Dialogue: 0,0:37:23.38,0:37:27.66,English,,0,0,0,,I will go down to 0 and then it will wrap around to become
Dialogue: 0,0:37:23.38,0:37:27.66,Chinese,,0,0,0,,我将它减到0然后它会回去成为
Dialogue: 0,0:37:28.22,0:37:30.14,English,,0,0,0,, The largest possible unsigned number
Dialogue: 0,0:37:28.22,0:37:30.14,Chinese,,0,0,0,,最大的无符号数
Dialogue: 0,0:37:30.14,0:37:34.08,English,,0,0,0,,Which is probably way out of bounds and it will give a memory error
Dialogue: 0,0:37:30.14,0:37:34.08,Chinese,,0,0,0,,可能会超出数组边界，然后会给出内存错误
Dialogue: 0,0:37:35.34,0:37:37.64,English,,0,0,0,,But it won't do what's supposed to be
Dialogue: 0,0:37:35.34,0:37:37.64,Chinese,,0,0,0,,但它不会做应该做的事情
Dialogue: 0,0:37:37.82,0:37:42.67,English,,0,0,0,,And as I mentioned before these things there is a lot of sneaky ways this problem can show up
Dialogue: 0,0:37:37.82,0:37:42.67,Chinese,,0,0,0,,正如我之前提到的那样，这个问题可以展示许多诡异的问题
Dialogue: 0,0:37:43.00,0:37:44.90,English,,0,0,0,, In ways you might never think of
Dialogue: 0,0:37:43.00,0:37:44.90,Chinese,,0,0,0,,以你可能永远不会想到的方式
Dialogue: 0,0:37:45.28,0:37:55.16,English,,0,0,0,,So for example the operator sizeof is defined to say how big a particular datatype is
Dialogue: 0,0:37:45.28,0:37:55.16,Chinese,,0,0,0,,例如，运算符sizeof被定义为表示数据类型的大小
Dialogue: 0,0:37:55.86,0:37:57.38,English,,0,0,0,,It's a very useful operator
Dialogue: 0,0:37:55.86,0:37:57.38,Chinese,,0,0,0,,这是一个非常有用的运算符
Dialogue: 0,0:37:57.38,0:38:03.48,English,,0,0,0,, But it's its return value is a what's called a size underscore t
Dialogue: 0,0:37:57.38,0:38:03.48,Chinese,,0,0,0,,但它的返回值是一个size_t
Dialogue: 0,0:38:03.48,0:38:07.12,English,,0,0,0,,Which is defined to be a long unsigned number
Dialogue: 0,0:38:03.48,0:38:07.12,Chinese,,0,0,0,,它被定义为 unsigned long 
Dialogue: 0,0:38:07.70,0:38:12.88,English,,0,0,0,, And so if we just throw in a constant like this
Dialogue: 0,0:38:07.70,0:38:12.88,Chinese,,0,0,0,,所以，如果我们就这样把它输出
Dialogue: 0,0:38:13.14,0:38:17.02,English,,0,0,0,, Then this subtraction we have a sign in is now int
Dialogue: 0,0:38:13.14,0:38:17.02,Chinese,,0,0,0,,然后这个减法中有一个int类型的值
Dialogue: 0,0:38:17.54,0:38:19.60,English,,0,0,0,,But sizeof is unsgned
Dialogue: 0,0:38:17.54,0:38:19.60,Chinese,,0,0,0,,但sizeof是无符号的
Dialogue: 0,0:38:19.86,0:38:23.38,English,,0,0,0,,And so it will cast that to be unsigned implicitly
Dialogue: 0,0:38:19.86,0:38:23.38,Chinese,,0,0,0,,因此它将 int 自动转换为无符号的
Dialogue: 0,0:38:24.15,0:38:28.06,English,,0,0,0,,And when you compare it to 0 you'll have the same problem as before
Dialogue: 0,0:38:24.15,0:38:28.06,Chinese,,0,0,0,,当你将它与0比较时，你会遇到和以前一样的问题
Dialogue: 0,0:38:29.40,0:38:35.00,English,,0,0,0,, So just to show you that these things can sneak in very tricky ways
Dialogue: 0,0:38:29.40,0:38:35.00,Chinese,,0,0,0,,所以只是为了告诉你这些东西在你想耍点小聪明的时候会变的十分诡异
Dialogue: 0,0:38:35.46,0:38:41.86,English,,0,0,0,,So one way to do that then is just don't use unsigned like
Dialogue: 0,0:38:35.46,0:38:41.86,Chinese,,0,0,0,,因此，避免这个的一种方法就是不要这样使用无符号整型
Dialogue: 0,0:38:41.92,0:38:47.14,English,,0,0,0,,And make sure if this is a a possible
Dialogue: 0,0:38:41.92,0:38:47.14,Chinese,,0,0,0,,如果这是可能的请确保
Dialogue: 0,0:38:48.26,0:38:51.36,English,,0,0,0,,Unsigned number you cast it to signed
Dialogue: 0,0:38:48.26,0:38:51.36,Chinese,,0,0,0,,你已经把无符号数变为有符号数
Dialogue: 0,0:38:51.70,0:38:54.34,English,,0,0,0,,You make sure this is recognized and signed
Dialogue: 0,0:38:51.70,0:38:54.34,Chinese,,0,0,0,,你确保这是是有符号整数
Dialogue: 0,0:38:54.94,0:38:57.72,English,,0,0,0,, But there's another way that actually
Dialogue: 0,0:38:54.94,0:38:57.72,Chinese,,0,0,0,,但实际上还有另一种方式
Dialogue: 0,0:38:57.96,0:39:02.40,English,,0,0,0,, At least there's a fellow over the software engineering Institute named Robert Seacord
Dialogue: 0,0:38:57.96,0:39:02.40,Chinese,,0,0,0,,至少有一位名叫Robert Seacord的软件工程学院的研究员
Dialogue: 0,0:39:03.02,0:39:12.88,English,,0,0,0,, Who has written the books that are suited to considered the  this the gold standard for how to write secure code
Dialogue: 0,0:39:03.02,0:39:12.88,Chinese,,0,0,0,,他编写了如何写出安全代码的黄金标准
Dialogue: 0,0:39:13.20,0:39:16.82,English,,0,0,0,,He works for this organization called the computer emergency response team
Dialogue: 0,0:39:13.20,0:39:16.82,Chinese,,0,0,0,,他在一个名为计算机应急响应小组的组织工作
Dialogue: 0,0:39:16.82,0:39:24.72,English,,0,0,0,, Which is out there tracking down bad things going on in computer security
Dialogue: 0,0:39:16.82,0:39:24.72,Chinese,,0,0,0,,这个组织是去找出计算机安全中存在的威胁
Dialogue: 0,0:39:25.18,0:39:30.20,English,,0,0,0,,And one of the things he and others have done is to try and come up with standards
Dialogue: 0,0:39:25.18,0:39:30.20,Chinese,,0,0,0,,他和其他人所做的一件事就是尝试提出标准
Dialogue: 0,0:39:30.20,0:39:36.04,English,,0,0,0,, So that people who write programs will you know avoid some of the pitfalls
Dialogue: 0,0:39:30.20,0:39:36.04,Chinese,,0,0,0,,以便编写程序的人避免一些
Dialogue: 0,0:39:36.04,0:39:40.74,English,,0,0,0,, That make their programs vulnerable to the security of was to attack
Dialogue: 0,0:39:36.04,0:39:40.74,Chinese,,0,0,0,,会使他们的程序易受攻击的陷阱
Dialogue: 0,0:39:41.24,0:39:44.62,English,,0,0,0,, And so his recommended technique is when I first saw this
Dialogue: 0,0:39:41.24,0:39:44.62,Chinese,,0,0,0,,他推荐的方法，当我第一次看到时
Dialogue: 0,0:39:44.62,0:39:46.70,English,,0,0,0,,It was so counterintuitive to me
Dialogue: 0,0:39:44.62,0:39:46.70,Chinese,,0,0,0,,这对我来说太违反直觉了
Dialogue: 0,0:39:47.46,0:39:52.36,English,,0,0,0,,It hardly made sense right
Dialogue: 0,0:39:47.46,0:39:52.36,Chinese,,0,0,0,,这很难马上有感觉
Dialogue: 0,0:39:52.48,0:39:55.62,English,,0,0,0,,So you start and again this is all unsigned arithmetic
Dialogue: 0,0:39:52.48,0:39:55.62,Chinese,,0,0,0,,所以你重新开始这这里全部是无符号整数
Dialogue: 0,0:39:55.84,0:39:58.18,English,,0,0,0,, So I'm starting to count down
Dialogue: 0,0:39:55.84,0:39:58.18,Chinese,,0,0,0,,所以我开始倒计时了
Dialogue: 0,0:39:58.42,0:40:01.50,English,,0,0,0,,And my test is when I is less than count
Dialogue: 0,0:39:58.42,0:40:01.50,Chinese,,0,0,0,,我的测试条件是当ｉ小于 cnt 时
Dialogue: 0,0:40:02.40,0:40:05.62,English,,0,0,0,,So here's the thing I started off smaller than count
Dialogue: 0,0:40:02.40,0:40:05.62,Chinese,,0,0,0,,所以有一个问题, 当 i 小于 cnt 时
Dialogue: 0,0:40:06.14,0:40:10.58,English,,0,0,0,,And it's only being decremented so when would this test ever fail
Dialogue: 0,0:40:06.14,0:40:10.58,Chinese,,0,0,0,,它只会减少，所以这次测试什么时候会终止
Dialogue: 0,0:40:10.58,0:40:15.68,English,,0,0,0,,[student question]
Dialogue: 0,0:40:10.58,0:40:15.68,Chinese,,0,0,0,,[学生问题]
Dialogue: 0,0:40:15.84,0:40:17.92,English,,0,0,0,,When it overflows when it wraps around
Dialogue: 0,0:40:15.84,0:40:17.92,Chinese,,0,0,0,,当它溢出时，对吧
Dialogue: 0,0:40:18.26,0:40:23.30,English,,0,0,0,, Right when I goes from zero and counts down to what would now be UMax
Dialogue: 0,0:40:18.26,0:40:23.30,Chinese,,0,0,0,,当我从 0 开始倒计时，之后就会变成UMAX
Dialogue: 0,0:40:24.28,0:40:27.82,English,,0,0,0,,This test will fail which is exactly when you want it to stop
Dialogue: 0,0:40:24.28,0:40:27.82,Chinese,,0,0,0,,此测试失败，正好是你希望它停止的时
Dialogue: 0,0:40:28.60,0:40:35.60,English,,0,0,0,,And his observation is and in C with signed numbers there's no guarantee on what happens with overflowing
Dialogue: 0,0:40:28.60,0:40:35.60,Chinese,,0,0,0,,他的观察结果是在C中有符号数字，并不能保证溢出会发生什么
Dialogue: 0,0:40:35.68,0:40:39.68,English,,0,0,0,,As I said most people just assume it's going to be two's complement
Dialogue: 0,0:40:35.68,0:40:39.68,Chinese,,0,0,0,,正如我所说，大多数人只是假设它将是补码
Dialogue: 0,0:40:39.68,0:40:41.64,English,,0,0,0,,But if you really want to be careful
Dialogue: 0,0:40:39.68,0:40:41.64,Chinese,,0,0,0,,但如果你真的想要小心
Dialogue: 0,0:40:41.90,0:40:45.04,English,,0,0,0,,You shouldn't assume anything outside of the C standard
Dialogue: 0,0:40:41.90,0:40:45.04,Chinese,,0,0,0,,你不应该假设C标准之外的任何东西
Dialogue: 0,0:40:45.30,0:40:47.24,English,,0,0,0,,And if you're trying to write secure code
Dialogue: 0,0:40:45.30,0:40:47.24,Chinese,,0,0,0,,如果你正在尝试编写安全代码
Dialogue: 0,0:40:47.54,0:40:51.12,English,,0,0,0,, It's probably a good idea to be cautious be conservative
Dialogue: 0,0:40:47.54,0:40:51.12,Chinese,,0,0,0,,谨慎保守可能是一个好主意
Dialogue: 0,0:40:52.16,0:40:55.46,English,,0,0,0,,On the other hand the C standard guarantees
Dialogue: 0,0:40:52.16,0:40:55.46,Chinese,,0,0,0,,另一方面，C标准保证
Dialogue: 0,0:40:55.94,0:41:00.50,English,,0,0,0,,That unsigned arithmetic will be modular arithmetic so it guarantees
Dialogue: 0,0:40:55.94,0:41:00.50,Chinese,,0,0,0,,无符号运算将是模运算，因此它保证
Dialogue: 0,0:41:00.68,0:41:05.48,English,,0,0,0,,If you subtract one from zero you'll get the largest number that could be represented
Dialogue: 0,0:41:00.68,0:41:05.48,Chinese,,0,0,0,,如果从0中减去 1，你将获得无符号数可以表示的最大数字
Dialogue: 0,0:41:05.96,0:41:09.16,English,,0,0,0,,So it will be okay
Dialogue: 0,0:41:05.96,0:41:09.16,Chinese,,0,0,0,,所以没关系
Dialogue: 0,0:41:09.36,0:41:13.40,English,,0,0,0,,And in fact he recommends instead of using unsigned
Dialogue: 0,0:41:09.36,0:41:13.40,Chinese,,0,0,0,,事实上，他建议不要使用无符号数
Dialogue: 0,0:41:13.40,0:41:16.92,English,,0,0,0,,Which is on our machines just a 32-bit value
Dialogue: 0,0:41:13.40,0:41:16.92,Chinese,,0,0,0,,在我们的机器上只有32位
Dialogue: 0,0:41:17.86,0:41:21.92,English,,0,0,0,, That you call it a size_t which is a 64-bit value
Dialogue: 0,0:41:17.86,0:41:21.92,Chinese,,0,0,0,,用被称为size_t的有64位值的代替
Dialogue: 0,0:41:22.44,0:41:26.64,English,,0,0,0,, And so and write your code the way that I showed you
Dialogue: 0,0:41:22.44,0:41:26.64,Chinese,,0,0,0,,然后以我向你展示的方式编写代码
Dialogue: 0,0:41:27.74,0:41:29.48,English,,0,0,0,,So I've actually started doing this
Dialogue: 0,0:41:27.74,0:41:29.48,Chinese,,0,0,0,,所以我实际上已经开始这样做了
Dialogue: 0,0:41:29.98,0:41:33.50,English,,0,0,0,,And once you kind of get used to it it it's an OK way to write code
Dialogue: 0,0:41:29.98,0:41:33.50,Chinese,,0,0,0,,一旦你习惯了它，它就是编写代码的好方法
Dialogue: 0,0:41:33.50,0:41:36.42,English,,0,0,0,,But it's very strange-looking initial
Dialogue: 0,0:41:33.50,0:41:36.42,Chinese,,0,0,0,,但它一开始看起来非常奇怪
Dialogue: 0,0:41:37.43,0:41:44.14,English,,0,0,0,,One thing I'll point out is
Dialogue: 0,0:41:37.43,0:41:44.14,Chinese,,0,0,0,,我要指出的一件事是
Dialogue: 0,0:41:44.24,0:41:50.64,English,,0,0,0,,What would happen if count were a signed number int
Dialogue: 0,0:41:44.24,0:41:50.64,Chinese,,0,0,0,,如果count是有符号数int会发生什么
Dialogue: 0,0:41:52.08,0:41:57.50,English,,0,0,0,,And it were you were up and it was less than zero what would happen here
Dialogue: 0,0:41:52.08,0:41:57.50,Chinese,,0,0,0,,在这里当他小于0的时候会发生什么
Dialogue: 0,0:42:01.80,0:42:04.58,English,,0,0,0,,So I less than count what would happen
Dialogue: 0,0:42:01.80,0:42:04.58,Chinese,,0,0,0,,所以我不知道会发生什么
Dialogue: 0,0:42:05.06,0:42:10.72,English,,0,0,0,, [student question]
Dialogue: 0,0:42:05.06,0:42:10.72,Chinese,,0,0,0,,[学生问题]
Dialogue: 0,0:42:10.72,0:42:14.46,English,,0,0,0,,Right and so it become a very large positive number
Dialogue: 0,0:42:10.72,0:42:14.46,Chinese,,0,0,0,,是的，所以它成为一个非常大的正数
Dialogue: 0,0:42:14.86,0:42:16.98,English,,0,0,0,,And this test would almost certainly succeed
Dialogue: 0,0:42:14.86,0:42:16.98,Chinese,,0,0,0,,而这项测试几乎肯定会成功
Dialogue: 0,0:42:17.04,0:42:20.58,English,,0,0,0,, So you have the same this code doesn't avoid the pitfall
Dialogue: 0,0:42:17.04,0:42:20.58,Chinese,,0,0,0,,所以你有相同的代码，不能避免陷阱
Dialogue: 0,0:42:21.00,0:42:22.54,English,,0,0,0,,It just shifts it to saying
Dialogue: 0,0:42:21.00,0:42:22.54,Chinese,,0,0,0,,它只是说
Dialogue: 0,0:42:23.26,0:42:30.46,English,,0,0,0,,You better make sure you don't you know just for this case beforehand before you get into it
Dialogue: 0,0:42:23.26,0:42:30.46,Chinese,,0,0,0,,在用它之前，你最好确保知道怎么用
Dialogue: 0,0:42:32.48,0:42:41.14,English,,0,0,0,,So I think part of it is the observation that man if you want to be careful and write code that
Dialogue: 0,0:42:32.48,0:42:41.14,Chinese,,0,0,0,,所以我认为，这部分就靠人的观察如果你想写出
Dialogue: 0,0:42:41.66,0:42:48.72,English,,0,0,0,,That is guaranteed correct no matter what implementation goes on as long as it's within the C standard
Dialogue: 0,0:42:41.66,0:42:48.72,Chinese,,0,0,0,,在C标准内，无论执行什么，都可以保证正确的代码
Dialogue: 0,0:42:49.16,0:42:51.46,English,,0,0,0,,It's pretty tricky business.question up there
Dialogue: 0,0:42:49.16,0:42:51.46,Chinese,,0,0,0,,这是非常棘手的业务。提问
Dialogue: 0,0:42:52.12,0:42:59.46,English,,0,0,0,,[student question]
Dialogue: 0,0:42:52.12,0:42:59.46,Chinese,,0,0,0,,[学生问题]
Dialogue: 0,0:42:59.84,0:43:04.42,English,,0,0,0,,Yes!Which is unfortunate right
Dialogue: 0,0:42:59.84,0:43:04.42,Chinese,,0,0,0,,是的！那是真的不辛
Dialogue: 0,0:43:04.42,0:43:06.22,English,,0,0,0,,So yes that's exactly the rule
Dialogue: 0,0:43:04.42,0:43:06.22,Chinese,,0,0,0,,所以是的，这就是规矩
Dialogue: 0,0:43:06.22,0:43:10.88,English,,0,0,0,,That it's implicitly silently the C compiler doesn't give any warnings
Dialogue: 0,0:43:06.22,0:43:10.88,Chinese,,0,0,0,,它只会静静地发生，C编译器不会发出任何警告
Dialogue: 0,0:43:11.24,0:43:14.48,English,,0,0,0,, You'll never know it cast it to unsigned and
Dialogue: 0,0:43:11.24,0:43:14.48,Chinese,,0,0,0,,你永远不会知道它转换为无符号还是
Dialogue: 0,0:43:14.90,0:43:20.62,English,,0,0,0,, As these examples show when you stare at that code and you think about it
Dialogue: 0,0:43:14.90,0:43:20.62,Chinese,,0,0,0,,正如这些示例所示，当你盯着该代码并考虑它时
Dialogue: 0,0:43:21.36,0:43:23.26,English,,0,0,0,, It's really easy to have bugs
Dialogue: 0,0:43:21.36,0:43:23.26,Chinese,,0,0,0,,有bug真的很容易
Dialogue: 0,0:43:23.26,0:43:28.22,English,,0,0,0,,That you just you can look at it a thousand times and not realize that it's a bug
Dialogue: 0,0:43:23.26,0:43:28.22,Chinese,,0,0,0,,你可能看一千次却不会意识到这是一个错误
Dialogue: 0,0:43:28.38,0:43:33.73,English,,0,0,0,,It's a very...and there's examples these examples in the book of
Dialogue: 0,0:43:28.38,0:43:33.73,Chinese,,0,0,0,,这是一个非常......在这本书中有这些例子
Dialogue: 0,0:43:33.73,0:43:41.56,English,,0,0,0,,Of security flaws in sort of very important library software due to this problem exactly
Dialogue: 0,0:43:33.73,0:43:41.56,Chinese,,0,0,0,,由于这个问题在一些非常重要的图书馆软件中存在安全漏洞
Dialogue: 0,0:43:45.26,0:43:49.52,English,,0,0,0,,So part of the reason we teach in the course is just so you appreciate that
Dialogue: 0,0:43:45.26,0:43:49.52,Chinese,,0,0,0,,因此，我们在课程中教授的部分原因就是让你领会
Dialogue: 0,0:43:49.78,0:43:54.86,English,,0,0,0,,This is a quirk in this and see that again
Dialogue: 0,0:43:49.78,0:43:54.86,Chinese,,0,0,0,,这是一个诡异的现象，再看一遍
Dialogue: 0,0:43:54.86,0:43:59.84,English,,0,0,0,,99% of the time you'll never even it won't bother you at all
Dialogue: 0,0:43:54.86,0:43:59.84,Chinese,,0,0,0,,在99％的时间里甚至都不会打扰你
Dialogue: 0,0:43:59.84,0:44:03.50,English,,0,0,0,,But there will be some oddball cases that you can get in trouble with
Dialogue: 0,0:43:59.84,0:44:03.50,Chinese,,0,0,0,,但是会在一些奇怪的地方你会遇到麻烦
Dialogue: 0,0:44:08.30,0:44:11.44,English,,0,0,0,,So the other place that you'll find
Dialogue: 0,0:44:08.30,0:44:11.44,Chinese,,0,0,0,,在另一个地方你将找到
Dialogue: 0,0:44:12.50,0:44:16.82,English,,0,0,0,,Unsigned arithmetic unsigned representation use voice first of all
Dialogue: 0,0:44:12.50,0:44:16.82,Chinese,,0,0,0,,无符号算术无符号表示首先使用模运算
Dialogue: 0,0:44:17.30,0:44:19.06,English,,0,0,0,,When you're doing modular arithmetic
Dialogue: 0,0:44:17.30,0:44:19.06,Chinese,,0,0,0,,当你进行模运算时
Dialogue: 0,0:44:19.06,0:44:24.46,English,,0,0,0,, Which is for example the way most encryption algorithms work
Dialogue: 0,0:44:19.06,0:44:24.46,Chinese,,0,0,0,,例如，大多数加密算法的工作方式
Dialogue: 0,0:44:25.24,0:44:28.56,English,,0,0,0,, Or when you're using the bits not to represent numbers
Dialogue: 0,0:44:25.24,0:44:28.56,Chinese,,0,0,0,,或者，当你使用不表示数字的位
Dialogue: 0,0:44:28.56,0:44:32.20,English,,0,0,0,,But to represent sets the way I described it before
Dialogue: 0,0:44:28.56,0:44:32.20,Chinese,,0,0,0,,但代表开关,这我之前说过
Dialogue: 0,0:44:32.66,0:44:39.36,English,,0,0,0,,Then you don't want it it's easiest to just think of that as unsigned numbers
Dialogue: 0,0:44:32.66,0:44:39.36,Chinese,,0,0,0,,那么你不希望它被简单地将其视为无符号数
Dialogue: 0,0:44:44.66,0:44:48.16,English,,0,0,0,, Okay so the final thing to talk about today is
Dialogue: 0,0:44:44.66,0:44:48.16,Chinese,,0,0,0,,好的，所以今天最后要谈的是
Dialogue: 0,0:44:48.72,0:44:52.86,English,,0,0,0,,Some of the low-level representations of numbers within memory
Dialogue: 0,0:44:48.72,0:44:52.86,Chinese,,0,0,0,,内存中数字的一些低级表示
Dialogue: 0,0:44:53.94,0:45:00.12,English,,0,0,0,,And the main point is when you are running a program on a computer
Dialogue: 0,0:44:53.94,0:45:00.12,Chinese,,0,0,0,,重点是在计算机上运行程序时
Dialogue: 0,0:45:02.38,0:45:09.38,English,,0,0,0,,From the programming perspective either, even not just as a C programmer
Dialogue: 0,0:45:02.38,0:45:09.38,Chinese,,0,0,0,,从编程角度来看，不仅仅是对于C程序员
Dialogue: 0,0:45:09.96,0:45:13.20,English,,0,0,0,, In your mind the memory is just this big array of bytes
Dialogue: 0,0:45:09.96,0:45:13.20,Chinese,,0,0,0,,在你的脑海中，内存就是个巨大的字节数组
Dialogue: 0,0:45:13.82,0:45:17.34,English,,0,0,0,,That's numbered from 0 up to some maximum number
Dialogue: 0,0:45:13.82,0:45:17.34,Chinese,,0,0,0,,从0到某个最大数字的编号
Dialogue: 0,0:45:17.80,0:45:22.54,English,,0,0,0,,So for example in the machines we're using the 64-bit machines
Dialogue: 0,0:45:17.80,0:45:22.54,Chinese,,0,0,0,,例如，在我们使用64位机器的机器中
Dialogue: 0,0:45:24.12,0:45:27.68,English,,0,0,0,,I'll an address is represented in 64 bits
Dialogue: 0,0:45:24.12,0:45:27.68,Chinese,,0,0,0,,地址用64位表示
Dialogue: 0,0:45:29.18,0:45:31.28,English,,0,0,0,,But in fact the maximum address
Dialogue: 0,0:45:29.18,0:45:31.28,Chinese,,0,0,0,,但实际上最大的内存地址
Dialogue: 0,0:45:31.76,0:45:37.10,English,,0,0,0,,You're allowed to use in current machines is a 47 bits
Dialogue: 0,0:45:31.76,0:45:37.10,Chinese,,0,0,0,,你被允许在当前的机器上使用是47位
Dialogue: 0,0:45:37.94,0:45:42.48,English,,0,0,0,, And 2^47 is still a pretty big number
Dialogue: 0,0:45:37.94,0:45:42.48,Chinese,,0,0,0,,2 ^ 47仍然是一个相当大的数字
Dialogue: 0,0:45:42.48,0:45:48.36,English,,0,0,0,,So that's more memory than anyone's able to buy right now anyhow
Dialogue: 0,0:45:42.48,0:45:48.36,Chinese,,0,0,0,,所以，无论如何，这比现在任何人都能购买的内存都多
Dialogue: 0,0:45:48.38,0:45:50.26,English,,0,0,0,,And so it's a reasonable restriction
Dialogue: 0,0:45:48.38,0:45:50.26,Chinese,,0,0,0,,所以这是一个合理的限制
Dialogue: 0,0:45:50.26,0:45:57.76,English,,0,0,0,,But the point is that logically your program thinks that it has a of that many bytes
Dialogue: 0,0:45:50.26,0:45:57.76,Chinese,,0,0,0,,但重点是逻辑上你的程序认为它有很多字节
Dialogue: 0,0:45:58.18,0:46:02.54,English,,0,0,0,,Let's try and figure out how big 2^47 is. Anyone know it off the top of their head
Dialogue: 0,0:45:58.18,0:46:02.54,Chinese,,0,0,0,,让我们试着弄清楚2 ^ 47有多大。任何人都知道它的这一点
Dialogue: 0,0:46:07.24,0:46:13.56,English,,0,0,0,,So there's a trick if you want to get an approximate idea
Dialogue: 0,0:46:07.24,0:46:13.56,Chinese,,0,0,0,,这有一个小技巧,  如果你想得到一个近似的值
Dialogue: 0,0:46:14.70,0:46:25.66,English,,0,0,0,,Which is to say that 2^10 which is 1024 is approximately equal to 10^3
Dialogue: 0,0:46:14.70,0:46:25.66,Chinese,,0,0,0,,也就是说，1024的2 ^ 10大约等于10 ^ 3
Dialogue: 0,0:46:28.20,0:46:30.16,English,,0,0,0,,You say oh well that's really helpful
Dialogue: 0,0:46:28.20,0:46:30.16,Chinese,,0,0,0,,你说哦，这真的很有帮助
Dialogue: 0,0:46:30.32,0:46:40.14,English,,0,0,0,,What it means is that 10 bits worth of number is about the same as three decimal digits all right
Dialogue: 0,0:46:30.32,0:46:40.14,Chinese,,0,0,0,,这意味着10位数的二进制数字与3位十进制数字大致相同
Dialogue: 0,0:46:40.64,0:46:53.94,English,,0,0,0,,So for example 2^20 is around 10^6
Dialogue: 0,0:46:40.64,0:46:53.94,Chinese,,0,0,0,,因此，例如2 ^ 20大约是10 ^ 6
Dialogue: 0,0:46:55.16,0:46:59.24,English,,0,0,0,,2^30 it's around 10^9
Dialogue: 0,0:46:55.16,0:46:59.24,Chinese,,0,0,0,,2 ^ 30大概是10 ^ 9
Dialogue: 0,0:47:00.92,0:47:05.18,English,,0,0,0,,2^40 it's around 10^12
Dialogue: 0,0:47:00.92,0:47:05.18,Chinese,,0,0,0,,2 ^ 40大约是10 ^ 12
Dialogue: 0,0:47:07.06,0:47:09.60,English,,0,0,0,,And so that would tell you that
Dialogue: 0,0:47:07.06,0:47:09.60,Chinese,,0,0,0,,所以这会告诉你
Dialogue: 0,0:47:10.46,0:47:22.56,English,,0,0,0,,2^47 is around 128*10^12. Which is 128 terabytes right  tera 10^12
Dialogue: 0,0:47:10.46,0:47:22.56,Chinese,,0,0,0,,2 ^ 47大约是128 * 10 ^ 12。这是128兆字节对吧,  兆是10 ^ 12
Dialogue: 0,0:47:23.28,0:47:30.56,English,,0,0,0,,So if you just want to say you know get a quick figure 4 and of course these are approximations
Dialogue: 0,0:47:23.28,0:47:30.56,Chinese,,0,0,0,,所以，如果你只是想说你想快速的得到一个数字4，当然这些是近似值
Dialogue: 0,0:47:31.02,0:47:33.28,English,,0,0,0,, But if you just want to get a quick handle on
Dialogue: 0,0:47:31.02,0:47:33.28,Chinese,,0,0,0,,但是，如果你想快速处理
Dialogue: 0,0:47:33.44,0:47:38.78,English,,0,0,0,,How big a number you know what's range of values can I represent with so many bits of it
Dialogue: 0,0:47:33.44,0:47:38.78,Chinese,,0,0,0,,你就要知道我可以用几个比特来表示多大的数
Dialogue: 0,0:47:38.96,0:47:41.32,English,,0,0,0,,This is a really easy trick to do that
Dialogue: 0,0:47:38.96,0:47:41.32,Chinese,,0,0,0,,这是一个非常简单的技巧
Dialogue: 0,0:47:42.40,0:47:48.42,English,,0,0,0,,So the point is a 128 terabytes is a lot
Dialogue: 0,0:47:42.40,0:47:48.42,Chinese,,0,0,0,,所以重点是128兆字节很多
Dialogue: 0,0:47:50.42,0:47:54.72,English,,0,0,0,,You can buy disk drives a couple of disk drives will do that for you
Dialogue: 0,0:47:50.42,0:47:54.72,Chinese,,0,0,0,,你可以通过购买一个或几个磁盘驱动器来构成这样大的空间
Dialogue: 0,0:47:54.72,0:48:00.28,English,,0,0,0,,But you couldn't buy enough DRAM on a normal budget to get that kind of memory
Dialogue: 0,0:47:54.72,0:48:00.28,Chinese,,0,0,0,,但是你无法在正常预算下购买足够的DRAM来获得这种内存
Dialogue: 0,0:48:00.78,0:48:06.06,English,,0,0,0,, So that's the the current range of values but logically when you run a program
Dialogue: 0,0:48:00.78,0:48:06.06,Chinese,,0,0,0,,所以这是当前的值范围，但在当你运行程序时
Dialogue: 0,0:48:06.58,0:48:09.62,English,,0,0,0,, It thinks that it has that possible range
Dialogue: 0,0:48:06.58,0:48:09.62,Chinese,,0,0,0,,它有一个可能的范围
Dialogue: 0,0:48:09.62,0:48:11.52,English,,0,0,0,,Now it doesn't really
Dialogue: 0,0:48:09.62,0:48:11.52,Chinese,,0,0,0,,它并不是真的
Dialogue: 0,0:48:11.68,0:48:18.96,English,,0,0,0,, And in fact what happens is that the operating system only allows certain regions within that memory to be referenced
Dialogue: 0,0:48:11.68,0:48:18.96,Chinese,,0,0,0,,事实上，操作系统只允许使用该内存中的某些区域
Dialogue: 0,0:48:19.38,0:48:26.28,English,,0,0,0,,And other regions if you try to access them it will create a it will signal an error what they call a segmentation fault
Dialogue: 0,0:48:19.38,0:48:26.28,Chinese,,0,0,0,,如果你尝试访问其他区域，它将发出错误信号，这称为段错误
Dialogue: 0,0:48:27.16,0:48:30.32,English,,0,0,0,,But logically at least it's as if you have this big array of bytes
Dialogue: 0,0:48:27.16,0:48:30.32,Chinese,,0,0,0,,但从逻辑上讲，你好像有至少这么大的字节数组
Dialogue: 0,0:48:30.82,0:48:33.96,English,,0,0,0,,Now in reality and we'll go into this when we talk about
Dialogue: 0,0:48:30.82,0:48:33.96,Chinese,,0,0,0,,事实上，当我们谈到这一点时，我们会更深入的去理解
Dialogue: 0,0:48:33.96,0:48:37.74,English,,0,0,0,, How the memory system is works in virtual memory
Dialogue: 0,0:48:33.96,0:48:37.74,Chinese,,0,0,0,,内存系统如何在虚拟内存中运行
Dialogue: 0,0:48:41.40,0:48:48.50,English,,0,0,0,, There's this very complex combination of hardware and software begins the program this image of a very large
Dialogue: 0,0:48:41.40,0:48:48.50,Chinese,,0,0,0,,这种非常复杂的硬件和软件组合开始程序,  一个很大的图片
Dialogue: 0,0:48:48.82,0:48:52.48,English,,0,0,0,,What you call flat space just a big array of bytes
Dialogue: 0,0:48:48.82,0:48:52.48,Chinese,,0,0,0,,你所说的平面空间只是一个巨大的字节数组
Dialogue: 0,0:48:52.80,0:48:57.86,English,,0,0,0,,When in reality it's shuffling between different regions of your memory
Dialogue: 0,0:48:52.80,0:48:57.86,Chinese,,0,0,0,,实际上它存在于内存的不同区域之间
Dialogue: 0,0:48:57.86,0:49:05.84,English,,0,0,0,,And even between your memory and your disk drive on your computer  to make it implement this particular
Dialogue: 0,0:48:57.86,0:49:05.84,Chinese,,0,0,0,,甚至在你的内存和你的计算机上的磁盘驱动器之间，以实现这一特殊的
Dialogue: 0,0:49:08.98,0:49:10.83,English,,0,0,0,,Idea that you have this big array of bytes
Dialogue: 0,0:49:08.98,0:49:10.83,Chinese,,0,0,0,,设想你有这么大的字节数组
Dialogue: 0,0:49:11.40,0:49:16.84,English,,0,0,0,,And that's all handled as I said by the operating system by the computer hardware
Dialogue: 0,0:49:11.40,0:49:16.84,Chinese,,0,0,0,,这所有都是由计算机系统和硬件来实现的
Dialogue: 0,0:49:17.12,0:49:22.12,English,,0,0,0,,And it's largely invisible even to the machine level programmer even people writing assembly code
Dialogue: 0,0:49:17.12,0:49:22.12,Chinese,,0,0,0,,即使对于底层程序员甚至是编写汇编代码的人，它也基本上是不可见的
Dialogue: 0,0:49:29.40,0:49:34.18,English,,0,0,0,,You'll often hear the term word size and it can get very confusing confusing nowadays
Dialogue: 0,0:49:29.40,0:49:34.18,Chinese,,0,0,0,,你会经常听到计算机位数这个词，现在可能会让人感到很困惑
Dialogue: 0,0:49:34.18,0:49:38.40,English,,0,0,0,,Because there's no really fixed idea of what a word size is
Dialogue: 0,0:49:34.18,0:49:38.40,Chinese,,0,0,0,,因为计算机位数没有明确的规定
Dialogue: 0,0:49:38.92,0:49:42.70,English,,0,0,0,,But roughly speaking the word size should be
Dialogue: 0,0:49:38.92,0:49:42.70,Chinese,,0,0,0,,但粗略地说，位数大小应该是
Dialogue: 0,0:49:42.80,0:49:54.70,English,,0,0,0,, Whatever the largest number is that or  the range that sort of signifies how big a pointer is in this language
Dialogue: 0,0:49:42.80,0:49:54.70,Chinese,,0,0,0,,无论最大数是什么，或者指针表示的范围在这种语言中有多大
Dialogue: 0,0:49:55.12,0:50:00.36,English,,0,0,0,,Or hardware wise the largest sort of chunk of hardware for which
Dialogue: 0,0:49:55.12,0:50:00.36,Chinese,,0,0,0,,或硬件方面最大的一部分
Dialogue: 0,0:50:00.36,0:50:05.10,English,,0,0,0,,There's standard support for storing it for arithmetic operations and so forth
Dialogue: 0,0:50:00.36,0:50:05.10,Chinese,,0,0,0,,有一个标准确定如何存储算术运算和其他东西的
Dialogue: 0,0:50:05.66,0:50:08.24,English,,0,0,0,,So when we say it's a 64-bit machine
Dialogue: 0,0:50:05.66,0:50:08.24,Chinese,,0,0,0,,所以当我们说它是64位机器时
Dialogue: 0,0:50:08.68,0:50:17.80,English,,0,0,0,, What we mean is that it it regular and routinely manipulate 64-bit values and arithmetic operations
Dialogue: 0,0:50:08.68,0:50:17.80,Chinese,,0,0,0,,我们的意思是它定期使用64位值和算术运算
Dialogue: 0,0:50:18.04,0:50:24.27,English,,0,0,0,, And also it has a pointers or the values of of addresses are 64-bit
Dialogue: 0,0:50:18.04,0:50:24.27,Chinese,,0,0,0,,并且它指针或地址的值是64位
Dialogue: 0,0:50:24.68,0:50:32.16,English,,0,0,0,,Even if for right now only 47 of those bits are usable it's still considered a 64-bit machine
Dialogue: 0,0:50:24.68,0:50:32.16,Chinese,,0,0,0,,即使现在只有47个这样的位可用，它仍然被认为是64位机器
Dialogue: 0,0:50:33.20,0:50:42.78,English,,0,0,0,, One thing that strange is in one of the features of of machines such as we have
Dialogue: 0,0:50:33.20,0:50:42.78,Chinese,,0,0,0,,有一件事很奇怪，就像我们的机器所拥有的一个特征
Dialogue: 0,0:50:48.24,0:50:54.06,English,,0,0,0,,It is that if I compile a program using GCC is the standard compiler
Dialogue: 0,0:50:48.24,0:50:54.06,Chinese,,0,0,0,,如果我使用GCC作为默认编译器来编译
Dialogue: 0,0:50:54.52,0:51:03.80,English,,0,0,0,, I can specify either I want it to be 64 bit code or 32 bit code as a flag
Dialogue: 0,0:50:54.52,0:51:03.80,Chinese,,0,0,0,,我可以指定它是64位编译还是32位编译
Dialogue: 0,0:51:07.22,0:51:11.66,English,,0,0,0,,And it will actually generate two different kinds of object code as a result
Dialogue: 0,0:51:07.22,0:51:11.66,Chinese,,0,0,0,,并且它实际上会生成两种不同类型的目标代码
Dialogue: 0,0:51:12.18,0:51:15.14,English,,0,0,0,, And we'll talk in about these later
Dialogue: 0,0:51:12.18,0:51:15.14,Chinese,,0,0,0,,我们稍后会谈到这些
Dialogue: 0,0:51:15.46,0:51:22.76,English,,0,0,0,,But for right now the point is the hardware itself doesn't necessarily define what the word size is
Dialogue: 0,0:51:15.46,0:51:22.76,Chinese,,0,0,0,,但就目前而言，重点是硬件本身并不需要定义位数大小
Dialogue: 0,0:51:23.70,0:51:27.58,English,,0,0,0,,It's a combination of the hardware and the compiler  that determines
Dialogue: 0,0:51:23.70,0:51:27.58,Chinese,,0,0,0,,硬件和编译器的组合,  决定着
Dialogue: 0,0:51:27.58,0:51:31.08,English,,0,0,0,,What is the word size being used in this particular program
Dialogue: 0,0:51:27.58,0:51:31.08,Chinese,,0,0,0,,在这个指定的程序中使用的位数大小是多少
Dialogue: 0,0:51:31.62,0:51:36.02,English,,0,0,0,, And that code can be run on the point is a 64 bit machine
Dialogue: 0,0:51:31.62,0:51:36.02,Chinese,,0,0,0,,并且该代码可以在64位机器上运行
Dialogue: 0,0:51:36.02,0:51:39.04,English,,0,0,0,, Such as we have and most machines are nowadays
Dialogue: 0,0:51:36.02,0:51:39.04,Chinese,,0,0,0,,比如我们有的和现今大多数机器都是如此
Dialogue: 0,0:51:39.28,0:51:46.54,English,,0,0,0,, Can insert of a backward compatibility a style also executes 32-bit code
Dialogue: 0,0:51:39.28,0:51:46.54,Chinese,,0,0,0,,可以插入一个向后兼容的插件来执行32​​位代码
Dialogue: 0,0:51:51.00,0:51:55.05,English,,0,0,0,,And as we also saw one of the other features is
Dialogue: 0,0:51:51.00,0:51:55.05,Chinese,,0,0,0,,而且我们也看到了另一个功能
Dialogue: 0,0:51:55.05,0:51:58.22,English,,0,0,0,,Even though it's a 64 bit word size the data type int
Dialogue: 0,0:51:55.05,0:51:58.22,Chinese,,0,0,0,,即使它是64位大小的数据类型int
Dialogue: 0,0:51:59.22,0:52:03.42,English,,0,0,0,,Without any other qualifiers to it is just 32 bit
Dialogue: 0,0:51:59.22,0:52:03.42,Chinese,,0,0,0,,没有任何其他限定符，它只是32位
Dialogue: 0,0:52:03.56,0:52:07.24,English,,0,0,0,,So the sort of this mixture of how big things are
Dialogue: 0,0:52:03.56,0:52:07.24,Chinese,,0,0,0,,所以这种复杂的东西有多大
Dialogue: 0,0:52:07.24,0:52:09.76,English,,0,0,0,,So when people just say word or word size
Dialogue: 0,0:52:07.24,0:52:09.76,Chinese,,0,0,0,,当人们只说位或位大小时
Dialogue: 0,0:52:10.62,0:52:15.04,English,,0,0,0,,And let's say give a precise definition that's not a very meaningful term
Dialogue: 0,0:52:10.62,0:52:15.04,Chinese,,0,0,0,,让我们说一个精确的定义，这不是一个非常有意义的术语
Dialogue: 0,0:52:15.44,0:52:18.56,English,,0,0,0,,And we'll sort of throw it around when we mean sort of a generic
Dialogue: 0,0:52:15.44,0:52:18.56,Chinese,,0,0,0,,当我们指的是一般的比特块时，我们会抛出它
Dialogue: 0,0:52:18.96,0:52:23.50,English,,0,0,0,,Chunk of bits without trying to assume that it has a particular number of bits to it
Dialogue: 0,0:52:18.96,0:52:23.50,Chinese,,0,0,0,,而不试图假设它具有特定数量的比特
Dialogue: 0,0:52:35.70,0:52:39.84,English,,0,0,0,,Yes so one of the things is if we ever get to 64-bit words
Dialogue: 0,0:52:35.70,0:52:39.84,Chinese,,0,0,0,,是的，所以其中一件事就是如果我们得到64位字的话
Dialogue: 0,0:52:41.10,0:52:48.04,English,,0,0,0,,It will be 16 petabytes 18 petabytes depending on how you define
Dialogue: 0,0:52:41.10,0:52:48.04,Chinese,,0,0,0,,根据你的定义，它将是18PB
Dialogue: 0,0:52:48.04,0:52:54.86,English,,0,0,0,,When you those numbers get big but the error due to this approximation gets more significant
Dialogue: 0,0:52:48.04,0:52:54.86,Chinese,,0,0,0,,当那些数字变大时由于近似引起的误差变得更加明显
Dialogue: 0,0:52:55.70,0:52:59.04,English,,0,0,0,,But something times 10^15 bytes
Dialogue: 0,0:52:55.70,0:52:59.04,Chinese,,0,0,0,,但一些需要10 ^ 15个字节
Dialogue: 0,0:52:59.16,0:53:04.64,English,,0,0,0,,But right now we can only get to 128*10^12
Dialogue: 0,0:52:59.16,0:53:04.64,Chinese,,0,0,0,,但是现在我们只能达到128 * 10 ^ 12
Dialogue: 0,0:53:12.12,0:53:17.08,English,,0,0,0,,So anyways the idea that that the memory itself is a series of bytes
Dialogue: 0,0:53:12.12,0:53:17.08,Chinese,,0,0,0,,所以无论如何，内存本身就是一系列字节
Dialogue: 0,0:53:17.68,0:53:23.16,English,,0,0,0,,But we can group those into blocks of words of different word sizes
Dialogue: 0,0:53:17.68,0:53:23.16,Chinese,,0,0,0,,但我们可以将它们分为不同大小的字块
Dialogue: 0,0:53:23.56,0:53:34.82,English,,0,0,0,,And the way we do that is usually by assuming that the address of the word is the lowest value address in it
Dialogue: 0,0:53:23.56,0:53:34.82,Chinese,,0,0,0,,我们这样做的方式通常是假设字的地址是其中最低位地址
Dialogue: 0,0:53:35.16,0:53:38.18,English,,0,0,0,,And we also will generally try to align these
Dialogue: 0,0:53:35.16,0:53:38.18,Chinese,,0,0,0,,我们通常也会尝试调整这些
Dialogue: 0,0:53:38.72,0:53:46.88,English,,0,0,0,,So that for example a 32-bit word would be a line
Dialogue: 0,0:53:38.72,0:53:46.88,Chinese,,0,0,0,,因此，例如32位字将是一条线
Dialogue: 0,0:53:46.88,0:54:01.92,English,,0,0,0,,So its first byte its lowest byte has all zeros in the first stuff in the first 5 bit positions right
Dialogue: 0,0:53:46.88,0:54:01.92,Chinese,,0,0,0,,所以它的低位在前五个位置全是 0
Dialogue: 0,0:54:02.44,0:54:05.62,English,,0,0,0,,No 32 4,I'm sorry the low is 2 bytes
Dialogue: 0,0:54:02.44,0:54:05.62,Chinese,,0,0,0,,不对是 32 4，对不起，低位是2个字节
Dialogue: 0,0:54:06.70,0:54:15.52,English,,0,0,0,,Right so as this example shows their address is 0,4,8  and 12
Dialogue: 0,0:54:06.70,0:54:15.52,Chinese,,0,0,0,,这是正确的，因为这个例子显示他们的地址是0,4,8和12
Dialogue: 0,0:54:15.52,0:54:18.20,English,,0,0,0,, They should have really written this in hex and set at C
Dialogue: 0,0:54:15.52,0:54:18.20,Chinese,,0,0,0,,他们本来就应该用十六进制写这个，然后再设置为C.
Dialogue: 0,0:54:19.78,0:54:22.04,English,,0,0,0,,I guess these are all in decimal anyhow
Dialogue: 0,0:54:19.78,0:54:22.04,Chinese,,0,0,0,,我猜这些都是用十进制写的
Dialogue: 0,0:54:22.94,0:54:26.64,English,,0,0,0,,So yeah these are decimal numbers so 0,4,8,12
Dialogue: 0,0:54:22.94,0:54:26.64,Chinese,,0,0,0,,所以是的，这些是十进制数，所以0,4,8,12
Dialogue: 0,0:54:27.00,0:54:31.30,English,,0,0,0,,So you see these are on multiples of 4 of bit boundaries
Dialogue: 0,0:54:27.00,0:54:31.30,Chinese,,0,0,0,,所以你看到它们是4的倍数
Dialogue: 0,0:54:31.94,0:54:35.48,English,,0,0,0,, And same way the 64-bit words are on multiples of 8
Dialogue: 0,0:54:31.94,0:54:35.48,Chinese,,0,0,0,,同样，64位字的倍数为8
Dialogue: 0,0:54:35.98,0:54:42.48,English,,0,0,0,,And those are known as aligned words and will generally will see that the compiler works pretty hard to keep things aligned
Dialogue: 0,0:54:35.98,0:54:42.48,Chinese,,0,0,0,,这些被称为对齐的单词，编译器通常非常难以保持对齐
Dialogue: 0,0:54:42.92,0:54:45.22,English,,0,0,0,,Because the hardware runs more efficiently that way
Dialogue: 0,0:54:42.92,0:54:45.22,Chinese,,0,0,0,,因为硬件运行效率很高
Dialogue: 0,0:54:45.90,0:54:50.14,English,,0,0,0,,But the main point is that we can just take as many bytes
Dialogue: 0,0:54:45.90,0:54:50.14,Chinese,,0,0,0,,但重点是我们可以占用尽可能多的字节
Dialogue: 0,0:54:50.14,0:54:54.86,English,,0,0,0,,As we want and collect them together and call it a word for whatever word size we need
Dialogue: 0,0:54:50.14,0:54:54.86,Chinese,,0,0,0,,正如我们想要的那样，将它们收集在一起，并将它称为一个字，用于我们需要的地方
Dialogue: 0,0:54:56.44,0:55:00.22,English,,0,0,0,,And as we think we saw a variant of this table before
Dialogue: 0,0:54:56.44,0:55:00.22,Chinese,,0,0,0,,而且和我们看过这个表的另一种形式一样
Dialogue: 0,0:55:00.24,0:55:07.16,English,,0,0,0,,But this is machines we'll be working on that  the standard int is still only 32 bits
Dialogue: 0,0:55:00.24,0:55:07.16,Chinese,,0,0,0,,这是我们正在研究的机器，标准int仍然只有32位
Dialogue: 0,0:55:07.62,0:55:11.22,English,,0,0,0,, But if we qualify something as being wrong
Dialogue: 0,0:55:07.62,0:55:11.22,Chinese,,0,0,0,,但是，如果我们认为某些事情是错误的
Dialogue: 0,0:55:11.70,0:55:15.03,English,,0,0,0,,Then it will be 64 bits and will tend to do that
Dialogue: 0,0:55:11.70,0:55:15.03,Chinese,,0,0,0,,然后它将是64位，并将倾向于这样做
Dialogue: 0,0:55:15.72,0:55:19.22,English,,0,0,0,,There's two different floating-point representations that we'll talk about
Dialogue: 0,0:55:15.72,0:55:19.22,Chinese,,0,0,0,,我们将讨论两种不同的浮点表示
Dialogue: 0,0:55:19.62,0:55:28.12,English,,0,0,0,,And then the main feature of a 64 bit machine  is it has an 8 byte or 64 bit pointer as compared to 32
Dialogue: 0,0:55:19.62,0:55:28.12,Chinese,,0,0,0,,然后64位机器的主要特征是它有一个8字节或64位指针与32相比
Dialogue: 0,0:55:30.38,0:55:35.24,English,,0,0,0,,Now there's one other kind of detail that says ok
Dialogue: 0,0:55:30.38,0:55:35.24,Chinese,,0,0,0,,现在有另外一个细节
Dialogue: 0,0:55:35.24,0:55:37.90,English,,0,0,0,,So if a word has multiple bytes in it
Dialogue: 0,0:55:35.24,0:55:37.90,Chinese,,0,0,0,,如果一个字中有多个字节
Dialogue: 0,0:55:38.40,0:55:41.28,English,,0,0,0,,What order should those bytes be should it be the
Dialogue: 0,0:55:38.40,0:55:41.28,Chinese,,0,0,0,,这些字节应该是什么顺序呢？
Dialogue: 0,0:55:43.14,0:55:45.72,English,,0,0,0,,And there's two basic ways this could go one
Dialogue: 0,0:55:43.14,0:55:45.72,Chinese,,0,0,0,,并且有两种基本的存储方式
Dialogue: 0,0:55:46.04,0:55:51.40,English,,0,0,0,,One is that you put the bytes in what's known as little endian order meaning that
Dialogue: 0,0:55:46.04,0:55:51.40,Chinese,,0,0,0,,一个是你把字节放在所谓的小端序中意味着
Dialogue: 0,0:55:51.40,0:55:54.82,English,,0,0,0,,The first byte and the word is the least significant byte
Dialogue: 0,0:55:51.40,0:55:54.82,Chinese,,0,0,0,,第一个字节是最低有效字节
Dialogue: 0,0:55:54.82,0:56:00.18,English,,0,0,0,,Then the next and the final byte in the word is the most significant
Dialogue: 0,0:55:54.82,0:56:00.18,Chinese,,0,0,0,,然后，下一个,下一个,字中的最后一个字节是最重要的
Dialogue: 0,0:56:00.64,0:56:03.84,English,,0,0,0,,Or you can flip that around and
Dialogue: 0,0:56:00.64,0:56:03.84,Chinese,,0,0,0,,或者你可以翻转它
Dialogue: 0,0:56:03.84,0:56:11.54,English,,0,0,0,,Those are called little-endian and big-endian is the sort of terms for that
Dialogue: 0,0:56:03.84,0:56:11.54,Chinese,,0,0,0,,被称为小端和大端的术语
Dialogue: 0,0:56:11.54,0:56:19.40,English,,0,0,0,,Which comes from English book called Gulliver's Travels
Dialogue: 0,0:56:11.54,0:56:19.40,Chinese,,0,0,0,,来自英文书籍<<Gulliver's Travels>>
Dialogue: 0,0:56:19.40,0:56:21.94,English,,0,0,0,,Which didn't anticipate computers at all
Dialogue: 0,0:56:19.40,0:56:21.94,Chinese,,0,0,0,,这书根本没有预料到计算机
Dialogue: 0,0:56:22.32,0:56:25.44,English,,0,0,0,,But it's an interesting story of how that comes about
Dialogue: 0,0:56:22.32,0:56:25.44,Chinese,,0,0,0,,但这是一个有趣的故事关于这是如何而来的
Dialogue: 0,0:56:26.02,0:56:31.18,English,,0,0,0,,So in out there in the world you'll find both types of machines big-endian and little-endian machines
Dialogue: 0,0:56:26.02,0:56:31.18,Chinese,,0,0,0,,因此，在世界各地，你会发现大端机器和小端机器
Dialogue: 0,0:56:31.80,0:56:36.40,English,,0,0,0,,It turns out that increasingly it's getting hard to find big-Endian machines
Dialogue: 0,0:56:31.80,0:56:36.40,Chinese,,0,0,0,,事实证明，越来越难以找到大端机器
Dialogue: 0,0:56:36.96,0:56:40.52,English,,0,0,0,, So little-endian all of x86 is little-endian
Dialogue: 0,0:56:36.96,0:56:40.52,Chinese,,0,0,0,,所以x86的机器都是小端的
Dialogue: 0,0:56:41.70,0:56:44.74,English,,0,0,0,, And it turns out ARM processors like
Dialogue: 0,0:56:41.70,0:56:44.74,Chinese,,0,0,0,,事实证明，ARM处理器就像
Dialogue: 0,0:56:44.74,0:56:50.14,English,,0,0,0,,What you have in almost every cell phone here is an ARM processor
Dialogue: 0,0:56:44.74,0:56:50.14,Chinese,,0,0,0,,几乎每部手机都有ARM处理器
Dialogue: 0,0:56:51.32,0:56:56.92,English,,0,0,0,,And the hardware those can actually be configured to run either way big-endian or little-endian
Dialogue: 0,0:56:51.32,0:56:56.92,Chinese,,0,0,0,,那些实际上可以配置为既可以运行big-endian也可以运行little-endian的硬件
Dialogue: 0,0:56:57.50,0:57:07.48,English,,0,0,0,,But when you're running it on any of the standard operating systems that run on ARM processors then it's running little-endian
Dialogue: 0,0:56:57.50,0:57:07.48,Chinese,,0,0,0,,但是当你在ARM处理器上的任何标准操作系统上运行它时，它会用小端来运行
Dialogue: 0,0:57:07.50,0:57:14.80,English,,0,0,0,,So there used to be a brand called Sun Microsystems and they were fairly common on campus
Dialogue: 0,0:57:07.50,0:57:14.80,Chinese,,0,0,0,,所以曾经有一个名为Sun Microsystems的品牌，它们在校园里相当常见
Dialogue: 0,0:57:15.56,0:57:21.26,English,,0,0,0,,And then back in the Macintosh before they were x86 processors
Dialogue: 0,0:57:15.56,0:57:21.26,Chinese,,0,0,0,,然后在Macintosh还不是x86时
Dialogue: 0,0:57:21.76,0:57:23.92,English,,0,0,0,, They ran one called the PowerPC
Dialogue: 0,0:57:21.76,0:57:23.92,Chinese,,0,0,0,,他们推出了一款名为PowerPC的产品
Dialogue: 0,0:57:25.42,0:57:27.36,English,,0,0,0,, And that was a big-endian machine
Dialogue: 0,0:57:25.42,0:57:27.36,Chinese,,0,0,0,,那是一台大端机器
Dialogue: 0,0:57:27.36,0:57:30.15,English,,0,0,0,, But those are long in the distant past
Dialogue: 0,0:57:27.36,0:57:30.15,Chinese,,0,0,0,,但是在遥远的过去了
Dialogue: 0,0:57:30.80,0:57:33.72,English,,0,0,0,,The internet's about the only place out there
Dialogue: 0,0:57:30.80,0:57:33.72,Chinese,,0,0,0,,互联网里唯一有关这个的地方
Dialogue: 0,0:57:33.90,0:57:40.10,English,,0,0,0,, When you send packets over the internet and you want to send it of 32-bit words
Dialogue: 0,0:57:33.90,0:57:40.10,Chinese,,0,0,0,,当你通过Internet发送数据包并且想要发送32位字时
Dialogue: 0,0:57:40.30,0:57:42.90,English,,0,0,0,, They're actually sent in big-endian order and so
Dialogue: 0,0:57:40.30,0:57:42.90,Chinese,,0,0,0,,它们实际上是以大端顺序发送的
Dialogue: 0,0:57:43.14,0:57:46.98,English,,0,0,0,,At the network interface you have to translate between those two
Dialogue: 0,0:57:43.14,0:57:46.98,Chinese,,0,0,0,,在网络接口，你必须在这两者之间进行转换
Dialogue: 0,0:57:48.40,0:57:51.60,English,,0,0,0,,So again just to illustrate what I mean by this
Dialogue: 0,0:57:48.40,0:57:51.60,Chinese,,0,0,0,,所以再一次为了说明我的意思
Dialogue: 0,0:57:51.96,0:57:57.64,English,,0,0,0,, is think of a byte value 4 byte value like this
Dialogue: 0,0:57:51.96,0:57:57.64,Chinese,,0,0,0,,想像这样的4个字节
Dialogue: 0,0:57:58.00,0:58:03.32,English,,0,0,0,,And remember that the way we write numbers is we put the most significant to the left
Dialogue: 0,0:57:58.00,0:58:03.32,Chinese,,0,0,0,,请记住，我们编写数字的方式是我们将最高位数字放在左边
Dialogue: 0,0:58:03.78,0:58:05.84,English,,0,0,0,,And the least significant to the right
Dialogue: 0,0:58:03.78,0:58:05.84,Chinese,,0,0,0,,最低位的放在右边
Dialogue: 0,0:58:09.60,0:58:17.74,English,,0,0,0,, And so now with a big-endian instead of the intuitive one from that perspective in that the bikes
Dialogue: 0,0:58:09.60,0:58:17.74,Chinese,,0,0,0,,所以现在有了一个大端而不是直观地感受它
Dialogue: 0,0:58:17.74,0:58:23.10,English,,0,0,0,,If you write the words in memory from the smallest address up to the highest
Dialogue: 0,0:58:17.74,0:58:23.10,Chinese,,0,0,0,,如果你在内存中从最小地址到最高地址写入字
Dialogue: 0,0:58:23.68,0:58:26.44,English,,0,0,0,,The big-endian will sort of map to what you see
Dialogue: 0,0:58:23.68,0:58:26.44,Chinese,,0,0,0,,大端法将根据你的看法进行映射
Dialogue: 0,0:58:26.92,0:58:30.88,English,,0,0,0,, Whereas a little-endian will look confusing
Dialogue: 0,0:58:26.92,0:58:30.88,Chinese,,0,0,0,,而小端将看起来令人困惑
Dialogue: 0,0:58:31.16,0:58:34.56,English,,0,0,0,, that you say 01,23,45,67
Dialogue: 0,0:58:31.16,0:58:34.56,Chinese,,0,0,0,,你说的是01,23,45,67
Dialogue: 0,0:58:34.56,0:58:39.06,English,,0,0,0,,Because 67 is actually the least significant byte here
Dialogue: 0,0:58:34.56,0:58:39.06,Chinese,,0,0,0,,因为67实际上是这里最小的字节
Dialogue: 0,0:58:39.06,0:58:41.68,English,,0,0,0,, And so that comes first in little-endian order
Dialogue: 0,0:58:39.06,0:58:41.68,Chinese,,0,0,0,,所以这首先是小端序
Dialogue: 0,0:58:43.20,0:58:49.68,English,,0,0,0,,And so the it used to be people would get in passionate arguments about this
Dialogue: 0,0:58:43.20,0:58:49.68,Chinese,,0,0,0,,因此过去人们会对此充满热情的争论
Dialogue: 0,0:58:50.16,0:58:52.50,English,,0,0,0,,That's sort of in the distant past
Dialogue: 0,0:58:50.16,0:58:52.50,Chinese,,0,0,0,,那是在遥远的过去
Dialogue: 0,0:58:53.04,0:58:55.36,English,,0,0,0,,But and people saying you know
Dialogue: 0,0:58:53.04,0:58:55.36,Chinese,,0,0,0,,但是有人说你知道
Dialogue: 0,0:58:57.62,0:59:04.14,English,,0,0,0,,And the main feature in some sort of argument of big-endian is's this feature here that
Dialogue: 0,0:58:57.62,0:59:04.14,Chinese,,0,0,0,,而对于大端的某种论证的主要是
Dialogue: 0,0:59:04.46,0:59:06.94,English,,0,0,0,,When you look at it it's easier to write down
Dialogue: 0,0:59:04.46,0:59:06.94,Chinese,,0,0,0,,当你看它时，写下来会更容易
Dialogue: 0,0:59:07.54,0:59:09.38,English,,0,0,0,,But computers don't really care
Dialogue: 0,0:59:07.54,0:59:09.38,Chinese,,0,0,0,,但是电脑并不在乎
Dialogue: 0,0:59:09.50,0:59:13.00,English,,0,0,0,,They're happy either way and so they just want one convention or another
Dialogue: 0,0:59:09.50,0:59:13.00,Chinese,,0,0,0,,无论哪种方式，他们都很开心，所以他们只想要一个规定或另一个
Dialogue: 0,0:59:13.30,0:59:20.64,English,,0,0,0,,And like I said some hardware's can actually be a by a sort of flag to flip it from  being big-endian to little-endian
Dialogue: 0,0:59:13.30,0:59:20.64,Chinese,,0,0,0,,就像我说的一些硬件实际上可以通过一种标志来将其从大端变为小端
Dialogue: 0,0:59:21.12,0:59:26.62,English,,0,0,0,,But the reality is most of machines  one counter you'll encounter a little-endian machine days
Dialogue: 0,0:59:21.12,0:59:26.62,Chinese,,0,0,0,,但实际情况是大多数机器总有一天会遇到一个小端机器
Dialogue: 0,0:59:27.68,0:59:29.42,English,,0,0,0,,But just to give you an example
Dialogue: 0,0:59:27.68,0:59:29.42,Chinese,,0,0,0,,但只是举个例子
Dialogue: 0,0:59:29.94,0:59:35.68,English,,0,0,0,,Here some results that I got from actual machines there used to be some machines around
Dialogue: 0,0:59:29.94,0:59:35.68,Chinese,,0,0,0,,这是一些结果我在以前的机器里跑出来的当它还可以运行时
Dialogue: 0,0:59:36.58,0:59:38.88,English,,0,0,0,,So back in the old days I could run this
Dialogue: 0,0:59:36.58,0:59:38.88,Chinese,,0,0,0,,所以在过去，我可以运行这个
Dialogue: 0,0:59:38.88,0:59:42.66,English,,0,0,0,,I don't even know where to get a big-endian machine anymore
Dialogue: 0,0:59:38.88,0:59:42.66,Chinese,,0,0,0,,现在我甚至不知道在哪里可以得到一台大端机器
Dialogue: 0,0:59:43.08,0:59:46.28,English,,0,0,0,,So these are sort of legacy results
Dialogue: 0,0:59:43.08,0:59:46.28,Chinese,,0,0,0,,所以这些都是遗留下来的结果
Dialogue: 0,0:59:47.92,0:59:52.44,English,,0,0,0,,But you'll see that the main feature is between a little-endian and a big-endian machine
Dialogue: 0,0:59:47.92,0:59:52.44,Chinese,,0,0,0,,但是你会发现在小端机器和大端机器之间的主要区别
Dialogue: 0,0:59:52.74,0:59:56.76,English,,0,0,0,,When you have a integer the bytes get flipped around
Dialogue: 0,0:59:52.74,0:59:56.76,Chinese,,0,0,0,,当你有一个整数时，字节会被翻转
Dialogue: 0,0:59:57.68,1:00:04.74,English,,0,0,0,, So that the least significant byte comes first in a little-endian machine  and last in a big-endian machine
Dialogue: 0,0:59:57.68,1:00:04.74,Chinese,,0,0,0,,因此，最低位的字节首先出现在小端机器中，最后出现在大端机器中
Dialogue: 0,1:00:05.74,1:00:08.72,English,,0,0,0,, And that's true with negative numbers as well
Dialogue: 0,1:00:05.74,1:00:08.72,Chinese,,0,0,0,,负数也是如此
Dialogue: 0,1:00:09.28,1:00:14.28,English,,0,0,0,, That you'll get the the sign bits first in a big-endian machine
Dialogue: 0,1:00:09.28,1:00:14.28,Chinese,,0,0,0,,你将在big-endian机器中首先得到符号位
Dialogue: 0,1:00:15.70,1:00:25.70,English,,0,0,0,,Along you'll see that the only difference between a 32-bit machine a 64-bit machine
Dialogue: 0,1:00:15.70,1:00:25.70,Chinese,,0,0,0,,接着你会看到32位机器和64位机器之间的唯一区别
Dialogue: 0,1:00:25.70,1:00:30.70,English,,0,0,0,, is you have more zeros or more ones depending whether it's a positive or negative number
Dialogue: 0,1:00:25.70,1:00:30.70,Chinese,,0,0,0,,是更多的 0 或更多的 1 ，取决于它是正数还是负数
Dialogue: 0,1:00:31.56,1:00:37.44,English,,0,0,0,,And again the a Sun and if I had access to a 64 bit machine
Dialogue: 0,1:00:31.56,1:00:37.44,Chinese,,0,0,0,,再一次sun，如果我可以使用64位机器
Dialogue: 0,1:00:37.66,1:00:41.24,English,,0,0,0,,Sun is now manufactured by a company called Oracle
Dialogue: 0,1:00:37.66,1:00:41.24,Chinese,,0,0,0,,Sun现在由一家名为Oracle的公司制造
Dialogue: 0,1:00:41.24,1:00:45.72,English,,0,0,0,, So in principle I could go get one of these machines and run this experiment
Dialogue: 0,1:00:41.24,1:00:45.72,Chinese,,0,0,0,,所以原我可以去买这些机器之一并运行这个实验
Dialogue: 0,1:00:46.00,1:00:48.96,English,,0,0,0,, But it's really not a very interesting experiment so I won't bother
Dialogue: 0,1:00:46.00,1:00:48.96,Chinese,,0,0,0,,但这真的不是一个非常有趣的实验，所以我不会做的
Dialogue: 0,1:00:51.68,1:00:59.00,English,,0,0,0,,So in principle I could try it on a 64-bit Oracle machine and show you something different
Dialogue: 0,1:00:51.68,1:00:59.00,Chinese,,0,0,0,,所以事实上我可以在64位Oracle机器上运行它并向你展示不同的东西
Dialogue: 0,1:01:02.72,1:01:08.66,English,,0,0,0,, So one thing that it's kind of a useful tool the book goes through some examples of this
Dialogue: 0,1:01:02.72,1:01:08.66,Chinese,,0,0,0,,这是一个有用的工具,这本书会告诉你通过
Dialogue: 0,1:01:09.24,1:01:17.24,English,,0,0,0,,is a little program that will take a series of bytes starting at some position start
Dialogue: 0,1:01:09.24,1:01:17.24,Chinese,,0,0,0,,一个小程序，它将从一个位置开始提取一系列字节
Dialogue: 0,1:01:17.86,1:01:21.16,English,,0,0,0,,And do it for however many bytes you request
Dialogue: 0,1:01:17.86,1:01:21.16,Chinese,,0,0,0,,无论你给什么数字他都会正确执行
Dialogue: 0,1:01:21.54,1:01:24.90,English,,0,0,0,, And just print out in hex format
Dialogue: 0,1:01:21.54,1:01:24.90,Chinese,,0,0,0,,并以十六进制格式打印出来
Dialogue: 0,1:01:25.28,1:01:30.70,English,,0,0,0,,The two hex digits that represent that byte valve
Dialogue: 0,1:01:25.28,1:01:30.70,Chinese,,0,0,0,,这两个十六进制数字数字代表这个字节的值
Dialogue: 0,1:01:31.94,1:01:41.02,English,,0,0,0,,And here this term pointer I'm using an unsigned char  as a pointer type a sort of generic pointer type
Dialogue: 0,1:01:31.94,1:01:41.02,Chinese,,0,0,0,,在这里的指针我使用unsigned char作为一种通用指针类型
Dialogue: 0,1:01:47.58,1:01:53.96,English,,0,0,0,,And so again if I run this on a x86 machine
Dialogue: 0,1:01:47.58,1:01:53.96,Chinese,,0,0,0,,如果我在x86机器上运行它
Dialogue: 0,1:01:56.28,1:01:59.12,English,,0,0,0,, I'll oh and I'm also by the way printing out the actual address
Dialogue: 0,1:01:56.28,1:01:59.12,Chinese,,0,0,0,,哦，我也会打印出实际的地址
Dialogue: 0,1:01:59.26,1:02:03.30,English,,0,0,0,,This character is stored it too
Dialogue: 0,1:01:59.26,1:02:03.30,Chinese,,0,0,0,,该字符存储在其中
Dialogue: 0,1:02:03.74,1:02:09.42,English,,0,0,0,,And so you'll see that there is these addresses with a lot of 7 Fs
Dialogue: 0,1:02:03.74,1:02:09.42,Chinese,,0,0,0,,所以你会发现这些地址有很多7和F
Dialogue: 0,1:02:10.22,1:02:15.02,English,,0,0,0,,What that means is it's in the upper end of this 47 bit address space
Dialogue: 0,1:02:10.22,1:02:15.02,Chinese,,0,0,0,,这意味着它位于这个47位地址空间的上端
Dialogue: 0,1:02:15.02,1:02:16.76,English,,0,0,0,, If you work it through
Dialogue: 0,1:02:15.02,1:02:16.76,Chinese,,0,0,0,,如果你仔细观察它
Dialogue: 0,1:02:17.46,1:02:21.48,English,,0,0,0,,There's seven is three ones and then there's
Dialogue: 0,1:02:17.46,1:02:21.48,Chinese,,0,0,0,,有三个七，然后就是
Dialogue: 0,1:02:22.58,1:02:26.36,English,,0,0,0,, Enough hex digits here to correspond to
Dialogue: 0,1:02:22.58,1:02:26.36,Chinese,,0,0,0,,这里有足够的十六进制数字来表示
Dialogue: 0,1:02:27.12,1:02:29.72,English,,0,0,0,,So there's 11 hex digits beyond the seven
Dialogue: 0,1:02:27.12,1:02:29.72,Chinese,,0,0,0,,所以除了七之外还有11个十六进制数字
Dialogue: 0,1:02:31.66,1:02:37.52,English,,0,0,0,,And you'll see that these addresses are at successive bytes bc,bd,be,bf
Dialogue: 0,1:02:31.66,1:02:37.52,Chinese,,0,0,0,,你会看到这些地址是连续的字节bc，bd，be，bf
Dialogue: 0,1:02:38.24,1:02:42.98,English,,0,0,0,,And the values are 0x6d3b0000 this is the least significant byte
Dialogue: 0,1:02:38.24,1:02:42.98,Chinese,,0,0,0,,值为0x6d3b0000，这是最低有效字节
Dialogue: 0,1:02:43.34,1:02:45.04,English,,0,0,0,,And these are the successive bytes
Dialogue: 0,1:02:43.34,1:02:45.04,Chinese,,0,0,0,,这些是连续的字节
Dialogue: 0,1:02:48.24,1:02:56.54,English,,0,0,0,,And similarly I can  use this to examine pointers of various sorts
Dialogue: 0,1:02:48.24,1:02:56.54,Chinese,,0,0,0,,同样，我可以用它来测试其他的变量
Dialogue: 0,1:02:56.54,1:03:01.60,English,,0,0,0,,And I can examine different values and just get their low-level byte representations
Dialogue: 0,1:02:56.54,1:03:01.60,Chinese,,0,0,0,,我可以检查不同的值，得到它们的低级字节表示
Dialogue: 0,1:03:02.18,1:03:05.76,English,,0,0,0,,And so I did this back when I could get to a Sun machine
Dialogue: 0,1:03:02.18,1:03:05.76,Chinese,,0,0,0,,所以当我用Sun机器时，我就这样做了
Dialogue: 0,1:03:05.78,1:03:07.92,English,,0,0,0,,It had one way of representing a pointer
Dialogue: 0,1:03:05.78,1:03:07.92,Chinese,,0,0,0,,它有一种表示指针的方法
Dialogue: 0,1:03:08.30,1:03:10.66,English,,0,0,0,,And the main point is even across machines
Dialogue: 0,1:03:08.30,1:03:10.66,Chinese,,0,0,0,,而重点是即使用了另一个机器机器
Dialogue: 0,1:03:10.66,1:03:14.02,English,,0,0,0,,Whether it's a byte ordering or whatever
Dialogue: 0,1:03:10.66,1:03:14.02,Chinese,,0,0,0,,无论是字节顺序还是其他什么
Dialogue: 0,1:03:14.44,1:03:21.82,English,,0,0,0,, You'll get different values for pointers,there's no guarantee  that when you load imputed a min to one machine and run it
Dialogue: 0,1:03:14.44,1:03:21.82,Chinese,,0,0,0,,你会得到不同的指针值，它无法保证你等一分钟后到一台机器并运行它时，
Dialogue: 0,1:03:22.04,1:03:28.06,English,,0,0,0,,That it will use the same addresses as that same programming running on a different machine
Dialogue: 0,1:03:22.04,1:03:28.06,Chinese,,0,0,0,,它将使用与之前一样的相同的编码和地址
Dialogue: 0,1:03:28.06,1:03:32.38,English,,0,0,0,,Even if actually they're identical hardware and operating system there can be variation
Dialogue: 0,1:03:28.06,1:03:32.38,Chinese,,0,0,0,,即使它们实际上是相同的硬件和操作系统，也可能存在差异
Dialogue: 0,1:03:33.44,1:03:39.22,English,,0,0,0,, Because pointers aren't you you can't directly copy a pointer from one machine to another
Dialogue: 0,1:03:33.44,1:03:39.22,Chinese,,0,0,0,,因为指针不是你，你不能直接将指针从一台机器复制到另一台机器
Dialogue: 0,1:03:41.24,1:03:51.32,English,,0,0,0,,On one thing about also is regardless of byte ordering  the ordering of of characters is the same
Dialogue: 0,1:03:41.24,1:03:51.32,Chinese,,0,0,0,,对于这件事也是无论字节顺序如何，字符的排序方式是相同的
Dialogue: 0,1:03:51.32,1:03:56.54,English,,0,0,0,,And so a string in C is always represented by a series of bytes
Dialogue: 0,1:03:51.32,1:03:56.54,Chinese,,0,0,0,,所以C中的字符串总是由一串字节表示
Dialogue: 0,1:03:57.02,1:04:01.20,English,,0,0,0,,Where the final byte is 0 note called null terminator
Dialogue: 0,1:03:57.02,1:04:01.20,Chinese,,0,0,0,,最后一个字节为0的地方称为 NULL 终止符
Dialogue: 0,1:04:01.50,1:04:08.06,English,,0,0,0,,And the individual bytes correspond to the character codes for that number
Dialogue: 0,1:04:01.50,1:04:08.06,Chinese,,0,0,0,,并且各个字节对应于该数值的字符代码
Dialogue: 0,1:04:08.36,1:04:12.92,English,,0,0,0,,And these character codes are just sometimes called ASCII format
Dialogue: 0,1:04:08.36,1:04:12.92,Chinese,,0,0,0,,这些字符代码有时也称为ASCII格式
Dialogue: 0,1:04:13.68,1:04:15.78,English,,0,0,0,,Which is a little bit old-fashioned by the way
Dialogue: 0,1:04:13.68,1:04:15.78,Chinese,,0,0,0,,顺便说一句，这有点过时了
Dialogue: 0,1:04:16.08,1:04:23.98,English,,0,0,0,, There's more modern character codes too that can represent non English alphabets
Dialogue: 0,1:04:16.08,1:04:23.98,Chinese,,0,0,0,,还有更现代的字符代码可以代表非英文字母
Dialogue: 0,1:04:24.44,1:04:32.14,English,,0,0,0,,But the C standard is still back in the days of only supporting the the ASCII format
Dialogue: 0,1:04:24.44,1:04:32.14,Chinese,,0,0,0,,但是C标准仍然支持ASCII格式
Dialogue: 0,1:04:32.14,1:04:33.14,English,,0,0,0,,Question
Dialogue: 0,1:04:32.14,1:04:33.14,Chinese,,0,0,0,,提问
Dialogue: 0,1:04:33.14,1:04:50.10,English,,0,0,0,, [student speaking]
Dialogue: 0,1:04:33.14,1:04:50.10,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:50.18,1:05:01.58,English,,0,0,0,,Yes!So this should have been...well no this is good so I'm casting
Dialogue: 0,1:04:50.18,1:05:01.58,Chinese,,0,0,0,,是的！所以这应该是......好吧这不是好事所以我正要解释
Dialogue: 0,1:05:01.88,1:05:05.00,English,,0,0,0,,I want to show the 4 bytes size event
Dialogue: 0,1:05:01.88,1:05:05.00,Chinese,,0,0,0,,我展示这4字节大小
Dialogue: 0,1:05:05.24,1:05:07.00,English,,0,0,0,,Because this is an int I'm representing
Dialogue: 0,1:05:05.24,1:05:07.00,Chinese,,0,0,0,,是因为这代表的是int
Dialogue: 0,1:05:07.80,1:05:11.44,English,,0,0,0,, The pointer let's see the code where it's printing the pointer
Dialogue: 0,1:05:07.80,1:05:11.44,Chinese,,0,0,0,,指针,  让我们看打印出指针的地方
Dialogue: 0,1:05:12.20,1:05:19.68,English,,0,0,0,,All this notation %p is the directive to say print out a pointer proposed right
Dialogue: 0,1:05:12.20,1:05:19.68,Chinese,,0,0,0,,符号％p打印出指针地址
Dialogue: 0,1:05:20.18,1:05:25.74,English,,0,0,0,,And %x is the directive to print out a hex representation
Dialogue: 0,1:05:20.18,1:05:25.74,Chinese,,0,0,0,,％x是打印出十六进制值
Dialogue: 0,1:05:26.68,1:05:31.54,English,,0,0,0,, So it's printing out both the address the starting position of that particular byte
Dialogue: 0,1:05:26.68,1:05:31.54,Chinese,,0,0,0,,因此，它将打印出这个比特的起始地址
Dialogue: 0,1:05:31.90,1:05:34.66,English,,0,0,0,, And the value of that byte as two different things
Dialogue: 0,1:05:31.90,1:05:34.66,Chinese,,0,0,0,,并且该字节的值是两个不同的东西
Dialogue: 0,1:05:35.56,1:05:36.90,English,,0,0,0,,Does that answer your question?
Dialogue: 0,1:05:35.56,1:05:36.90,Chinese,,0,0,0,,这是否能回答你的问题？
Dialogue: 0,1:05:37.04,1:05:51.98,English,,0,0,0,,[student speaking]
Dialogue: 0,1:05:37.04,1:05:51.98,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:05:52.10,1:06:00.42,English,,0,0,0,,But remember show bytes is being given a pointer and a length
Dialogue: 0,1:05:52.10,1:06:00.42,Chinese,,0,0,0,,但是请记住show bytes被给一个指针和数据类型长度
Dialogue: 0,1:06:01.50,1:06:09.02,English,,0,0,0,,And so what this is and what it's saying is starting at that address print out the next series of bytes for me
Dialogue: 0,1:06:01.50,1:06:09.02,Chinese,,0,0,0,,它所说的是从该地址开始为我打印出后面的字节
Dialogue: 0,1:06:09.02,1:06:11.22,English,,0,0,0,,How many bytes I asked for
Dialogue: 0,1:06:09.02,1:06:11.22,Chinese,,0,0,0,,按我要求的字节数
Dialogue: 0,1:06:11.62,1:06:15.68,English,,0,0,0,, And in this case I'm creating a pointer to this integer
Dialogue: 0,1:06:11.62,1:06:15.68,Chinese,,0,0,0,,在这种情况下，我创建了一个指向这个整数的指针
Dialogue: 0,1:06:15.90,1:06:22.26,English,,0,0,0,, But I want to show the the bytes in that integer the four bytes that make up that integer
Dialogue: 0,1:06:15.90,1:06:22.26,Chinese,,0,0,0,,但我想展示构成该整数的四个字节
Dialogue: 0,1:06:22.70,1:06:26.90,English,,0,0,0,, And that's why I'm giving it the number four here instead of eight is it
Dialogue: 0,1:06:22.70,1:06:26.90,Chinese,,0,0,0,,这就是为什么我在这里给它四个而不是八个
Dialogue: 0,1:06:26.90,1:06:32.84,English,,0,0,0,,[student speaking]
Dialogue: 0,1:06:26.90,1:06:32.84,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:06:32.84,1:06:34.62,English,,0,0,0,,Yes it will be
Dialogue: 0,1:06:32.84,1:06:34.62,Chinese,,0,0,0,,是的，它会
Dialogue: 0,1:06:34.62,1:06:37.46,English,,0,0,0,, And that's fine because in this code
Dialogue: 0,1:06:34.62,1:06:37.46,Chinese,,0,0,0,,这很好，因为在这段代码中
Dialogue: 0,1:06:37.84,1:06:43.78,English,,0,0,0,, It's I'm using the %p directive to designate how to print out the pointer
Dialogue: 0,1:06:37.84,1:06:43.78,Chinese,,0,0,0,,我正在使用％p指令来指示如何打印指针
Dialogue: 0,1:06:44.34,1:06:49.89,English,,0,0,0,,And that will print it as many bytes as it takes for that particular machine that it's running on
Dialogue: 0,1:06:44.34,1:06:49.89,Chinese,,0,0,0,,这将打印出特定机器运行时需要的字节
Dialogue: 0,1:06:50.74,1:06:53.64,English,,0,0,0,,So %p is actually a very handy directive
Dialogue: 0,1:06:50.74,1:06:53.64,Chinese,,0,0,0,,所以％p实际上是一个非常方便的指令
Dialogue: 0,1:06:53.64,1:06:57.50,English,,0,0,0,, If you have to print it addresses like for debugging purposes or something
Dialogue: 0,1:06:53.64,1:06:57.50,Chinese,,0,0,0,,如果你必须打印它的地址，如调试或其他东西
Dialogue: 0,1:06:57.50,1:07:01.32,English,,0,0,0,, Because it will automatically adapt to whatever machine it's running on
Dialogue: 0,1:06:57.50,1:07:01.32,Chinese,,0,0,0,,因为它会自动适应它运行的任何机器
Dialogue: 0,1:07:02.72,1:07:03.24,English,,0,0,0,,Question
Dialogue: 0,1:07:02.72,1:07:03.24,Chinese,,0,0,0,,题
Dialogue: 0,1:07:03.40,1:07:07.32,English,,0,0,0,,[student speaking]
Dialogue: 0,1:07:03.40,1:07:07.32,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:07:07.78,1:07:11.15,English,,0,0,0,,Well I've defined it to be an unsigned care here
Dialogue: 0,1:07:07.78,1:07:11.15,Chinese,,0,0,0,,好吧，我在这里定义它是一个无符号整数
Dialogue: 0,1:07:11.66,1:07:18.00,English,,0,0,0,,So typedef is a way to introduce a name for some of datatype right
Dialogue: 0,1:07:11.66,1:07:18.00,Chinese,,0,0,0,,因此，typedef 是一种为某些数据类型引入另外名称的运算符
Dialogue: 0,1:07:18.36,1:07:25.56,English,,0,0,0,,And so I've just declared a pointer quote pointer to refer to an unsigned care
Dialogue: 0,1:07:18.36,1:07:25.56,Chinese,,0,0,0,,我刚刚声明了一个无符号char类型的指针
Dialogue: 0,1:07:26.36,1:07:34.34,English,,0,0,0,,If you did a void * it would not be happy with this reference here right
Dialogue: 0,1:07:26.36,1:07:34.34,Chinese,,0,0,0,,如果你用 void *，你就不会对这里的写法所满意
Dialogue: 0,1:07:34.40,1:07:41.52,English,,0,0,0,,You can't reference a void * is just a way to pass around a generic pointer
Dialogue: 0,1:07:34.40,1:07:41.52,Chinese,,0,0,0,,你不能引用void *因为这只是一种传递泛型指针的方法
Dialogue: 0,1:07:41.52,1:07:43.56,English,,0,0,0,, But you can't actually reference that element
Dialogue: 0,1:07:41.52,1:07:43.56,Chinese,,0,0,0,,你实际上无法引用该元素
Dialogue: 0,1:07:44.06,1:07:49.70,English,,0,0,0,, So what I'm basically doing is saying this reference is treat it like an array
Dialogue: 0,1:07:44.06,1:07:49.70,Chinese,,0,0,0,,所以基本上我做的是把这个引用当作数组来处理
Dialogue: 0,1:07:50.38,1:07:56.54,English,,0,0,0,, Treat you treat my series of bytes is an array and print out each of the bytes in that array
Dialogue: 0,1:07:50.38,1:07:56.54,Chinese,,0,0,0,,把这一系列字节当作是一个数组并打印出该数组中的每个字节
Dialogue: 0,1:08:01.26,1:08:07.16,English,,0,0,0,,And so here where I'm a is a number
Dialogue: 0,1:08:01.26,1:08:07.16,Chinese,,0,0,0,,所以在我这里 a 是一个数字
Dialogue: 0,1:08:07.42,1:08:11.18,English,,0,0,0,, And I'm taking the address of that integer
Dialogue: 0,1:08:07.42,1:08:11.18,Chinese,,0,0,0,,而我取这个数的地址
Dialogue: 0,1:08:11.58,1:08:14.90,English,,0,0,0,,And casting it to be an unsigned char *
Dialogue: 0,1:08:11.58,1:08:14.90,Chinese,,0,0,0,,并将其转换为unsigned char *
Dialogue: 0,1:08:16.00,1:08:20.68,English,,0,0,0,,So sort of a generic slightly generic pointer but not quite as generic as void *
Dialogue: 0,1:08:16.00,1:08:20.68,Chinese,,0,0,0,,所以有点像泛型的通用指针，但不像void*那样通用
Dialogue: 0,1:08:21.58,1:08:26.50,English,,0,0,0,,And then printing it out.It's good question by the way
Dialogue: 0,1:08:21.58,1:08:26.50,Chinese,,0,0,0,,然后把它打印出来。顺便说一句，这是个好问题
Dialogue: 0,1:08:31.00,1:08:34.58,English,,0,0,0,,Okay so the point being that strings are just strings
Dialogue: 0,1:08:31.00,1:08:34.58,Chinese,,0,0,0,,好的，关键是字符串只是字符串
Dialogue: 0,1:08:34.58,1:08:37.58,English,,0,0,0,,So that's the same from one machine to the next
Dialogue: 0,1:08:34.58,1:08:37.58,Chinese,,0,0,0,,从一台机器到另一台机器也是如此
Dialogue: 0,1:08:39.20,1:08:42.26,English,,0,0,0,, Okay what soonish up today with some puzzles
Dialogue: 0,1:08:39.20,1:08:42.26,Chinese,,0,0,0,,好吧今天有一些谜题
Dialogue: 0,1:08:42.26,1:08:46.48,English,,0,0,0,,And these have this annoying way of showing up on exams
Dialogue: 0,1:08:42.26,1:08:46.48,Chinese,,0,0,0,,这些会用这种令人烦恼的方式出现在考试中
Dialogue: 0,1:08:46.84,1:08:50.66,English,,0,0,0,,So it's worth being able to do these kind of things
Dialogue: 0,1:08:46.84,1:08:50.66,Chinese,,0,0,0,,所以做这些事情是值得的
Dialogue: 0,1:08:52.76,1:08:57.12,English,,0,0,0,,And you'll also notice I cleverly did not include the answers in the slides
Dialogue: 0,1:08:52.76,1:08:57.12,Chinese,,0,0,0,,你还会注意到我没有把答案放在幻灯片中
Dialogue: 0,1:09:00.84,1:09:04.36,English,,0,0,0,,So you can't just peek ahead and figure out what the answers are
Dialogue: 0,1:09:00.84,1:09:04.36,Chinese,,0,0,0,,所以你不能只是向前看，得找出答案是什么
Dialogue: 0,1:09:04.36,1:09:08.42,English,,0,0,0,, So let's just go through them but I actually worked them out to make sure I have the answers
Dialogue: 0,1:09:04.36,1:09:08.42,Chinese,,0,0,0,,所以，让我们解决它们，但我实际上已经完成它们并确保我的答案是正确的
Dialogue: 0,1:09:09.04,1:09:16.62,English,,0,0,0,, So if x and basically these are sort of statements that you want to say these are either always true
Dialogue: 0,1:09:09.04,1:09:16.62,Chinese,,0,0,0,,如果x,  基本上这些问题你们总是会说这是正确的
Dialogue: 0,1:09:17.02,1:09:19.82,English,,0,0,0,,And maybe there's some logic behind why it's always true
Dialogue: 0,1:09:17.02,1:09:19.82,Chinese,,0,0,0,,也许有一些背后的逻辑说明为什么它总是正确的
Dialogue: 0,1:09:20.22,1:09:25.40,English,,0,0,0,,Or it's possibly false and you won't have to give some example that would make that false
Dialogue: 0,1:09:20.22,1:09:25.40,Chinese,,0,0,0,,或者它可能是错误的，你不必提供一些可能会导致错误的例子
Dialogue: 0,1:09:26.26,1:09:31.92,English,,0,0,0,,So let's go through these as many as we have time for  and see where we get to
Dialogue: 0,1:09:26.26,1:09:31.92,Chinese,,0,0,0,,因此，让我们尽可能多地浏览这些内容，看看能到达什么程度
Dialogue: 0,1:09:31.92,1:09:35.56,English,,0,0,0,,So if I take x and I double it multiply it by 2
Dialogue: 0,1:09:31.92,1:09:35.56,Chinese,,0,0,0,,所以如果我拿x和我加倍它乘以2
Dialogue: 0,1:09:35.98,1:09:41.43,English,,0,0,0,, if x who are negative and my guaranteed that 2x will be negative
Dialogue: 0,1:09:35.98,1:09:41.43,Chinese,,0,0,0,,如果x为负数那我就可以保证2x将为负数
Dialogue: 0,1:09:42.12,1:09:43.98,English,,0,0,0,,No so
Dialogue: 0,1:09:42.12,1:09:43.98,Chinese,,0,0,0,,不是的
Dialogue: 0,1:09:44.68,1:09:49.82,English,,0,0,0,,By the way one general way to find counter examples is to try team in
Dialogue: 0,1:09:44.68,1:09:49.82,Chinese,,0,0,0,,顺便提一下，找到反例的一种方法是尝试整体思考
Dialogue: 0,1:09:50.46,1:09:51.74,English,,0,0,0,,It's a really good one
Dialogue: 0,1:09:50.46,1:09:51.74,Chinese,,0,0,0,,这是一个非常好的例子
Dialogue: 0,1:09:52.40,1:09:57.44,English,,0,0,0,,And that works here right if I take team n which is one and a bunch of zeros I double it
Dialogue: 0,1:09:52.40,1:09:57.44,Chinese,,0,0,0,,如果我拿出一个有一个1和一堆0组成的数字然后我乘以2
Dialogue: 0,1:09:57.96,1:10:02.90,English,,0,0,0,,It's like shifting it but left and it will become what 0 right
Dialogue: 0,1:09:57.96,1:10:02.90,Chinese,,0,0,0,,我们向左移动,  他就变成了0
Dialogue: 0,1:10:05.12,1:10:09.58,English,,0,0,0,,And so again assume that x is at any negative number
Dialogue: 0,1:10:05.12,1:10:09.58,Chinese,,0,0,0,,因此再次假设x是任何负数
Dialogue: 0,1:10:09.58,1:10:14.66,English,,0,0,0,, And ux is any two's complement number
Dialogue: 0,1:10:09.58,1:10:14.66,Chinese,,0,0,0,,而且ux是任意一个补码数
Dialogue: 0,1:10:15.08,1:10:19.20,English,,0,0,0,,And ux is what happens if I cast it to be unsigned
Dialogue: 0,1:10:15.08,1:10:19.20,Chinese,,0,0,0,,如果我将它转换为无符号数，那么ux会发生什么
Dialogue: 0,1:10:19.42,1:10:22.06,English,,0,0,0,,So as ux always you're greater than or equal to 0
Dialogue: 0,1:10:19.42,1:10:22.06,Chinese,,0,0,0,,所以，因为ux总是大于或等于0
Dialogue: 0,1:10:23.04,1:10:23.48,English,,0,0,0,,Yeah
Dialogue: 0,1:10:23.04,1:10:23.48,Chinese,,0,0,0,,是啊
Dialogue: 0,1:10:25.84,1:10:32.16,English,,0,0,0,,This is slightly more obscure if I take x and I mask off 7
Dialogue: 0,1:10:25.84,1:10:32.16,Chinese,,0,0,0,,这稍微模糊一些，如果我用x遮掩掉7
Dialogue: 0,1:10:32.16,1:10:34.78,English,,0,0,0,,you remember is the bit pattern 111
Dialogue: 0,1:10:32.16,1:10:34.78,Chinese,,0,0,0,,你还记得是7的二进制表示是111
Dialogue: 0,1:10:35.34,1:10:38.18,English,,0,0,0,,So if I mask off all but the lowest 3 bits
Dialogue: 0,1:10:35.34,1:10:38.18,Chinese,,0,0,0,,因此，如果我屏蔽掉除最低3位之外的所有内容
Dialogue: 0,1:10:40.10,1:10:41.96,English,,0,0,0,,And I find that those are all ones
Dialogue: 0,1:10:40.10,1:10:41.96,Chinese,,0,0,0,,我发现这些都是1
Dialogue: 0,1:10:42.30,1:10:44.25,English,,0,0,0,,I'm already giving you the answer here
Dialogue: 0,1:10:42.30,1:10:44.25,Chinese,,0,0,0,,我已经在这里给你答案了
Dialogue: 0,1:10:44.25,1:10:47.08,English,,0,0,0,,And then I shift it left by 30 positions
Dialogue: 0,1:10:44.25,1:10:47.08,Chinese,,0,0,0,,然后我将其左移30个位置
Dialogue: 0,1:10:47.50,1:10:59.45,English,,0,0,0,,What can I say about the result
Dialogue: 0,1:10:47.50,1:10:59.45,Chinese,,0,0,0,,我能说结果是什么吗?
Dialogue: 0,1:10:59.84,1:11:06.00,English,,0,0,0,,So I know the x must finish with three ones right
Dialogue: 0,1:10:59.84,1:11:06.00,Chinese,,0,0,0,,我知道x必须用三个 1 才能完成
Dialogue: 0,1:11:07.30,1:11:20.18,English,,0,0,0,, And I shift that by thirty
Dialogue: 0,1:11:07.30,1:11:20.18,Chinese,,0,0,0,,我把它移30位
Dialogue: 0,1:11:20.18,1:11:25.24,English,,0,0,0,,And this these will be the only two bits that are left after the shifting
Dialogue: 0,1:11:20.18,1:11:25.24,Chinese,,0,0,0,,而这些将是移位后留下的唯一两位
Dialogue: 0,1:11:25.76,1:11:29.32,English,,0,0,0,,And they will be in the most significant position
Dialogue: 0,1:11:25.76,1:11:29.32,Chinese,,0,0,0,,他们将处于最高位
Dialogue: 0,1:11:29.32,1:11:33.02,English,,0,0,0,,So what can I say about that number is negative
Dialogue: 0,1:11:29.32,1:11:33.02,Chinese,,0,0,0,,那么我是否可以说这个数是负数?
Dialogue: 0,1:11:33.34,1:11:37.51,English,,0,0,0,,So this is a true statement rather obscure,but it is true
Dialogue: 0,1:11:33.34,1:11:37.51,Chinese,,0,0,0,,所以这是一个相当模糊的真实陈述，但这是事实
Dialogue: 0,1:11:38.18,1:11:40.96,English,,0,0,0,,Is UX greater than -1?
Dialogue: 0,1:11:38.18,1:11:40.96,Chinese,,0,0,0,,UX大于-1？
Dialogue: 0,1:11:45.64,1:11:50.66,English,,0,0,0,,It's almost true right
Dialogue: 0,1:11:45.64,1:11:50.66,Chinese,,0,0,0,,这几乎是对的
Dialogue: 0,1:11:50.78,1:11:58.14,English,,0,0,0,,The one counterexample would be what zero
Dialogue: 0,1:11:50.78,1:11:58.14,Chinese,,0,0,0,,一个反例就是零
Dialogue: 0,1:11:59.26,1:12:03.40,English,,0,0,0,,Well actually no you're right there's a lot of examples it's hardly ever true
Dialogue: 0,1:11:59.26,1:12:03.40,Chinese,,0,0,0,,实际上有很多例子证明他不是真的
Dialogue: 0,1:12:03.52,1:12:06.32,English,,0,0,0,,It's almost always false I was wrong
Dialogue: 0,1:12:03.52,1:12:06.32,Chinese,,0,0,0,,这几乎总是假的,  是我错了
Dialogue: 0,1:12:06.98,1:12:13.04,English,,0,0,0,,The only thing that would make it true would be...it's never true
Dialogue: 0,1:12:06.98,1:12:13.04,Chinese,,0,0,0,,唯一能让它变为对的...它永远不会是真的
Dialogue: 0,1:12:13.20,1:12:15.78,English,,0,0,0,,[student laugh]
Dialogue: 0,1:12:13.20,1:12:15.78,Chinese,,0,0,0,,[学生笑]
Dialogue: 0,1:12:15.78,1:12:16.88,English,,0,0,0,,Okay so it's never true
Dialogue: 0,1:12:15.78,1:12:16.88,Chinese,,0,0,0,,好的，所以它永远不会是真的
Dialogue: 0,1:12:18.40,1:12:23.40,English,,0,0,0,,Okay if x is greater than y is -x less than -y
Dialogue: 0,1:12:18.40,1:12:23.40,Chinese,,0,0,0,,好的，如果x大于y，则-x小于-y
Dialogue: 0,1:12:35.24,1:12:39.38,English,,0,0,0,,No so by the way one thing we didn't really cover is
Dialogue: 0,1:12:35.24,1:12:39.38,Chinese,,0,0,0,,不是这样，我们没有真正涵盖的一件事是
Dialogue: 0,1:12:39.78,1:12:46.94,English,,0,0,0,,What is the negative of Tmin
Dialogue: 0,1:12:39.78,1:12:46.94,Chinese,,0,0,0,,Tmin的非是什么？
Dialogue: 0,1:12:46.94,1:12:50.46,English,,0,0,0,,And to see that we can use our compliment  and income increment trick
Dialogue: 0,1:12:46.94,1:12:50.46,Chinese,,0,0,0,,看到我们可以使用之前的取反和增量的技巧
Dialogue: 0,1:12:58.95,1:13:04.82,English,,0,0,0,,So when you compliment and increment G min you get Tmin
Dialogue: 0,1:12:58.95,1:13:04.82,Chinese,,0,0,0,,因此，当你取反和增加G min时，你得到Tmin
Dialogue: 0,1:13:05.22,1:13:08.90,English,,0,0,0,,And that's a why it's such a great counter example
Dialogue: 0,1:13:05.22,1:13:08.90,Chinese,,0,0,0,,这就是为什么它是一个如此强大的反例
Dialogue: 0,1:13:10.64,1:13:19.13,English,,0,0,0,, So in particular if y is tmin and x is something else
Dialogue: 0,1:13:10.64,1:13:19.13,Chinese,,0,0,0,,所以特别是如果y是tmin而x是其他东西
Dialogue: 0,1:13:19.92,1:13:24.22,English,,0,0,0,,Then that left-hand part will be true but the right-hand part will not be true
Dialogue: 0,1:13:19.92,1:13:24.22,Chinese,,0,0,0,,然后左部分将是真的，但右部分将不是真的
Dialogue: 0,1:13:27.02,1:13:34.54,English,,0,0,0,,Okay x*x greater than or equal to zero we've seen examples of that being false
Dialogue: 0,1:13:27.02,1:13:34.54,Chinese,,0,0,0,,好的x * x大于或等于零，我们已经看到了假的例子
Dialogue: 0,1:13:37.60,1:13:45.18,English,,0,0,0,,If x is...this is kind of silly. If x is greater than 0 and y is greater than 0. Is x+y > 0.No
Dialogue: 0,1:13:37.60,1:13:45.18,Chinese,,0,0,0,,如果x是......这有点傻。如果x大于0且y大于0.是x + y> 0.No
Dialogue: 0,1:13:47.24,1:13:51.90,English,,0,0,0,,If x >= 0. Is -x<= 0
Dialogue: 0,1:13:47.24,1:13:51.90,Chinese,,0,0,0,,如果x> = 0.是-x <= 0
Dialogue: 0,1:13:54.28,1:13:57.48,English,,0,0,0,,Gotcha, you're right it's true right
Dialogue: 0,1:13:54.28,1:13:57.48,Chinese,,0,0,0,,好的，你是对的，这是对的
Dialogue: 0,1:13:58.12,1:14:06.03,English,,0,0,0,, Because that...but let's take it counter part.If x <=0. Is -x >= 0
Dialogue: 0,1:13:58.12,1:14:06.03,Chinese,,0,0,0,,因为那......但是让我们把它作为对应部分。如果x <= 0,  则-x> = 0
Dialogue: 0,1:14:06.90,1:14:14.82,English,,0,0,0,,Tmin right so right the point being that the largest any positive number can be represented as negative
Dialogue: 0,1:14:06.90,1:14:14.82,Chinese,,0,0,0,,Tmin对，因为任何正数都可以表示为负数
Dialogue: 0,1:14:15.40,1:14:19.46,English,,0,0,0,,But there's one negative number that can't be represented as positive
Dialogue: 0,1:14:15.40,1:14:19.46,Chinese,,0,0,0,,但是有一个负数不能表示为正数
Dialogue: 0,1:14:20.18,1:14:24.00,English,,0,0,0,,And so that asymmetry is why you get different answers to these
Dialogue: 0,1:14:20.18,1:14:24.00,Chinese,,0,0,0,,因此这种不对称决定了你会得到不同的答案
Dialogue: 0,1:14:25.44,1:14:31.76,English,,0,0,0,, If I take x and I look at -x and I shift them to the right by 31
Dialogue: 0,1:14:25.44,1:14:31.76,Chinese,,0,0,0,,如果我对x和-x取或然后我将它们右移31位
Dialogue: 0,1:14:33.60,1:14:35.20,English,,0,0,0,,Am I going to get all ones
Dialogue: 0,1:14:33.60,1:14:35.20,Chinese,,0,0,0,,我会得到1
Dialogue: 0,1:14:36.44,1:14:48.08,English,,0,0,0,, This is a really weird statement
Dialogue: 0,1:14:36.44,1:14:48.08,Chinese,,0,0,0,,这是一个非常奇怪的陈述
Dialogue: 0,1:14:48.90,1:14:51.02,English,,0,0,0,,So it actually kind of works right
Dialogue: 0,1:14:48.90,1:14:51.02,Chinese,,0,0,0,,所以它实际上是可以工作的
Dialogue: 0,1:14:51.48,1:15:02.56,English,,0,0,0,,If I take all zeros
Dialogue: 0,1:14:51.48,1:15:02.56,Chinese,,0,0,0,,如果我取全部位为零
Dialogue: 0,1:15:03.00,1:15:11.66,English,,0,0,0,,And I subtract one I'll get -1
Dialogue: 0,1:15:03.00,1:15:11.66,Chinese,,0,0,0,,然后我减去1我会得到-1
Dialogue: 0,1:15:11.66,1:15:18.68,English,,0,0,0,,And I order them, that works
Dialogue: 0,1:15:11.66,1:15:18.68,Chinese,,0,0,0,,而我对他们取或，这都有效
Dialogue: 0,1:15:19.52,1:15:20.64,English,,0,0,0,,So what's wrong with this?
Dialogue: 0,1:15:19.52,1:15:20.64,Chinese,,0,0,0,,那有什么不对呢？
Dialogue: 0,1:15:25.24,1:15:25.80,English,,0,0,0,,what's that?
Dialogue: 0,1:15:25.24,1:15:25.80,Chinese,,0,0,0,,那是什么？
Dialogue: 0,1:15:27.62,1:15:32.82,English,,0,0,0,,Oh but if I shift this to the right 31 places it's going to shift arithmetic
Dialogue: 0,1:15:27.62,1:15:32.82,Chinese,,0,0,0,,哦，但是如果我把它右移31个位置，它就会做算术右移
Dialogue: 0,1:15:32.84,1:15:41.82,English,,0,0,0,,[student speaking]
Dialogue: 0,1:15:32.84,1:15:41.82,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:15:42.32,1:15:43.22,English,,0,0,0,,What's that?
Dialogue: 0,1:15:42.32,1:15:43.22,Chinese,,0,0,0,,那是什么？
Dialogue: 0,1:15:46.14,1:15:50.84,English,,0,0,0,,Oh I see, oh I'm sorry I already jumped ahead to a different puzzle
Dialogue: 0,1:15:46.14,1:15:50.84,Chinese,,0,0,0,,哦，我明白了，哦，对不起，我已经跳到了另一个难题
Dialogue: 0,1:15:52.94,1:15:59.01,English,,0,0,0,, x and  -x and I'm so you're right actually
Dialogue: 0,1:15:52.94,1:15:59.01,Chinese,,0,0,0,,x和-x，实际上你是对的
Dialogue: 0,1:15:59.88,1:16:08.50,English,,0,0,0,,If the two numbers are 0 and I or those I get 0
Dialogue: 0,1:15:59.88,1:16:08.50,Chinese,,0,0,0,,如果这两个数字是0,  那我就会得到0
Dialogue: 0,1:16:08.92,1:16:12.54,English,,0,0,0,, But you'll figure out you'll notice if it's anything non zero
Dialogue: 0,1:16:08.92,1:16:12.54,Chinese,,0,0,0,,但你会发现如果你注意到非零数
Dialogue: 0,1:16:13.46,1:16:14.82,English,,0,0,0,,Actually this will be true
Dialogue: 0,1:16:13.46,1:16:14.82,Chinese,,0,0,0,,这就是对的
Dialogue: 0,1:16:16.12,1:16:18.04,English,,0,0,0,,And that's an interesting feature
Dialogue: 0,1:16:16.12,1:16:18.04,Chinese,,0,0,0,,这是一个有趣的功能
Dialogue: 0,1:16:18.26,1:16:22.04,English,,0,0,0,,So there's a couple other puzzles and I'll let you solve those on your own
Dialogue: 0,1:16:18.26,1:16:22.04,Chinese,,0,0,0,,所以还有其他一些难题，我会让你自己解决这些难题
Dialogue: 0,1:16:22.08,1:16:25.22,English,,0,0,0,, We're all set for today
Dialogue: 0,1:16:22.08,1:16:25.22,Chinese,,0,0,0,,今天这堂课就结束了
