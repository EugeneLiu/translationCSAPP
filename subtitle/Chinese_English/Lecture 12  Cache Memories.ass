[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 12  Cache Memories.mp4
Video File: ../../../../Desktop/csapp/Lecture 12  Cache Memories.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.125000
Scroll Position: 844
Active Line: 849
Video Position: 141193

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:04.16,English,,0,0,0,,Good afternoon everyone welcome to 213 it's good to see you
Dialogue: 0,0:00:00.00,0:00:04.16,Chinese,,0,0,0,,大家下午好，欢迎来到213，很高兴见到你
Dialogue: 0,0:00:06.14,0:00:12.46,English,,0,0,0,,Just a reminder that your attack lab is due tonight at 11:59 p.m.
Dialogue: 0,0:00:06.14,0:00:12.46,Chinese,,0,0,0,,请提醒你，你的攻击实验室将于今晚11点59分到期。
Dialogue: 0,0:00:13.22,0:00:16.18,English,,0,0,0,,You have one grace day for this lab
Dialogue: 0,0:00:13.22,0:00:16.18,Chinese,,0,0,0,,这个实验室你有一个宽限期
Dialogue: 0,0:00:17.00,0:00:19.82,English,,0,0,0,,And cache lab we'll go out it right about the same time
Dialogue: 0,0:00:17.00,0:00:19.82,Chinese,,0,0,0,,和缓存实验室我们将在同一时间出去
Dialogue: 0,0:00:21.36,0:00:25.68,English,,0,0,0,,Now it's going to be a little tight for cache labs it'll be due next Thursday
Dialogue: 0,0:00:21.36,0:00:25.68,Chinese,,0,0,0,,现在它对缓存实验室来说有点紧张，它将在下周四到期
Dialogue: 0,0:00:27.04,0:00:29.84,English,,0,0,0,,So you might want to you might want to get started on that soon
Dialogue: 0,0:00:27.04,0:00:29.84,Chinese,,0,0,0,,所以你可能希望你很快就能开始这么做
Dialogue: 0,0:00:32.92,0:00:36.90,English,,0,0,0,,Last lecture we learned about the memory hierarchy and the idea of caching
Dialogue: 0,0:00:32.92,0:00:36.90,Chinese,,0,0,0,,最后一节课我们了解了内存层次结构和缓存的概念
Dialogue: 0,0:00:37.54,0:00:41.24,English,,0,0,0,,Today we're going to look at a very important kind of cache
Dialogue: 0,0:00:37.54,0:00:41.24,Chinese,,0,0,0,,今天我们将看一个非常重要的缓存
Dialogue: 0,0:00:43.28,0:00:46.22,English,,0,0,0,,Which are called cache memories
Dialogue: 0,0:00:43.28,0:00:46.22,Chinese,,0,0,0,,哪些被称为缓存
Dialogue: 0,0:00:47.40,0:00:49.96,English,,0,0,0,,And they're very important to you as a programmer
Dialogue: 0,0:00:47.40,0:00:49.96,Chinese,,0,0,0,,作为程序员，它们对你非常重要
Dialogue: 0,0:00:49.96,0:00:53.40,English,,0,0,0,,Because they can have such a big impact on the performance of your program
Dialogue: 0,0:00:49.96,0:00:53.40,Chinese,,0,0,0,,因为它们会对程序的性能产生如此大的影响
Dialogue: 0,0:00:53.96,0:00:57.87,English,,0,0,0,,So if you know about these the existence of these cache memories and you know how they work
Dialogue: 0,0:00:53.96,0:00:57.87,Chinese,,0,0,0,,因此，如果你知道这些缓存的存在，你知道它们是如何工作的
Dialogue: 0,0:00:59.30,0:01:02.20,English,,0,0,0,,As a programmer you'll be able to take advantage of that in your programs
Dialogue: 0,0:00:59.30,0:01:02.20,Chinese,,0,0,0,,作为程序员，你将能够在程序中利用它
Dialogue: 0,0:01:08.42,0:01:15.58,English,,0,0,0,,So last time we looked at the memory hierarchy is a collection of storage devices
Dialogue: 0,0:01:08.42,0:01:15.58,Chinese,,0,0,0,,所以上次我们查看内存层次结构是一个存储设备的集合
Dialogue: 0,0:01:16.30,0:01:31.02,English,,0,0,0,,With smaller,costlier and faster devices at the top and slower cheaper and much larger devices at the at the bottom
Dialogue: 0,0:01:16.30,0:01:31.02,Chinese,,0,0,0,,顶部设备更小，更昂贵，速度更快，底部设备更便宜，设备更大
Dialogue: 0,0:01:32.04,0:01:34.80,English,,0,0,0,,And then at each level in this hierarchy
Dialogue: 0,0:01:32.04,0:01:34.80,Chinese,,0,0,0,,然后在这个层次结构的每个级别
Dialogue: 0,0:01:35.48,0:01:42.76,English,,0,0,0,,The device at level k serves as a cache holds a subset of the blocks of
Dialogue: 0,0:01:35.48,0:01:42.76,Chinese,,0,0,0,,级别k的设备用作高速缓存保存块的子集
Dialogue: 0,0:01:43.28,0:01:47.92,English,,0,0,0,,That are contained in the device at the lower level at level k+1
Dialogue: 0,0:01:43.28,0:01:47.92,Chinese,,0,0,0,,它包含在较低级别的设备中，级别为k + 1
Dialogue: 0,0:01:52.06,0:01:55.94,English,,0,0,0,,Now recall the general idea of caching so we have a memory
Dialogue: 0,0:01:52.06,0:01:55.94,Chinese,,0,0,0,,现在回想一下缓存的一般概念，这样我们就有了记忆
Dialogue: 0,0:01:57.10,0:02:01.70,English,,0,0,0,,It's an array of bytes and we break it up arbitrarily into a collection of blocks
Dialogue: 0,0:01:57.10,0:02:01.70,Chinese,,0,0,0,,它是一个字节数组，我们将它任意分解为一个块集合
Dialogue: 0,0:02:03.52,0:02:08.30,English,,0,0,0,,And these this memory is larger slower and cheaper
Dialogue: 0,0:02:03.52,0:02:08.30,Chinese,,0,0,0,,而这些内存更慢更便宜
Dialogue: 0,0:02:08.48,0:02:14.98,English,,0,0,0,,And so it's,and it's much larger than than a cache which is smaller faster and more expensive
Dialogue: 0,0:02:08.48,0:02:14.98,Chinese,,0,0,0,,它就是这样，而且它比一个更小，更快，更昂贵的缓存大得多
Dialogue: 0,0:02:15.76,0:02:20.82,English,,0,0,0,,And which holds a subset of the blocks that are contained in the main memory
Dialogue: 0,0:02:15.76,0:02:20.82,Chinese,,0,0,0,,并且它包含主存储器中包含的块的子集
Dialogue: 0,0:02:22.66,0:02:27.96,English,,0,0,0,,And then blocks are copied back and forth between the cache in the memory in these block size transfer units
Dialogue: 0,0:02:22.66,0:02:27.96,Chinese,,0,0,0,,然后，在这些块大小传输单元中，块在存储器中的高速缓存之间来回复制
Dialogue: 0,0:02:29.00,0:02:35.62,English,,0,0,0,,So for example if our program requests a word that's in contained in block number 4
Dialogue: 0,0:02:29.00,0:02:35.62,Chinese,,0,0,0,,因此，例如，如果我们的程序请求包含在块编号4中的单词
Dialogue: 0,0:02:38.16,0:02:43.30,English,,0,0,0,,It asks the cache to return the word that's contained in block 4
Dialogue: 0,0:02:38.16,0:02:43.30,Chinese,,0,0,0,,它要求缓存返回块4中包含的单词
Dialogue: 0,0:02:43.90,0:02:48.16,English,,0,0,0,,The cache looks and it's at the blocks that it's the subset of the blocks
Dialogue: 0,0:02:43.90,0:02:48.16,Chinese,,0,0,0,,缓存看起来就是块，它是块的子集
Dialogue: 0,0:02:48.16,0:02:51.34,English,,0,0,0,,That it's stored discovers that block 4 is not there
Dialogue: 0,0:02:48.16,0:02:51.34,Chinese,,0,0,0,,存储它发现块4不存在
Dialogue: 0,0:02:52.04,0:02:54.44,English,,0,0,0,,So it asks the main memory to send it block 4
Dialogue: 0,0:02:52.04,0:02:54.44,Chinese,,0,0,0,,所以它要求主存储器发送它块4
Dialogue: 0,0:02:55.00,0:02:59.40,English,,0,0,0,,Which it does and when that block arrives at the cache
Dialogue: 0,0:02:55.00,0:02:59.40,Chinese,,0,0,0,,它的作用以及该块何时到达缓存
Dialogue: 0,0:02:59.90,0:03:04.30,English,,0,0,0,,The cache stores it but potentially overwriting some existing block
Dialogue: 0,0:02:59.90,0:03:04.30,Chinese,,0,0,0,,缓存存储它但可能覆盖一些现有块
Dialogue: 0,0:03:05.04,0:03:08.48,English,,0,0,0,,Similarly if our program asks for a data word
Dialogue: 0,0:03:05.04,0:03:08.48,Chinese,,0,0,0,,同样，如果我们的程序要求数据字
Dialogue: 0,0:03:09.08,0:03:10.74,English,,0,0,0,,If that's contained within block 10
Dialogue: 0,0:03:09.08,0:03:10.74,Chinese,,0,0,0,,如果包含在第10块中
Dialogue: 0,0:03:11.42,0:03:14.24,English,,0,0,0,,The cache looks sees that it doesn't have that block
Dialogue: 0,0:03:11.42,0:03:14.24,Chinese,,0,0,0,,缓存外观看到它没有该块
Dialogue: 0,0:03:14.58,0:03:19.04,English,,0,0,0,,So it requests that block for memory which copies it into the cache
Dialogue: 0,0:03:14.58,0:03:19.04,Chinese,,0,0,0,,因此它请求将内存块复制到缓存中
Dialogue: 0,0:03:19.77,0:03:22.58,English,,0,0,0,,Which overwrites an existing block
Dialogue: 0,0:03:19.77,0:03:22.58,Chinese,,0,0,0,,这会覆盖现有的块
Dialogue: 0,0:03:23.40,0:03:28.86,English,,0,0,0,,Now subsequently if our program asks for a request
Dialogue: 0,0:03:23.40,0:03:28.86,Chinese,,0,0,0,,现在，如果我们的程序要求请求
Dialogue: 0,0:03:29.04,0:03:32.56,English,,0,0,0,,If our program references a word that's contained in block 10
Dialogue: 0,0:03:29.04,0:03:32.56,Chinese,,0,0,0,,如果我们的程序引用了块10中包含的单词
Dialogue: 0,0:03:32.62,0:03:38.98,English,,0,0,0,,For example then the cache then we have a hit and the cache can return that block immediately
Dialogue: 0,0:03:32.62,0:03:38.98,Chinese,,0,0,0,,例如，然后缓存然后我们有一个命中，缓存可以立即返回该块
Dialogue: 0,0:03:39.34,0:03:45.94,English,,0,0,0,,Without going through the expensive operation of contacting memory and fetching that block from memory
Dialogue: 0,0:03:39.34,0:03:45.94,Chinese,,0,0,0,,无需经历昂贵的联系内存操作并从内存中获取该块
Dialogue: 0,0:03:50.22,0:03:54.95,English,,0,0,0,,Now there's a very important class of caches these so called cache memories
Dialogue: 0,0:03:50.22,0:03:54.95,Chinese,,0,0,0,,现在有一类非常重要的缓存，即所谓的缓存
Dialogue: 0,0:03:55.80,0:03:59.12,English,,0,0,0,,Which are contained in the CPU chip itself
Dialogue: 0,0:03:55.80,0:03:59.12,Chinese,,0,0,0,,哪些包含在CPU芯片本身中
Dialogue: 0,0:04:00.02,0:04:01.98,English,,0,0,0,,And are managed completely by hardware
Dialogue: 0,0:04:00.02,0:04:01.98,Chinese,,0,0,0,,并且完全由硬件管理
Dialogue: 0,0:04:02.56,0:04:05.88,English,,0,0,0,,And they're implemented using fast SRAM memories
Dialogue: 0,0:04:02.56,0:04:05.88,Chinese,,0,0,0,,它们是使用快速SRAM存储器实现的
Dialogue: 0,0:04:07.56,0:04:11.88,English,,0,0,0,,And the idea for this cache which write next to the register file
Dialogue: 0,0:04:07.56,0:04:11.88,Chinese,,0,0,0,,以及写入寄存器文件旁边的缓存的想法
Dialogue: 0,0:04:13.50,0:04:18.50,English,,0,0,0,,Is to hold frequently access blocks or blocks from main memory that are accessed frequently
Dialogue: 0,0:04:13.50,0:04:18.50,Chinese,,0,0,0,,是经常访问主存储器中经常访问的块或块
Dialogue: 0,0:04:19.06,0:04:22.40,English,,0,0,0,,Okay so hopefully because of the principle of locality
Dialogue: 0,0:04:19.06,0:04:22.40,Chinese,,0,0,0,,好吧，希望因为地方原则
Dialogue: 0,0:04:23.20,0:04:31.02,English,,0,0,0,,Most of our requests for data will actually be served out of this cache memory and a few cycles
Dialogue: 0,0:04:23.20,0:04:31.02,Chinese,,0,0,0,,我们对数据的大多数请求实际上都会从这个缓存内存中提供几个周期
Dialogue: 0,0:04:31.48,0:04:35.32,English,,0,0,0,,Rather than from this slow main memory
Dialogue: 0,0:04:31.48,0:04:35.32,Chinese,,0,0,0,,而不是从这个缓慢的主存
Dialogue: 0,0:04:40.40,0:04:43.04,English,,0,0,0,,Now cache memories are managed completely in hardware
Dialogue: 0,0:04:40.40,0:04:43.04,Chinese,,0,0,0,,现在，高速缓存存储器完全由硬件管理
Dialogue: 0,0:04:44.00,0:04:49.32,English,,0,0,0,,So this means that the heart there's ,here has to be hardware logic that knows
Dialogue: 0,0:04:44.00,0:04:49.32,Chinese,,0,0,0,,所以这意味着那里的心脏，这里必须是知道的硬件逻辑
Dialogue: 0,0:04:49.80,0:04:55.62,English,,0,0,0,,How to look for blocks in the cache and determine whether or not a particular block is contained there
Dialogue: 0,0:04:49.80,0:04:55.62,Chinese,,0,0,0,,如何查找缓存中的块并确定是否包含特定块
Dialogue: 0,0:04:55.62,0:05:00.96,English,,0,0,0,,So cache memories are have to be organized in a very kind of strict simple way
Dialogue: 0,0:04:55.62,0:05:00.96,Chinese,,0,0,0,,因此，必须以非常严格的简单方式组织高速缓存存储器
Dialogue: 0,0:05:00.96,0:05:03.80,English,,0,0,0,,So that the logic the lookup logic can be pretty simple
Dialogue: 0,0:05:00.96,0:05:03.80,Chinese,,0,0,0,,因此查找逻辑的逻辑可以非常简单
Dialogue: 0,0:05:04.78,0:05:10.22,English,,0,0,0,,So this is very all cache memories are organized in the following way
Dialogue: 0,0:05:04.78,0:05:10.22,Chinese,,0,0,0,,因此，所有缓存存储器都按以下方式组织
Dialogue: 0,0:05:11.00,0:05:17.76,English,,0,0,0,,You can think of the cache as an array of S=2^s sets
Dialogue: 0,0:05:11.00,0:05:17.76,Chinese,,0,0,0,,你可以将缓存视为S = 2 ^ s集的数组
Dialogue: 0,0:05:20.35,0:05:25.12,English,,0,0,0,,Ok each set consists of E=2^e lines
Dialogue: 0,0:05:20.35,0:05:25.12,Chinese,,0,0,0,,好的每一组都包含E = 2 ^ e行
Dialogue: 0,0:05:28.60,0:05:37.48,English,,0,0,0,,Where each line consists of a block of B=2^b bytes of data
Dialogue: 0,0:05:28.60,0:05:37.48,Chinese,,0,0,0,,其中每一行由一个B = 2 ^ b字节的数据块组成
Dialogue: 0,0:05:39.48,0:05:48.68,English,,0,0,0,,A valid bit which indicates whether these data bits are actually that the bits and the data block are actually meaningful right
Dialogue: 0,0:05:39.48,0:05:48.68,Chinese,,0,0,0,,一个有效位，指示这些数据位是否实际上是位和数据块实际上是有意义的
Dialogue: 0,0:05:49.30,0:05:53.78,English,,0,0,0,,It's possible they could just be random bits like you know when you first turn on the machine
Dialogue: 0,0:05:49.30,0:05:53.78,Chinese,,0,0,0,,当你第一次打开机器时，它们可能只是你知道的随机位
Dialogue: 0,0:05:54.20,0:05:55.50,English,,0,0,0,,There's nothing in the cache
Dialogue: 0,0:05:54.20,0:05:55.50,Chinese,,0,0,0,,缓存中没有任何内容
Dialogue: 0,0:05:56.12,0:05:59.58,English,,0,0,0,,But those bits will have values right that they'll lead to be ones or zeros
Dialogue: 0,0:05:56.12,0:05:59.58,Chinese,,0,0,0,,但这些位将具有正确的值，它们将导致为1或0
Dialogue: 0,0:05:59.58,0:06:01.36,English,,0,0,0,,But they won't actually correspond to data
Dialogue: 0,0:05:59.58,0:06:01.36,Chinese,,0,0,0,,但它们实际上并不符合数据
Dialogue: 0,0:06:01.94,0:06:08.28,English,,0,0,0,,Okay so the valid bit tells us if these B bytes actually mean anything
Dialogue: 0,0:06:01.94,0:06:08.28,Chinese,,0,0,0,,好的，有效位告诉我们这些B字节是否实际意味着什么
Dialogue: 0,0:06:09.14,0:06:11.94,English,,0,0,0,,And then there's some additional bits called the tag bits
Dialogue: 0,0:06:09.14,0:06:11.94,Chinese,,0,0,0,,然后还有一些称为标记位的附加位
Dialogue: 0,0:06:12.52,0:06:16.53,English,,0,0,0,,Which will help us search for blocks which I'll show you in a minute
Dialogue: 0,0:06:12.52,0:06:16.53,Chinese,,0,0,0,,这将帮助我们搜索我将在一分钟内向你展示的块
Dialogue: 0,0:06:17.44,0:06:19.26,English,,0,0,0,,Now when we talk about our cache size
Dialogue: 0,0:06:17.44,0:06:19.26,Chinese,,0,0,0,,现在我们谈谈我们的缓存大小
Dialogue: 0,0:06:19.92,0:06:25.40,English,,0,0,0,,We're referring to the number of data bytes that are contained in blocks
Dialogue: 0,0:06:19.92,0:06:25.40,Chinese,,0,0,0,,我们指的是块中包含的数据字节数
Dialogue: 0,0:06:26.88,0:06:31.60,English,,0,0,0,,And so each cache has there's S sets
Dialogue: 0,0:06:26.88,0:06:31.60,Chinese,,0,0,0,,所以每个缓存都有S套
Dialogue: 0,0:06:32.84,0:06:36.32,English,,0,0,0,,There's E blocks per set
Dialogue: 0,0:06:32.84,0:06:36.32,Chinese,,0,0,0,,每套都有E块
Dialogue: 0,0:06:36.98,0:06:38.46,English,,0,0,0,,And there's B bytes per block
Dialogue: 0,0:06:36.98,0:06:38.46,Chinese,,0,0,0,,并且每个块有B个字节
Dialogue: 0,0:06:38.56,0:06:42.96,English,,0,0,0,,Ok so the total cache size C=S*E*B
Dialogue: 0,0:06:38.56,0:06:42.96,Chinese,,0,0,0,,好的总缓存大小C = S * E * B.
Dialogue: 0,0:06:44.44,0:06:49.36,English,,0,0,0,,Ok now so there's a lot of terms to sort of keep straight and it's very easy to get
Dialogue: 0,0:06:44.44,0:06:49.36,Chinese,,0,0,0,,好了，所以有很多条款可以保持直线，而且很容易获得
Dialogue: 0,0:06:50.42,0:06:55.54,English,,0,0,0,,To confuse the difference between lines and blocks and lines and sets
Dialogue: 0,0:06:50.42,0:06:55.54,Chinese,,0,0,0,,混淆行和块以及行和集之间的差异
Dialogue: 0,0:06:56.14,0:07:01.42,English,,0,0,0,,Okay so we'll go through some examples and hopefully these will see these will start to make more sense
Dialogue: 0,0:06:56.14,0:07:01.42,Chinese,,0,0,0,,好的，我们将通过一些例子，希望这些将会开始变得更有意义
Dialogue: 0,0:07:03.06,0:07:11.00,English,,0,0,0,,Now let's look at in general how the cache hardware implements a read
Dialogue: 0,0:07:03.06,0:07:11.00,Chinese,,0,0,0,,现在让我们来看一下缓存硬件如何实现读取
Dialogue: 0,0:07:12.26,0:07:17.02,English,,0,0,0,,So when our program accesses, when our program executes an instruction
Dialogue: 0,0:07:12.26,0:07:17.02,Chinese,,0,0,0,,因此，当我们的程序访问时，我们的程序执行指令
Dialogue: 0,0:07:17.88,0:07:20.80,English,,0,0,0,,That references some word in memory
Dialogue: 0,0:07:17.88,0:07:20.80,Chinese,,0,0,0,,这引用了记忆中的一些词
Dialogue: 0,0:07:22.66,0:07:26.88,English,,0,0,0,,The CPU sends that address to the cache
Dialogue: 0,0:07:22.66,0:07:26.88,Chinese,,0,0,0,,CPU将该地址发送到缓存
Dialogue: 0,0:07:27.16,0:07:34.44,English,,0,0,0,,And asks and it asks the cache to return the word the word at that address
Dialogue: 0,0:07:27.16,0:07:34.44,Chinese,,0,0,0,,并询问并要求缓存在该地址返回单词
Dialogue: 0,0:07:37.00,0:07:39.24,English,,0,0,0,,So the cache takes that address
Dialogue: 0,0:07:37.00,0:07:39.24,Chinese,,0,0,0,,因此缓存占用该地址
Dialogue: 0,0:07:41.38,0:07:46.02,English,,0,0,0,,This would be a 64-bit address in case of x86-64
Dialogue: 0,0:07:41.38,0:07:46.02,Chinese,,0,0,0,,对于x86-64，这将是64位地址
Dialogue: 0,0:07:47.12,0:07:52.36,English,,0,0,0,,And it divides the address into a number of regions
Dialogue: 0,0:07:47.12,0:07:52.36,Chinese,,0,0,0,,它将地址划分为多个区域
Dialogue: 0,0:07:52.98,0:07:56.18,English,,0,0,0,,Which are determined by the organization of the cache
Dialogue: 0,0:07:52.98,0:07:56.18,Chinese,,0,0,0,,这由缓存的组织决定
Dialogue: 0,0:07:56.96,0:08:01.24,English,,0,0,0,,Okay they're determined by those parameters S sets
Dialogue: 0,0:07:56.96,0:08:01.24,Chinese,,0,0,0,,好的，他们是由那些参数决定的
Dialogue: 0,0:08:01.86,0:08:07.48,English,,0,0,0,,The s the number of sets a the number of lines per set and b the size of each data block
Dialogue: 0,0:08:01.86,0:08:07.48,Chinese,,0,0,0,,s设置的数量是每组的行数，b是每个数据块的大小
Dialogue: 0,0:08:09.04,0:08:15.82,English,,0,0,0,,So the low order bits there are b low order bits which determine the offset in the block
Dialogue: 0,0:08:09.04,0:08:15.82,Chinese,,0,0,0,,因此，低阶位有b个低阶位，用于确定块中的偏移量
Dialogue: 0,0:08:16.18,0:08:17.68,English,,0,0,0,,That that word starts at
Dialogue: 0,0:08:16.18,0:08:17.68,Chinese,,0,0,0,,那个词开始于
Dialogue: 0,0:08:20.36,0:08:25.88,English,,0,0,0,,Okay the next s bits are treated as an unsigned integer
Dialogue: 0,0:08:20.36,0:08:25.88,Chinese,,0,0,0,,好的，接下来的s位被视为无符号整数
Dialogue: 0,0:08:26.42,0:08:30.20,English,,0,0,0,,Which serves as an index into the array of sets
Dialogue: 0,0:08:26.42,0:08:30.20,Chinese,,0,0,0,,它作为集合数组的索引
Dialogue: 0,0:08:31.02,0:08:34.74,English,,0,0,0,,Okay remember we just think of these as think of this cache as an array of set
Dialogue: 0,0:08:31.02,0:08:34.74,Chinese,,0,0,0,,好的记住，我们只是将这些想法视为一个集合数组
Dialogue: 0,0:08:35.78,0:08:41.30,English,,0,0,0,,The set index bits provide the index into this array of sets
Dialogue: 0,0:08:35.78,0:08:41.30,Chinese,,0,0,0,,设置的索引位为这个数组提供索引
Dialogue: 0,0:08:42.12,0:08:43.74,English,,0,0,0,,And then all of the remaining bits
Dialogue: 0,0:08:42.12,0:08:43.74,Chinese,,0,0,0,,然后是所有剩下的比特
Dialogue: 0,0:08:46.06,0:08:51.14,English,,0,0,0,,All of the remaining t bits constitute what we call tag
Dialogue: 0,0:08:46.06,0:08:51.14,Chinese,,0,0,0,,所有剩余的t位构成了我们称之为标签的东西
Dialogue: 0,0:08:51.56,0:08:53.22,English,,0,0,0,,Which will help us when we do our search
Dialogue: 0,0:08:51.56,0:08:53.22,Chinese,,0,0,0,,这将有助于我们进行搜索
Dialogue: 0,0:08:54.40,0:08:56.68,English,,0,0,0,,So the cache logic takes this address
Dialogue: 0,0:08:54.40,0:08:56.68,Chinese,,0,0,0,,因此缓存逻辑采用此地址
Dialogue: 0,0:08:58.42,0:09:01.14,English,,0,0,0,,And it first extracts the the set index
Dialogue: 0,0:08:58.42,0:09:01.14,Chinese,,0,0,0,,它首先提取集合索引
Dialogue: 0,0:09:01.42,0:09:06.66,English,,0,0,0,,And uses that to,as an index into this array to identify the set that
Dialogue: 0,0:09:01.42,0:09:06.66,Chinese,,0,0,0,,并使用它作为此数组的索引来识别该集合
Dialogue: 0,0:09:07.20,0:09:11.32,English,,0,0,0,,If this block is in the set,I'm sorry,if the data word
Dialogue: 0,0:09:07.20,0:09:11.32,Chinese,,0,0,0,,如果这个块在集合中，我很抱歉，如果是数据字
Dialogue: 0,0:09:12.20,0:09:17.78,English,,0,0,0,,If the block that contains the data word at this address is in the cache
Dialogue: 0,0:09:12.20,0:09:17.78,Chinese,,0,0,0,,如果包含此地址的数据字的块在缓存中
Dialogue: 0,0:09:18.54,0:09:23.54,English,,0,0,0,,It's going to be in the set denoted by the the set index
Dialogue: 0,0:09:18.54,0:09:23.54,Chinese,,0,0,0,,它将在set索引表示的集合中
Dialogue: 0,0:09:27.16,0:09:30.52,English,,0,0,0,,So first it identifies which index to look in
Dialogue: 0,0:09:27.16,0:09:30.52,Chinese,,0,0,0,,首先，它确定要查看的索引
Dialogue: 0,0:09:36.28,0:09:41.80,English,,0,0,0,,And then it checks the tag,it checks all of the lines in that set
Dialogue: 0,0:09:36.28,0:09:41.80,Chinese,,0,0,0,,然后它检查标签，它检查该组中的所有行
Dialogue: 0,0:09:43.30,0:09:46.66,English,,0,0,0,,To see if there's any of those lines have a matching tag
Dialogue: 0,0:09:43.30,0:09:46.66,Chinese,,0,0,0,,要查看这些行中是否有任何匹配的标记
Dialogue: 0,0:09:46.88,0:09:50.88,English,,0,0,0,,That a tag that matches the the t the tag bits and the address
Dialogue: 0,0:09:46.88,0:09:50.88,Chinese,,0,0,0,,这是一个与标签位和地址匹配的标签
Dialogue: 0,0:09:53.58,0:09:56.52,English,,0,0,0,,And it checks to see if the valid bit is turned on
Dialogue: 0,0:09:53.58,0:09:56.52,Chinese,,0,0,0,,并检查有效位是否打开
Dialogue: 0,0:09:56.52,0:09:59.70,English,,0,0,0,,So if those two conditions holds if there's a line anywhere in the set
Dialogue: 0,0:09:56.52,0:09:59.70,Chinese,,0,0,0,,因此，如果这两个条件成立，那么集合中的任何地方都有一条线
Dialogue: 0,0:10:00.28,0:10:05.30,English,,0,0,0,,As of where the valid bit is one and there's a matching tag
Dialogue: 0,0:10:00.28,0:10:05.30,Chinese,,0,0,0,,至于有效位是1并且有匹配标记的位置
Dialogue: 0,0:10:06.06,0:10:10.84,English,,0,0,0,,Then we have a hit okay then the block that we're looking for is contained in this set
Dialogue: 0,0:10:06.06,0:10:10.84,Chinese,,0,0,0,,然后我们点击好了，然后我们正在寻找的块包含在这个集合中
Dialogue: 0,0:10:15.58,0:10:20.42,English,,0,0,0,,Okay if we...once we determine that with that we've identified the block
Dialogue: 0,0:10:15.58,0:10:20.42,Chinese,,0,0,0,,好的，如果我们......一旦我们确定了那个，我们已经确定了该块
Dialogue: 0,0:10:20.72,0:10:25.48,English,,0,0,0,,Then the cache uses that the low-order b bits to determine where that
Dialogue: 0,0:10:20.72,0:10:25.48,Chinese,,0,0,0,,然后缓存使用低位b位来确定它的位置
Dialogue: 0,0:10:26.40,0:10:30.28,English,,0,0,0,,Where the data we're interested in begins okay within that block
Dialogue: 0,0:10:26.40,0:10:30.28,Chinese,,0,0,0,,我们感兴趣的数据在该块内开始正常
Dialogue: 0,0:10:32.38,0:10:37.24,English,,0,0,0,,All right let's look at a more specific example for a the simplest kind of cache
Dialogue: 0,0:10:32.38,0:10:37.24,Chinese,,0,0,0,,好吧，让我们看一个最简单的缓存的更具体的例子
Dialogue: 0,0:10:38.00,0:10:42.00,English,,0,0,0,,Which is when E=1 when there's only one line per set
Dialogue: 0,0:10:38.00,0:10:42.00,Chinese,,0,0,0,,当每组只有一行时E = 1
Dialogue: 0,0:10:43.68,0:10:46.12,English,,0,0,0,,Okay so E=1 one line per set
Dialogue: 0,0:10:43.68,0:10:46.12,Chinese,,0,0,0,,好的，所以E = 1每行一行
Dialogue: 0,0:10:46.78,0:10:49.04,English,,0,0,0,,This kind of cache is called a direct mapped cache
Dialogue: 0,0:10:46.78,0:10:49.04,Chinese,,0,0,0,,这种缓存称为直接映射缓存
Dialogue: 0,0:10:52.26,0:10:55.98,English,,0,0,0,,So here we have S sets each set consists of a single line
Dialogue: 0,0:10:52.26,0:10:55.98,Chinese,,0,0,0,,所以这里我们有S组，每组由一条线组成
Dialogue: 0,0:10:56.64,0:11:00.74,English,,0,0,0,,And now suppose our program references the data item
Dialogue: 0,0:10:56.64,0:11:00.74,Chinese,,0,0,0,,现在假设我们的程序引用了数据项
Dialogue: 0,0:11:01.02,0:11:06.52,English,,0,0,0,,And a particular address the CPU sense that address to the cache
Dialogue: 0,0:11:01.02,0:11:06.52,Chinese,,0,0,0,,并且CPU感知到缓存的地址的特定地址
Dialogue: 0,0:11:07.20,0:11:11.68,English,,0,0,0,,The cache takes that address breaks it up into these into these three fields
Dialogue: 0,0:11:07.20,0:11:11.68,Chinese,,0,0,0,,缓存将该地址分解为这三个字段
Dialogue: 0,0:11:12.76,0:11:17.92,English,,0,0,0,,For this particular address the block offset is four
Dialogue: 0,0:11:12.76,0:11:17.92,Chinese,,0,0,0,,对于此特定地址，块偏移量为四
Dialogue: 0,0:11:19.46,0:11:26.30,English,,0,0,0,,And the set index is one and then there's some tag bits which we'll just denote with is a color pink
Dialogue: 0,0:11:19.46,0:11:26.30,Chinese,,0,0,0,,设置索引是一个，然后有一些标记位，我们只是用粉红色表示
Dialogue: 0,0:11:28.04,0:11:33.02,English,,0,0,0,,So the cache extracts the set index which is one
Dialogue: 0,0:11:28.04,0:11:33.02,Chinese,,0,0,0,,因此缓存提取的集合索引为1
Dialogue: 0,0:11:33.16,0:11:36.46,English,,0,0,0,,And then it uses that as the index into the set
Dialogue: 0,0:11:33.16,0:11:36.46,Chinese,,0,0,0,,然后它使用它作为集合的索引
Dialogue: 0,0:11:42.00,0:11:44.94,English,,0,0,0,,And then it just ignores all the other the sets
Dialogue: 0,0:11:42.00,0:11:44.94,Chinese,,0,0,0,,然后它只是忽略了所有其他的集合
Dialogue: 0,0:11:45.62,0:11:50.65,English,,0,0,0,,If the block we're looking for is...is in the cache it's going to be in this inset number one
Dialogue: 0,0:11:45.62,0:11:50.65,Chinese,,0,0,0,,如果我们正在寻找的块是...在缓存中它将在这个插入的第一个
Dialogue: 0,0:11:51.50,0:11:54.84,English,,0,0,0,,Then it does the comparison of the tag bits and the valid bits
Dialogue: 0,0:11:51.50,0:11:54.84,Chinese,,0,0,0,,然后它进行标记位和有效位的比较
Dialogue: 0,0:11:55.42,0:11:58.64,English,,0,0,0,,And assume that they assume that valid bits on and that it matches
Dialogue: 0,0:11:55.42,0:11:58.64,Chinese,,0,0,0,,并假设他们假设有效位和它匹配
Dialogue: 0,0:12:00.16,0:12:02.54,English,,0,0,0,,Then it looks at the block offset which is four
Dialogue: 0,0:12:00.16,0:12:02.54,Chinese,,0,0,0,,然后它查看块偏移量为4
Dialogue: 0,0:12:03.94,0:12:11.76,English,,0,0,0,,And which tells it that the four bit in suppose that that's what the instruction was referencing
Dialogue: 0,0:12:03.94,0:12:11.76,Chinese,,0,0,0,,并且它告诉它四位假设这就是指令引用的内容
Dialogue: 0,0:12:12.28,0:12:14.82,English,,0,0,0,,The four byte in begins that offset for
Dialogue: 0,0:12:12.28,0:12:14.82,Chinese,,0,0,0,,四个字节开始偏移为
Dialogue: 0,0:12:15.28,0:12:22.38,English,,0,0,0,,So now the cache takes this int and it sends it back to the to the CPU which puts it in the register
Dialogue: 0,0:12:15.28,0:12:22.38,Chinese,,0,0,0,,所以现在缓存采用这个int并将它发送回CPU，并将其放入寄存器中
Dialogue: 0,0:12:28.96,0:12:36.22,English,,0,0,0,,Okay if the tag doesn't match then the old-line, if the tag doesn't match then there's a miss
Dialogue: 0,0:12:28.96,0:12:36.22,Chinese,,0,0,0,,好的，如果标签与旧线不匹配，如果标签不匹配，则表示未命中
Dialogue: 0,0:12:38.16,0:12:43.64,English,,0,0,0,,And in that case the cache has to fetch the block the corresponding block from memory
Dialogue: 0,0:12:38.16,0:12:43.64,Chinese,,0,0,0,,在这种情况下，缓存必须从内存中获取相应块的块
Dialogue: 0,0:12:44.36,0:12:47.68,English,,0,0,0,,And then overwrite this block in the line
Dialogue: 0,0:12:44.36,0:12:47.68,Chinese,,0,0,0,,然后在行中覆盖此块
Dialogue: 0,0:12:48.98,0:12:55.92,English,,0,0,0,,And then it can serve,then it can fetch,it can get the word out of the block and send it back to the processor
Dialogue: 0,0:12:48.98,0:12:55.92,Chinese,,0,0,0,,然后它可以服务，然后它可以获取，它可以从块中取出字并将其发送回处理器
Dialogue: 0,0:12:57.80,0:13:02.24,English,,0,0,0,,Okay now let me ask you a question just to see you kind of check to see you're following along with this
Dialogue: 0,0:12:57.80,0:13:02.24,Chinese,,0,0,0,,好的，现在让我问你一个问题，只是为了看看你有什么检查看到你跟着这个
Dialogue: 0,0:13:03.22,0:13:04.20,English,,0,0,0,,So if there's a miss
Dialogue: 0,0:13:03.22,0:13:04.20,Chinese,,0,0,0,,所以，如果有一个错过
Dialogue: 0,0:13:05.34,0:13:09.10,English,,0,0,0,,And the cache has two requests the block for memory
Dialogue: 0,0:13:05.34,0:13:09.10,Chinese,,0,0,0,,并且缓存有两个请求内存块
Dialogue: 0,0:13:09.90,0:13:14.34,English,,0,0,0,,Fetch it from memory and then overwrite the the block in the current line
Dialogue: 0,0:13:09.90,0:13:14.34,Chinese,,0,0,0,,从内存中获取它，然后覆盖当前行中的块
Dialogue: 0,0:13:16.54,0:13:22.18,English,,0,0,0,,Does it also have to change the tag bits or do those stay the same?
Dialogue: 0,0:13:16.54,0:13:22.18,Chinese,,0,0,0,,是否还必须更改标记位或保持不变？
Dialogue: 0,0:13:22.18,0:13:28.58,English,,0,0,0,,So does the do the tag bits that were in this line get overwritten with a different value
Dialogue: 0,0:13:22.18,0:13:28.58,Chinese,,0,0,0,,那么这一行中的标记位是否会被不同的值覆盖
Dialogue: 0,0:13:30.04,0:13:39.42,English,,0,0,0,,Or is it the same? same? different? same? different?
Dialogue: 0,0:13:30.04,0:13:39.42,Chinese,,0,0,0,,还是一样吗？相同？不同？相同？不同？
Dialogue: 0,0:13:43.70,0:13:44.98,English,,0,0,0,,Now why would it be different ?
Dialogue: 0,0:13:43.70,0:13:44.98,Chinese,,0,0,0,,现在为什么会有所不同？
Dialogue: 0,0:13:48.46,0:13:59.24,English,,0,0,0,,-we haven't changed yes-[student speaking]-I'm sorry oh-[student speaking]
Dialogue: 0,0:13:48.46,0:13:59.24,Chinese,,0,0,0,, - 我们没有改变是 -  [学生说话]  - 对不起哦 -  [学生说话]
Dialogue: 0,0:13:59.54,0:14:02.52,English,,0,0,0,,Oh it almost certainly has different data
Dialogue: 0,0:13:59.54,0:14:02.52,Chinese,,0,0,0,,哦，它几乎肯定有不同的数据
Dialogue: 0,0:14:02.92,0:14:04.16,English,,0,0,0,,But just have a different address
Dialogue: 0,0:14:02.92,0:14:04.16,Chinese,,0,0,0,,但只是有一个不同的地址
Dialogue: 0,0:14:13.24,0:14:17.60,English,,0,0,0,,Exactly it missed because the tag
Dialogue: 0,0:14:13.24,0:14:17.60,Chinese,,0,0,0,,完全错过了因为标签
Dialogue: 0,0:14:18.18,0:14:19.82,English,,0,0,0,,It missed because the tag didn't match
Dialogue: 0,0:14:18.18,0:14:19.82,Chinese,,0,0,0,,它错过了因为标签不匹配
Dialogue: 0,0:14:22.90,0:14:26.94,English,,0,0,0,,If the valid bit was false and the tag match then that would also be a miss
Dialogue: 0,0:14:22.90,0:14:26.94,Chinese,,0,0,0,,如果有效位为假且标记匹配，那么这也将是未命中
Dialogue: 0,0:14:28.74,0:14:34.74,English,,0,0,0,,Oh then you wouldn't...okay that's right,that's...okay good good good,okay,great
Dialogue: 0,0:14:28.74,0:14:34.74,Chinese,,0,0,0,,哦，那你就不会......好吧，那是......好吧好的好，好的，好的
Dialogue: 0,0:14:39.70,0:14:48.10,English,,0,0,0,,All right let me do a little, let me do a really simple specific example of a how direct map cache works
Dialogue: 0,0:14:39.70,0:14:48.10,Chinese,,0,0,0,,好吧，让我做一点，让我做一个关于直接地图缓存如何工作的一个非常简单的具体例子
Dialogue: 0,0:14:48.92,0:14:53.56,English,,0,0,0,,I want you to understand in real detail how this would work
Dialogue: 0,0:14:48.92,0:14:53.56,Chinese,,0,0,0,,我希望你真正了解这是如何工作的
Dialogue: 0,0:14:53.56,0:14:59.42,English,,0,0,0,,But I also want to make a point for about the weakness of direct mapped cache is and why
Dialogue: 0,0:14:53.56,0:14:59.42,Chinese,,0,0,0,,但我也想说明直接映射缓存的弱点和原因
Dialogue: 0,0:15:00.08,0:15:02.62,English,,0,0,0,,Why you would want to have more than one line per set
Dialogue: 0,0:15:00.08,0:15:02.62,Chinese,,0,0,0,,为什么你希望每组有多行
Dialogue: 0,0:15:04.96,0:15:11.48,English,,0,0,0,,Okay this is a really simple we have our memory system consists of 16 bytes
Dialogue: 0,0:15:04.96,0:15:11.48,Chinese,,0,0,0,,好的，这是一个非常简单的我们的内存系统由16个字节组成
Dialogue: 0,0:15:11.70,0:15:15.30,English,,0,0,0,,Ok so it's not a very useful system with 4 bit addresses
Dialogue: 0,0:15:11.70,0:15:15.30,Chinese,,0,0,0,,好的，这不是一个非常有用的4位地址系统
Dialogue: 0,0:15:16.94,0:15:20.42,English,,0,0,0,,And it's broken up into blocks of 2 bytes each
Dialogue: 0,0:15:16.94,0:15:20.42,Chinese,,0,0,0,,它被分解为每个2字节的块
Dialogue: 0,0:15:21.74,0:15:26.34,English,,0,0,0,,Our cache consists of 4 sets with one block per set
Dialogue: 0,0:15:21.74,0:15:26.34,Chinese,,0,0,0,,我们的缓存由4组组成，每组一个区块
Dialogue: 0,0:15:28.32,0:15:31.26,English,,0,0,0,,Now 4 bytes,4 bit addresses
Dialogue: 0,0:15:28.32,0:15:31.26,Chinese,,0,0,0,,现在4个字节，4位地址
Dialogue: 0,0:15:33.08,0:15:38.56,English,,0,0,0,,Because B=2, that's 2^1 we only need 1 block offset bit
Dialogue: 0,0:15:33.08,0:15:38.56,Chinese,,0,0,0,,因为B = 2，即2 ^ 1，我们只需要1个块偏移位
Dialogue: 0,0:15:38.80,0:15:44.74,English,,0,0,0,,Right there's only 2 bytes in a block so the byte we're looking for is either at 0 or 1
Dialogue: 0,0:15:38.80,0:15:44.74,Chinese,,0,0,0,,在一个块中只有2个字节，所以我们要查找的字节是0或1
Dialogue: 0,0:15:46.80,0:15:51.82,English,,0,0,0,,Okay because we have 4 sets we need set index bits
Dialogue: 0,0:15:46.80,0:15:51.82,Chinese,,0,0,0,,好的，因为我们有4套，我们需要设置索引位
Dialogue: 0,0:15:52.52,0:15:57.20,English,,0,0,0,,And then the remaining bits are always tag bits in this case there's just one tag bit
Dialogue: 0,0:15:52.52,0:15:57.20,Chinese,,0,0,0,,然后剩余的位总是标记位，在这种情况下只有一个标记位
Dialogue: 0,0:15:58.66,0:16:05.38,English,,0,0,0,,All right now let's suppose that our program executes instructions
Dialogue: 0,0:15:58.66,0:16:05.38,Chinese,,0,0,0,,好了，我们假设我们的程序执行指令
Dialogue: 0,0:16:05.54,0:16:12.30,English,,0,0,0,,That reference the following memory address is 0,1,7,8 and 0
Dialogue: 0,0:16:05.54,0:16:12.30,Chinese,,0,0,0,,该引用以下内存地址为0,1,7,8和0
Dialogue: 0,0:16:14.10,0:16:18.34,English,,0,0,0,,And these references are reads that they're reading one byte per read
Dialogue: 0,0:16:14.10,0:16:18.34,Chinese,,0,0,0,,这些引用是读取它们每次读取一个字节的读取
Dialogue: 0,0:16:19.04,0:16:20.92,English,,0,0,0,,Okay like I said this is a really simple system
Dialogue: 0,0:16:19.04,0:16:20.92,Chinese,,0,0,0,,好吧我说这是一个非常简单的系统
Dialogue: 0,0:16:23.46,0:16:24.90,English,,0,0,0,,So let's look at what happens now
Dialogue: 0,0:16:23.46,0:16:24.90,Chinese,,0,0,0,,那么让我们来看看现在发生了什么
Dialogue: 0,0:16:24.90,0:16:33.82,English,,0,0,0,,We start tag,initially,cache is empty valid bits are all set to zero
Dialogue: 0,0:16:24.90,0:16:33.82,Chinese,,0,0,0,,我们开始标记，最初，缓存是空的有效位都被设置为零
Dialogue: 0,0:16:35.76,0:16:40.64,English,,0,0,0,,And now the cache receives the request for the byte that's at address 0
Dialogue: 0,0:16:35.76,0:16:40.64,Chinese,,0,0,0,,现在，缓存接收对地址为0的字节的请求
Dialogue: 0,0:16:43.02,0:16:46.90,English,,0,0,0,,So it extracts the set index bits which in this case are 00
Dialogue: 0,0:16:43.02,0:16:46.90,Chinese,,0,0,0,,因此它提取设置索引位，在本例中为00
Dialogue: 0,0:16:47.96,0:16:51.02,English,,0,0,0,,So these so it's going to look in set 0
Dialogue: 0,0:16:47.96,0:16:51.02,Chinese,,0,0,0,,所以这些它将在第0组中查找
Dialogue: 0,0:16:52.58,0:16:58.36,English,,0,0,0,,For and in this case since valid is 0 it's just a miss ok
Dialogue: 0,0:16:52.58,0:16:58.36,Chinese,,0,0,0,,对于和在这种情况下，因为有效是0，它只是一个错过确定
Dialogue: 0,0:16:59.76,0:17:04.64,English,,0,0,0,,So it fetches that block from memory sticks the block
Dialogue: 0,0:16:59.76,0:17:04.64,Chinese,,0,0,0,,因此它从存储器中取出块来阻止块
Dialogue: 0,0:17:06.04,0:17:11.60,English,,0,0,0,,So this memory this is the...this is using array notation for memory
Dialogue: 0,0:17:06.04,0:17:11.60,Chinese,,0,0,0,,所以这个内存就是......这是使用数组符号表示内存
Dialogue: 0,0:17:11.60,0:17:18.78,English,,0,0,0,,So this is like the the bytes that extend from offset 0 to offset 1 inclusive in memory
Dialogue: 0,0:17:11.60,0:17:18.78,Chinese,,0,0,0,,所以这就像在内存中从偏移0延伸到偏移1的字节
Dialogue: 0,0:17:20.84,0:17:25.42,English,,0,0,0,,The tag bit is 0 and the valid bit is 1
Dialogue: 0,0:17:20.84,0:17:25.42,Chinese,,0,0,0,,标记位为0，有效位为1
Dialogue: 0,0:17:26.14,0:17:30.76,English,,0,0,0,,Ok now the next address that comes by is for address 1
Dialogue: 0,0:17:26.14,0:17:30.76,Chinese,,0,0,0,,好的，现在下一个地址是地址1
Dialogue: 0,0:17:32.86,0:17:40.14,English,,0,0,0,,Well that's a hit right...because we...that block the block that contains the byte at address 1 is already in the cache
Dialogue: 0,0:17:32.86,0:17:40.14,Chinese,,0,0,0,,好吧，这是一个正确的...因为我们...阻止包含地址1字节的块已经在缓存中
Dialogue: 0,0:17:41.82,0:17:45.62,English,,0,0,0,,The tag and the tags match okay so we're good that's a hit
Dialogue: 0,0:17:41.82,0:17:45.62,Chinese,,0,0,0,,标签和标签匹配正常，所以我们很好，这是一个打击
Dialogue: 0,0:17:47.16,0:17:48.64,English,,0,0,0,,You now we get address 7
Dialogue: 0,0:17:47.16,0:17:48.64,Chinese,,0,0,0,,你现在我们得到地址7
Dialogue: 0,0:17:50.62,0:17:57.72,English,,0,0,0,,So the cache extracts the set index bits,which in this case are 11 or 4 or 3 rather
Dialogue: 0,0:17:50.62,0:17:57.72,Chinese,,0,0,0,,因此缓存提取设置的索引位，在这种情况下是11或4或3
Dialogue: 0,0:17:59.80,0:18:07.42,English,,0,0,0,,Looks in set 3 there's no valid bit,so that's a miss and it loads the the data from memory
Dialogue: 0,0:17:59.80,0:18:07.42,Chinese,,0,0,0,,在第3组中查找没有有效位，因此这是一个未命中并且它从内存加载数据
Dialogue: 0,0:18:08.22,0:18:11.14,English,,0,0,0,,That spans bytes 6~7
Dialogue: 0,0:18:08.22,0:18:11.14,Chinese,,0,0,0,,跨越字节6~7
Dialogue: 0,0:18:13.04,0:18:16.68,English,,0,0,0,,In this case the the tag bit is 0
Dialogue: 0,0:18:13.04,0:18:16.68,Chinese,,0,0,0,,在这种情况下，标记位为0
Dialogue: 0,0:18:17.74,0:18:21.20,English,,0,0,0,,Okay so we record that in our metadata
Dialogue: 0,0:18:17.74,0:18:21.20,Chinese,,0,0,0,,好的，我们在元数据中记录了这一点
Dialogue: 0,0:18:22.84,0:18:24.98,English,,0,0,0,,Okay the next reference that comes by is 8
Dialogue: 0,0:18:22.84,0:18:24.98,Chinese,,0,0,0,,好的，下一个参考是8
Dialogue: 0,0:18:27.06,0:18:31.02,English,,0,0,0,,Now 8 has a set index of 0,00
Dialogue: 0,0:18:27.06,0:18:31.02,Chinese,,0,0,0,,现在8的集合索引为0,00
Dialogue: 0,0:18:31.84,0:18:36.70,English,,0,0,0,,But that's currently occupied by block zero one
Dialogue: 0,0:18:31.84,0:18:36.70,Chinese,,0,0,0,,但那个目前被零块一个占据
Dialogue: 0,0:18:37.20,0:18:41.96,English,,0,0,0,,And we can tell that because address eight has a tag of one
Dialogue: 0,0:18:37.20,0:18:41.96,Chinese,,0,0,0,,我们可以告诉你，因为地址8有一个标签
Dialogue: 0,0:18:42.40,0:18:49.70,English,,0,0,0,,And the existing block,the block at the earlier address at address zero has a tag of zero so that's a miss so
Dialogue: 0,0:18:42.40,0:18:49.70,Chinese,,0,0,0,,而现有的块，地址为零的早期地址处的块具有零标记，因此这是一个未命中
Dialogue: 0,0:18:51.32,0:18:58.82,English,,0,0,0,,So now we have to go fetch the block containing byte number eight into memory
Dialogue: 0,0:18:51.32,0:18:58.82,Chinese,,0,0,0,,所以现在我们必须将包含字节数8的块提取到内存中
Dialogue: 0,0:18:58.82,0:19:03.88,English,,0,0,0,,So now we have bytes 8-9 and we in our new tag bit
Dialogue: 0,0:18:58.82,0:19:03.88,Chinese,,0,0,0,,所以现在我们有8-9字节，我们在新的标签位
Dialogue: 0,0:19:05.82,0:19:11.12,English,,0,0,0,,Okay now the next instruction is for byte 0
Dialogue: 0,0:19:05.82,0:19:11.12,Chinese,,0,0,0,,好的，现在下一条指令是字节0
Dialogue: 0,0:19:12.62,0:19:18.30,English,,0,0,0,,And we just replaced,we had that it,we had that in our cache and we just replaced it
Dialogue: 0,0:19:12.62,0:19:18.30,Chinese,,0,0,0,,我们刚刚更换了，我们就拥有了它，我们在缓存中有了它，我们只是替换它
Dialogue: 0,0:19:19.76,0:19:22.32,English,,0,0,0,,So it's another miss so that's unfortunate
Dialogue: 0,0:19:19.76,0:19:22.32,Chinese,,0,0,0,,所以这是另一个错过，所以这是不幸的
Dialogue: 0,0:19:23.24,0:19:30.02,English,,0,0,0,,And it's the only reason we missed it is because we've got just one line per set
Dialogue: 0,0:19:23.24,0:19:30.02,Chinese,,0,0,0,,这是我们错过它的唯一原因是因为我们每组只有一行
Dialogue: 0,0:19:31.06,0:19:33.00,English,,0,0,0,,Right so we were forced to overwrite
Dialogue: 0,0:19:31.06,0:19:33.00,Chinese,,0,0,0,,是的，所以我们被迫覆盖
Dialogue: 0,0:19:38.22,0:19:45.92,English,,0,0,0,,That that block containing bytes,the block zero one when we missed on block eight nine
Dialogue: 0,0:19:38.22,0:19:45.92,Chinese,,0,0,0,,那块包含字节的块，当我们在块8九时错过时块0
Dialogue: 0,0:19:47.88,0:19:54.14,English,,0,0,0,,Okay and you see there's plenty of room in our cache we've still got,we've got two lines
Dialogue: 0,0:19:47.88,0:19:54.14,Chinese,,0,0,0,,好的，你看我们的缓存中有足够的空间我们还有，我们有两条线
Dialogue: 0,0:19:54.78,0:19:58.96,English,,0,0,0,,That we haven't even access right so we've our cache is plenty big
Dialogue: 0,0:19:54.78,0:19:58.96,Chinese,,0,0,0,,我们甚至都没有访问权限，因此我们的缓存非常大
Dialogue: 0,0:19:59.62,0:20:04.54,English,,0,0,0,,But just because of the low associativity of our cache
Dialogue: 0,0:19:59.62,0:20:04.54,Chinese,,0,0,0,,但仅仅因为我们的缓存关联性低
Dialogue: 0,0:20:05.18,0:20:08.96,English,,0,0,0,,And the the sort of the pattern the access pattern that we were presented with
Dialogue: 0,0:20:05.18,0:20:08.96,Chinese,,0,0,0,,以及我们呈现的访问模式的模式类型
Dialogue: 0,0:20:09.36,0:20:12.88,English,,0,0,0,,We've got a miss that really was kind of unnecessary
Dialogue: 0,0:20:09.36,0:20:12.88,Chinese,,0,0,0,,我们有一个真的有点不必要的小姐
Dialogue: 0,0:20:13.68,0:20:15.06,English,,0,0,0,,So oh yeah sorry
Dialogue: 0,0:20:13.68,0:20:15.06,Chinese,,0,0,0,,哦，对不起
Dialogue: 0,0:20:15.06,0:20:29.06,English,,0,0,0,,[student speaking]
Dialogue: 0,0:20:15.06,0:20:29.06,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:20:29.10,0:20:34.20,English,,0,0,0,,Six,so when we referenced a seven
Dialogue: 0,0:20:29.10,0:20:34.20,Chinese,,0,0,0,,六，所以当我们引用七
Dialogue: 0,0:20:35.26,0:20:40.72,English,,0,0,0,,It's actually the it's at offset one in that block 6-7
Dialogue: 0,0:20:35.26,0:20:40.72,Chinese,,0,0,0,,它实际上就是6-7区块中的偏移量
Dialogue: 0,0:20:41.50,0:20:45.38,English,,0,0,0,,Okay since blocks are two bytes they'll always start on an even multiple
Dialogue: 0,0:20:41.50,0:20:45.38,Chinese,,0,0,0,,好吧，因为块是两个字节，它们总是以偶数倍开始
Dialogue: 0,0:20:51.58,0:20:52.80,English,,0,0,0,,Any other questions
Dialogue: 0,0:20:51.58,0:20:52.80,Chinese,,0,0,0,,还有其他问题吗
Dialogue: 0,0:20:57.64,0:21:06.78,English,,0,0,0,,Okay so this sort of is the reason why you have caches have higher associativity,higher values of E
Dialogue: 0,0:20:57.64,0:21:06.78,Chinese,,0,0,0,,好的，所以这就是为什么你有缓存具有更高的关联性，更高的E值的原因
Dialogue: 0,0:21:08.24,0:21:17.96,English,,0,0,0,,So let's look at...and so for values of E greater...for values of E greater than greater than 1
Dialogue: 0,0:21:08.24,0:21:17.96,Chinese,,0,0,0,,因此，让我们看看......对于E值大于......对于E的值大于1
Dialogue: 0,0:21:19.22,0:21:22.98,English,,0,0,0,,We refer to them as E way set associative caches
Dialogue: 0,0:21:19.22,0:21:22.98,Chinese,,0,0,0,,我们将它们称为E路集关联缓存
Dialogue: 0,0:21:24.34,0:21:27.92,English,,0,0,0,,So here E=2 so it's a 2-way it's 2-way associative
Dialogue: 0,0:21:24.34,0:21:27.92,Chinese,,0,0,0,,所以这里E = 2所以它是双向的，它是双向关联的
Dialogue: 0,0:21:30.44,0:21:36.00,English,,0,0,0,,Let's suppose we have a 2-way associative cache
Dialogue: 0,0:21:30.44,0:21:36.00,Chinese,,0,0,0,,假设我们有一个双向关联缓存
Dialogue: 0,0:21:36.00,0:21:43.94,English,,0,0,0,,So here we have an array of sets and now each set contains two lines ok instead of one line
Dialogue: 0,0:21:36.00,0:21:43.94,Chinese,,0,0,0,,所以这里我们有一组数组，现在每组包含两行ok而不是一行
Dialogue: 0,0:21:46.28,0:21:51.18,English,,0,0,0,,And suppose we're presented with an address with the following form
Dialogue: 0,0:21:46.28,0:21:51.18,Chinese,,0,0,0,,并且假设我们被提供了具有以下形式的地址
Dialogue: 0,0:21:53.50,0:21:58.40,English,,0,0,0,,We're looking for the word that begins at an off set of four inside our block
Dialogue: 0,0:21:53.50,0:21:58.40,Chinese,,0,0,0,,我们正在寻找从我们的区块内的一组四个开始的单词
Dialogue: 0,0:22:01.04,0:22:05.20,English,,0,0,0,,At within set number one
Dialogue: 0,0:22:01.04,0:22:05.20,Chinese,,0,0,0,,在第一组内
Dialogue: 0,0:22:08.04,0:22:11.00,English,,0,0,0,,Okay so the cache expects tracts that set index
Dialogue: 0,0:22:08.04,0:22:11.00,Chinese,,0,0,0,,好的，所以缓存需要设置索引的tracts
Dialogue: 0,0:22:12.02,0:22:20.34,English,,0,0,0,,So this is set 0,this is set 1,this is set 2,throws away all the other sets
Dialogue: 0,0:22:12.02,0:22:20.34,Chinese,,0,0,0,,所以这设置为0，设置为1，设置为2，抛弃所有其他集
Dialogue: 0,0:22:21.50,0:22:33.58,English,,0,0,0,,And now in parallel it searches,it searches the tags,it searches for a matching tag in both of these lines
Dialogue: 0,0:22:21.50,0:22:33.58,Chinese,,0,0,0,,现在并行搜索，搜索标签，搜索这两行中的匹配标签
Dialogue: 0,0:22:35.18,0:22:40.22,English,,0,0,0,,And a valid bit so if we get a matching tag and a valid bit true
Dialogue: 0,0:22:35.18,0:22:40.22,Chinese,,0,0,0,,如果我们得到匹配的标签和有效位，则为有效位
Dialogue: 0,0:22:40.74,0:22:45.06,English,,0,0,0,,Then we've got a hit
Dialogue: 0,0:22:40.74,0:22:45.06,Chinese,,0,0,0,,然后我们受到了打击
Dialogue: 0,0:22:47.38,0:22:49.38,English,,0,0,0,,Now that yes yes
Dialogue: 0,0:22:47.38,0:22:49.38,Chinese,,0,0,0,,现在是的，是的
Dialogue: 0,0:22:49.38,0:22:56.84,English,,0,0,0,,[student speaking]
Dialogue: 0,0:22:49.38,0:22:56.84,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:22:56.92,0:23:01.60,English,,0,0,0,,Oh it's a very good question,so there's hardware logic that does that compare
Dialogue: 0,0:22:56.92,0:23:01.60,Chinese,,0,0,0,,哦，这是一个非常好的问题，所以有比较的硬件逻辑
Dialogue: 0,0:23:02.60,0:23:09.82,English,,0,0,0,,And that's the reason that as the number of...as the associativity goes up that logic gets more and more expensive
Dialogue: 0,0:23:02.60,0:23:09.82,Chinese,,0,0,0,,这就是因为随着关联性的增加，逻辑变得越来越昂贵
Dialogue: 0,0:23:10.78,0:23:15.42,English,,0,0,0,,Okay it's like something...like you're kind of doing some kind of tree search
Dialogue: 0,0:23:10.78,0:23:15.42,Chinese,,0,0,0,,好吧，这就像是某种东西......就像你在做某种树搜索一样
Dialogue: 0,0:23:17.32,0:23:19.46,English,,0,0,0,,And so that actually is the limit that's why..
Dialogue: 0,0:23:17.32,0:23:19.46,Chinese,,0,0,0,,所以这实际上是限制，这就是为什么..
Dialogue: 0,0:23:19.56,0:23:25.04,English,,0,0,0,,I mean because in general right that if you take this to the limit there's just one set
Dialogue: 0,0:23:19.56,0:23:25.04,Chinese,,0,0,0,,我的意思是因为一般来说，如果你把它限制在极限，那么只有一套
Dialogue: 0,0:23:26.36,0:23:32.24,English,,0,0,0,,With there's just...we call that a fully associative cache so there's just one set
Dialogue: 0,0:23:26.36,0:23:32.24,Chinese,,0,0,0,,只有...我们称之为完全关联的缓存，因此只有一组
Dialogue: 0,0:23:33.08,0:23:35.74,English,,0,0,0,,And now any block...a block can go anywhere
Dialogue: 0,0:23:33.08,0:23:35.74,Chinese,,0,0,0,,而现在任何一块......一个块可以去任何地方
Dialogue: 0,0:23:36.16,0:23:38.44,English,,0,0,0,,Right there's no constraints now where you place a block
Dialogue: 0,0:23:36.16,0:23:38.44,Chinese,,0,0,0,,现在没有限制，你放置一个块
Dialogue: 0,0:23:39.66,0:23:44.74,English,,0,0,0,,But because of the complexity of that fully associative search
Dialogue: 0,0:23:39.66,0:23:44.74,Chinese,,0,0,0,,但由于完全关联搜索的复杂性
Dialogue: 0,0:23:45.10,0:23:53.22,English,,0,0,0,,Those are very rare in fact we do see we'll see fully associative caches but their software caches
Dialogue: 0,0:23:45.10,0:23:53.22,Chinese,,0,0,0,,这些是非常罕见的，事实上我们确实看到我们会看到完全关联的缓存，但他们的软件缓存
Dialogue: 0,0:23:54.70,0:23:59.12,English,,0,0,0,,Okay so in software,so the complexity the hardware
Dialogue: 0,0:23:54.70,0:23:59.12,Chinese,,0,0,0,,好的，在软件中，硬件的复杂性
Dialogue: 0,0:23:59.90,0:24:03.40,English,,0,0,0,,And sort of doesn't
Dialogue: 0,0:23:59.90,0:24:03.40,Chinese,,0,0,0,,而有点不
Dialogue: 0,0:24:05.22,0:24:12.06,English,,0,0,0,,Doesn't it's not worth the complexity of the hardware for the penalty of having a lower associativity
Dialogue: 0,0:24:05.22,0:24:12.06,Chinese,,0,0,0,,对于具有较低关联性的惩罚，不值得硬件的复杂性
Dialogue: 0,0:24:12.78,0:24:16.24,English,,0,0,0,,Okay but there are some systems later on when we study virtual memory
Dialogue: 0,0:24:12.78,0:24:16.24,Chinese,,0,0,0,,好的，但是稍后我们研究虚拟内存时会有一些系统
Dialogue: 0,0:24:17.20,0:24:23.74,English,,0,0,0,,In a virtual memory system the DRAM serves as a cache for data stored on the disk
Dialogue: 0,0:24:17.20,0:24:23.74,Chinese,,0,0,0,,在虚拟存储器系统中，DRAM用作存储在磁盘上的数据的高速缓存
Dialogue: 0,0:24:24.78,0:24:28.04,English,,0,0,0,,And as we saw last time the penalty for a miss
Dialogue: 0,0:24:24.78,0:24:28.04,Chinese,,0,0,0,,正如我们上次看到一个小姐的点球
Dialogue: 0,0:24:28.88,0:24:32.22,English,,0,0,0,,If you have a cache on DRAM and you miss and you have to go to disk
Dialogue: 0,0:24:28.88,0:24:32.22,Chinese,,0,0,0,,如果你在DRAM上有一个缓存但你错过了，你必须转到磁盘
Dialogue: 0,0:24:32.96,0:24:34.68,English,,0,0,0,,The penalty is huge for that
Dialogue: 0,0:24:35.14,0:24:42.74,English,,0,0,0,,And so because of that it's worth while having very complex search algorithms
Dialogue: 0,0:24:35.14,0:24:42.74,Chinese,,0,0,0,,因此，拥有非常复杂的搜索算法是值得的
Dialogue: 0,0:24:42.96,0:24:51.11,English,,0,0,0,,In particular in a virtual memory system that the DRAM is implements a fully associative cache where blocks from disk can go anywhere
Dialogue: 0,0:24:42.96,0:24:51.11,Chinese,,0,0,0,,特别是在虚拟存储器系统中，DRAM实现了完全关联的高速缓存，其中来自磁盘的块可以到达任何地方
Dialogue: 0,0:24:51.52,0:24:54.40,English,,0,0,0,,We'll get into that later when we look in virtual memory
Dialogue: 0,0:24:54.60,0:24:56.22,English,,0,0,0,,But you're right you'll see in real systems
Dialogue: 0,0:24:54.60,0:24:56.22,Chinese,,0,0,0,,但你是对的，你会在真实的系统中看到
Dialogue: 0,0:24:56.70,0:25:01.16,English,,0,0,0,,Nowadays that the number goes up right because feature sizes are going down and
Dialogue: 0,0:25:01.56,0:25:04.86,English,,0,0,0,,Designers can afford to implement more expensive hardware
Dialogue: 0,0:25:01.56,0:25:04.86,Chinese,,0,0,0,,设计人员可以负担得起更昂贵的硬件
Dialogue: 0,0:25:04.86,0:25:12.02,English,,0,0,0,,But the largest associativity are Intel systems that I know of is 16-way associative L3 caches
Dialogue: 0,0:25:04.86,0:25:12.02,Chinese,,0,0,0,,但最大的关联性是我所知道的英特尔系统是16路关联L3缓存
Dialogue: 0,0:25:12.60,0:25:14.14,English,,0,0,0,,And then the others are 8-ways associative
Dialogue: 0,0:25:12.60,0:25:14.14,Chinese,,0,0,0,,然后其他人是8方式联想
Dialogue: 0,0:25:14.14,0:25:17.14,English,,0,0,0,,So that's sort of the order of magnitude that's state of the art right now
Dialogue: 0,0:25:14.14,0:25:17.14,Chinese,,0,0,0,,所以这就是现在最先进的数量级
Dialogue: 0,0:25:20.76,0:25:25.24,English,,0,0,0,,Okay so then once we've identified a match we use the set offset bits
Dialogue: 0,0:25:20.76,0:25:25.24,Chinese,,0,0,0,,好的，一旦我们确定匹配，我们就使用设置的偏移位
Dialogue: 0,0:25:26.46,0:25:33.20,English,,0,0,0,,In this case we're accessing a short int, so four is the offset within the block of this
Dialogue: 0,0:25:26.46,0:25:33.20,Chinese,,0,0,0,,在这种情况下，我们正在访问一个短整数，因此四是该区块内的偏移量
Dialogue: 0,0:25:33.90,0:25:37.48,English,,0,0,0,,The two byte short int which then we can return to the processor
Dialogue: 0,0:25:33.90,0:25:37.48,Chinese,,0,0,0,,两个字节短的int然后我们可以返回到处理器
Dialogue: 0,0:25:39.44,0:25:42.02,English,,0,0,0,,Alright so let's do that same simulation that we did before
Dialogue: 0,0:25:39.44,0:25:42.02,Chinese,,0,0,0,,好吧，让我们做同样的模拟，我们之前做过
Dialogue: 0,0:25:42.02,0:25:46.10,English,,0,0,0,,But this time with a 2-way associative cache
Dialogue: 0,0:25:42.02,0:25:46.10,Chinese,,0,0,0,,但这次使用了双向关联缓存
Dialogue: 0,0:25:46.78,0:25:49.02,English,,0,0,0,,Now memory system is the same
Dialogue: 0,0:25:46.78,0:25:49.02,Chinese,,0,0,0,,现在记忆系统是一样的
Dialogue: 0,0:25:50.42,0:25:52.90,English,,0,0,0,,But now instead of one set we have two sets
Dialogue: 0,0:25:50.42,0:25:52.90,Chinese,,0,0,0,,但现在我们有两套，而不是一套
Dialogue: 0,0:25:54.50,0:25:58.86,English,,0,0,0,,And I mean I'm sorry instead of four sets we have two sets
Dialogue: 0,0:25:54.50,0:25:58.86,Chinese,,0,0,0,,我的意思是我很抱歉而不是四套我们有两套
Dialogue: 0,0:25:58.94,0:26:02.06,English,,0,0,0,,So the cache,this is the same sized cache
Dialogue: 0,0:25:58.94,0:26:02.06,Chinese,,0,0,0,,所以缓存，这是相同大小的缓存
Dialogue: 0,0:26:02.14,0:26:07.12,English,,0,0,0,,But we're just going to organize it differently, instead of 1-way instead of a direct mapped cache
Dialogue: 0,0:26:02.14,0:26:07.12,Chinese,,0,0,0,,但我们只是以不同的方式组织它，而不是单向而不是直接映射缓存
Dialogue: 0,0:26:08.36,0:26:12.00,English,,0,0,0,,With four lines containing four lines,one line per set
Dialogue: 0,0:26:08.36,0:26:12.00,Chinese,,0,0,0,,四行包含四行，每行一行
Dialogue: 0,0:26:12.48,0:26:18.50,English,,0,0,0,,We're going to implement a 2-way associative cache where we have two sets with two lines per set
Dialogue: 0,0:26:12.48,0:26:18.50,Chinese,,0,0,0,,我们将实现一个双向关联缓存，其中我们有两组，每组有两行
Dialogue: 0,0:26:18.68,0:26:22.10,English,,0,0,0,,Okay so each case there's four total lines
Dialogue: 0,0:26:18.68,0:26:22.10,Chinese,,0,0,0,,好的，所以每个案例总共有四行
Dialogue: 0,0:26:22.46,0:26:22.86,English,,0,0,0,,Question
Dialogue: 0,0:26:22.46,0:26:22.86,Chinese,,0,0,0,,题
Dialogue: 0,0:26:24.30,0:26:29.80,English,,0,0,0,,[student speaking]
Dialogue: 0,0:26:29.80,0:26:32.08,English,,0,0,0,,Oh so that that comes in with the request somehow
Dialogue: 0,0:26:29.80,0:26:32.08,Chinese,,0,0,0,,哦，以便以某种方式提出请求
Dialogue: 0,0:26:32.62,0:26:34.74,English,,0,0,0,,And I actually don't know the details of that
Dialogue: 0,0:26:32.62,0:26:34.74,Chinese,,0,0,0,,而我实际上并不知道具体细节
Dialogue: 0,0:26:35.90,0:26:39.36,English,,0,0,0,,It may...I guess there...it could ask for just...
Dialogue: 0,0:26:35.90,0:26:39.36,Chinese,,0,0,0,,它可能......我猜...它可以要求......
Dialogue: 0,0:26:40.42,0:26:48.84,English,,0,0,0,,there could just be a default sighs maybe it's always a 64-byte word and then the processor extracts that the current bits
Dialogue: 0,0:26:48.84,0:26:51.68,English,,0,0,0,,I actually don't know the details of that
Dialogue: 0,0:26:48.84,0:26:51.68,Chinese,,0,0,0,,我实际上不知道那个细节
Dialogue: 0,0:26:51.98,0:26:59.10,English,,0,0,0,,But it either comes in on the request or there's a standard size that the processor then parses out
Dialogue: 0,0:26:51.98,0:26:59.10,Chinese,,0,0,0,,但它要么在请求中，要么处理器然后解析标准大小
Dialogue: 0,0:27:01.46,0:27:05.00,English,,0,0,0,,We'll just assume that the cache knows the what size to return yes
Dialogue: 0,0:27:01.46,0:27:05.00,Chinese,,0,0,0,,我们假设缓存知道返回的大小是什么
Dialogue: 0,0:27:05.22,0:27:08.80,English,,0,0,0,,[student speaking]
Dialogue: 0,0:27:05.22,0:27:08.80,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:27:08.82,0:27:12.06,English,,0,0,0,,How do you decide which block to replace?that's a really good question
Dialogue: 0,0:27:08.82,0:27:12.06,Chinese,,0,0,0,,你如何决定要替换哪个块？这是一个非常好的问题
Dialogue: 0,0:27:12.06,0:27:13.70,English,,0,0,0,,So there's a lot of different algorithms
Dialogue: 0,0:27:12.06,0:27:13.70,Chinese,,0,0,0,,所以有很多不同的算法
Dialogue: 0,0:27:14.32,0:27:19.48,English,,0,0,0,,The most common algorithm or a common algorithm is least recently used
Dialogue: 0,0:27:14.32,0:27:19.48,Chinese,,0,0,0,,最常用的算法或常用算法是最近最少使用的
Dialogue: 0,0:27:20.26,0:27:26.32,English,,0,0,0,,So by locality you want to keep blocks in the cache that are being used a lot
Dialogue: 0,0:27:20.26,0:27:26.32,Chinese,,0,0,0,,因此，根据位置，你希望将缓存中的块保留在正在使用的块中
Dialogue: 0,0:27:27.32,0:27:34.94,English,,0,0,0,,And so if a block isn't referenced for a long time by the principle of locality by sort of the inverse locality principle
Dialogue: 0,0:27:27.32,0:27:34.94,Chinese,,0,0,0,,因此，如果通过反向局部性原理的类型，通过局部性原理长时间不引用块
Dialogue: 0,0:27:35.40,0:27:39.32,English,,0,0,0,,It's likely not to be addressed referenced in the near future
Dialogue: 0,0:27:35.40,0:27:39.32,Chinese,,0,0,0,,它可能不会在不久的将来被引用
Dialogue: 0,0:27:40.00,0:27:42.92,English,,0,0,0,,So that's one algorithm
Dialogue: 0,0:27:40.00,0:27:42.92,Chinese,,0,0,0,,这就是一种算法
Dialogue: 0,0:27:42.96,0:27:48.60,English,,0,0,0,,That you just keep track of and I'm not showing there needs to be additional bits
Dialogue: 0,0:27:42.96,0:27:48.60,Chinese,,0,0,0,,你只是跟踪，我没有显示那里需要额外的位
Dialogue: 0,0:27:49.06,0:27:53.44,English,,0,0,0,,In the line to sort of keep like sort of virtual timestamps that
Dialogue: 0,0:27:49.06,0:27:53.44,Chinese,,0,0,0,,在排序中保持类似虚拟时间戳的那种
Dialogue: 0,0:27:54.28,0:27:56.92,English,,0,0,0,,But that's sort of the general way you do it
Dialogue: 0,0:27:54.28,0:27:56.92,Chinese,,0,0,0,,但这是你做这件事的一般方式
Dialogue: 0,0:27:56.92,0:28:04.78,English,,0,0,0,,Just try to keep the things that are the blocks being accessed the most frequently,most recently yes
Dialogue: 0,0:27:56.92,0:28:04.78,Chinese,,0,0,0,,只是尽量保持最常访问的块，最近是的
Dialogue: 0,0:28:04.92,0:28:09.02,English,,0,0,0,,[student speaking]
Dialogue: 0,0:28:04.92,0:28:09.02,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:28:09.04,0:28:11.74,English,,0,0,0,,Okay the question is what determines the block size
Dialogue: 0,0:28:09.04,0:28:11.74,Chinese,,0,0,0,,好的问题是什么决定了块的大小
Dialogue: 0,0:28:12.92,0:28:15.28,English,,0,0,0,,That's determined by the design of the memory system
Dialogue: 0,0:28:12.92,0:28:15.28,Chinese,,0,0,0,,这是由内存系统的设计决定的
Dialogue: 0,0:28:15.98,0:28:20.86,English,,0,0,0,,So that's a fixed parameter of the memory system
Dialogue: 0,0:28:15.98,0:28:20.86,Chinese,,0,0,0,,所以这是内存系统的固定参数
Dialogue: 0,0:28:21.38,0:28:26.50,English,,0,0,0,,So when the intel designers decided to put cache memories on their processors
Dialogue: 0,0:28:21.38,0:28:26.50,Chinese,,0,0,0,,因此，当英特尔设计师决定将缓存存储器放在他们的处理器上时
Dialogue: 0,0:28:27.18,0:28:30.20,English,,0,0,0,,They decided that the block size would be 64 bytes
Dialogue: 0,0:28:27.18,0:28:30.20,Chinese,,0,0,0,,他们认为块大小为64字节
Dialogue: 0,0:28:33.30,0:28:37.28,English,,0,0,0,,Sorry
Dialogue: 0,0:28:33.30,0:28:37.28,Chinese,,0,0,0,,抱歉
Dialogue: 0,0:28:39.28,0:28:43.68,English,,0,0,0,,So the block size comes the block size comes first
Dialogue: 0,0:28:39.28,0:28:43.68,Chinese,,0,0,0,,因此块大小首先出现块大小
Dialogue: 0,0:28:44.76,0:28:48.46,English,,0,0,0,,Then you determine how big you want your cache to be
Dialogue: 0,0:28:44.76,0:28:48.46,Chinese,,0,0,0,,然后确定你希望缓存的大小
Dialogue: 0,0:28:49.66,0:28:52.78,English,,0,0,0,,Okay and you determine the associativity
Dialogue: 0,0:28:49.66,0:28:52.78,Chinese,,0,0,0,,好的，你确定了关联性
Dialogue: 0,0:28:54.54,0:28:59.08,English,,0,0,0,,And then once you've determined the associativity and you know how big your cache is
Dialogue: 0,0:28:54.54,0:28:59.08,Chinese,,0,0,0,,然后，一旦确定了关联性，就知道缓存有多大
Dialogue: 0,0:28:59.54,0:29:01.32,English,,0,0,0,,Then that determines the number of sets
Dialogue: 0,0:28:59.54,0:29:01.32,Chinese,,0,0,0,,然后确定集的数量
Dialogue: 0,0:29:02.68,0:29:09.23,English,,0,0,0,,Okay so basically all of those the
Dialogue: 0,0:29:02.68,0:29:09.23,Chinese,,0,0,0,,好吧基本上所有这些
Dialogue: 0,0:29:09.70,0:29:16.62,English,,0,0,0,,The the number of lines and the cat and the capacity
Dialogue: 0,0:29:09.70,0:29:16.62,Chinese,,0,0,0,,行数和猫的数量和容量
Dialogue: 0,0:29:16.72,0:29:21.70,English,,0,0,0,,The number of lines per set is sort of a fixed high-level parameter design parameter
Dialogue: 0,0:29:16.72,0:29:21.70,Chinese,,0,0,0,,每组的行数是固定的高级参数设计参数
Dialogue: 0,0:29:21.98,0:29:26.50,English,,0,0,0,,The size of the cache is a high-level design parameter
Dialogue: 0,0:29:21.98,0:29:26.50,Chinese,,0,0,0,,缓存的大小是高级设计参数
Dialogue: 0,0:29:26.84,0:29:29.88,English,,0,0,0,,And then the number of sets then is induced from that
Dialogue: 0,0:29:26.84,0:29:29.88,Chinese,,0,0,0,,然后由此引发集合的数量
Dialogue: 0,0:29:30.94,0:29:31.70,English,,0,0,0,,Okay yes
Dialogue: 0,0:29:30.94,0:29:31.70,Chinese,,0,0,0,,好的，是的
Dialogue: 0,0:29:32.32,0:29:40.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:29:32.32,0:29:40.74,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:29:41.06,0:29:45.38,English,,0,0,0,,Ah that's yeah how does...so that's the replacement policy
Dialogue: 0,0:29:41.06,0:29:45.38,Chinese,,0,0,0,,啊，那是怎么回事......这就是替代政策
Dialogue: 0,0:29:46.28,0:29:51.74,English,,0,0,0,,So the question is how does it when there's multiple lines in a set how does it determine which to over overwrite
Dialogue: 0,0:29:46.28,0:29:51.74,Chinese,,0,0,0,,所以问题是如何在一组中有多行时如何确定哪些过度覆盖
Dialogue: 0,0:29:52.32,0:29:55.88,English,,0,0,0,,And that was the previous question probably maybe I should have repeated it
Dialogue: 0,0:29:52.32,0:29:55.88,Chinese,,0,0,0,,这就是之前的问题，也许我应该重复一遍
Dialogue: 0,0:29:56.34,0:30:00.14,English,,0,0,0,,So you try to pick a line that was least recently used
Dialogue: 0,0:29:56.34,0:30:00.14,Chinese,,0,0,0,,因此，你尝试选择最近最少使用的行
Dialogue: 0,0:30:00.90,0:30:03.42,English,,0,0,0,,So lines that haven't been accessed
Dialogue: 0,0:30:00.90,0:30:03.42,Chinese,,0,0,0,,所以没有访问过的行
Dialogue: 0,0:30:04.36,0:30:06.98,English,,0,0,0,,Recently are good candidates for replacement because
Dialogue: 0,0:30:04.36,0:30:06.98,Chinese,,0,0,0,,最近很适合替换，因为
Dialogue: 0,0:30:07.14,0:30:09.90,English,,0,0,0,,Because of the sort of inverse locality principle right that
Dialogue: 0,0:30:07.14,0:30:09.90,Chinese,,0,0,0,,由于这种反向局部性原理的正确性
Dialogue: 0,0:30:10.18,0:30:14.58,English,,0,0,0,,They haven't been inverse referenced recently chances are they won't be referenced
Dialogue: 0,0:30:10.18,0:30:14.58,Chinese,,0,0,0,,它们最近没有被反向引用它们不会被引用的可能性很大
Dialogue: 0,0:30:15.16,0:30:19.06,English,,0,0,0,,Again it
Dialogue: 0,0:30:15.16,0:30:19.06,Chinese,,0,0,0,,再一次
Dialogue: 0,0:30:19.08,0:30:22.28,English,,0,0,0,,Oh yeah there's additional bits that I'm not showing here that you have to
Dialogue: 0,0:30:19.08,0:30:22.28,Chinese,,0,0,0,,哦，是的，还有一些我不会在这里展示你需要的东西
Dialogue: 0,0:30:22.82,0:30:25.58,English,,0,0,0,,So when you replace a line in the set
Dialogue: 0,0:30:22.82,0:30:25.58,Chinese,,0,0,0,,所以当你替换集合中的一行时
Dialogue: 0,0:30:26.16,0:30:30.56,English,,0,0,0,,If that data is has changed then it has to be written back to memory
Dialogue: 0,0:30:26.16,0:30:30.56,Chinese,,0,0,0,,如果该数据已更改，则必须将其写回内存
Dialogue: 0,0:30:30.58,0:30:31.94,English,,0,0,0,,And that's another bit I haven't shown
Dialogue: 0,0:30:30.58,0:30:31.94,Chinese,,0,0,0,,这是我没有表现出来的另一点
Dialogue: 0,0:30:31.94,0:30:32.20,English,,0,0,0,,Yes
Dialogue: 0,0:30:31.94,0:30:32.20,Chinese,,0,0,0,,是
Dialogue: 0,0:30:32.36,0:30:44.46,English,,0,0,0,,[student speaking]
Dialogue: 0,0:30:32.36,0:30:44.46,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:30:44.46,0:30:52.14,English,,0,0,0,,Ah so yeah,so this is a really this is really tricky parameter writing
Dialogue: 0,0:30:44.46,0:30:52.14,Chinese,,0,0,0,,啊，所以是的，所以这真是一个非常棘手的参数写作
Dialogue: 0,0:30:52.14,0:30:56.72,English,,0,0,0,,It's a high level system parameter that it goes on for years
Dialogue: 0,0:30:52.14,0:30:56.72,Chinese,,0,0,0,,它是一个高级系统参数，它持续多年
Dialogue: 0,0:30:57.62,0:31:02.02,English,,0,0,0,,So the idea you want to have blocks in order to exploit spatial locality
Dialogue: 0,0:30:57.62,0:31:02.02,Chinese,,0,0,0,,所以你想要拥有块以利用空间局部性的想法
Dialogue: 0,0:31:03.10,0:31:07.20,English,,0,0,0,,Right think about if you're going to go to the trouble of if you have a miss in cache
Dialogue: 0,0:31:03.10,0:31:07.20,Chinese,,0,0,0,,正确的想一想，如果你错过缓存，你是否会遇到麻烦
Dialogue: 0,0:31:07.68,0:31:11.94,English,,0,0,0,,And you're going to go to the trouble of going all the way to memory to get some data
Dialogue: 0,0:31:07.68,0:31:11.94,Chinese,,0,0,0,,而且你将会遇到一路走向内存以获取一些数据的麻烦
Dialogue: 0,0:31:12.64,0:31:18.94,English,,0,0,0,,You want to amortize the cost of fetching that data by fetching more than one byte
Dialogue: 0,0:31:12.64,0:31:18.94,Chinese,,0,0,0,,你希望通过获取多个字节来分摊获取该数据的成本
Dialogue: 0,0:31:19.78,0:31:21.66,English,,0,0,0,,That's the motivation for blocks
Dialogue: 0,0:31:19.78,0:31:21.66,Chinese,,0,0,0,,这是块的动机
Dialogue: 0,0:31:22.46,0:31:29.34,English,,0,0,0,,Because by the principle of locality in spatial locality in particular
Dialogue: 0,0:31:22.46,0:31:29.34,Chinese,,0,0,0,,因为特别是在空间局部性的原则上
Dialogue: 0,0:31:30.64,0:31:32.90,English,,0,0,0,,If you reference a word inside of a block
Dialogue: 0,0:31:30.64,0:31:32.90,Chinese,,0,0,0,,如果你引用块内的单词
Dialogue: 0,0:31:32.90,0:31:36.60,English,,0,0,0,,Chances are you're going to reference a nearby word which will also be an epilogue
Dialogue: 0,0:31:32.90,0:31:36.60,Chinese,,0,0,0,,你可能会引用附近的单词，这也是一个结尾
Dialogue: 0,0:31:37.52,0:31:42.98,English,,0,0,0,,Okay so blocks the whole purpose of blocks is to exploit spatial locality
Dialogue: 0,0:31:37.52,0:31:42.98,Chinese,,0,0,0,,好吧阻止块的整个目的是利用空间局部性
Dialogue: 0,0:31:43.40,0:31:49.28,English,,0,0,0,,Now if you make your block too small then you don't amortize
Dialogue: 0,0:31:43.40,0:31:49.28,Chinese,,0,0,0,,现在，如果你的块太小，那么你就不会摊销
Dialogue: 0,0:31:49.66,0:31:52.32,English,,0,0,0,,You don't get the same amortization right you maybe get one
Dialogue: 0,0:31:49.66,0:31:52.32,Chinese,,0,0,0,,你没有获得相同的摊销权，你可能得到一个
Dialogue: 0,0:31:52.80,0:31:53.98,English,,0,0,0,,You bring the block in
Dialogue: 0,0:31:52.80,0:31:53.98,Chinese,,0,0,0,,你把块带进来
Dialogue: 0,0:31:55.10,0:31:57.62,English,,0,0,0,,So there's a reference you get a miss you bring the block in
Dialogue: 0,0:31:55.10,0:31:57.62,Chinese,,0,0,0,,所以有一个参考，你得到一个小姐，你带来了块
Dialogue: 0,0:31:58.12,0:32:01.60,English,,0,0,0,,There's another reference nearby you get a hit because the blocks in memory
Dialogue: 0,0:31:58.12,0:32:01.60,Chinese,,0,0,0,,附近有另一个参考，因为内存中的块，你会受到打击
Dialogue: 0,0:32:02.24,0:32:04.76,English,,0,0,0,,But then the next reference is in a different block
Dialogue: 0,0:32:02.24,0:32:04.76,Chinese,,0,0,0,,但接下来的参考文献是在不同的块中
Dialogue: 0,0:32:05.32,0:32:06.90,English,,0,0,0,,Because your block sizes are too small
Dialogue: 0,0:32:05.32,0:32:06.90,Chinese,,0,0,0,,因为你的块大小太小
Dialogue: 0,0:32:07.22,0:32:11.68,English,,0,0,0,,Right so you kind of want to make blocks big as big as possible
Dialogue: 0,0:32:07.22,0:32:11.68,Chinese,,0,0,0,,是的，所以你想要制作尽可能大的积木
Dialogue: 0,0:32:12.10,0:32:13.74,English,,0,0,0,,But without slowing the system down
Dialogue: 0,0:32:12.10,0:32:13.74,Chinese,,0,0,0,,但不会减慢系统速度
Dialogue: 0,0:32:13.74,0:32:17.84,English,,0,0,0,,So if you made your block size too big it would just take too long to bring that block in
Dialogue: 0,0:32:13.74,0:32:17.84,Chinese,,0,0,0,,因此，如果你将块大小设置得过大，则需要花费太长时间才能使用该块
Dialogue: 0,0:32:19.06,0:32:26.10,English,,0,0,0,,Plus now your blocks,that your blocks are taking up bits in your cache memory
Dialogue: 0,0:32:19.06,0:32:26.10,Chinese,,0,0,0,,再加上你的块，你的块占用缓存内存中的位
Dialogue: 0,0:32:26.48,0:32:28.12,English,,0,0,0,,So now there's no room for other blocks
Dialogue: 0,0:32:26.48,0:32:28.12,Chinese,,0,0,0,,所以现在没有其他街区的空间了
Dialogue: 0,0:32:28.12,0:32:32.12,English,,0,0,0,,Right so it's a really tricky design problem right and
Dialogue: 0,0:32:28.12,0:32:32.12,Chinese,,0,0,0,,对，所以这是一个非常棘手的设计问题
Dialogue: 0,0:32:32.60,0:32:37.54,English,,0,0,0,,If we're doing it taking an architecture class then we would sort of dive into the
Dialogue: 0,0:32:32.60,0:32:37.54,Chinese,,0,0,0,,如果我们正在做一个建筑类课程，那么我们就会深入研究
Dialogue: 0,0:32:38.12,0:32:41.46,English,,0,0,0,,You know how how architects make those design decisions
Dialogue: 0,0:32:38.12,0:32:41.46,Chinese,,0,0,0,,你知道建筑师如何做出这些设计决策
Dialogue: 0,0:32:41.86,0:32:44.72,English,,0,0,0,,But in general that's what it's kind of a balancing act right
Dialogue: 0,0:32:41.86,0:32:44.72,Chinese,,0,0,0,,但总的来说，这是一种平衡行为
Dialogue: 0,0:32:46.34,0:32:48.06,English,,0,0,0,,Were there any other questions? yes
Dialogue: 0,0:32:46.34,0:32:48.06,Chinese,,0,0,0,,还有其他问题吗？是
Dialogue: 0,0:32:48.06,0:32:56.02,English,,0,0,0,,[student speaking]
Dialogue: 0,0:32:48.06,0:32:56.02,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:32:56.18,0:32:58.72,English,,0,0,0,,Oh the question is every time there's a miss
Dialogue: 0,0:32:56.18,0:32:58.72,Chinese,,0,0,0,,哦问题是每次都有错过
Dialogue: 0,0:32:58.72,0:33:02.34,English,,0,0,0,,Do you have to select a victim line and override it
Dialogue: 0,0:32:58.72,0:33:02.34,Chinese,,0,0,0,,你是否必须选择受害者行并覆盖它
Dialogue: 0,0:33:03.00,0:33:07.32,English,,0,0,0,,Yeah I don't know of any caches that don't do that
Dialogue: 0,0:33:03.00,0:33:07.32,Chinese,,0,0,0,,是的我不知道任何不这样做的缓存
Dialogue: 0,0:33:07.92,0:33:09.48,English,,0,0,0,,Now we'll see when we look at rights
Dialogue: 0,0:33:07.92,0:33:09.48,Chinese,,0,0,0,,现在我们将看到我们何时看待权利
Dialogue: 0,0:33:10.70,0:33:14.88,English,,0,0,0,,We'll see there's an option of whether we're only looking at reads right now
Dialogue: 0,0:33:10.70,0:33:14.88,Chinese,,0,0,0,,我们会看到有一个选项，我们是否只是立即查看读取
Dialogue: 0,0:33:15.16,0:33:17.02,English,,0,0,0,,But with rights that question does come up
Dialogue: 0,0:33:15.16,0:33:17.02,Chinese,,0,0,0,,但是权利确实会出现问题
Dialogue: 0,0:33:17.86,0:33:24.02,English,,0,0,0,,If you wait in a couple of slides we'll go over that
Dialogue: 0,0:33:17.86,0:33:24.02,Chinese,,0,0,0,,如果你在几张幻灯片中等待，我们就会过去
Dialogue: 0,0:33:24.78,0:33:25.80,English,,0,0,0,,Any other questions
Dialogue: 0,0:33:24.78,0:33:25.80,Chinese,,0,0,0,,还有其他问题吗
Dialogue: 0,0:33:29.04,0:33:32.48,English,,0,0,0,,Okay so let's look at this two-way associative cache now
Dialogue: 0,0:33:29.04,0:33:32.48,Chinese,,0,0,0,,好的，现在让我们来看看这个双向关联缓存
Dialogue: 0,0:33:33.94,0:33:36.78,English,,0,0,0,,There's one block offset bit
Dialogue: 0,0:33:33.94,0:33:36.78,Chinese,,0,0,0,,有一个块偏移位
Dialogue: 0,0:33:37.30,0:33:40.18,English,,0,0,0,,We only have two sets so that we only need one set index
Dialogue: 0,0:33:37.30,0:33:40.18,Chinese,,0,0,0,,我们只有两个集合，所以我们只需要一个集合索引
Dialogue: 0,0:33:41.04,0:33:42.96,English,,0,0,0,,And then the remaining two bits are tagged
Dialogue: 0,0:33:41.04,0:33:42.96,Chinese,,0,0,0,,然后标记剩下的两位
Dialogue: 0,0:33:44.02,0:33:52.16,English,,0,0,0,,So let's go through our trace so address zero has a set is in set zero right here that's a miss
Dialogue: 0,0:33:44.02,0:33:52.16,Chinese,,0,0,0,,所以让我们通过我们的跟踪，所以地址零有一个集合在这里设置为零，这是一个未命中
Dialogue: 0,0:33:53.06,0:33:54.54,English,,0,0,0,, so we load that into memory
Dialogue: 0,0:33:53.06,0:33:54.54,Chinese,,0,0,0,,所以我们把它加载到内存中
Dialogue: 0,0:33:59.72,0:34:01.50,English,,0,0,0,,With the reference to address one
Dialogue: 0,0:33:59.72,0:34:01.50,Chinese,,0,0,0,,参考地址一
Dialogue: 0,0:34:02.24,0:34:08.10,English,,0,0,0,,That's in set zero and that's a hit because that byte is in a block
Dialogue: 0,0:34:02.24,0:34:08.10,Chinese,,0,0,0,,这是设置为零，这是一个命中，因为该字节在一个块中
Dialogue: 0,0:34:09.08,0:34:13.04,English,,0,0,0,,The reference to seven is a miss that's in set one so we load that
Dialogue: 0,0:34:09.08,0:34:13.04,Chinese,,0,0,0,,对七的引用是在第一组中的未命中，因此我们加载它
Dialogue: 0,0:34:13.56,0:34:17.36,English,,0,0,0,,And we were just picking randomly pick one of these two over right
Dialogue: 0,0:34:13.56,0:34:17.36,Chinese,,0,0,0,,而我们只是随意挑选这两个中的一个
Dialogue: 0,0:34:18.54,0:34:20.80,English,,0,0,0,,Because the cache is empty
Dialogue: 0,0:34:18.54,0:34:20.80,Chinese,,0,0,0,,因为缓存是空的
Dialogue: 0,0:34:21.34,0:34:25.72,English,,0,0,0,,The next reference is to address number eight which is in set zero
Dialogue: 0,0:34:21.34,0:34:25.72,Chinese,,0,0,0,,下一个参考是地址为零的地址
Dialogue: 0,0:34:26.20,0:34:31.80,English,,0,0,0,,Now here's the difference between the direct mapped cache and this 2-way set associative cache
Dialogue: 0,0:34:26.20,0:34:31.80,Chinese,,0,0,0,,现在，这是直接映射缓存和这个双向组关联缓存之间的区别
Dialogue: 0,0:34:32.86,0:34:35.66,English,,0,0,0,,When we reference address 8
Dialogue: 0,0:34:32.86,0:34:35.66,Chinese,,0,0,0,,当我们引用地址8时
Dialogue: 0,0:34:36.90,0:34:42.26,English,,0,0,0,,That block has to the corresponding block has to go into set 0
Dialogue: 0,0:34:36.90,0:34:42.26,Chinese,,0,0,0,,该块必须进入相应的块才能进入设置0
Dialogue: 0,0:34:42.98,0:34:44.74,English,,0,0,0,,Because of this zero set index bit
Dialogue: 0,0:34:42.98,0:34:44.74,Chinese,,0,0,0,,因为这个零设置索引位
Dialogue: 0,0:34:45.46,0:34:49.38,English,,0,0,0,,But we've got room now because we are set to have room for two lines instead of one
Dialogue: 0,0:34:45.46,0:34:49.38,Chinese,,0,0,0,,但是我们现在已经有了空间，因为我们可以设置两条线而不是一条线
Dialogue: 0,0:34:50.52,0:34:55.18,English,,0,0,0,,So when we load that in well if we have an available empty slot
Dialogue: 0,0:34:50.52,0:34:55.18,Chinese,,0,0,0,,因此，如果我们有一个可用的空槽，那么当我们将其加载到井中时
Dialogue: 0,0:34:55.18,0:35:01.02,English,,0,0,0,,We'll put it there we won't overwrite anything right so if possible always try to overwrite empty lines
Dialogue: 0,0:34:55.18,0:35:01.02,Chinese,,0,0,0,,我们将它放在那里我们不会覆盖任何正确的，所以如果可能的话总是试图覆盖空行
Dialogue: 0,0:35:02.64,0:35:07.86,English,,0,0,0,,So now we've got in this set...we've got block 0-1 and block 8-9
Dialogue: 0,0:35:02.64,0:35:07.86,Chinese,,0,0,0,,所以现在我们已经进入了这个集合......我们有0-1区块和8-9区块
Dialogue: 0,0:35:08.38,0:35:12.46,English,,0,0,0,,So when we get our reference to address zero
Dialogue: 0,0:35:08.38,0:35:12.46,Chinese,,0,0,0,,所以当我们得到我们的地址零参考时
Dialogue: 0,0:35:13.04,0:35:16.94,English,,0,0,0,,Whereas before with the when we had a conflict miss in the direct map cache
Dialogue: 0,0:35:13.04,0:35:16.94,Chinese,,0,0,0,,而在之前我们在直接地图缓存中发生了冲突错过
Dialogue: 0,0:35:16.94,0:35:19.94,English,,0,0,0,,Now we can satisfy that that request
Dialogue: 0,0:35:16.94,0:35:19.94,Chinese,,0,0,0,,现在我们可以满足那个要求
Dialogue: 0,0:35:20.60,0:35:25.28,English,,0,0,0,,It hits in memory and the cache can satisfy it from the cache instead of going to memory
Dialogue: 0,0:35:20.60,0:35:25.28,Chinese,,0,0,0,,它在内存中命中，缓存可以从缓存中满足它而不是去内存
Dialogue: 0,0:35:26.78,0:35:30.40,English,,0,0,0,,Okay so that makes sense
Dialogue: 0,0:35:26.78,0:35:30.40,Chinese,,0,0,0,,好的，这样才有意义
Dialogue: 0,0:35:35.38,0:35:36.68,English,,0,0,0,,Okay now what about rights?
Dialogue: 0,0:35:35.38,0:35:36.68,Chinese,,0,0,0,,好的，现在权利怎么样？
Dialogue: 0,0:35:39.20,0:35:41.38,English,,0,0,0,,So there's multiple copies of the data
Dialogue: 0,0:35:39.20,0:35:41.38,Chinese,,0,0,0,,所以有多个数据副本
Dialogue: 0,0:35:42.08,0:35:49.96,English,,0,0,0,,Right we're sub setting as we move up the hierarchy we're creating subsets of the data in the caches
Dialogue: 0,0:35:42.08,0:35:49.96,Chinese,,0,0,0,,我们正在进行子设置，因为我们在层次结构中向上移动，我们在缓存中创建数据的子集
Dialogue: 0,0:35:50.88,0:36:00.62,English,,0,0,0,,So what we do a write to a word within a block that's currently in the cache
Dialogue: 0,0:35:50.88,0:36:00.62,Chinese,,0,0,0,,那么我们对当前在缓存中的块内的单词进行写操作
Dialogue: 0,0:36:02.86,0:36:04.82,English,,0,0,0,,Okay we have two options
Dialogue: 0,0:36:02.86,0:36:04.82,Chinese,,0,0,0,,好的，我们有两个选择
Dialogue: 0,0:36:05.46,0:36:09.02,English,,0,0,0,,We can write that block immediately to memory right
Dialogue: 0,0:36:05.46,0:36:09.02,Chinese,,0,0,0,,我们可以立即将该块写入内存
Dialogue: 0,0:36:09.68,0:36:13.26,English,,0,0,0,,We're got a block that's like this big and we're updating a little chunk of it
Dialogue: 0,0:36:09.68,0:36:13.26,Chinese,,0,0,0,,我们有一个像这样大的块，我们正在更新它的一小部分
Dialogue: 0,0:36:15.10,0:36:19.24,English,,0,0,0,,So we can either do the update and then flush it to memory immediately
Dialogue: 0,0:36:15.10,0:36:19.24,Chinese,,0,0,0,,所以我们可以进行更新，然后立即将其刷新到内存中
Dialogue: 0,0:36:19.28,0:36:25.02,English,,0,0,0,,So that memory always mirrors the contents of memory always mirror the contents of the cache
Dialogue: 0,0:36:19.28,0:36:25.02,Chinese,,0,0,0,,因此，内存始终镜像内存的内容始终镜像缓存的内容
Dialogue: 0,0:36:26.42,0:36:29.60,English,,0,0,0,,Okay but that's expensive right
Dialogue: 0,0:36:26.42,0:36:29.60,Chinese,,0,0,0,,好吧，但这是昂贵的权利
Dialogue: 0,0:36:29.62,0:36:32.44,English,,0,0,0,,I mean you know memory accesses are expensive
Dialogue: 0,0:36:29.62,0:36:32.44,Chinese,,0,0,0,,我的意思是你知道内存访问很昂贵
Dialogue: 0,0:36:33.68,0:36:36.96,English,,0,0,0,,The other so the other option is what what's called write back
Dialogue: 0,0:36:33.68,0:36:36.96,Chinese,,0,0,0,,另一个是另一个选择就是所谓的回写
Dialogue: 0,0:36:37.90,0:36:40.56,English,,0,0,0,,So in this case when we write to a block in the cache
Dialogue: 0,0:36:37.90,0:36:40.56,Chinese,,0,0,0,,所以在这种情况下我们写入缓存中的块
Dialogue: 0,0:36:41.66,0:36:44.80,English,,0,0,0,,We don't flush it to memory
Dialogue: 0,0:36:41.66,0:36:44.80,Chinese,,0,0,0,,我们不会将其刷新到内存中
Dialogue: 0,0:36:45.14,0:36:50.94,English,,0,0,0,,Until we elect that particular line as a victim that's going to be overwritten
Dialogue: 0,0:36:45.14,0:36:50.94,Chinese,,0,0,0,,直到我们选择那条特定的线作为受害者才会被覆盖
Dialogue: 0,0:36:52.38,0:36:55.90,English,,0,0,0,,And only then when we're just we sort of defer
Dialogue: 0,0:36:52.38,0:36:55.90,Chinese,,0,0,0,,只有这样，当我们只是推迟时
Dialogue: 0,0:36:55.92,0:36:58.56,English,,0,0,0,,The writing to memory until the last possible minute
Dialogue: 0,0:36:55.92,0:36:58.56,Chinese,,0,0,0,,写入内存直到最后一分钟
Dialogue: 0,0:36:59.22,0:37:04.71,English,,0,0,0,,We defer it until just before the cache would overwrite that  that data block
Dialogue: 0,0:36:59.22,0:37:04.71,Chinese,,0,0,0,,我们将其推迟到缓存覆盖该数据块之前
Dialogue: 0,0:37:05.36,0:37:06.80,English,,0,0,0,,Okay so that's called right back
Dialogue: 0,0:37:05.36,0:37:06.80,Chinese,,0,0,0,,好的，这就叫回来吧
Dialogue: 0,0:37:07.20,0:37:12.90,English,,0,0,0,,And for right back you need to have some an extra bit in the line that indicates whether that blocks been written to
Dialogue: 0,0:37:07.20,0:37:12.90,Chinese,,0,0,0,,对于右后卫，你需要在行中加一些额外的位来指示是否写入了这些块
Dialogue: 0,0:37:13.60,0:37:18.88,English,,0,0,0,,So the algorithm is when the cache identifies a particular line to overwrite
Dialogue: 0,0:37:13.60,0:37:18.88,Chinese,,0,0,0,,因此，算法是在缓存标识要覆盖的特定行时
Dialogue: 0,0:37:19.62,0:37:25.50,English,,0,0,0,,It checks the dirty bit on that line if it's set then it writes that data to back to disk
Dialogue: 0,0:37:19.62,0:37:25.50,Chinese,,0,0,0,,它检查该行上的脏位，如果已设置，则将该数据写回磁盘
Dialogue: 0,0:37:28.18,0:37:33.26,English,,0,0,0,,Okay if the data hasn't...if that block hasn't been written there's no point there's no need to write it back
Dialogue: 0,0:37:28.18,0:37:33.26,Chinese,,0,0,0,,好的，如果数据没有...如果没有写入该块那么没有必要将其写回来
Dialogue: 0,0:37:33.26,0:37:38.14,English,,0,0,0,,Because it has the same value as the copy of the block on disk
Dialogue: 0,0:37:33.26,0:37:38.14,Chinese,,0,0,0,,因为它与磁盘上块的副本具有相同的值
Dialogue: 0,0:37:41.20,0:37:45.74,English,,0,0,0,,Okay now so what about...so that's a right here now what happens if we have a right miss
Dialogue: 0,0:37:41.20,0:37:45.74,Chinese,,0,0,0,,好的，那么......那么现在就在这里，如果我们有一个正确的错过会发生什么
Dialogue: 0,0:37:46.46,0:37:48.98,English,,0,0,0,,So we're doing a write to memory
Dialogue: 0,0:37:46.46,0:37:48.98,Chinese,,0,0,0,,所以我们正在写一个内存
Dialogue: 0,0:37:50.60,0:37:55.88,English,,0,0,0,,And the word that we're writing is not contained in any block that's in our cache
Dialogue: 0,0:37:50.60,0:37:55.88,Chinese,,0,0,0,,我们写的字不包含在缓存中的任何块中
Dialogue: 0,0:37:57.90,0:38:02.58,English,,0,0,0,,So we have two options we can do what's called write allocate so we can treat it if there's a miss
Dialogue: 0,0:37:57.90,0:38:02.58,Chinese,,0,0,0,,所以我们有两个选项，我们可以做什么叫做写分配，所以我们可以处理它，如果有一个错过
Dialogue: 0,0:38:03.24,0:38:07.32,English,,0,0,0,,We can do sort of the symmetric thing that we did with a hit which was create a new
Dialogue: 0,0:38:03.24,0:38:07.32,Chinese,,0,0,0,,我们可以做一些对称的事情，我们用一个创建新的命中
Dialogue: 0,0:38:08.08,0:38:11.26,English,,0,0,0,,A newline possibly overwriting an existing line
Dialogue: 0,0:38:08.08,0:38:11.26,Chinese,,0,0,0,,换行符可能会覆盖现有行
Dialogue: 0,0:38:11.96,0:38:18.18,English,,0,0,0,,And then write in so we could create that cache enter that cache line
Dialogue: 0,0:38:11.96,0:38:18.18,Chinese,,0,0,0,,然后写入，以便我们可以创建该缓存进入该缓存行
Dialogue: 0,0:38:18.48,0:38:21.48,English,,0,0,0,,Fetch it from memory and then do the right
Dialogue: 0,0:38:18.48,0:38:21.48,Chinese,,0,0,0,,从内存中获取它，然后执行右键
Dialogue: 0,0:38:23.18,0:38:25.34,English,,0,0,0,,Okay so this is sort of symmetric to reads right then
Dialogue: 0,0:38:23.18,0:38:25.34,Chinese,,0,0,0,,好的，所以这对于那时的读取来说是对称的
Dialogue: 0,0:38:25.80,0:38:32.10,English,,0,0,0,,So every right if it misses when the write finishes the that block will be in the cache
Dialogue: 0,0:38:25.80,0:38:32.10,Chinese,,0,0,0,,因此，如果在写入完成该块时未命中，则每个权限都将在缓存中
Dialogue: 0,0:38:33.10,0:38:35.56,English,,0,0,0,,And if we do a subsequent read we get a hit
Dialogue: 0,0:38:33.10,0:38:35.56,Chinese,,0,0,0,,如果我们进行后续阅读，我们会受到打击
Dialogue: 0,0:38:36.04,0:38:38.18,English,,0,0,0,,Okay so that's the reason you might want to do that
Dialogue: 0,0:38:36.04,0:38:38.18,Chinese,,0,0,0,,好的，这就是你可能想要这样做的原因
Dialogue: 0,0:38:40.56,0:38:42.92,English,,0,0,0,,The the other option is just to
Dialogue: 0,0:38:40.56,0:38:42.92,Chinese,,0,0,0,,另一种选择就是
Dialogue: 0,0:38:43.44,0:38:50.18,English,,0,0,0,,Don't allocate an entry in the cache don't allocate a new line just write write the data directly to memory
Dialogue: 0,0:38:43.44,0:38:50.18,Chinese,,0,0,0,,不要在缓存中分配条目不要分配新行只是将数据直接写入内存
Dialogue: 0,0:38:52.48,0:38:56.00,English,,0,0,0,,You don't really need to understand the distinction between these two things
Dialogue: 0,0:38:52.48,0:38:56.00,Chinese,,0,0,0,,你真的不需要理解这两件事之间的区别
Dialogue: 0,0:38:56.44,0:38:58.66,English,,0,0,0,,Different caches use different policies
Dialogue: 0,0:38:56.44,0:38:58.66,Chinese,,0,0,0,,不同的缓存使用不同的策略
Dialogue: 0,0:38:59.27,0:39:06.18,English,,0,0,0,,For your own mental model a good model to use is just to assume write back write allocate
Dialogue: 0,0:38:59.27,0:39:06.18,Chinese,,0,0,0,,对于你自己的心理模型，一个好的模型就是假设写回写分配
Dialogue: 0,0:39:07.08,0:39:10.22,English,,0,0,0,,So just assume that we won't copy the data to disk
Dialogue: 0,0:39:07.08,0:39:10.22,Chinese,,0,0,0,,所以假设我们不会将数据复制到磁盘
Dialogue: 0,0:39:10.76,0:39:14.84,English,,0,0,0,,If there's a hit we won't write it back to disk until the last possible minute
Dialogue: 0,0:39:10.76,0:39:14.84,Chinese,,0,0,0,,如果有击中，我们将不会在最后一刻之前将其写回磁盘
Dialogue: 0,0:39:15.28,0:39:19.72,English,,0,0,0,,And every time there's a write miss what will create a new entry in the cache
Dialogue: 0,0:39:15.28,0:39:19.72,Chinese,,0,0,0,,每次有写错过什么都会在缓存中创建一个新条目
Dialogue: 0,0:39:20.28,0:39:23.84,English,,0,0,0,,Okay so that's...that I think that's sort of the simplest model that
Dialogue: 0,0:39:20.28,0:39:23.84,Chinese,,0,0,0,,好的，那就是......我觉得那是最简单的模型
Dialogue: 0,0:39:24.32,0:39:30.84,English,,0,0,0,,And it's a reason it's a reasonable model that you can use regardless of the particular cache implementation
Dialogue: 0,0:39:24.32,0:39:30.84,Chinese,,0,0,0,,这是一个合理的模型，无论特定的缓存实现如何，你都可以使用它
Dialogue: 0,0:39:33.78,0:39:38.04,English,,0,0,0,,Now in a real system so far we've only looked at we've only assumed that there's a single cache
Dialogue: 0,0:39:33.78,0:39:38.04,Chinese,,0,0,0,,到目前为止，在一个真实的系统中，我们只看到我们只假设有一个缓存
Dialogue: 0,0:39:38.52,0:39:44.86,English,,0,0,0,,But in a in real systems there's multiple caches
Dialogue: 0,0:39:38.52,0:39:44.86,Chinese,,0,0,0,,但在实际系统中，有多个缓存
Dialogue: 0,0:39:46.66,0:39:53.86,English,,0,0,0,,So modern core i7 has well architecture from intel
Dialogue: 0,0:39:46.66,0:39:53.86,Chinese,,0,0,0,,所以现代核心i7拥有来自英特尔的良好架构
Dialogue: 0,0:39:56.24,0:39:58.48,English,,0,0,0,,Contains multiple processor cores
Dialogue: 0,0:39:56.24,0:39:58.48,Chinese,,0,0,0,,包含多个处理器核心
Dialogue: 0,0:39:59.40,0:40:02.32,English,,0,0,0,,So 4 is a typical number for like desktop systems
Dialogue: 0,0:39:59.40,0:40:02.32,Chinese,,0,0,0,,所以4是类似桌面系统的典型数字
Dialogue: 0,0:40:02.80,0:40:06.12,English,,0,0,0,,8~12 is typical for server class systems
Dialogue: 0,0:40:02.80,0:40:06.12,Chinese,,0,0,0,,8~12是服务器类系统的典型代表
Dialogue: 0,0:40:06.74,0:40:12.58,English,,0,0,0,,These processor cores can each execute their own independent instruction stream in parallel
Dialogue: 0,0:40:06.74,0:40:12.58,Chinese,,0,0,0,,这些处理器内核可以各自并行执行它们自己的独立指令流
Dialogue: 0,0:40:14.54,0:40:21.34,English,,0,0,0,,And each processor core can contains general-purpose registers which that's level 0 in the cache
Dialogue: 0,0:40:14.54,0:40:21.34,Chinese,,0,0,0,,并且每个处理器内核可以包含通用寄存器，其在高速缓存中为0级
Dialogue: 0,0:40:22.46,0:40:26.30,English,,0,0,0,,And then two different kinds of L1 caches
Dialogue: 0,0:40:22.46,0:40:26.30,Chinese,,0,0,0,,然后是两种不同的L1缓存
Dialogue: 0,0:40:27.20,0:40:29.16,English,,0,0,0,,The data cache the L1 d-cache
Dialogue: 0,0:40:27.20,0:40:29.16,Chinese,,0,0,0,,数据缓存L1 d缓存
Dialogue: 0,0:40:30.26,0:40:33.86,English,,0,0,0,,And the i-cache is the...which is the instruction cache
Dialogue: 0,0:40:30.26,0:40:33.86,Chinese,,0,0,0,,而i-cache是​​......这是指令缓存
Dialogue: 0,0:40:35.28,0:40:40.16,English,,0,0,0,,And these are fairly small 32 k bytes they're eight-way associative
Dialogue: 0,0:40:35.28,0:40:40.16,Chinese,,0,0,0,,这些是相当小的32 k字节，它们是八路关联的
Dialogue: 0,0:40:40.74,0:40:44.14,English,,0,0,0,,And they can be accessed in a very small number of cycles
Dialogue: 0,0:40:40.74,0:40:44.14,Chinese,,0,0,0,,并且可以在极少数周期内访问它们
Dialogue: 0,0:40:45.60,0:40:51.40,English,,0,0,0,,The next level of the hierarchy is L2 cache
Dialogue: 0,0:40:45.60,0:40:51.40,Chinese,,0,0,0,,层次结构的下一级是L2缓存
Dialogue: 0,0:40:52.12,0:40:58.58,English,,0,0,0,,Which is still fairly small 256 k bytes same associativity
Dialogue: 0,0:40:52.12,0:40:58.58,Chinese,,0,0,0,,这仍然是相当小的256 k字节相同的关联性
Dialogue: 0,0:40:59.12,0:41:02.30,English,,0,0,0,,And it has a slightly longer access time
Dialogue: 0,0:40:59.12,0:41:02.30,Chinese,,0,0,0,,它的访问时间稍长
Dialogue: 0,0:41:03.14,0:41:08.68,English,,0,0,0,,And it's unified in the sense that the L2 cache contains both data and instructions
Dialogue: 0,0:41:03.14,0:41:08.68,Chinese,,0,0,0,,在L2缓存包含数据和指令的意义上，它是统一的
Dialogue: 0,0:41:11.42,0:41:14.10,English,,0,0,0,,Ok so that's all within a single core on the chip
Dialogue: 0,0:41:11.42,0:41:14.10,Chinese,,0,0,0,,好的，所以这一切都在芯片的单核心内
Dialogue: 0,0:41:15.74,0:41:20.80,English,,0,0,0,,And then also on the chip but external to all the cores and shared by all the cores
Dialogue: 0,0:41:15.74,0:41:20.80,Chinese,,0,0,0,,然后在芯片上，但在所有内核外部并由所有内核共享
Dialogue: 0,0:41:21.36,0:41:27.62,English,,0,0,0,,Is at L3 unified cache which is 8 megabytes and 16 way associative
Dialogue: 0,0:41:21.36,0:41:27.62,Chinese,,0,0,0,,处于L3统一缓存，即8兆字节和16路关联
Dialogue: 0,0:41:28.06,0:41:31.74,English,,0,0,0,,With an access time that's like 40 to 75 cycles
Dialogue: 0,0:41:28.06,0:41:31.74,Chinese,,0,0,0,,访问时间大约为40到75个周期
Dialogue: 0,0:41:33.84,0:41:43.06,English,,0,0,0,,So if there's a miss in L1,then the L1 sense or tries to sends a request to L2 to try to find the data in L2
Dialogue: 0,0:41:33.84,0:41:43.06,Chinese,,0,0,0,,因此，如果在L1中出现未命中，则L1感测或尝试向L2发送请求以尝试在L2中查找数据
Dialogue: 0,0:41:43.08,0:41:47.60,English,,0,0,0,,Since L2 is a little bigger maybe maybe the data hasn't been flushed out of L2 yet
Dialogue: 0,0:41:43.08,0:41:47.60,Chinese,,0,0,0,,由于L2稍微大一点，也许数据还没有从L2中刷出
Dialogue: 0,0:41:48.14,0:41:55.10,English,,0,0,0,,If L2 can't find it,it sends a request to L3 to see if they can find the data in L3
Dialogue: 0,0:41:48.14,0:41:55.10,Chinese,,0,0,0,,如果L2无法找到它，它会向L3发送请求，以查看它们是否可以在L3中找到数据
Dialogue: 0,0:41:55.88,0:41:59.62,English,,0,0,0,,If L3 can't find it then it gives up and it goes off chip to memory
Dialogue: 0,0:41:55.88,0:41:59.62,Chinese,,0,0,0,,如果L3找不到它，那么它就会放弃，它会从芯片到内存中消失
Dialogue: 0,0:42:00.46,0:42:03.88,English,,0,0,0,,Yes question
Dialogue: 0,0:42:00.46,0:42:03.88,Chinese,,0,0,0,,是的问题
Dialogue: 0,0:42:03.92,0:42:09.32,English,,0,0,0,,Yes name memory is this that's it's the DRAM built of DRAM chips
Dialogue: 0,0:42:03.92,0:42:09.32,Chinese,,0,0,0,,是名称内存，这是由DRAM芯片构成的DRAM
Dialogue: 0,0:42:09.94,0:42:13.96,English,,0,0,0,,It's separate,it's in a separate separate set of chips on the motherboard
Dialogue: 0,0:42:09.94,0:42:13.96,Chinese,,0,0,0,,它是独立的，它在主板上的一组独立芯片中
Dialogue: 0,0:42:14.90,0:42:18.22,English,,0,0,0,,Connected by those that I/O bridge
Dialogue: 0,0:42:14.90,0:42:18.22,Chinese,,0,0,0,,由那些I / O桥连接
Dialogue: 0,0:42:18.22,0:42:22.90,English,,0,0,0,,That we and the bus various buses then that we talked about last time
Dialogue: 0,0:42:18.22,0:42:22.90,Chinese,,0,0,0,,那我们和公共汽车的各种公共汽车然后我们上次谈到了
Dialogue: 0,0:42:29.14,0:42:34.02,English,,0,0,0,,And for all different for all of these different caches that block size is 64 bytes
Dialogue: 0,0:42:29.14,0:42:34.02,Chinese,,0,0,0,,对于所有这些不同的缓存，所有不同的块大小为64字节
Dialogue: 0,0:42:38.88,0:42:44.60,English,,0,0,0,,Now there's a number of different ways to I think about the performance of caches
Dialogue: 0,0:42:38.88,0:42:44.60,Chinese,,0,0,0,,现在有很多不同的方法来考虑缓存的性能
Dialogue: 0,0:42:46.72,0:42:51.36,English,,0,0,0,,My most common way is using a metric called the miss rate
Dialogue: 0,0:42:46.72,0:42:51.36,Chinese,,0,0,0,,我最常见的方法是使用称为未命中率的指标
Dialogue: 0,0:42:52.08,0:42:54.96,English,,0,0,0,,So what this is the fraction of references that miss
Dialogue: 0,0:42:52.08,0:42:54.96,Chinese,,0,0,0,,那么这是错过的参考文献的一部分
Dialogue: 0,0:42:56.50,0:43:00.34,English,,0,0,0,,So we're very so I thought and it's 1- hit rate
Dialogue: 0,0:42:56.50,0:43:00.34,Chinese,,0,0,0,,所以我们非常认真，这是1的命中率
Dialogue: 0,0:43:01.56,0:43:06.22,English,,0,0,0,,So typical for caches to work that miss rate has to be pretty low
Dialogue: 0,0:43:01.56,0:43:06.22,Chinese,,0,0,0,,对于工作缓存来说，典型的错过率必须非常低
Dialogue: 0,0:43:07.58,0:43:11.70,English,,0,0,0,,And fortunately because of locality these miss rates are low
Dialogue: 0,0:43:07.58,0:43:11.70,Chinese,,0,0,0,,幸运的是，由于当地的情况，这些错失率很低
Dialogue: 0,0:43:13.38,0:43:16.66,English,,0,0,0,,Another metric is the hit time
Dialogue: 0,0:43:13.38,0:43:16.66,Chinese,,0,0,0,,另一个指标是命中时间
Dialogue: 0,0:43:16.66,0:43:21.34,English,,0,0,0,,So if we do have a hit in the cache how long does it actually take to...
Dialogue: 0,0:43:16.66,0:43:21.34,Chinese,,0,0,0,,因此，如果我们确实在缓存中有一个命中，它实际需要多长时间...
Dialogue: 0,0:43:21.90,0:43:26.78,English,,0,0,0,,Sort of look up the you know do the lookup to determine that there was a hit and then return the value
Dialogue: 0,0:43:21.90,0:43:26.78,Chinese,,0,0,0,,查找你知道的查找排序，确定有一个命中，然后返回值
Dialogue: 0,0:43:29.08,0:43:36.66,English,,0,0,0,,So for L1 and in an intel system this is 4 clock cycles,10 clock cycles for L2
Dialogue: 0,0:43:29.08,0:43:36.66,Chinese,,0,0,0,,因此对于L1和在intel系统中，这是4个时钟周期，L2为10个时钟周期
Dialogue: 0,0:43:37.74,0:43:39.40,English,,0,0,0,,And then there's an additional cost if
Dialogue: 0,0:43:37.74,0:43:39.40,Chinese,,0,0,0,,然后还有额外的费用
Dialogue: 0,0:43:39.92,0:43:43.62,English,,0,0,0,,So you always have to pay the hit time right the hit time is the best you can do
Dialogue: 0,0:43:39.92,0:43:43.62,Chinese,,0,0,0,,所以你总是要付出命中时间，你可以做到最好
Dialogue: 0,0:43:45.42,0:43:49.08,English,,0,0,0,,But if you have a miss then it's you pay the hit time
Dialogue: 0,0:43:45.42,0:43:49.08,Chinese,,0,0,0,,但是，如果你有一个小姐，那么你需要支付命中时间
Dialogue: 0,0:43:50.66,0:43:54.80,English,,0,0,0,,Because you have to do the search and eventually you're going to have to return the word back to the requester
Dialogue: 0,0:43:50.66,0:43:54.80,Chinese,,0,0,0,,因为你必须进行搜索，最终你必须将该单词返回给请求者
Dialogue: 0,0:43:55.32,0:43:57.34,English,,0,0,0,,But you then you have this additional cost
Dialogue: 0,0:43:55.32,0:43:57.34,Chinese,,0,0,0,,但是你有这个额外的费用
Dialogue: 0,0:43:57.34,0:44:01.24,English,,0,0,0,,Which you have to go which is going to the the memory ready to fetch the data
Dialogue: 0,0:43:57.34,0:44:01.24,Chinese,,0,0,0,,你必须去哪个内存准备好获取数据
Dialogue: 0,0:44:02.16,0:44:05.76,English,,0,0,0,,Okay so that miss penalty,that's what called miss penalty
Dialogue: 0,0:44:02.16,0:44:05.76,Chinese,,0,0,0,,好吧，这样的小姐罚款，这就是所谓的小姐罚款
Dialogue: 0,0:44:07.40,0:44:10.16,English,,0,0,0,,Is on the order of hundreds of cycles for main memory
Dialogue: 0,0:44:07.40,0:44:10.16,Chinese,,0,0,0,,对于主存储器来说是大约数百个周期的顺序
Dialogue: 0,0:44:11.00,0:44:14.35,English,,0,0,0,,But at other levels of the hierarchy it can be huge
Dialogue: 0,0:44:11.00,0:44:14.35,Chinese,,0,0,0,,但在层次结构的其他层面，它可能是巨大的
Dialogue: 0,0:44:14.84,0:44:18.02,English,,0,0,0,,So the miss penalty if you have a cache in main memory
Dialogue: 0,0:44:14.84,0:44:18.02,Chinese,,0,0,0,,因此，如果你在主内存中有缓存，则会导致未命中
Dialogue: 0,0:44:18.64,0:44:23.12,English,,0,0,0,,That's caching blocks that are stored on disk, the miss penalty is enormous
Dialogue: 0,0:44:18.64,0:44:23.12,Chinese,,0,0,0,,这是存储在磁盘上的缓存块，未命中的惩罚是巨大的
Dialogue: 0,0:44:28.60,0:44:32.00,English,,0,0,0,,So it's kind of interesting if you think about it
Dialogue: 0,0:44:28.60,0:44:32.00,Chinese,,0,0,0,,所以如果你想一想它会很有趣
Dialogue: 0,0:44:34.00,0:44:39.74,English,,0,0,0,,The performance of these systems is very sensitive to the miss rate much more sensitive than you would think
Dialogue: 0,0:44:34.00,0:44:39.74,Chinese,,0,0,0,,这些系统的性能对未命中率非常敏感，比你想象的要灵敏得多
Dialogue: 0,0:44:41.32,0:44:49.66,English,,0,0,0,,And in fact 99% hit rate is twice as good as a 97% hit rate
Dialogue: 0,0:44:41.32,0:44:49.66,Chinese,,0,0,0,,事实上，99％的命中率是97％命中率的两倍
Dialogue: 0,0:44:50.64,0:44:51.04,English,,0,0,0,,Yes
Dialogue: 0,0:44:50.64,0:44:51.04,Chinese,,0,0,0,,是
Dialogue: 0,0:44:51.60,0:45:06.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:44:51.60,0:45:06.74,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:45:06.86,0:45:13.50,English,,0,0,0,,Yeah they hit,so the question is does the hit time include the time to access the tag and yes
Dialogue: 0,0:45:06.86,0:45:13.50,Chinese,,0,0,0,,是的，他们打了，所以问题是命中时间是否包括访问标签的时间，是的
Dialogue: 0,0:45:13.80,0:45:17.38,English,,0,0,0,,So the hit time is the time it takes to just to search
Dialogue: 0,0:45:13.80,0:45:17.38,Chinese,,0,0,0,,因此，命中时间是搜索所需的时间
Dialogue: 0,0:45:17.96,0:45:22.16,English,,0,0,0,,To determine if that item is in the cache and then return it
Dialogue: 0,0:45:17.96,0:45:22.16,Chinese,,0,0,0,,确定该项是否在缓存中，然后将其返回
Dialogue: 0,0:45:22.16,0:45:39.20,English,,0,0,0,,[student speaking]
Dialogue: 0,0:45:22.16,0:45:39.20,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:45:39.22,0:45:48.20,English,,0,0,0,,Yeah so the yeah so the the miss the miss penalty is the time it takes for the cash to fetch the data from memory
Dialogue: 0,0:45:39.22,0:45:48.20,Chinese,,0,0,0,,是的所以是的，所以错过点球的错过是现金从记忆中获取数据所需的时间
Dialogue: 0,0:45:48.94,0:45:51.92,English,,0,0,0,,So that's all the latency you know going across the buses
Dialogue: 0,0:45:48.94,0:45:51.92,Chinese,,0,0,0,,这就是你所知道的所有延迟
Dialogue: 0,0:45:52.28,0:45:55.32,English,,0,0,0,,The time it takes the memory to respond to the requests
Dialogue: 0,0:45:52.28,0:45:55.32,Chinese,,0,0,0,,内存响应请求所花费的时间
Dialogue: 0,0:45:55.83,0:45:59.78,English,,0,0,0,,The time it takes the data to flow back over the buses back to the the cache
Dialogue: 0,0:45:55.83,0:45:59.78,Chinese,,0,0,0,,数据通过总线返回缓存所需的时间
Dialogue: 0,0:46:00.48,0:46:05.10,English,,0,0,0,,So the time for a miss is going to be the hit time plus the miss penalty that clear
Dialogue: 0,0:46:00.48,0:46:05.10,Chinese,,0,0,0,,因此，未命中的时间将是命中时间加上明确的未命中罚分
Dialogue: 0,0:46:09.76,0:46:17.00,English,,0,0,0,,So I mean imagine suppose there's a hit time of one cycle and a miss penalty of 100 cycles that those are reasonable numbers
Dialogue: 0,0:46:09.76,0:46:17.00,Chinese,,0,0,0,,所以我的意思是假设有一个周期的命中时间和100个周期的未命中罚分，那些是合理的数字
Dialogue: 0,0:46:18.48,0:46:22.76,English,,0,0,0,,So the the average access time if you have 97% hits
Dialogue: 0,0:46:18.48,0:46:22.76,Chinese,,0,0,0,,所以如果你有97％的点击率，平均访问时间
Dialogue: 0,0:46:24.22,0:46:29.48,English,,0,0,0,,It's the hit time plus the percentage of misses times the miss penalty
Dialogue: 0,0:46:24.22,0:46:29.48,Chinese,,0,0,0,,这是命中时间加上未命中罚分的百分比
Dialogue: 0,0:46:30.06,0:46:32.66,English,,0,0,0,,So that's four cycles for the average access time
Dialogue: 0,0:46:30.06,0:46:32.66,Chinese,,0,0,0,,所以这是平均访问时间的四个周期
Dialogue: 0,0:46:33.36,0:46:36.56,English,,0,0,0,,But if we just increase the hit rate by two percent
Dialogue: 0,0:46:33.36,0:46:36.56,Chinese,,0,0,0,,但如果我们只是将命中率提高2％
Dialogue: 0,0:46:37.38,0:46:42.72,English,,0,0,0,,The average access time drops by 50% a factor of two
Dialogue: 0,0:46:37.38,0:46:42.72,Chinese,,0,0,0,,平均访问时间减少了50％，减少了两倍
Dialogue: 0,0:46:47.26,0:46:51.72,English,,0,0,0,,All right so why is this stuff important why should you care about it
Dialogue: 0,0:46:47.26,0:46:51.72,Chinese,,0,0,0,,好吧，为什么这个东西很重要，为什么要关心它呢？
Dialogue: 0,0:46:53.42,0:46:57.78,English,,0,0,0,,So cash is that as we've seen are these these they're automatic they're all built in hardware
Dialogue: 0,0:46:53.42,0:46:57.78,Chinese,,0,0,0,,所以现金就像我们所看到的那样，这些都是自动的，它们都是用硬件构建的
Dialogue: 0,0:46:58.44,0:47:04.48,English,,0,0,0,,There's no part of the sort of the visible instruction set that
Dialogue: 0,0:46:58.44,0:47:04.48,Chinese,,0,0,0,,没有那种可见指令集的那部分
Dialogue: 0,0:47:05.02,0:47:09.94,English,,0,0,0,,Lets you manipulate caches and your assembly machine code programs
Dialogue: 0,0:47:05.02,0:47:09.94,Chinese,,0,0,0,,允许你操作缓存和组装机器代码程序
Dialogue: 0,0:47:11.72,0:47:16.32,English,,0,0,0,,So that it all happens behind the scenes automatically in hardware
Dialogue: 0,0:47:11.72,0:47:16.32,Chinese,,0,0,0,,所以这一切都在硬件中自动发生在幕后
Dialogue: 0,0:47:17.42,0:47:21.26,English,,0,0,0,,But if you know how kit...if you know about the existence of caches
Dialogue: 0,0:47:17.42,0:47:21.26,Chinese,,0,0,0,,但是，如果你知道如何使用套件......如果你知道缓存的存在
Dialogue: 0,0:47:21.26,0:47:24.18,English,,0,0,0,,And you have this general idea of how you can work how they work
Dialogue: 0,0:47:21.26,0:47:24.18,Chinese,,0,0,0,,而且你对如何运用它们的工作方式有了一个大概的了解
Dialogue: 0,0:47:24.84,0:47:27.76,English,,0,0,0,,Then you can write code that's cache friendly
Dialogue: 0,0:47:24.84,0:47:27.76,Chinese,,0,0,0,,然后你可以编写缓存友好的代码
Dialogue: 0,0:47:27.76,0:47:36.68,English,,0,0,0,,In the sense that your code will have a higher higher miss rate than code that that isn't cache friendly
Dialogue: 0,0:47:27.76,0:47:36.68,Chinese,,0,0,0,,从某种意义上说，你的代码具有比不缓存友好的代码更高的未命中率
Dialogue: 0,0:47:37.96,0:47:44.76,English,,0,0,0,,So the idea is to...you want to focus on making the common case go fast
Dialogue: 0,0:47:37.96,0:47:44.76,Chinese,,0,0,0,,因此，我们的想法是......你希望专注于使常见案例快速进行
Dialogue: 0,0:47:44.82,0:47:48.90,English,,0,0,0,,Don't spend your time on code  that sort of code that doesn't get execute very much
Dialogue: 0,0:47:44.82,0:47:48.90,Chinese,,0,0,0,,不要把时间花在那些代码不能很快执行的代码上
Dialogue: 0,0:47:50.16,0:47:53.00,English,,0,0,0,,So look at the most commonly called functions
Dialogue: 0,0:47:50.16,0:47:53.00,Chinese,,0,0,0,,所以看看最常见的函数
Dialogue: 0,0:47:54.32,0:47:57.12,English,,0,0,0,,And then within those functions look at the inner loops of those functions
Dialogue: 0,0:47:54.32,0:47:57.12,Chinese,,0,0,0,,然后在这些函数中查看这些函数的内部循环
Dialogue: 0,0:47:57.12,0:47:59.36,English,,0,0,0,,Because it's the inner loops that are executing the most
Dialogue: 0,0:47:57.12,0:47:59.36,Chinese,,0,0,0,,因为它是执行最多的内循环
Dialogue: 0,0:48:00.30,0:48:04.78,English,,0,0,0,,Right so you can as a first approximation you can just ignore sort of stuff
Dialogue: 0,0:48:00.30,0:48:04.78,Chinese,,0,0,0,,对，所以你可以作为第一个近似，你可以忽略一些东西
Dialogue: 0,0:48:04.78,0:48:08.76,English,,0,0,0,,If you have nested loops you can ignore stuff that's going on in the outer loops
Dialogue: 0,0:48:04.78,0:48:08.76,Chinese,,0,0,0,,如果你有嵌套循环，你可以忽略外循环中发生的事情
Dialogue: 0,0:48:08.78,0:48:11.02,English,,0,0,0,,And just focus on the code in the inner loop
Dialogue: 0,0:48:08.78,0:48:11.02,Chinese,,0,0,0,,然后只关注内循环中的代码
Dialogue: 0,0:48:12.36,0:48:15.22,English,,0,0,0,,Now what you want to do is try to minimize the misses in the inner loop
Dialogue: 0,0:48:12.36,0:48:15.22,Chinese,,0,0,0,,现在你想要做的是尽量减少内循环中的失误
Dialogue: 0,0:48:16.62,0:48:21.91,English,,0,0,0,,Okay so repeated references to a variable is variables are good
Dialogue: 0,0:48:16.62,0:48:21.91,Chinese,,0,0,0,,好吧，如此重复引用变量是变量是好的
Dialogue: 0,0:48:22.34,0:48:24.20,English,,0,0,0,,Especially if those are local variables
Dialogue: 0,0:48:22.34,0:48:24.20,Chinese,,0,0,0,,特别是如果那些是局部变量
Dialogue: 0,0:48:24.78,0:48:27.56,English,,0,0,0,,Right so remember if you declare a local variable and see
Dialogue: 0,0:48:24.78,0:48:27.56,Chinese,,0,0,0,,对，所以请记住，如果你声明一个局部变量，看看
Dialogue: 0,0:48:28.52,0:48:30.90,English,,0,0,0,,The compiler can put that in a register
Dialogue: 0,0:48:28.52,0:48:30.90,Chinese,,0,0,0,,编译器可以将它放在寄存器中
Dialogue: 0,0:48:32.30,0:48:34.30,English,,0,0,0,,Right if you're referencing global variables
Dialogue: 0,0:48:32.30,0:48:34.30,Chinese,,0,0,0,,如果你正在引用全局变量，那就正确
Dialogue: 0,0:48:34.72,0:48:37.26,English,,0,0,0,,Maybe not,the compiler doesn't know what's going on
Dialogue: 0,0:48:34.72,0:48:37.26,Chinese,,0,0,0,,也许不是，编译器不知道发生了什么
Dialogue: 0,0:48:37.72,0:48:44.30,English,,0,0,0,,So it can't put the reference to that variable to see in a register
Dialogue: 0,0:48:37.72,0:48:44.30,Chinese,,0,0,0,,因此它无法将该变量的引用放入寄存器中
Dialogue: 0,0:48:44.98,0:48:50.18,English,,0,0,0,,Okay so repeated references to local variables stored on the stack are good
Dialogue: 0,0:48:44.98,0:48:50.18,Chinese,,0,0,0,,好吧，如此重复引用存储在堆栈中的局部变量是好的
Dialogue: 0,0:48:50.48,0:48:52.78,English,,0,0,0,,Because those will get turned into register accesses
Dialogue: 0,0:48:50.48,0:48:52.78,Chinese,,0,0,0,,因为那些将变成寄存器访问
Dialogue: 0,0:48:53.06,0:48:54.30,English,,0,0,0,,You'll never go to memory
Dialogue: 0,0:48:53.06,0:48:54.30,Chinese,,0,0,0,,你永远不会去记忆
Dialogue: 0,0:48:55.42,0:48:58.90,English,,0,0,0,,Okay also stride one accesses two arrays are good
Dialogue: 0,0:48:55.42,0:48:58.90,Chinese,,0,0,0,,好的还有一个访问两个阵列是好的
Dialogue: 0,0:48:59.98,0:49:02.60,English,,0,0,0,,And they're good because of the existence of these blocks
Dialogue: 0,0:48:59.98,0:49:02.60,Chinese,,0,0,0,,由于存在这些块，它们很好
Dialogue: 0,0:49:03.20,0:49:07.48,English,,0,0,0,,Right so the only way you'd know that stride one references our good is if you knew that
Dialogue: 0,0:49:03.20,0:49:07.48,Chinese,,0,0,0,,对，所以你知道如果你知道的话，唯一的方法就是知道那个步骤引用了我们的好处
Dialogue: 0,0:49:07.90,0:49:10.20,English,,0,0,0,,Caches have the 64-byte blocks
Dialogue: 0,0:49:07.90,0:49:10.20,Chinese,,0,0,0,,高速缓存具有64字节块
Dialogue: 0,0:49:11.88,0:49:18.34,English,,0,0,0,,Okay so the and stride one reference will have half the miss rate as a stride to reference
Dialogue: 0,0:49:11.88,0:49:18.34,Chinese,,0,0,0,,好的，所以并且一步参考将有一半的未命中率作为参考的步幅
Dialogue: 0,0:49:19.74,0:49:26.42,English,,0,0,0,,Because if you're doing stride one references the first reference to a word and a block will miss
Dialogue: 0,0:49:19.74,0:49:26.42,Chinese,,0,0,0,,因为如果你正在做步幅，则引用对单词的第一个引用，并且块将会错过
Dialogue: 0,0:49:27.70,0:49:29.68,English,,0,0,0,,But then subsequent references will hit
Dialogue: 0,0:49:27.70,0:49:29.68,Chinese,,0,0,0,,但随后的参考文献将会出现
Dialogue: 0,0:49:31.64,0:49:37.42,English,,0,0,0,,Right and you'll hit if you're doing a stride one reference you're going to hit every word in that block
Dialogue: 0,0:49:31.64,0:49:37.42,Chinese,,0,0,0,,是的，如果你正在做一个步幅，那么你将会击中你将要击中该区块中的每个单词
Dialogue: 0,0:49:38.10,0:49:41.84,English,,0,0,0,,If your drive if you're doing stride two references you're only going to hit every other word
Dialogue: 0,0:49:38.10,0:49:41.84,Chinese,,0,0,0,,如果你的驱动器如果你正在做两个参考，你只会打到其他所有的单词
Dialogue: 0,0:49:42.78,0:49:46.92,English,,0,0,0,,Right so you'll only get,you'll get sort of half the so you'll missed at twice the rate
Dialogue: 0,0:49:42.78,0:49:46.92,Chinese,,0,0,0,,对，所以你只会得到，你会得到一半，所以你会错过两倍的速度
Dialogue: 0,0:49:50.98,0:49:51.92,English,,0,0,0,,So
Dialogue: 0,0:49:50.98,0:49:51.92,Chinese,,0,0,0,,所以
Dialogue: 0,0:49:54.38,0:49:59.28,English,,0,0,0,,So basically the point I want to make to you is that our understanding of caches
Dialogue: 0,0:49:54.38,0:49:59.28,Chinese,,0,0,0,,所以基本上我想对你说的是我们对缓存的理解
Dialogue: 0,0:49:59.84,0:50:06.20,English,,0,0,0,,Allow us to sort of quantify this qualitative notion of locality that we developed the last time
Dialogue: 0,0:49:59.84,0:50:06.20,Chinese,,0,0,0,,让我们来量化我们最后一次开发的这种定性的地方概念
Dialogue: 0,0:50:06.20,0:50:11.06,English,,0,0,0,,Right the last time we looked at we said if it's doing stride one references that's good if
Dialogue: 0,0:50:06.20,0:50:11.06,Chinese,,0,0,0,,我们最后一次看到的时候，我们说如果它正在大步推进一个参考，那就好了
Dialogue: 0,0:50:11.64,0:50:16.98,English,,0,0,0,,If we're doing if we're accessing the same variable over and over that's good
Dialogue: 0,0:50:11.64,0:50:16.98,Chinese,,0,0,0,,如果我们正在做的话，如果我们一遍又一遍地访问同一个变量那就好了
Dialogue: 0,0:50:17.62,0:50:21.74,English,,0,0,0,,But if we understand caches now we can quantify it in terms of miss rate
Dialogue: 0,0:50:17.62,0:50:21.74,Chinese,,0,0,0,,但是，如果我们现在了解缓存，我们可以根据未命中率对其进行量化
Dialogue: 0,0:50:26.42,0:50:28.82,English,,0,0,0,,All right so let's finish up the rest of the class
Dialogue: 0,0:50:26.42,0:50:28.82,Chinese,,0,0,0,,好吧，让我们完成课程的其余部分
Dialogue: 0,0:50:28.82,0:50:32.50,English,,0,0,0,,We're going to look at the performance impact of caches on your code
Dialogue: 0,0:50:28.82,0:50:32.50,Chinese,,0,0,0,,我们将研究缓存对代码的性能影响
Dialogue: 0,0:50:33.00,0:50:36.43,English,,0,0,0,,Okay and why you need to why you need to know about these things
Dialogue: 0,0:50:33.00,0:50:36.43,Chinese,,0,0,0,,好的，为什么你需要知道为什么你需要知道这些事情
Dialogue: 0,0:50:37.16,0:50:39.10,English,,0,0,0,,And that the impact that they can have
Dialogue: 0,0:50:37.16,0:50:39.10,Chinese,,0,0,0,,而且他们可以产生的影响
Dialogue: 0,0:50:41.52,0:50:44.58,English,,0,0,0,,So there's a very interesting function
Dialogue: 0,0:50:41.52,0:50:44.58,Chinese,,0,0,0,,所以有一个非常有趣的功能
Dialogue: 0,0:50:45.22,0:50:48.32,English,,0,0,0,,This actually plotted on the cover of your text book
Dialogue: 0,0:50:45.22,0:50:48.32,Chinese,,0,0,0,,这实际上绘制在教科书的封面上
Dialogue: 0,0:50:49.12,0:50:50.50,English,,0,0,0,,That we call the memory mountain
Dialogue: 0,0:50:49.12,0:50:50.50,Chinese,,0,0,0,,我们称之为记忆山
Dialogue: 0,0:50:51.10,0:50:59.14,English,,0,0,0,,I learned about this from a graduate student here at Carnegie Mellon back in the 90s who developed this notion made Tom Stricker
Dialogue: 0,0:50:51.10,0:50:59.14,Chinese,,0,0,0,,我从90年代卡内基梅隆大学的一名研究生那里了解到这一点，他开发了这个概念，让汤姆史翠克
Dialogue: 0,0:51:00.34,0:51:07.66,English,,0,0,0,,And what it's a the memory mountain plots a measure called read through put or read bandwidth
Dialogue: 0,0:51:00.34,0:51:07.66,Chinese,,0,0,0,,而它是一个记忆山，它描绘了一种称为通读或读取带宽的措施
Dialogue: 0,0:51:08.18,0:51:10.38,English,,0,0,0,,Which is the number of bytes read from memory
Dialogue: 0,0:51:08.18,0:51:10.38,Chinese,,0,0,0,,哪个是从内存中读取的字节数
Dialogue: 0,0:51:10.66,0:51:16.08,English,,0,0,0,,So if you have a loop and you're scanning over a vector
Dialogue: 0,0:51:10.66,0:51:16.08,Chinese,,0,0,0,,所以，如果你有一个循环而你正在扫描一个向量
Dialogue: 0,0:51:16.36,0:51:19.40,English,,0,0,0,,So you have a vector of say double words
Dialogue: 0,0:51:16.36,0:51:19.40,Chinese,,0,0,0,,所以你有一个说双字的向量
Dialogue: 0,0:51:20.20,0:51:23.86,English,,0,0,0,,And you're reading those elements from a vector one after the other
Dialogue: 0,0:51:20.20,0:51:23.86,Chinese,,0,0,0,,而且你正在逐个从矢量中读取这些元素
Dialogue: 0,0:51:24.68,0:51:30.04,English,,0,0,0,,The read throughput is the number of megabytes per second that you can perform that task
Dialogue: 0,0:51:24.68,0:51:30.04,Chinese,,0,0,0,,读取吞吐量是你可以执行该任务的每秒兆字节数
Dialogue: 0,0:51:31.14,0:51:34.62,English,,0,0,0,,At and the memory mountain plots read throughput
Dialogue: 0,0:51:31.14,0:51:34.62,Chinese,,0,0,0,,在和记忆山图上读取吞吐量
Dialogue: 0,0:51:35.02,0:51:39.48,English,,0,0,0,,As a function of the temporal and spatial locality in that loop
Dialogue: 0,0:51:35.02,0:51:39.48,Chinese,,0,0,0,,作为该循环中的时间和空间局部性的函数
Dialogue: 0,0:51:41.20,0:51:48.60,English,,0,0,0,,Okay so in a sense it's looking at a wide range of locality options or characteristics in a program
Dialogue: 0,0:51:41.20,0:51:48.60,Chinese,,0,0,0,,好的，从某种意义上说，它正在考虑程序中的各种地点选项或特征
Dialogue: 0,0:51:48.80,0:51:55.68,English,,0,0,0,,And it's plotting the performance of that memory system on that across that range as a two-dimensional function
Dialogue: 0,0:51:48.80,0:51:55.68,Chinese,,0,0,0,,并且它正在将该存储系统的性能绘制在该范围内作为二维函数
Dialogue: 0,0:51:56.08,0:51:58.23,English,,0,0,0,,So in some ways the memory mountain is a
Dialogue: 0,0:51:56.08,0:51:58.23,Chinese,,0,0,0,,所以在某些方面，记忆山是一个
Dialogue: 0,0:51:59.10,0:52:02.56,English,,0,0,0,,Kind of a fingerprint right every system has its own unique memory mountain
Dialogue: 0,0:51:59.10,0:52:02.56,Chinese,,0,0,0,,每种系统都有自己独特的记忆山
Dialogue: 0,0:52:03.26,0:52:06.04,English,,0,0,0,,That we can measure right by writing a simple program
Dialogue: 0,0:52:03.26,0:52:06.04,Chinese,,0,0,0,,我们可以通过编写一个简单的程序来衡量
Dialogue: 0,0:52:07.50,0:52:14.22,English,,0,0,0,,And so the idea here is that to construct the memory mountain
Dialogue: 0,0:52:07.50,0:52:14.22,Chinese,,0,0,0,,所以这里的想法是构建记忆山
Dialogue: 0,0:52:15.08,0:52:16.78,English,,0,0,0,,We write a program called test
Dialogue: 0,0:52:15.08,0:52:16.78,Chinese,,0,0,0,,我们编写了一个名为test的程序
Dialogue: 0,0:52:35.50,0:52:36.60,English,,0,0,0,,Oh shoot
Dialogue: 0,0:52:35.50,0:52:36.60,Chinese,,0,0,0,,哦拍
Dialogue: 0,0:52:51.54,0:52:53.04,English,,0,0,0,,For some reason it's not
Dialogue: 0,0:52:51.54,0:52:53.04,Chinese,,0,0,0,,出于某种原因，事实并非如此
Dialogue: 0,0:52:57.02,0:53:01.56,English,,0,0,0,,Okay right
Dialogue: 0,0:52:57.02,0:53:01.56,Chinese,,0,0,0,,好的，没错
Dialogue: 0,0:53:04.22,0:53:06.66,English,,0,0,0,,So when we build a memory mountain
Dialogue: 0,0:53:04.22,0:53:06.66,Chinese,,0,0,0,,所以当我们建立一座记忆山
Dialogue: 0,0:53:07.38,0:53:12.66,English,,0,0,0,,We're given a vector that consists of a collection of double words
Dialogue: 0,0:53:07.38,0:53:12.66,Chinese,,0,0,0,,我们给出了一个由双字组合组成的向量
Dialogue: 0,0:53:17.60,0:53:24.40,English,,0,0,0,,And then we write a loop that reads those words that read some number of words in this case
Dialogue: 0,0:53:17.60,0:53:24.40,Chinese,,0,0,0,,然后我们编写一个循环来读取在这种情况下读取一些单词的那些单词
Dialogue: 0,0:53:25.54,0:53:42.84,English,,0,0,0,,Hmm
Dialogue: 0,0:53:25.54,0:53:42.84,Chinese,,0,0,0,,嗯
Dialogue: 0,0:53:42.92,0:53:43.86,English,,0,0,0,,There we go
Dialogue: 0,0:53:42.92,0:53:43.86,Chinese,,0,0,0,,我们走了
Dialogue: 0,0:53:44.90,0:53:49.60,English,,0,0,0,,So it reads it reads elems number of elements right
Dialogue: 0,0:53:44.90,0:53:49.60,Chinese,,0,0,0,,所以它读取它读取元素数量正确
Dialogue: 0,0:53:49.90,0:53:55.28,English,,0,0,0,,So we've got each of these double word elements with a stride of stride
Dialogue: 0,0:53:49.90,0:53:55.28,Chinese,,0,0,0,,因此，我们已经获得了这些双字元素中的每一个都迈出了一大步
Dialogue: 0,0:53:56.62,0:53:58.40,English,,0,0,0,,Okay so if we have a stride of one
Dialogue: 0,0:53:56.62,0:53:58.40,Chinese,,0,0,0,,好的，如果我们有一个步伐
Dialogue: 0,0:54:02.46,0:54:04.18,English,,0,0,0,,I know that was kind of redundant huh
Dialogue: 0,0:54:02.46,0:54:04.18,Chinese,,0,0,0,,我知道那有点多余了
Dialogue: 0,0:54:04.44,0:54:06.00,English,,0,0,0,,So if we have a stride of one
Dialogue: 0,0:54:04.44,0:54:06.00,Chinese,,0,0,0,,所以，如果我们有一个步伐
Dialogue: 0,0:54:09.18,0:54:12.86,English,,0,0,0,,Then we'll have our loop wills was sort of looped through
Dialogue: 0,0:54:09.18,0:54:12.86,Chinese,,0,0,0,,然后我们将循环意志循环通过
Dialogue: 0,0:54:13.62,0:54:17.62,English,,0,0,0,,And read these elements until we've read elems number of those elements
Dialogue: 0,0:54:13.62,0:54:17.62,Chinese,,0,0,0,,并阅读这些元素，直到我们阅读了这些元素的元数
Dialogue: 0,0:54:18.54,0:54:23.14,English,,0,0,0,,Okay and then we'll do it again and then that warms up the cache
Dialogue: 0,0:54:18.54,0:54:23.14,Chinese,,0,0,0,,好的，然后我们会再次这样做，然后加热缓存
Dialogue: 0,0:54:23.88,0:54:27.66,English,,0,0,0,,Then we do it again and do exactly the same thing
Dialogue: 0,0:54:23.88,0:54:27.66,Chinese,,0,0,0,,然后我们再做一次并做同样的事情
Dialogue: 0,0:54:28.54,0:54:32.82,English,,0,0,0,,So if we're doing this with a stride of two then we would be reading
Dialogue: 0,0:54:28.54,0:54:32.82,Chinese,,0,0,0,,因此，如果我们以两个步幅这样做，那么我们将会阅读
Dialogue: 0,0:54:33.76,0:54:41.80,English,,0,0,0,,We would read this word zero or elem 2 elem 4 and so on
Dialogue: 0,0:54:33.76,0:54:41.80,Chinese,,0,0,0,,我们会读到这个单词零或元素2元素4等等
Dialogue: 0,0:54:45.60,0:54:50.02,English,,0,0,0,,Okay so well then what all we're doing we're just for wide range of strides
Dialogue: 0,0:54:45.60,0:54:50.02,Chinese,,0,0,0,,好吧那么我们所做的一切只是为了取得广泛的进步
Dialogue: 0,0:54:50.84,0:54:53.20,English,,0,0,0,,And a wide range of sizes
Dialogue: 0,0:54:50.84,0:54:53.20,Chinese,,0,0,0,,和各种尺寸
Dialogue: 0,0:54:53.78,0:55:00.12,English,,0,0,0,,We're scanning over this vector and just recording how long it takes to do that read
Dialogue: 0,0:54:53.78,0:55:00.12,Chinese,,0,0,0,,我们正在扫描这个向量，只记录读取所需的时间
Dialogue: 0,0:55:00.56,0:55:04.03,English,,0,0,0,,And then convert we convert that into megabytes per second
Dialogue: 0,0:55:00.56,0:55:04.03,Chinese,,0,0,0,,然后转换我们将其转换为每秒兆字节
Dialogue: 0,0:55:05.32,0:55:12.74,English,,0,0,0,,And in order to I just wanted to show you this is we don't need,we're not going to go into detail about this but
Dialogue: 0,0:55:05.32,0:55:12.74,Chinese,,0,0,0,,而且为了我想告诉你这是我们不需要的，我们不打算详细讨论这个问题
Dialogue: 0,0:55:13.09,0:55:17.86,English,,0,0,0,,This is actually how I generated the the cover on the book and
Dialogue: 0,0:55:13.09,0:55:17.86,Chinese,,0,0,0,,这实际上就是我在书上制作封面的方式
Dialogue: 0,0:55:18.10,0:55:23.72,English,,0,0,0,,In order to use to exploit the parallelism inside the intel processor
Dialogue: 0,0:55:18.10,0:55:23.72,Chinese,,0,0,0,,为了利用intel处理器内部的并行性
Dialogue: 0,0:55:23.86,0:55:27.30,English,,0,0,0,,Like you learned about last week there's a lot of parallel functional units
Dialogue: 0,0:55:23.86,0:55:27.30,Chinese,,0,0,0,,就像你上周学到的那样，有许多并行的功能单元
Dialogue: 0,0:55:27.88,0:55:33.68,English,,0,0,0,,In order to exploit those I did 4x4 loop unrolling
Dialogue: 0,0:55:27.88,0:55:33.68,Chinese,,0,0,0,,为了利用那些我做了4x4循环展开
Dialogue: 0,0:55:34.20,0:55:36.96,English,,0,0,0,,So I'm actually doing sort of four scans in parallel
Dialogue: 0,0:55:34.20,0:55:36.96,Chinese,,0,0,0,,所以我实际上并行进行了四次扫描
Dialogue: 0,0:55:38.66,0:55:41.00,English,,0,0,0,,But the general idea is just what I've showed you here
Dialogue: 0,0:55:38.66,0:55:41.00,Chinese,,0,0,0,,但总的想法就是我在这里向你展示的内容
Dialogue: 0,0:55:41.78,0:55:47.34,English,,0,0,0,,And this this 4x4 loop unrolling is just an optimization
Dialogue: 0,0:55:41.78,0:55:47.34,Chinese,,0,0,0,,这个4x4循环展开只是一个优化
Dialogue: 0,0:55:47.92,0:55:51.74,English,,0,0,0,,But I wanted to show it to you because it actually it's the exact same principles
Dialogue: 0,0:55:47.92,0:55:51.74,Chinese,,0,0,0,,但我想向你展示它，因为它实际上是完全相同的原则
Dialogue: 0,0:55:51.74,0:55:57.24,English,,0,0,0,,You learned about last week professor Bryant talked about code optimization
Dialogue: 0,0:55:51.74,0:55:57.24,Chinese,,0,0,0,,你上周了解了布莱恩特教授谈到的代码优化问题
Dialogue: 0,0:55:58.78,0:56:05.48,English,,0,0,0,,So what we do is,we call this test function with these various ranges of elems and stride
Dialogue: 0,0:55:58.78,0:56:05.48,Chinese,,0,0,0,,所以我们所做的是，我们称这个测试函数具有各种各样的元素和步幅
Dialogue: 0,0:56:06.22,0:56:09.96,English,,0,0,0,,And then we measure the performance and we get this beautiful picture
Dialogue: 0,0:56:06.22,0:56:09.96,Chinese,,0,0,0,,然后我们衡量表现，我们得到了这幅美丽的画面
Dialogue: 0,0:56:10.38,0:56:14.44,English,,0,0,0,,This beautiful function ,to me it's beautiful I don't know does it look beautiful to you
Dialogue: 0,0:56:10.38,0:56:14.44,Chinese,,0,0,0,,这个美丽的功能，对我来说它是美丽的我不知道它对你来说是否美丽
Dialogue: 0,0:56:22.40,0:56:24.92,English,,0,0,0,,So on the z
Dialogue: 0,0:56:22.40,0:56:24.92,Chinese,,0,0,0,,所以在z
Dialogue: 0,0:56:25.32,0:56:29.90,English,,0,0,0,,On the z axis is plotting read throughput in megabytes per second
Dialogue: 0,0:56:25.32,0:56:29.90,Chinese,,0,0,0,,在z轴上绘制读取吞吐量，以兆字节/秒为单位
Dialogue: 0,0:56:29.90,0:56:37.58,English,,0,0,0,,Ranging from 2000 megabytes per second up to 16,000 megabytes per second
Dialogue: 0,0:56:29.90,0:56:37.58,Chinese,,0,0,0,,范围从每秒2000兆字节到每秒16,000兆字节
Dialogue: 0,0:56:42.66,0:56:48.62,English,,0,0,0,,This this axis is measuring is stride
Dialogue: 0,0:56:42.66,0:56:48.62,Chinese,,0,0,0,,这个轴测量是大步
Dialogue: 0,0:56:49.28,0:56:53.00,English,,0,0,0,,So going from stride 1 up to stride 12
Dialogue: 0,0:56:49.28,0:56:53.00,Chinese,,0,0,0,,所以从步幅1到步伐12
Dialogue: 0,0:56:55.08,0:57:03.86,English,,0,0,0,,And this axis is...so as we as we increase stride we're decreasing the spatial locality
Dialogue: 0,0:56:55.08,0:57:03.86,Chinese,,0,0,0,,而这个轴是......所以当我们增加步幅时，我们正在减少空间局部性
Dialogue: 0,0:57:05.54,0:57:06.34,English,,0,0,0,,Alright
Dialogue: 0,0:57:05.54,0:57:06.34,Chinese,,0,0,0,,好的
Dialogue: 0,0:57:09.68,0:57:18.00,English,,0,0,0,,And this axis is the size axis so we're going from I think 16k up to 128 megabytes
Dialogue: 0,0:57:09.68,0:57:18.00,Chinese,,0,0,0,,这个轴是大小轴，所以我们认为从16k到128兆
Dialogue: 0,0:57:18.72,0:57:23.16,English,,0,0,0,,So this is the number of elements we're going to read each pass through
Dialogue: 0,0:57:18.72,0:57:23.16,Chinese,,0,0,0,,所以这是我们每次传递时要阅读的元素数量
Dialogue: 0,0:57:25.60,0:57:29.10,English,,0,0,0,,So as we as we increase the size
Dialogue: 0,0:57:25.60,0:57:29.10,Chinese,,0,0,0,,因此，正如我们增加尺寸一样
Dialogue: 0,0:57:30.38,0:57:36.08,English,,0,0,0,,We're sort of decreasing the impact of temporal locality because word
Dialogue: 0,0:57:30.38,0:57:36.08,Chinese,,0,0,0,,我们有点减少时间局部性的影响因为单词
Dialogue: 0,0:57:36.82,0:57:41.80,English,,0,0,0,,As we increase the size there's fewer and fewer caches in our hierarchy can hold all that data
Dialogue: 0,0:57:36.82,0:57:41.80,Chinese,,0,0,0,,随着我们增加大小，我们的层次结构中的缓存越来越少，可以容纳所有数据
Dialogue: 0,0:57:44.62,0:57:49.94,English,,0,0,0,,And so this so we've got spatial locality decreasing in this direction
Dialogue: 0,0:57:44.62,0:57:49.94,Chinese,,0,0,0,,所以这样我们就可以在这个方向上减少空间局部性
Dialogue: 0,0:57:50.44,0:57:53.06,English,,0,0,0,,And temporal locality decreasing in this direction
Dialogue: 0,0:57:50.44,0:57:53.06,Chinese,,0,0,0,,并且时间局部性在这个方向上减少
Dialogue: 0,0:57:54.76,0:57:58.46,English,,0,0,0,,So as a programmer what you want to do you want to be up here
Dialogue: 0,0:57:54.76,0:57:58.46,Chinese,,0,0,0,,所以作为程序员你想做什么，你想要在这里
Dialogue: 0,0:57:59.86,0:58:02.52,English,,0,0,0,,Right good spatial locality good temporal locality
Dialogue: 0,0:57:59.86,0:58:02.52,Chinese,,0,0,0,,正确的良好空间局部性良好的时间局部性
Dialogue: 0,0:58:02.92,0:58:07.60,English,,0,0,0,,Because you can get like 14 gigabytes per second measure agreed throughput
Dialogue: 0,0:58:02.92,0:58:07.60,Chinese,,0,0,0,,因为你可以达到每秒14千兆字节的速度来衡量一致的吞吐量
Dialogue: 0,0:58:08.98,0:58:10.70,English,,0,0,0,,You don't want to be down here
Dialogue: 0,0:58:08.98,0:58:10.70,Chinese,,0,0,0,,你不想在这里
Dialogue: 0,0:58:11.98,0:58:15.94,English,,0,0,0,,Which is only about 100 megabytes per second where you're reading out of memory
Dialogue: 0,0:58:11.98,0:58:15.94,Chinese,,0,0,0,,在你读取内存时，每秒只有大约100兆字节
Dialogue: 0,0:58:16.18,0:58:20.42,English,,0,0,0,,Right so the difference between reading all of your data from memory
Dialogue: 0,0:58:16.18,0:58:20.42,Chinese,,0,0,0,,这样就可以从内存中读取所有数据了
Dialogue: 0,0:58:21.42,0:58:28.80,English,,0,0,0,,And reading it from some part of the the caches is huge it's enormous
Dialogue: 0,0:58:21.42,0:58:28.80,Chinese,,0,0,0,,从缓存的某些部分读取它是巨大的，它是巨大的
Dialogue: 0,0:58:29.60,0:58:32.52,English,,0,0,0,,Ok so because you're 213 students you'll be up here
Dialogue: 0,0:58:29.60,0:58:32.52,Chinese,,0,0,0,,好的，因为你是213名学生，你会在这里
Dialogue: 0,0:58:33.08,0:58:35.94,English,,0,0,0,,And all the students that didn't take 213 they'll be down here
Dialogue: 0,0:58:33.08,0:58:35.94,Chinese,,0,0,0,,并且所有没有拿到213的学生都会在这里
Dialogue: 0,0:58:38.10,0:58:43.04,English,,0,0,0,,And I've actually had I've actually had people several people write back
Dialogue: 0,0:58:38.10,0:58:43.04,Chinese,,0,0,0,,事实上，我实际上有几个人写回来的人
Dialogue: 0,0:58:43.04,0:58:48.40,English,,0,0,0,,To tell me about their experiences you know in internships and jobs after they left CMU
Dialogue: 0,0:58:43.04,0:58:48.40,Chinese,,0,0,0,,告诉我他们离开CMU后在实习和工作中所了解的经历
Dialogue: 0,0:58:48.94,0:58:51.74,English,,0,0,0,,Where they were given some code that that was down here
Dialogue: 0,0:58:48.94,0:58:51.74,Chinese,,0,0,0,,他们在那里获得了一些代码
Dialogue: 0,0:58:52.96,0:58:59.52,English,,0,0,0,,And they recognized the locality issues and they got it you know better up here or close at least better
Dialogue: 0,0:58:52.96,0:58:59.52,Chinese,,0,0,0,,他们认识到了地方问题，他们得到了你在这里知道的更好或至少更好地关闭
Dialogue: 0,0:59:01.18,0:59:07.22,English,,0,0,0,,So this picture this so-called memory mountain has all kinds of interesting features
Dialogue: 0,0:59:01.18,0:59:07.22,Chinese,,0,0,0,,所以这张照片所谓的记忆山有各种有趣的特征
Dialogue: 0,0:59:08.10,0:59:11.40,English,,0,0,0,,First of all there's these what I call ridges of temporal locality
Dialogue: 0,0:59:08.10,0:59:11.40,Chinese,,0,0,0,,首先，我称之为时间局部的脊
Dialogue: 0,0:59:12.02,0:59:15.86,English,,0,0,0,,Where these ridges see these ridge lines if you think of this is like a mountain
Dialogue: 0,0:59:12.02,0:59:15.86,Chinese,,0,0,0,,如果你认为这就像一座山，这些山脊会看到这些山脊线
Dialogue: 0,0:59:15.86,0:59:19.62,English,,0,0,0,,You see this ridge line and you see this ridge line
Dialogue: 0,0:59:15.86,0:59:19.62,Chinese,,0,0,0,,你看到这条山脊线，你看到这条山脊线
Dialogue: 0,0:59:20.34,0:59:23.24,English,,0,0,0,,And here's another ridge line and then here's a here's another one
Dialogue: 0,0:59:20.34,0:59:23.24,Chinese,,0,0,0,,而这里是另一条山脊线，然后这里是另一条山脊线
Dialogue: 0,0:59:23.56,0:59:25.70,English,,0,0,0,,These correspond to different levels in the hierarchy
Dialogue: 0,0:59:23.56,0:59:25.70,Chinese,,0,0,0,,这些对应于层次结构中的不同级别
Dialogue: 0,0:59:25.70,0:59:29.58,English,,0,0,0,,So this this top ridge line is where you're reading directly out of L1
Dialogue: 0,0:59:25.70,0:59:29.58,Chinese,,0,0,0,,所以这条顶部山脊线就是你直接读出L1的地方
Dialogue: 0,0:59:30.78,0:59:33.16,English,,0,0,0,,And it should be perfectly flat and
Dialogue: 0,0:59:30.78,0:59:33.16,Chinese,,0,0,0,,它应该是完全平坦的
Dialogue: 0,0:59:33.90,0:59:38.80,English,,0,0,0,,It's so fast that we're getting like measurement jitter performance jitter right
Dialogue: 0,0:59:33.90,0:59:38.80,Chinese,,0,0,0,,这是如此之快，以至于我们正在获得正确的测量抖动性能抖动
Dialogue: 0,0:59:39.90,0:59:45.60,English,,0,0,0,,But it's and this little drop off here is a measurement artifact it it should it shouldn't be there
Dialogue: 0,0:59:39.90,0:59:45.60,Chinese,,0,0,0,,但它和这里的一点点下降是一个测量工件它应该不应该存在
Dialogue: 0,0:59:45.60,0:59:49.22,English,,0,0,0,,It should be flat and go all the way to the wall back here
Dialogue: 0,0:59:45.60,0:59:49.22,Chinese,,0,0,0,,它应该是平的，一直到这里的墙
Dialogue: 0,0:59:52.50,0:59:58.48,English,,0,0,0,,And then here this ridge line is where we're accessing L2
Dialogue: 0,0:59:52.50,0:59:58.48,Chinese,,0,0,0,,然后在这里这条山脊线是我们访问L2的地方
Dialogue: 0,0:59:59.16,1:00:00.94,English,,0,0,0,,This is where we're accessing L3
Dialogue: 0,0:59:59.16,1:00:00.94,Chinese,,0,0,0,,这是我们访问L3的地方
Dialogue: 0,1:00:02.00,1:00:05.26,English,,0,0,0,,And here's what we're accessing mostly from memory
Dialogue: 0,1:00:02.00,1:00:05.26,Chinese,,0,0,0,,这就是我们主要通过记忆访问的内容
Dialogue: 0,1:00:06.38,1:00:08.58,English,,0,0,0,,So you have these ridges of temporal locality
Dialogue: 0,1:00:06.38,1:00:08.58,Chinese,,0,0,0,,所以你有这些时间局部的山脊
Dialogue: 0,1:00:08.94,1:00:12.26,English,,0,0,0,,And then you have these slopes of decreasing spatial locality
Dialogue: 0,1:00:08.94,1:00:12.26,Chinese,,0,0,0,,然后你有这些空间局部减少的斜率
Dialogue: 0,1:00:13.00,1:00:14.42,English,,0,0,0,,So you see the slope here
Dialogue: 0,1:00:13.00,1:00:14.42,Chinese,,0,0,0,,所以你看到这里的斜坡
Dialogue: 0,1:00:15.52,1:00:20.42,English,,0,0,0,,As work so as we're moving from the top of the slope down to the bottom
Dialogue: 0,1:00:15.52,1:00:20.42,Chinese,,0,0,0,,正如我们正在从斜坡顶部向下移动到底部
Dialogue: 0,1:00:21.84,1:00:28.76,English,,0,0,0,,We're decreasing our spatial locality so we're getting less benefit for these blocks that we're bringing in
Dialogue: 0,1:00:21.84,1:00:28.76,Chinese,,0,0,0,,我们正在减少我们的空间位置，因此我们带来的这些块的利益会减少
Dialogue: 0,1:00:29.27,1:00:33.32,English,,0,0,0,,So you can see the we're getting less benefit out of the cost
Dialogue: 0,1:00:29.27,1:00:33.32,Chinese,,0,0,0,,所以你可以看到我们从成本中获得的收益越来越少
Dialogue: 0,1:00:33.68,1:00:36.64,English,,0,0,0,,That we went through of importing of fetching these blocks
Dialogue: 0,1:00:33.68,1:00:36.64,Chinese,,0,0,0,,我们经历了导入这些块的导入
Dialogue: 0,1:00:38.18,1:00:42.28,English,,0,0,0,,And once the stride hits the block size
Dialogue: 0,1:00:38.18,1:00:42.28,Chinese,,0,0,0,,一旦步幅达到块大小
Dialogue: 0,1:00:43.40,1:00:45.58,English,,0,0,0,,Now every reference is hitting a different block
Dialogue: 0,1:00:43.40,1:00:45.58,Chinese,,0,0,0,,现在每个引用都会遇到不同的块
Dialogue: 0,1:00:46.02,1:00:50.40,English,,0,0,0,,And so and then it flattens out then you get you're getting noes benefit from spatial locality
Dialogue: 0,1:00:46.02,1:00:50.40,Chinese,,0,0,0,,然后它变得平坦，然后你得到你从空间局部获得noes
Dialogue: 0,1:00:53.68,1:00:59.50,English,,0,0,0,,And similarly here is where this this slope is where we're reading from L3
Dialogue: 0,1:00:53.68,1:00:59.50,Chinese,,0,0,0,,同样，这里的斜率是我们从L3读取的地方
Dialogue: 0,1:01:00.44,1:01:09.80,English,,0,0,0,,And it flattens out always they always flatten out at the block size which is a stride these are double words right
Dialogue: 0,1:01:00.44,1:01:09.80,Chinese,,0,0,0,,并且它变得平坦，总是它们总是在块尺寸上变平，这是一个跨步，这些是双字
Dialogue: 0,1:01:10.44,1:01:14.12,English,,0,0,0,,So it's stride of eight is 64 bytes
Dialogue: 0,1:01:10.44,1:01:14.12,Chinese,,0,0,0,,所以8的步幅是64字节
Dialogue: 0,1:01:14.12,1:01:16.66,English,,0,0,0,,So once you exceed a stride of eight then you're no longer
Dialogue: 0,1:01:14.12,1:01:16.66,Chinese,,0,0,0,,所以，一旦你超过8的步伐，你就不再了
Dialogue: 0,1:01:17.18,1:01:20.14,English,,0,0,0,,You're missing every time in a different block
Dialogue: 0,1:01:17.18,1:01:20.14,Chinese,,0,0,0,,你每次都在不同的街区
Dialogue: 0,1:01:23.48,1:01:26.18,English,,0,0,0,,There's this interesting this one puzzled me for a while
Dialogue: 0,1:01:23.48,1:01:26.18,Chinese,,0,0,0,,这个有趣的是这个让我困惑了一段时间
Dialogue: 0,1:01:26.94,1:01:32.88,English,,0,0,0,,You might be wondering like how come like over here is we increase the size
Dialogue: 0,1:01:26.94,1:01:32.88,Chinese,,0,0,0,,你可能想知道我们在这里如何增加尺寸
Dialogue: 0,1:01:33.52,1:01:39.86,English,,0,0,0,,We can sort of getting the...we're sort of as we increase the size
Dialogue: 0,1:01:33.52,1:01:39.86,Chinese,,0,0,0,,我们可以得到......我们就像增加尺寸一样
Dialogue: 0,1:01:39.86,1:01:45.60,English,,0,0,0,,We're doing most of our references out of caches that are lower in the cache hierarchy
Dialogue: 0,1:01:39.86,1:01:45.60,Chinese,,0,0,0,,我们从缓存层次结构中较低的缓存中执行大多数引用
Dialogue: 0,1:01:47.60,1:01:50.68,English,,0,0,0,,Okay but except when we're doing stride one references
Dialogue: 0,1:01:47.60,1:01:50.68,Chinese,,0,0,0,,好吧，但除非我们正在大步提到一个参考
Dialogue: 0,1:01:51.48,1:01:55.48,English,,0,0,0,,You can see all the way up to right at the end
Dialogue: 0,1:01:51.48,1:01:55.48,Chinese,,0,0,0,,你可以看到最后一直到最后
Dialogue: 0,1:01:56.80,1:01:59.76,English,,0,0,0,,Right before it exceeds the size of L3
Dialogue: 0,1:01:56.80,1:01:59.76,Chinese,,0,0,0,,就在它超过L3的大小之前
Dialogue: 0,1:02:01.24,1:02:01.96,English,,0,0,0,,It's flat
Dialogue: 0,1:02:01.24,1:02:01.96,Chinese,,0,0,0,,它很平坦
Dialogue: 0,1:02:05.74,1:02:07.78,English,,0,0,0,,And it's running at the L2 rate
Dialogue: 0,1:02:05.74,1:02:07.78,Chinese,,0,0,0,,并且它以L2速率运行
Dialogue: 0,1:02:08.08,1:02:13.06,English,,0,0,0,,Alright so here's the L1 rate and then it drops off and then it's running at a constant L2 rate
Dialogue: 0,1:02:08.08,1:02:13.06,Chinese,,0,0,0,,好吧所以这里是L1率然后它下降然后它以恒定的L2速率运行
Dialogue: 0,1:02:13.64,1:02:15.92,English,,0,0,0,,Until the data no longer fits in L3
Dialogue: 0,1:02:13.64,1:02:15.92,Chinese,,0,0,0,,直到数据不再适合L3
Dialogue: 0,1:02:17.24,1:02:20.36,English,,0,0,0,,So I think what's going on here is that the the hardware
Dialogue: 0,1:02:17.24,1:02:20.36,Chinese,,0,0,0,,所以我认为这里发生的是硬件
Dialogue: 0,1:02:21.28,1:02:28.72,English,,0,0,0,,The cache L2 cache hardware is recognizing or maybe it's an L1 but
Dialogue: 0,1:02:21.28,1:02:28.72,Chinese,,0,0,0,,高速缓存L2高速缓存硬件正在识别或者它可能是L1但是
Dialogue: 0,1:02:28.90,1:02:34.28,English,,0,0,0,,Some logic in the cache system is recognizing the stride one reference pattern
Dialogue: 0,1:02:28.90,1:02:34.28,Chinese,,0,0,0,,缓存系统中的一些逻辑正在识别步幅一个参考模式
Dialogue: 0,1:02:35.44,1:02:37.26,English,,0,0,0,,Right because it sees all the addresses
Dialogue: 0,1:02:35.44,1:02:37.26,Chinese,,0,0,0,,是的，因为它看到了所有的地址
Dialogue: 0,1:02:37.96,1:02:40.84,English,,0,0,0,,It's recognizing that stride one pattern
Dialogue: 0,1:02:37.96,1:02:40.84,Chinese,,0,0,0,,它认识到跨越一种模式
Dialogue: 0,1:02:41.58,1:02:46.36,English,,0,0,0,,And then it's aggressively prefetching from L3 into L2
Dialogue: 0,1:02:41.58,1:02:46.36,Chinese,,0,0,0,,然后它积极地从L3预取到L2
Dialogue: 0,1:02:46.90,1:02:51.04,English,,0,0,0,,So that those so it's fetching ahead of time it's anticipating
Dialogue: 0,1:02:46.90,1:02:51.04,Chinese,,0,0,0,,所以那些提前取出的东西正在预料中
Dialogue: 0,1:02:51.04,1:02:54.52,English,,0,0,0,,It's saying look I've gotten five stride one references in a row
Dialogue: 0,1:02:51.04,1:02:54.52,Chinese,,0,0,0,,它说我已经连续五次获得了一个参考文献
Dialogue: 0,1:02:55.14,1:02:58.10,English,,0,0,0,,I'm going to go grab a whole bunch of blocks and load them all up
Dialogue: 0,1:02:55.14,1:02:58.10,Chinese,,0,0,0,,我要去抓一大堆积然后加载它们
Dialogue: 0,1:02:58.10,1:03:02.66,English,,0,0,0,,Because by the principle of spatial locality those blocks
Dialogue: 0,1:02:58.10,1:03:02.66,Chinese,,0,0,0,,因为根据空间局部性原则那些块
Dialogue: 0,1:03:03.32,1:03:05.84,English,,0,0,0,,Those blocks are going to be referenced in the near future
Dialogue: 0,1:03:03.32,1:03:05.84,Chinese,,0,0,0,,这些块将在不久的将来被引用
Dialogue: 0,1:03:07.10,1:03:09.94,English,,0,0,0,,So this was really neat and this only happened within the last couple years
Dialogue: 0,1:03:07.10,1:03:09.94,Chinese,,0,0,0,,所以这真的很整洁，这只发生在过去的几年里
Dialogue: 0,1:03:09.94,1:03:12.58,English,,0,0,0,,So the intel engineers are always hard at work
Dialogue: 0,1:03:09.94,1:03:12.58,Chinese,,0,0,0,,因此，英特尔工程师总是努力工作
Dialogue: 0,1:03:13.14,1:03:20.70,English,,0,0,0,,And maybe by the time the time we do the next the next edition of the memory mountain
Dialogue: 0,1:03:13.14,1:03:20.70,Chinese,,0,0,0,,也许到我们下一期的记忆山的时候
Dialogue: 0,1:03:22.12,1:03:26.78,English,,0,0,0,,Those systems will recognize stride 2 and you know other stride pattarns two
Dialogue: 0,1:03:22.12,1:03:26.78,Chinese,,0,0,0,,那些系统将识别步幅2，你知道其他步幅2
Dialogue: 0,1:03:27.72,1:03:31.04,English,,0,0,0,,But from this data it appears that it's only recognizing stride one
Dialogue: 0,1:03:27.72,1:03:31.04,Chinese,,0,0,0,,但从这些数据来看，它似乎只是认识到了一步
Dialogue: 0,1:03:36.16,1:03:44.42,English,,0,0,0,,Ok so you can real...you we can improve the spatial and temporal locality of our programs
Dialogue: 0,1:03:36.16,1:03:44.42,Chinese,,0,0,0,,好的，你可以真实......你我们可以改善我们程序的空间和时间局部性
Dialogue: 0,1:03:45.84,1:03:51.52,English,,0,0,0,,In several different ways that one way to improve the spatial locality is to rearrange loops
Dialogue: 0,1:03:45.84,1:03:51.52,Chinese,,0,0,0,,以几种不同的方式，改善空间局部性的一种方法是重新排列循环
Dialogue: 0,1:03:52.64,1:03:55.08,English,,0,0,0,,And I'll use matrix multiplication as an example
Dialogue: 0,1:03:52.64,1:03:55.08,Chinese,,0,0,0,,我将使用矩阵乘法作为例子
Dialogue: 0,1:03:56.48,1:04:03.58,English,,0,0,0,,So here's a sort of a simple matrix multiplication in code
Dialogue: 0,1:03:56.48,1:04:03.58,Chinese,,0,0,0,,所以这是代码中的一种简单矩阵乘法
Dialogue: 0,1:04:03.58,1:04:08.14,English,,0,0,0,,Where we're multiplying a times b and adding it
Dialogue: 0,1:04:03.58,1:04:08.14,Chinese,,0,0,0,,在哪里我们乘以次数b并加上它
Dialogue: 0,1:04:08.58,1:04:13.82,English,,0,0,0,,We're taking what's in of the c[i][j]
Dialogue: 0,1:04:08.58,1:04:13.82,Chinese,,0,0,0,,我们正在考虑c [i] [j]中的内容
Dialogue: 0,1:04:15.18,1:04:24.72,English,,0,0,0,,And then to that we're adding the sum the inner product of row i of a and the row j column j of b
Dialogue: 0,1:04:15.18,1:04:24.72,Chinese,,0,0,0,,然后我们将a的第i行和b的第j行j的内积相加
Dialogue: 0,1:04:26.06,1:04:30.28,English,,0,0,0,,Okay and then so we're going through and for each i,j in this matrix c
Dialogue: 0,1:04:26.06,1:04:30.28,Chinese,,0,0,0,,好的，那么我们将通过这个矩阵c中的每个i，j
Dialogue: 0,1:04:30.30,1:04:35.96,English,,0,0,0,,We're computing an inner product and then creating that sum
Dialogue: 0,1:04:30.30,1:04:35.96,Chinese,,0,0,0,,我们正在计算内部产品，然后创造这个总和
Dialogue: 0,1:04:38.20,1:04:42.64,English,,0,0,0,,So we can actually turns out there's a lot of different ways to do matrix multiply
Dialogue: 0,1:04:38.20,1:04:42.64,Chinese,,0,0,0,,所以我们实际上可以证明有很多不同的方法来进行矩阵乘法运算
Dialogue: 0,1:04:43.76,1:04:46.08,English,,0,0,0,,And this is we can permute these these loops
Dialogue: 0,1:04:43.76,1:04:46.08,Chinese,,0,0,0,,这是我们可以置换这些循环
Dialogue: 0,1:04:47.36,1:04:50.50,English,,0,0,0,,In any of six different possible permutations
Dialogue: 0,1:04:47.36,1:04:50.50,Chinese,,0,0,0,,在六种不同的可能排列中的任何一种
Dialogue: 0,1:04:51.44,1:04:56.10,English,,0,0,0,,So this is a permutation where it's i followed by j followed by k
Dialogue: 0,1:04:51.44,1:04:56.10,Chinese,,0,0,0,,所以这是一个排列，其中我跟着j后跟k
Dialogue: 0,1:04:56.10,1:05:00.48,English,,0,0,0,,But five other possibilities are feasible
Dialogue: 0,1:04:56.10,1:05:00.48,Chinese,,0,0,0,,但其他五种可能性是可行的
Dialogue: 0,1:05:01.94,1:05:05.56,English,,0,0,0,,And so we can actually analyze those those different permutations
Dialogue: 0,1:05:01.94,1:05:05.56,Chinese,,0,0,0,,所以我们实际上可以分析那些不同的排列
Dialogue: 0,1:05:05.90,1:05:08.24,English,,0,0,0,,And predict which one will have the best performance
Dialogue: 0,1:05:05.90,1:05:08.24,Chinese,,0,0,0,,并预测哪一个会有最佳表现
Dialogue: 0,1:05:10.24,1:05:12.02,English,,0,0,0,,Okay so what we'll do is we'll look at the inner loop
Dialogue: 0,1:05:10.24,1:05:12.02,Chinese,,0,0,0,,好的，我们要做的就是看看内循环
Dialogue: 0,1:05:15.56,1:05:18.02,English,,0,0,0,,And we'll look at the access pattern of the inner loops
Dialogue: 0,1:05:15.56,1:05:18.02,Chinese,,0,0,0,,我们将看看内循环的访问模式
Dialogue: 0,1:05:18.02,1:05:22.34,English,,0,0,0,,And it's in the access pattern on arrays c,a and b
Dialogue: 0,1:05:18.02,1:05:22.34,Chinese,,0,0,0,,它位于数组c，a和b的访问模式中
Dialogue: 0,1:05:25.22,1:05:30.94,English,,0,0,0,,Okay so let's look at the i,j,k implementation that I just showed you
Dialogue: 0,1:05:25.22,1:05:30.94,Chinese,,0,0,0,,好的，让我们来看看我刚给你看的i，j，k实现
Dialogue: 0,1:05:31.76,1:05:33.60,English,,0,0,0,,So as always we focus on the inner loop
Dialogue: 0,1:05:31.76,1:05:33.60,Chinese,,0,0,0,,因此，我们始终专注于内循环
Dialogue: 0,1:05:35.38,1:05:41.54,English,,0,0,0,,And if you notice this inner loop is doing a row wise access of column a
Dialogue: 0,1:05:35.38,1:05:41.54,Chinese,,0,0,0,,如果你注意到这个内部循环正在对列a进行行方式访问
Dialogue: 0,1:05:42.98,1:05:47.18,English,,0,0,0,,And a column wise access,I'm sorry, a row wise access of array a
Dialogue: 0,1:05:42.98,1:05:47.18,Chinese,,0,0,0,,并且列明智的访问，对不起，一行明智访问数组a
Dialogue: 0,1:05:47.82,1:05:51.00,English,,0,0,0,,And column wise access of row b
Dialogue: 0,1:05:47.82,1:05:51.00,Chinese,,0,0,0,,并且列b明智地访问
Dialogue: 0,1:05:52.24,1:05:56.62,English,,0,0,0,,So row wise of a,column wise of b,we don't really care about c
Dialogue: 0,1:05:52.24,1:05:56.62,Chinese,,0,0,0,,顺便说一下b的列，我们并不关心c
Dialogue: 0,1:05:56.62,1:05:59.82,English,,0,0,0,,Because it's not in the inner loop okay so just ignore that
Dialogue: 0,1:05:56.62,1:05:59.82,Chinese,,0,0,0,,因为它不在内循环中，所以只需忽略它
Dialogue: 0,1:06:01.88,1:06:08.26,English,,0,0,0,,So given our assumption that we can hold in this case we're assuming that
Dialogue: 0,1:06:01.88,1:06:08.26,Chinese,,0,0,0,,因此，假设我们可以在这种情况下坚持我们假设
Dialogue: 0,1:06:08.26,1:06:13.80,English,,0,0,0,,We can hold for of these integer elements in a in one block
Dialogue: 0,1:06:08.26,1:06:13.80,Chinese,,0,0,0,,我们可以在一个块中保存这些整数元素
Dialogue: 0,1:06:15.52,1:06:20.22,English,,0,0,0,,So the row wise access which has good spatial locality will miss one every four accesses
Dialogue: 0,1:06:15.52,1:06:20.22,Chinese,,0,0,0,,因此，具有良好空间局部性的行式访问将错过每四次访问一次
Dialogue: 0,1:06:21.14,1:06:24.68,English,,0,0,0,,Okay the very first reference will miss and then the next three will hit
Dialogue: 0,1:06:21.14,1:06:24.68,Chinese,,0,0,0,,好的，第一个参考将错过，然后接下来的三个将被击中
Dialogue: 0,1:06:25.58,1:06:27.76,English,,0,0,0,,And then the next reference after that will hit a new block
Dialogue: 0,1:06:25.58,1:06:27.76,Chinese,,0,0,0,,然后在那之后的下一个参考将达到一个新的块
Dialogue: 0,1:06:28.62,1:06:33.24,English,,0,0,0,,Okay so one out of four references to a will miss
Dialogue: 0,1:06:28.62,1:06:33.24,Chinese,,0,0,0,,好的，所以四分之一的引用会遗漏
Dialogue: 0,1:06:33.94,1:06:41.22,English,,0,0,0,,But because the access pattern for b is column wise every reference to b will miss
Dialogue: 0,1:06:33.94,1:06:41.22,Chinese,,0,0,0,,但由于b的访问模式是列式的，因此每次对b的引用都会丢失
Dialogue: 0,1:06:42.46,1:06:45.84,English,,0,0,0,,Okay so the average number of misses per loop iteration is 1.25
Dialogue: 0,1:06:42.46,1:06:45.84,Chinese,,0,0,0,,好吧，每次循环迭代的平均未命中数是1.25
Dialogue: 0,1:06:47.30,1:06:50.92,English,,0,0,0,,Okay the j,i,k version is exactly the same pattern
Dialogue: 0,1:06:47.30,1:06:50.92,Chinese,,0,0,0,,好吧，j，i，k版本是完全相同的模式
Dialogue: 0,1:06:55.08,1:06:57.78,English,,0,0,0,,K,i,j is a little different here
Dialogue: 0,1:06:55.08,1:06:57.78,Chinese,,0,0,0,,K，i，j在这里有点不同
Dialogue: 0,1:06:59.22,1:07:01.34,English,,0,0,0,,We're doing row wise access of b
Dialogue: 0,1:06:59.22,1:07:01.34,Chinese,,0,0,0,,我们正在对b进行逐行访问
Dialogue: 0,1:07:03.12,1:07:05.64,English,,0,0,0,,And a row wise access of c, so that's good right
Dialogue: 0,1:07:03.12,1:07:05.64,Chinese,,0,0,0,,并且明智地访问c，这样才对
Dialogue: 0,1:07:06.00,1:07:09.30,English,,0,0,0,,So now we've got stride one accesses on both b and c
Dialogue: 0,1:07:06.00,1:07:09.30,Chinese,,0,0,0,,所以现在我们在b和c上都进行了一次访问
Dialogue: 0,1:07:10.16,1:07:13.58,English,,0,0,0,,And the reference to a is outside of the loop,so we don't care about it
Dialogue: 0,1:07:10.16,1:07:13.58,Chinese,,0,0,0,,对a的引用是在循环之外，所以我们不关心它
Dialogue: 0,1:07:14.84,1:07:18.96,English,,0,0,0,,So so both b and c will miss one quarter of the time
Dialogue: 0,1:07:14.84,1:07:18.96,Chinese,,0,0,0,,所以b和c都会错过四分之一的时间
Dialogue: 0,1:07:20.40,1:07:24.34,English,,0,0,0,,Okay so the total average number of misses per loop iteration will be 0.5
Dialogue: 0,1:07:20.40,1:07:24.34,Chinese,,0,0,0,,好吧，每次循环迭代的总平均未命中数将为0.5
Dialogue: 0,1:07:25.40,1:07:29.70,English,,0,0,0,,That's pretty good and i,k,j has the same similar behavior
Dialogue: 0,1:07:25.40,1:07:29.70,Chinese,,0,0,0,,这是非常好的，我，k，j具有相同的相似行为
Dialogue: 0,1:07:30.90,1:07:33.28,English,,0,0,0,,Now j,k,i is sort of the exact opposite
Dialogue: 0,1:07:30.90,1:07:33.28,Chinese,,0,0,0,,现在j，k，我恰恰相反
Dialogue: 0,1:07:33.28,1:07:37.74,English,,0,0,0,,j,k,i does column wise access of a
Dialogue: 0,1:07:33.28,1:07:37.74,Chinese,,0,0,0,,j，k，我按列进行a
Dialogue: 0,1:07:38.48,1:07:42.20,English,,0,0,0,,And column-wise access of c so right we know that's a stinker right
Dialogue: 0,1:07:38.48,1:07:42.20,Chinese,,0,0,0,,对于c的列式访问权限我们知道这是一个很难找到的东西
Dialogue: 0,1:07:42.96,1:07:51.62,English,,0,0,0,,And we qualitative well you know it's bad and we can compute that it will miss a one time per loop iteration
Dialogue: 0,1:07:42.96,1:07:51.62,Chinese,,0,0,0,,而且我们定性很好，你知道它很糟糕，我们可以计算出它会错过每循环迭代一次
Dialogue: 0,1:07:52.46,1:07:55.36,English,,0,0,0,,So that will be two total of two misses per iteration
Dialogue: 0,1:07:52.46,1:07:55.36,Chinese,,0,0,0,,这样每次迭代总共会有两次失误
Dialogue: 0,1:07:55.54,1:07:57.90,English,,0,0,0,,And k,j,i has the same bad pattern
Dialogue: 0,1:07:55.54,1:07:57.90,Chinese,,0,0,0,,和k，j，我有相同的坏模式
Dialogue: 0,1:07:58.86,1:08:01.02,English,,0,0,0,,Okay so if we look at all these permutations
Dialogue: 0,1:07:58.86,1:08:01.02,Chinese,,0,0,0,,好的，如果我们看看所有这些排列
Dialogue: 0,1:08:02.42,1:08:08.68,English,,0,0,0,,You can see that i,j,k and j,i,k miss 1.25 have 1.25 misses
Dialogue: 0,1:08:02.42,1:08:08.68,Chinese,,0,0,0,,你可以看到i，j，k和j，i，k小姐1.25有1.25次未命中
Dialogue: 0,1:08:09.72,1:08:13.86,English,,0,0,0,,k,i,j has 0.5 misses and j,k,i has 2 misses
Dialogue: 0,1:08:09.72,1:08:13.86,Chinese,,0,0,0,,k，i，j有0.5个未命中，j，k，我有2个未命中
Dialogue: 0,1:08:15.06,1:08:20.92,English,,0,0,0,,So clearly it looks like k,i,j and its brethren are the best option
Dialogue: 0,1:08:15.06,1:08:20.92,Chinese,,0,0,0,,很明显，看起来k，i，j及其兄弟是最好的选择
Dialogue: 0,1:08:20.92,1:08:25.56,English,,0,0,0,,The only difference is that k,i,j has this additional store
Dialogue: 0,1:08:20.92,1:08:25.56,Chinese,,0,0,0,,唯一的区别是k，i，j有这个额外的商店
Dialogue: 0,1:08:25.56,1:08:29.54,English,,0,0,0,,So there might be a question that is that going to create is that going to slow things down
Dialogue: 0,1:08:25.56,1:08:29.54,Chinese,,0,0,0,,因此，可能存在一个问题，即创造的是减慢速度
Dialogue: 0,1:08:30.74,1:08:37.20,English,,0,0,0,,Well it turns out in systems in any kind storage systems rights
Dialogue: 0,1:08:30.74,1:08:37.20,Chinese,,0,0,0,,在任何类型的存储系统权利系统中都证明了这一点
Dialogue: 0,1:08:37.74,1:08:39.46,English,,0,0,0,,Are much easier to deal with them reads
Dialogue: 0,1:08:37.74,1:08:39.46,Chinese,,0,0,0,,处理它们更容易阅读
Dialogue: 0,1:08:40.94,1:08:42.90,English,,0,0,0,,Can you think about why that might be true
Dialogue: 0,1:08:40.94,1:08:42.90,Chinese,,0,0,0,,你能想一想为什么会这样吗？
Dialogue: 0,1:08:44.28,1:08:47.32,English,,0,0,0,,So writes you have a lot more flexibility than you do with reads
Dialogue: 0,1:08:44.28,1:08:47.32,Chinese,,0,0,0,,所以写道你比读取更灵活
Dialogue: 0,1:08:53.06,1:08:57.26,English,,0,0,0,,I mean yes
Dialogue: 0,1:08:53.06,1:08:57.26,Chinese,,0,0,0,,我是说是的
Dialogue: 0,1:08:57.28,1:09:02.78,English,,0,0,0,,That's exactly so you can you have options you can do you can write back defer you can defer writing
Dialogue: 0,1:08:57.28,1:09:02.78,Chinese,,0,0,0,,这就是你可以做的选择，你可以写回来推迟你可以推迟写作
Dialogue: 0,1:09:03.60,1:09:07.04,English,,0,0,0,,Until the value that you're written is actually used
Dialogue: 0,1:09:03.60,1:09:07.04,Chinese,,0,0,0,,直到你实际使用的值
Dialogue: 0,1:09:07.38,1:09:09.04,English,,0,0,0,,But when you read an item you're stuck
Dialogue: 0,1:09:07.38,1:09:09.04,Chinese,,0,0,0,,但是当你读到一件物品时，你就会陷入困境
Dialogue: 0,1:09:10.02,1:09:12.64,English,,0,0,0,,You can't do anything until you get that data
Dialogue: 0,1:09:10.02,1:09:12.64,Chinese,,0,0,0,,在获得该数据之前，你无法做任何事情
Dialogue: 0,1:09:13.08,1:09:17.30,English,,0,0,0,,So it turns out that rights don't really that this additional store doesn't really hurt us
Dialogue: 0,1:09:13.08,1:09:17.30,Chinese,,0,0,0,,所以事实证明，权利并不是真的这个额外的商店并没有真正伤害我们
Dialogue: 0,1:09:18.54,1:09:22.22,English,,0,0,0,,And so when we measure these on a modern system
Dialogue: 0,1:09:18.54,1:09:22.22,Chinese,,0,0,0,,因此，当我们在现代系统上测量这些时
Dialogue: 0,1:09:22.66,1:09:29.34,English,,0,0,0,,You can see that that the k,i,j which has the the fewest number of misses
Dialogue: 0,1:09:22.66,1:09:29.34,Chinese,,0,0,0,,你可以看到k，i，j具有最少的未命中数
Dialogue: 0,1:09:29.82,1:09:36.32,English,,0,0,0,,Has you see we're getting like one miss what we're plotting here is cycles per inter loop iteration
Dialogue: 0,1:09:29.82,1:09:36.32,Chinese,,0,0,0,,你有没有看到我们正在想象我们在这里绘制的是每个循环迭代的周期
Dialogue: 0,1:09:36.32,1:09:40.50,English,,0,0,0,,So each iteration is taking about one cycle which is really good
Dialogue: 0,1:09:36.32,1:09:40.50,Chinese,,0,0,0,,所以每次迭代都需要大约一个周期，这非常好
Dialogue: 0,1:09:41.54,1:09:46.30,English,,0,0,0,,This i,j,k pattern which is kind of the intermediate 1.2 misses
Dialogue: 0,1:09:41.54,1:09:46.30,Chinese,,0,0,0,,这种i，j，k模式是中间体1.2的一种未命中
Dialogue: 0,1:09:47.00,1:09:51.98,English,,0,0,0,,That's sort of in between and the j,k,i which has two misses per iteration is the worst
Dialogue: 0,1:09:47.00,1:09:51.98,Chinese,,0,0,0,,这种情况介于两者之间，每次迭代有两次未命中的j，k，i是最差的
Dialogue: 0,1:09:52.86,1:09:57.16,English,,0,0,0,,Ok so what's interesting is we could actually just by doing a little bit of analysis
Dialogue: 0,1:09:52.86,1:09:57.16,Chinese,,0,0,0,,好的，有趣的是我们实际上可以通过做一些分析
Dialogue: 0,1:09:57.88,1:10:02.08,English,,0,0,0,,Simple analysis we could actually predict what this graph would look like
Dialogue: 0,1:09:57.88,1:10:02.08,Chinese,,0,0,0,,简单分析我们实际上可以预测这个图形的样子
Dialogue: 0,1:10:03.74,1:10:08.16,English,,0,0,0,,Okay in the last ten minutes of the class
Dialogue: 0,1:10:03.74,1:10:08.16,Chinese,,0,0,0,,好在课程的最后十分钟
Dialogue: 0,1:10:08.46,1:10:11.28,English,,0,0,0,,We're going to look at how to improve temporal locality
Dialogue: 0,1:10:08.46,1:10:11.28,Chinese,,0,0,0,,我们将研究如何改善时间局部性
Dialogue: 0,1:10:12.04,1:10:15.00,English,,0,0,0,,Now so what we did with... when we rearranged our loops
Dialogue: 0,1:10:12.04,1:10:15.00,Chinese,,0,0,0,,现在我们做了什么......当我们重新安排我们的循环时
Dialogue: 0,1:10:15.38,1:10:20.26,English,,0,0,0,,With in the matrix multiplication what we were doing was in improving our spatial locality right
Dialogue: 0,1:10:15.38,1:10:20.26,Chinese,,0,0,0,,在矩阵乘法中，我们正在做的是改善我们的空间局部性
Dialogue: 0,1:10:21.30,1:10:24.96,English,,0,0,0,,But we didn't really do anything to improve the temporal locality
Dialogue: 0,1:10:21.30,1:10:24.96,Chinese,,0,0,0,,但我们并没有真正做任何改善时间局部性的事情
Dialogue: 0,1:10:25.58,1:10:28.58,English,,0,0,0,,To improve temporal locality you have to use a technique called blocking
Dialogue: 0,1:10:25.58,1:10:28.58,Chinese,,0,0,0,,要改善时间局部性，你必须使用称为分块的技术
Dialogue: 0,1:10:29.50,1:10:34.78,English,,0,0,0,,And this is important to understand because you're going to need it in your cache lab for one thing
Dialogue: 0,1:10:29.50,1:10:34.78,Chinese,,0,0,0,,这一点很重要，因为你需要在缓存实验室中完成一件事
Dialogue: 0,1:10:35.18,1:10:37.02,English,,0,0,0,,But it's also a very general technique
Dialogue: 0,1:10:35.18,1:10:37.02,Chinese,,0,0,0,,但它也是一种非常通用的技术
Dialogue: 0,1:10:37.50,1:10:40.82,English,,0,0,0,,Anytime you need,any time you're having issues with temporal locality
Dialogue: 0,1:10:37.50,1:10:40.82,Chinese,,0,0,0,,任何时候你需要，任何时候你遇到时间局部问题
Dialogue: 0,1:10:42.08,1:10:42.82,English,,0,0,0,,Okay so
Dialogue: 0,1:10:42.08,1:10:42.82,Chinese,,0,0,0,,可以，然后呢
Dialogue: 0,1:10:46.02,1:10:51.00,English,,0,0,0,,We're not going to go into too much detail this code but what I did I rewrote the matrix multiply
Dialogue: 0,1:10:46.02,1:10:51.00,Chinese,,0,0,0,,我们不打算详细介绍这段代码，但是我做了什么我重写了矩阵乘法
Dialogue: 0,1:10:53.06,1:10:58.18,English,,0,0,0,,So that it operates you know a two-dimensional matrix that you can really just think of it as a contiguous array of bytes
Dialogue: 0,1:10:53.06,1:10:58.18,Chinese,,0,0,0,,因此，它运行时你知道一个二维矩阵，你真的可以把它想象成一个连续的字节数组
Dialogue: 0,1:10:58.68,1:11:03.02,English,,0,0,0,,So I just rewrote this code to operate on a contiguous array one-dimensional array
Dialogue: 0,1:10:58.68,1:11:03.02,Chinese,,0,0,0,,所以我只是重写了这段代码来操作一个连续的数组一维数组
Dialogue: 0,1:11:03.60,1:11:06.04,English,,0,0,0,,And then I'm doing the indexing explicitly here
Dialogue: 0,1:11:03.60,1:11:06.04,Chinese,,0,0,0,,然后我在这里明确地做索引
Dialogue: 0,1:11:06.30,1:11:11.22,English,,0,0,0,,So here at c[i*n+j] this is n matrix
Dialogue: 0,1:11:06.30,1:11:11.22,Chinese,,0,0,0,,所以这里在c [i * n + j]这是n矩阵
Dialogue: 0,1:11:11.22,1:11:16.30,English,,0,0,0,,So what I'm doing is...I'm accessing the I'm computing where the I throw starts
Dialogue: 0,1:11:11.22,1:11:16.30,Chinese,,0,0,0,,所以我正在做的是......我正在访问我正在计算我开始的地方
Dialogue: 0,1:11:16.92,1:11:21.66,English,,0,0,0,,And then I'm going to the j column of that row and then accessing that element
Dialogue: 0,1:11:16.92,1:11:21.66,Chinese,,0,0,0,,然后我将转到该行的j列，然后访问该元素
Dialogue: 0,1:11:27.50,1:11:30.08,English,,0,0,0,,All right so let's...but it's the same idea as before
Dialogue: 0,1:11:27.50,1:11:30.08,Chinese,,0,0,0,,好吧，让我们......但它和以前一样
Dialogue: 0,1:11:31.04,1:11:38.16,English,,0,0,0,,So let's look at the miss rate for this, this is just an original this is an original unblocked matrix multiplied
Dialogue: 0,1:11:31.04,1:11:38.16,Chinese,,0,0,0,,因此，让我们看一下这个未命中率，这只是一个原始的，这是一个原始的无分块矩阵相乘
Dialogue: 0,1:11:39.34,1:11:44.78,English,,0,0,0,,So what we're doing is we're computing c[0][0]
Dialogue: 0,1:11:39.34,1:11:44.78,Chinese,,0,0,0,,所以我们正在做的是我们计算c [0] [0]
Dialogue: 0,1:11:45.46,1:11:50.24,English,,0,0,0,,And we're doing that by taking an inner product of row 0 and column 0
Dialogue: 0,1:11:45.46,1:11:50.24,Chinese,,0,0,0,,我们通过采用第0行和第0列的内积来做到这一点
Dialogue: 0,1:11:53.80,1:11:59.80,English,,0,0,0,,So if you look at the we're assuming that the cache blocks holds eight doubles
Dialogue: 0,1:11:53.80,1:11:59.80,Chinese,,0,0,0,,所以如果你看一下我们假设缓存块有8个双打
Dialogue: 0,1:12:00.06,1:12:04.64,English,,0,0,0,,And that the matrix elements are doubles then we're going to miss one eight of the time
Dialogue: 0,1:12:00.06,1:12:04.64,Chinese,,0,0,0,,并且矩阵元素是双倍的，那么我们将错过八个时间
Dialogue: 0,1:12:05.96,1:12:08.06,English,,0,0,0,,Okay so in the first iteration
Dialogue: 0,1:12:05.96,1:12:08.06,Chinese,,0,0,0,,好的，在第一次迭代中
Dialogue: 0,1:12:11.42,1:12:16.22,English,,0,0,0,,We're going to miss the first iteration does n of these things
Dialogue: 0,1:12:11.42,1:12:16.22,Chinese,,0,0,0,,我们将错过这些事情的第一次迭代
Dialogue: 0,1:12:16.66,1:12:19.34,English,,0,0,0,,And since we're missing n over eight of the time
Dialogue: 0,1:12:16.66,1:12:19.34,Chinese,,0,0,0,,因为我们在八分之一的时间里都缺席了
Dialogue: 0,1:12:19.72,1:12:25.12,English,,0,0,0,,We're missing one block for every eight references
Dialogue: 0,1:12:19.72,1:12:25.12,Chinese,,0,0,0,,我们每八个引用丢失一个块
Dialogue: 0,1:12:28.30,1:12:32.48,English,,0,0,0,,For each for the first iteration we're going to miss n over eight
Dialogue: 0,1:12:28.30,1:12:32.48,Chinese,,0,0,0,,对于第一次迭代的每一次，我们将错过n超过八
Dialogue: 0,1:12:34.22,1:12:37.44,English,,0,0,0,,And since there's n for each element for each block I'm sorry
Dialogue: 0,1:12:34.22,1:12:37.44,Chinese,,0,0,0,,因为每个块的每个元素都有n，对不起
Dialogue: 0,1:12:37.90,1:12:45.56,English,,0,0,0,,And then oh so this is the number of blocks and the number of misses and then we have n elements
Dialogue: 0,1:12:37.90,1:12:45.56,Chinese,,0,0,0,,哦，所以这是块数和未命中数，然后我们有n个元素
Dialogue: 0,1:12:45.98,1:12:52.46,English,,0,0,0,,So that the total number of misses is 9n/8 misses for the first iteration
Dialogue: 0,1:12:45.98,1:12:52.46,Chinese,,0,0,0,,因此，第一次迭代的未命中总数为9n / 8次未命中
Dialogue: 0,1:12:54.24,1:12:58.56,English,,0,0,0,,Okay the second iteration will have the same number of misses
Dialogue: 0,1:12:54.24,1:12:58.56,Chinese,,0,0,0,,好的，第二次迭代将有相同数量的未命中
Dialogue: 0,1:12:58.56,1:13:01.92,English,,0,0,0,,Because of our assumptions about the the size of this array
Dialogue: 0,1:12:58.56,1:13:01.92,Chinese,,0,0,0,,因为我们对这个数组大小的假设
Dialogue: 0,1:13:02.36,1:13:06.00,English,,0,0,0,,So this these rows are way too big to fit in the cache
Dialogue: 0,1:13:02.36,1:13:06.00,Chinese,,0,0,0,,所以这些行太大了，不适合缓存
Dialogue: 0,1:13:06.20,1:13:09.46,English,,0,0,0,,So we never get any we don't get any temporal locality
Dialogue: 0,1:13:06.20,1:13:09.46,Chinese,,0,0,0,,所以我们永远不会得到任何我们没有得到任何时间局部性
Dialogue: 0,1:13:11.24,1:13:18.30,English,,0,0,0,,Okay so the total number of misses is 9n/8 times the number of elements that we're updating which is n squared
Dialogue: 0,1:13:11.24,1:13:18.30,Chinese,,0,0,0,,好的，总失误次数是我们正在更新的元素数量的9n / 8倍，即n平方
Dialogue: 0,1:13:18.94,1:13:23.20,English,,0,0,0,,Okay so our total misses is 9n/8*n^3
Dialogue: 0,1:13:18.94,1:13:23.20,Chinese,,0,0,0,,好的，所以我们的总失误是9n / 8 * n ^ 3
Dialogue: 0,1:13:25.62,1:13:28.38,English,,0,0,0,,Now let's rewrite the code to use blocking and so
Dialogue: 0,1:13:25.62,1:13:28.38,Chinese,,0,0,0,,现在让我们重写代码以使用分块等等
Dialogue: 0,1:13:30.44,1:13:31.94,English,,0,0,0,,You can look at this code later
Dialogue: 0,1:13:30.44,1:13:31.94,Chinese,,0,0,0,,你可以稍后查看此代码
Dialogue: 0,1:13:32.40,1:13:36.78,English,,0,0,0,,But it's much simpler just to look at it pictorially
Dialogue: 0,1:13:32.40,1:13:36.78,Chinese,,0,0,0,,但是以图形方式看待它会简单得多
Dialogue: 0,1:13:36.80,1:13:42.06,English,,0,0,0,,So what we're doing instead of updating one element at a time
Dialogue: 0,1:13:36.80,1:13:42.06,Chinese,,0,0,0,,所以我们正在做的不是一次更新一个元素
Dialogue: 0,1:13:43.30,1:13:46.82,English,,0,0,0,,We're updating a sub block a b by b sub block
Dialogue: 0,1:13:43.30,1:13:46.82,Chinese,,0,0,0,,我们正在通过b子块更新子块a b
Dialogue: 0,1:13:48.96,1:13:55.38,English,,0,0,0,,And we're doing that just totally analogously to when an original case where b=1
Dialogue: 0,1:13:48.96,1:13:55.38,Chinese,,0,0,0,,我们这样做完全类似于原始情况，其中b = 1
Dialogue: 0,1:13:56.54,1:14:04.10,English,,0,0,0,,This b by b sub block and c is computed by taking an inner product of the sub blocks
Dialogue: 0,1:13:56.54,1:14:04.10,Chinese,,0,0,0,,这个b乘b子块和c是通过取子块的内积来计算的
Dialogue: 0,1:14:05.66,1:14:11.66,English,,0,0,0,,Of a set of sub blocks in an a with a set of sub blocks in b
Dialogue: 0,1:14:05.66,1:14:11.66,Chinese,,0,0,0,,a中的一组子块中的一组子块中的b
Dialogue: 0,1:14:12.32,1:14:15.48,English,,0,0,0,,And for each one of those we're doing a little mini matrix multiplication
Dialogue: 0,1:14:12.32,1:14:15.48,Chinese,,0,0,0,,对于每一个我们正在做一点迷你矩阵乘法
Dialogue: 0,1:14:15.48,1:14:21.42,English,,0,0,0,,So we're taking this sub block times this sub block
Dialogue: 0,1:14:15.48,1:14:21.42,Chinese,,0,0,0,,所以我们将这个子块占用了这个子块
Dialogue: 0,1:14:22.62,1:14:29.26,English,,0,0,0,,Plus the second sub block of a times the second sub block of of b
Dialogue: 0,1:14:22.62,1:14:29.26,Chinese,,0,0,0,,加上b的第二个子块的第二个子块
Dialogue: 0,1:14:30.06,1:14:34.22,English,,0,0,0,,Plus the third sub block of a times the third sub block of b and so on
Dialogue: 0,1:14:30.06,1:14:34.22,Chinese,,0,0,0,,加上第三个子块，一次是b的第三个子块，依此类推
Dialogue: 0,1:14:34.88,1:14:37.38,English,,0,0,0,,Okay so we're doing the same inner product  operation
Dialogue: 0,1:14:34.88,1:14:37.38,Chinese,,0,0,0,,好的，我们正在做同样的内部产品操作
Dialogue: 0,1:14:37.38,1:14:42.50,English,,0,0,0,,But instead of scalars we're doing it with these little sub these little tiny matrices
Dialogue: 0,1:14:37.38,1:14:42.50,Chinese,,0,0,0,,但是我们用这些小小的矩阵来代替标量，而不是标量
Dialogue: 0,1:14:45.82,1:14:50.76,English,,0,0,0,,Ok all right so let's look at,let's look at what happens to the miss rate when we do this
Dialogue: 0,1:14:45.82,1:14:50.76,Chinese,,0,0,0,,好的，所以让我们来看看，让我们来看看当我们这样做时未命中率会发生什么
Dialogue: 0,1:14:53.80,1:15:03.38,English,,0,0,0,,So there's there's n over b blocks in any row or column
Dialogue: 0,1:14:53.80,1:15:03.38,Chinese,,0,0,0,,所以在任何行或列中都有n个b块
Dialogue: 0,1:15:05.08,1:15:11.26,English,,0,0,0,,And since there's b squared items in each block b*b
Dialogue: 0,1:15:05.08,1:15:11.26,Chinese,,0,0,0,,并且因为每个块b * b中有b个平方项
Dialogue: 0,1:15:11.76,1:15:14.30,English,,0,0,0,,There's B^2/8 misses for each block
Dialogue: 0,1:15:11.76,1:15:14.30,Chinese,,0,0,0,,每个区块都有B ^ 2/8未命中
Dialogue: 0,1:15:19.66,1:15:25.60,English,,0,0,0,,Okay and so then and then since there's there's n over b blocks in each matrix and there's two matrices
Dialogue: 0,1:15:19.66,1:15:25.60,Chinese,,0,0,0,,好的等等然后因为每个矩阵中有超过b个块，并且有两个矩阵
Dialogue: 0,1:15:26.30,1:15:34.82,English,,0,0,0,,There's 2n/B*B^2/8 misses for this first iteration
Dialogue: 0,1:15:26.30,1:15:34.82,Chinese,,0,0,0,,第一次迭代有2n / B * B ^ 2/8未命中
Dialogue: 0,1:15:34.82,1:15:38.66,English,,0,0,0,,So that works out to be an nB/4 and
Dialogue: 0,1:15:34.82,1:15:38.66,Chinese,,0,0,0,,所以这可能是一个nB / 4和
Dialogue: 0,1:15:41.50,1:15:46.30,English,,0,0,0,,And the second iteration has the same miss rate
Dialogue: 0,1:15:41.50,1:15:46.30,Chinese,,0,0,0,,并且第二次迭代具有相同的未命中率
Dialogue: 0,1:15:47.08,1:15:54.20,English,,0,0,0,,So the total number of misses is the number of misses for each iteration
Dialogue: 0,1:15:47.08,1:15:54.20,Chinese,,0,0,0,,因此，未命中的总数是每次迭代的未命中数
Dialogue: 0,1:15:55.44,1:16:01.22,English,,0,0,0,,Times the number of elements in C that we're updating
Dialogue: 0,1:15:55.44,1:16:01.22,Chinese,,0,0,0,,计算我们正在更新的C中元素的数量
Dialogue: 0,1:16:01.56,1:16:04.06,English,,0,0,0,,Okay which is (n/B)^2
Dialogue: 0,1:16:01.56,1:16:04.06,Chinese,,0,0,0,,好的，是（n / B）^ 2
Dialogue: 0,1:16:05.80,1:16:10.20,English,,0,0,0,,So that all works out too it's still in n^3*(1/4B)
Dialogue: 0,1:16:05.80,1:16:10.20,Chinese,,0,0,0,,这样一切都有效，它仍然在n ^ 3 *（1 / 4B）
Dialogue: 0,1:16:12.86,1:16:19.48,English,,0,0,0,,So in our first case with no blocking although that the number of misses is asymptotically the same
Dialogue: 0,1:16:12.86,1:16:19.48,Chinese,,0,0,0,,所以在我们的第一个没有分块的情况下，虽然未命中的数量是渐近相同的
Dialogue: 0,1:16:20.06,1:16:25.40,English,,0,0,0,,But there's this pretty, this big difference in the constant factor so for no blocking it's 9/8
Dialogue: 0,1:16:20.06,1:16:25.40,Chinese,,0,0,0,,但是有这个漂亮的，恒定因素的这个巨大差异，所以没有分块它是9/8
Dialogue: 0,1:16:26.26,1:16:31.08,English,,0,0,0,,For blocking it's 1/4b we're now we can we can just sort of drive that down
Dialogue: 0,1:16:26.26,1:16:31.08,Chinese,,0,0,0,,对于分块来说它是1 / 4b我们现在我们可以把它驱逐下来
Dialogue: 0,1:16:31.52,1:16:36.38,English,,0,0,0,,By by increasing the block size so this gives us some control
Dialogue: 0,1:16:31.52,1:16:36.38,Chinese,,0,0,0,,通过增加块大小，这给了我们一些控制
Dialogue: 0,1:16:39.02,1:16:44.68,English,,0,0,0,,But we still we have...we can't make the block the blocks too big because we need to fit three blocks
Dialogue: 0,1:16:39.02,1:16:44.68,Chinese,,0,0,0,,但是我们仍然有......我们无法让块块太大，因为我们需要适合三个块
Dialogue: 0,1:16:45.44,1:16:47.46,English,,0,0,0,,In cache at any one point in time
Dialogue: 0,1:16:45.44,1:16:47.46,Chinese,,0,0,0,,在任何一个时间点的缓存中
Dialogue: 0,1:16:50.44,1:16:52.80,English,,0,0,0,,Ok so the reason this is a dramatic difference right
Dialogue: 0,1:16:50.44,1:16:52.80,Chinese,,0,0,0,,好吧，这是一个戏剧性的差异吧
Dialogue: 0,1:16:54.34,1:16:59.80,English,,0,0,0,,And the reason for this is that by doing the blocking we're sort of exploiting
Dialogue: 0,1:16:54.34,1:16:59.80,Chinese,,0,0,0,,其原因在于，通过分块我们就是在利用
Dialogue: 0,1:17:00.54,1:17:04.74,English,,0,0,0,,Once we load a block into memory we're sort of reusing its items over and over again
Dialogue: 0,1:17:00.54,1:17:04.74,Chinese,,0,0,0,,一旦我们将一个块加载到内存中，我们就会一遍又一遍地重复使用它
Dialogue: 0,1:17:04.74,1:17:06.74,English,,0,0,0,,So we're exploiting more temporal locality
Dialogue: 0,1:17:04.74,1:17:06.74,Chinese,,0,0,0,,所以我们正在利用更多的时间局部性
Dialogue: 0,1:17:08.30,1:17:12.68,English,,0,0,0,,And matrix multiplication has this into this implicit locality
Dialogue: 0,1:17:08.30,1:17:12.68,Chinese,,0,0,0,,矩阵乘法将这种情况纳入这个隐含的局部性
Dialogue: 0,1:17:12.68,1:17:18.88,English,,0,0,0,,Because the computation is order n cubed but the size of the data is n squared
Dialogue: 0,1:17:12.68,1:17:18.88,Chinese,,0,0,0,,因为计算是n阶的，但是数据的大小是n的平方
Dialogue: 0,1:17:19.98,1:17:23.36,English,,0,0,0,,Right so we must be reusing some data items
Dialogue: 0,1:17:19.98,1:17:23.36,Chinese,,0,0,0,,是的，所以我们必须重用一些数据项
Dialogue: 0,1:17:24.18,1:17:29.71,English,,0,0,0,,Right the problem with our scalar approach is that we were when we were reusing them they weren't in the cache
Dialogue: 0,1:17:24.18,1:17:29.71,Chinese,,0,0,0,,我们的标量方法的问题是我们在重用它们时它们不在缓存中
Dialogue: 0,1:17:29.71,1:17:32.67,English,,0,0,0,,Ok
Dialogue: 0,1:17:29.71,1:17:32.67,Chinese,,0,0,0,,好
Dialogue: 0,1:17:35.66,1:17:40.00,English,,0,0,0,,All right so the point that I wanted to make with you is that
Dialogue: 0,1:17:35.66,1:17:40.00,Chinese,,0,0,0,,好的，所以我想与你合作的重点是
Dialogue: 0,1:17:40.72,1:17:47.06,English,,0,0,0,,Cache memories although they're sort of built-in automatic hardware storage devices
Dialogue: 0,1:17:40.72,1:17:47.06,Chinese,,0,0,0,,高速缓存存储器虽然它们是一种内置的自动硬件存储设备
Dialogue: 0,1:17:47.72,1:17:49.60,English,,0,0,0,,And you can't really control them
Dialogue: 0,1:17:47.72,1:17:49.60,Chinese,,0,0,0,,你无法控制它们
Dialogue: 0,1:17:50.04,1:17:54.20,English,,0,0,0,,If you know about them you can take advantage of your knowledge
Dialogue: 0,1:17:50.04,1:17:54.20,Chinese,,0,0,0,,如果你了解它们，你可以利用你的知识
Dialogue: 0,1:17:54.68,1:17:58.16,English,,0,0,0,,And exploit them and make your code run faster
Dialogue: 0,1:17:54.68,1:17:58.16,Chinese,,0,0,0,,并利用它们并使你的代码运行得更快
Dialogue: 0,1:17:59.36,1:18:03.14,English,,0,0,0,,Okay and the way you do this is like I said focus on the inner loops
Dialogue: 0,1:17:59.36,1:18:03.14,Chinese,,0,0,0,,好吧，你这样做的方式就像我说的那样专注于内循环
Dialogue: 0,1:18:05.84,1:18:10.00,English,,0,0,0,,Do is try to do try to do accesses that a stride one
Dialogue: 0,1:18:05.84,1:18:10.00,Chinese,,0,0,0,,是尝试尝试做一个跨步的访问
Dialogue: 0,1:18:10.66,1:18:14.02,English,,0,0,0,,And try to maximize to to maximize spatial locality
Dialogue: 0,1:18:10.66,1:18:14.02,Chinese,,0,0,0,,并尝试最大化以最大化空间局部性
Dialogue: 0,1:18:14.40,1:18:18.42,English,,0,0,0,,And try to maximize temporal locality by reusing local variables
Dialogue: 0,1:18:14.40,1:18:18.42,Chinese,,0,0,0,,并尝试通过重用局部变量来最大化时间局部性
Dialogue: 0,1:18:18.50,1:18:20.08,English,,0,0,0,,Which can then be put into registers
Dialogue: 0,1:18:18.50,1:18:20.08,Chinese,,0,0,0,,然后可以将其放入寄存器中
Dialogue: 0,1:18:21.90,1:18:26.46,English,,0,0,0,,Okay so that's it for today good luck with your attack lab if you haven't finished it and
Dialogue: 0,1:18:21.90,1:18:26.46,Chinese,,0,0,0,,好吧，如果你还没有完成它，那么今天你的攻击实验室会好运
Dialogue: 0,1:18:27.18,1:18:32.30,English,,0,0,0,,Don't forget to get started on cache lab this weekend 
Dialogue: 0,1:18:27.18,1:18:32.30,Chinese,,0,0,0,,不要忘记本周末开始使用缓存实验室
