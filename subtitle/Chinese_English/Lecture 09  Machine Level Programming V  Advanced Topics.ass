[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video File: ../../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.015625
Scroll Position: 824
Active Line: 838
Video Position: 141558

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:04.82,English,,0,0,0,,This come this will be the last lecture on machine level programming
Dialogue: 0,0:00:00.00,0:00:04.82,Chinese,,0,0,0,,这将是关于机器级编程的最后一次讲座
Dialogue: 0,0:00:05.42,0:00:09.94,English,,0,0,0,,We call it advanced topics but think of it more as miscellaneous topics
Dialogue: 0,0:00:05.42,0:00:09.94,Chinese,,0,0,0,,我们将其称为高级主题，但将其视为杂项主题
Dialogue: 0,0:00:10.70,0:00:16.00,English,,0,0,0,,And I think most to you of course you know that your bomb lab due tonight
Dialogue: 0,0:00:10.70,0:00:16.00,Chinese,,0,0,0,,我想你当然最了解你的炸弹实验室今晚到期了
Dialogue: 0,0:00:16.00,0:00:20.72,English,,0,0,0,,So you most year probably well into that or hopefully through it
Dialogue: 0,0:00:16.00,0:00:20.72,Chinese,,0,0,0,,所以你大部分时间都可能很好，或希望通过它
Dialogue: 0,0:00:21.08,0:00:26.44,English,,0,0,0,,And then at midnight tonight the next web will come out which is called attack lab
Dialogue: 0,0:00:21.08,0:00:26.44,Chinese,,0,0,0,,然后在今晚的午夜，下一个网络将出现，称为攻击实验室
Dialogue: 0,0:00:26.96,0:00:28.98,English,,0,0,0,,And there is a recitation about that yesterday
Dialogue: 0,0:00:26.96,0:00:28.98,Chinese,,0,0,0,,昨天有一个关于这个的背诵
Dialogue: 0,0:00:28.98,0:00:32.90,English,,0,0,0,,But this is a lab that's a new to the course
Dialogue: 0,0:00:28.98,0:00:32.90,Chinese,,0,0,0,,但这是一个实验室，是课程的新手
Dialogue: 0,0:00:33.36,0:00:37.50,English,,0,0,0,,It's a similar to one that we used to use at this point in the course
Dialogue: 0,0:00:33.36,0:00:37.50,Chinese,,0,0,0,,它类似于我们过去在课程中使用的那个
Dialogue: 0,0:00:37.64,0:00:41.60,English,,0,0,0,,But it's been updated and changed in significant ways
Dialogue: 0,0:00:37.64,0:00:41.60,Chinese,,0,0,0,,但它已经在很大程度上得到了更新和改变
Dialogue: 0,0:00:41.70,0:00:49.88,English,,0,0,0,,So we're actually when you have labs like we do in this course with this many students
Dialogue: 0,0:00:41.70,0:00:49.88,Chinese,,0,0,0,,所以我们实际上就像你在这个课程中有这么多学生一样的实验室
Dialogue: 0,0:00:49.88,0:00:51.90,English,,0,0,0,,There's a lot of things can go wrong
Dialogue: 0,0:00:49.88,0:00:51.90,Chinese,,0,0,0,,有很多事情可能会出错
Dialogue: 0,0:00:51.90,0:00:55.96,English,,0,0,0,,So we're going to keep a close eye on how things are going
Dialogue: 0,0:00:51.90,0:00:55.96,Chinese,,0,0,0,,因此，我们将密切关注事情的进展
Dialogue: 0,0:00:55.96,0:00:59.70,English,,0,0,0,,But I'd encourage you you only have a week and a half to do this next lab
Dialogue: 0,0:00:55.96,0:00:59.70,Chinese,,0,0,0,,但我鼓励你，你只有一个半星期的时间去做下一个实验
Dialogue: 0,0:01:00.10,0:01:05.10,English,,0,0,0,,To get started soon and partly by having some people start sooner
Dialogue: 0,0:01:00.10,0:01:05.10,Chinese,,0,0,0,,要尽快开始，部分是让一些人早点开始
Dialogue: 0,0:01:05.10,0:01:07.88,English,,0,0,0,,You'll start breaking things for us that we can track down
Dialogue: 0,0:01:05.10,0:01:07.88,Chinese,,0,0,0,,你将开始为我们打破我们可以追踪的事情
Dialogue: 0,0:01:09.56,0:01:16.94,English,,0,0,0,,So today what we'll talk about is a couple like I said it's miscellaneous topics but important topics
Dialogue: 0,0:01:09.56,0:01:16.94,Chinese,,0,0,0,,所以今天我们要谈的是一对夫妇，比如我说它是杂项主题，但重要的话题
Dialogue: 0,0:01:17.00,0:01:25.52,English,,0,0,0,,One is just sort of what does the memory look like when you're running x86-64 programs
Dialogue: 0,0:01:17.00,0:01:25.52,Chinese,,0,0,0,,一个是运行x86-64程序时内存的样子
Dialogue: 0,0:01:26.00,0:01:31.34,English,,0,0,0,,The other is a very important topic on security vulnerability called buffer overflows
Dialogue: 0,0:01:26.00,0:01:31.34,Chinese,,0,0,0,,另一个是关于安全漏洞的非常重要的主题，称为缓冲区溢出
Dialogue: 0,0:01:31.86,0:01:37.44,English,,0,0,0,,And in fact the attack lab will be precisely exploiting those security vulnerabilities
Dialogue: 0,0:01:31.86,0:01:37.44,Chinese,,0,0,0,,事实上，攻击实验室将正是利用这些安全漏洞
Dialogue: 0,0:01:37.96,0:01:43.02,English,,0,0,0,,And then we'll look at unions,so far you've booked it arrays and structs and how they're organized
Dialogue: 0,0:01:37.96,0:01:43.02,Chinese,,0,0,0,,然后我们会看看工会，到目前为止，你已经预订了数组和结构以及它们是如何组织的
Dialogue: 0,0:01:43.72,0:01:45.90,English,,0,0,0,,And I want to compare that to unions
Dialogue: 0,0:01:43.72,0:01:45.90,Chinese,,0,0,0,,我想把它与工会进行比较
Dialogue: 0,0:01:47.88,0:01:53.82,English,,0,0,0,,So let's talk about memory then as I said at the beginning early in the course
Dialogue: 0,0:01:47.88,0:01:53.82,Chinese,,0,0,0,,那么就像我在课程开始时所说的那样，让我们​​谈谈记忆
Dialogue: 0,0:01:54.26,0:01:57.68,English,,0,0,0,,Conceptually a memory is just a big array of bytes
Dialogue: 0,0:01:54.26,0:01:57.68,Chinese,,0,0,0,,从概念上讲，内存只是一个很大的字节数组
Dialogue: 0,0:01:58.46,0:02:03.44,English,,0,0,0,,And that's the view of this the machine level programmer
Dialogue: 0,0:01:58.46,0:02:03.44,Chinese,,0,0,0,,这就是机器级程序员的看法
Dialogue: 0,0:02:03.72,0:02:05.84,English,,0,0,0,,Even though it's not the actual implementation
Dialogue: 0,0:02:03.72,0:02:05.84,Chinese,,0,0,0,,即使它不是实际的实现
Dialogue: 0,0:02:05.84,0:02:08.70,English,,0,0,0,,There's a whole part that we'll talk about later in the course
Dialogue: 0,0:02:05.84,0:02:08.70,Chinese,,0,0,0,,我们将在课程后期讨论整个部分
Dialogue: 0,0:02:09.58,0:02:11.84,English,,0,0,0,,Of this is called virtual memory
Dialogue: 0,0:02:09.58,0:02:11.84,Chinese,,0,0,0,,其中称为虚拟内存
Dialogue: 0,0:02:12.92,0:02:16.14,English,,0,0,0,,This organization is very simple organization
Dialogue: 0,0:02:12.92,0:02:16.14,Chinese,,0,0,0,,这个组织非常简单
Dialogue: 0,0:02:16.60,0:02:20.28,English,,0,0,0,,But the underlying implementation is this complex management of
Dialogue: 0,0:02:16.60,0:02:20.28,Chinese,,0,0,0,,但底层实施是这种复杂的管理
Dialogue: 0,0:02:20.88,0:02:27.52,English,,0,0,0,,Of various different memory types from disk memories to solid state disks
Dialogue: 0,0:02:20.88,0:02:27.52,Chinese,,0,0,0,,从磁盘存储器到固态磁盘的各种不同存储器类型
Dialogue: 0,0:02:28.00,0:02:32.60,English,,0,0,0,,And to what's called DRAM which stands for dynamic RAM the
Dialogue: 0,0:02:28.00,0:02:32.60,Chinese,,0,0,0,,而所谓的DRAM代表动态RAM
Dialogue: 0,0:02:32.80,0:02:35.88,English,,0,0,0,,When you buy memory for your processor its DRAM
Dialogue: 0,0:02:32.80,0:02:35.88,Chinese,,0,0,0,,当你为你的处理器购买内存时它的DRAM
Dialogue: 0,0:02:36.98,0:02:48.27,English,,0,0,0,,Um so as you know in x86-64 we're working with machines that nominally have addresses can be up to 64 bits long
Dialogue: 0,0:02:36.98,0:02:48.27,Chinese,,0,0,0,,嗯，你知道在x86-64我们正在使用名义上有地址的机器可以长达64位
Dialogue: 0,0:02:48.66,0:02:52.22,English,,0,0,0,,And if you work out the numbers remember I told you at the beginning of the course
Dialogue: 0,0:02:48.66,0:02:52.22,Chinese,,0,0,0,,如果你算出数字，记得我在课程开始时告诉过你
Dialogue: 0,0:02:52.22,0:03:00.28,English,,0,0,0,,You can estimate how big a number like to the 64 is by remembering that 1024
Dialogue: 0,0:02:52.22,0:03:00.28,Chinese,,0,0,0,,你可以通过记住1024来估计与64相似的数字
Dialogue: 0,0:03:00.82,0:03:03.22,English,,0,0,0,,And a thousand are very close to each other
Dialogue: 0,0:03:00.82,0:03:03.22,Chinese,,0,0,0,,千人彼此非常接近
Dialogue: 0,0:03:03.22,0:03:07.66,English,,0,0,0,,So 2^10 is roughly the same as 10^3
Dialogue: 0,0:03:03.22,0:03:07.66,Chinese,,0,0,0,,因此2 ^ 10与10 ^ 3大致相同
Dialogue: 0,0:03:08.52,0:03:11.48,English,,0,0,0,,So you take 64 and you think 60
Dialogue: 0,0:03:08.52,0:03:11.48,Chinese,,0,0,0,,所以你拿64，你认为60
Dialogue: 0,0:03:11.48,0:03:21.04,English,,0,0,0,,So how big is 2^60 well that's 6*10 and therefore it's 6*3,it's like 10^18
Dialogue: 0,0:03:11.48,0:03:21.04,Chinese,,0,0,0,,那么2 ^ 60井有多大6 * 10因此它是6 * 3，就像10 ^ 18
Dialogue: 0,0:03:22.28,0:03:27.00,English,,0,0,0,,And then you add the four to that that's 2^4 and 16
Dialogue: 0,0:03:22.28,0:03:27.00,Chinese,,0,0,0,,然后你将四个加到2 ^ 4和16
Dialogue: 0,0:03:27.00,0:03:30.58,English,,0,0,0,,So it's around 16*10^18 bytes
Dialogue: 0,0:03:27.00,0:03:30.58,Chinese,,0,0,0,,所以它大约是16 * 10 ^ 18字节
Dialogue: 0,0:03:31.64,0:03:40.26,English,,0,0,0,,So if you were to go off and look online on amazon for DRAM chips
Dialogue: 0,0:03:31.64,0:03:40.26,Chinese,,0,0,0,,所以，如果你想在亚马逊网上看看DRAM芯片
Dialogue: 0,0:03:40.26,0:03:44.74,English,,0,0,0,,And try to buy that much memory you'd find you're spending a lot of money
Dialogue: 0,0:03:40.26,0:03:44.74,Chinese,,0,0,0,,并尝试购买那么多内存，你会发现你花了很多钱
Dialogue: 0,0:03:45.66,0:03:52.60,English,,0,0,0,,More than you I don't know the numbers but it would be a lot of memory money
Dialogue: 0,0:03:45.66,0:03:52.60,Chinese,,0,0,0,,比你更多我不知道数字，但它会有很多记忆金
Dialogue: 0,0:03:53.06,0:03:55.16,English,,0,0,0,,And so you basically can't do it nowadays
Dialogue: 0,0:03:53.06,0:03:55.16,Chinese,,0,0,0,,所以你现在基本上不能这样做
Dialogue: 0,0:03:56.12,0:04:00.48,English,,0,0,0,,Tend to the and so...
Dialogue: 0,0:03:56.12,0:04:00.48,Chinese,,0,0,0,,倾向于等...
Dialogue: 0,0:04:02.28,0:04:09.72,English,,0,0,0,,Right now the machines limit you to actually only 47 bits worth of address in the address space
Dialogue: 0,0:04:02.28,0:04:09.72,Chinese,,0,0,0,,现在，机器限制你在地址空间中实际只有47位的地址
Dialogue: 0,0:04:10.54,0:04:19.28,English,,0,0,0,,I'll and so 2^47 again work that out that's like 256*10^12
Dialogue: 0,0:04:10.54,0:04:19.28,Chinese,,0,0,0,,我会这样2 ^ 47再次工作，那就像256 * 10 ^ 12
Dialogue: 0,0:04:19.28,0:04:21.82,English,,0,0,0,,So it's 256 terabytes
Dialogue: 0,0:04:19.28,0:04:21.82,Chinese,,0,0,0,,所以它是256太字节
Dialogue: 0,0:04:23.16,0:04:26.86,English,,0,0,0,,And as you know you can buy a disk drive now that has 8 terabytes
Dialogue: 0,0:04:23.16,0:04:26.86,Chinese,,0,0,0,,如你所知，你现在可以买一个8TB的磁盘驱动器
Dialogue: 0,0:04:26.86,0:04:28.36,English,,0,0,0,,So it doesn't seem like that much
Dialogue: 0,0:04:26.86,0:04:28.36,Chinese,,0,0,0,,所以看起来并不那么多
Dialogue: 0,0:04:28.36,0:04:37.54,English,,0,0,0,,But if you tried to buy that much DRAM again you'd have to have a pretty big credit-card limit
Dialogue: 0,0:04:28.36,0:04:37.54,Chinese,,0,0,0,,但如果你再次尝试购买那么多的DRAM，你必须有一个非常大的信用卡限制
Dialogue: 0,0:04:38.12,0:04:45.70,English,,0,0,0,,And so even that's a huge number and modern super computer installations actually will have almost that much memory
Dialogue: 0,0:04:38.12,0:04:45.70,Chinese,,0,0,0,,因此，即使这是一个庞大的数字和现代超级计算机安装实际上将有几乎那么多的记忆
Dialogue: 0,0:04:45.70,0:04:51.76,English,,0,0,0,,But the point is that the hardware of today limits you to 47 bits worth of address
Dialogue: 0,0:04:45.70,0:04:51.76,Chinese,,0,0,0,,但问题是，今天的硬件限制了你的47位地址
Dialogue: 0,0:04:52.56,0:04:58.18,English,,0,0,0,,But that's not really a real limitation in terms of of of actual machines
Dialogue: 0,0:04:52.56,0:04:58.18,Chinese,,0,0,0,,但就实际机器而言，这并不是真正的限制
Dialogue: 0,0:04:58.32,0:05:03.12,English,,0,0,0,,And what will happen is memory prices get cheaper and the technology gets better
Dialogue: 0,0:04:58.32,0:05:03.12,Chinese,,0,0,0,,会发生什么是内存价格变得更便宜，技术变得更好
Dialogue: 0,0:05:03.46,0:05:08.10,English,,0,0,0,,They'll slowly start adding as succeeding generations of processors come along
Dialogue: 0,0:05:03.46,0:05:08.10,Chinese,,0,0,0,,随着后续几代处理器的出现，它们将慢慢开始添加
Dialogue: 0,0:05:08.78,0:05:11.62,English,,0,0,0,,Let you have bigger and bigger range of addresses
Dialogue: 0,0:05:08.78,0:05:11.62,Chinese,,0,0,0,,让你拥有越来越大的地址范围
Dialogue: 0,0:05:12.52,0:05:17.30,English,,0,0,0,,So all that is to say that's why
Dialogue: 0,0:05:12.52,0:05:17.30,Chinese,,0,0,0,,所有这就是说这就是原因
Dialogue: 0,0:05:19.58,0:05:23.84,English,,0,0,0,,This number shows up which is a seven followed by eleven Fs
Dialogue: 0,0:05:19.58,0:05:23.84,Chinese,,0,0,0,,这个数字显示为7，然后是11个Fs
Dialogue: 0,0:05:27.76,0:05:32.68,English,,0,0,0,,I can tell I need to scribble some numbers you guys
Dialogue: 0,0:05:27.76,0:05:32.68,Chinese,,0,0,0,,我可以说我需要给你们一些数字
Dialogue: 0,0:05:32.68,0:05:35.56,English,,0,0,0,,Just saying numbers in the air is not working here
Dialogue: 0,0:05:32.68,0:05:35.56,Chinese,,0,0,0,,只是说空中的数字在这里不起作用
Dialogue: 0,0:05:36.88,0:05:49.88,English,,0,0,0,,So let's try
Dialogue: 0,0:05:36.88,0:05:49.88,Chinese,,0,0,0,,让我们试试吧
Dialogue: 0,0:05:50.20,0:05:53.96,English,,0,0,0,,Ok
Dialogue: 0,0:05:50.20,0:05:53.96,Chinese,,0,0,0,,好
Dialogue: 0,0:05:55.32,0:06:06.21,English,,0,0,0,,Okay so remember I said before to 2^64 is about equal to 16*10^18
Dialogue: 0,0:05:55.32,0:06:06.21,Chinese,,0,0,0,,好吧所以记得我之前说过2 ^ 64大约相当于16 * 10 ^ 18
Dialogue: 0,0:06:09.20,0:06:17.82,English,,0,0,0,,And 2^47 is 128*10^12
Dialogue: 0,0:06:09.20,0:06:17.82,Chinese,,0,0,0,,并且2 ^ 47是128 * 10 ^ 12
Dialogue: 0,0:06:19.24,0:06:21.14,English,,0,0,0,,So it's 128 terabytes
Dialogue: 0,0:06:19.24,0:06:21.14,Chinese,,0,0,0,,所以这是128太字节
Dialogue: 0,0:06:29.26,0:06:33.56,English,,0,0,0,,So what's the number after a terabyte you know 10^15
Dialogue: 0,0:06:29.26,0:06:33.56,Chinese,,0,0,0,,那么你知道10 ^ 15之后的数字是多少
Dialogue: 0,0:06:36.78,0:06:40.74,English,,0,0,0,,How many but yes petabytes right
Dialogue: 0,0:06:36.78,0:06:40.74,Chinese,,0,0,0,,多少，但是正确的是petabytes
Dialogue: 0,0:06:44.82,0:06:48.58,English,,0,0,0,,And you know what 10^18 is
Dialogue: 0,0:06:44.82,0:06:48.58,Chinese,,0,0,0,,你知道10 ^ 18是什么
Dialogue: 0,0:06:53.40,0:07:00.02,English,,0,0,0,,So just as a reference a company like google roughly
Dialogue: 0,0:06:53.40,0:07:00.02,Chinese,,0,0,0,,所以就像谷歌粗略的公司一样参考
Dialogue: 0,0:07:00.46,0:07:04.10,English,,0,0,0,,It's probably it's total storage across the whole
Dialogue: 0,0:07:00.46,0:07:04.10,Chinese,,0,0,0,,它可能是整个存储的总存储空间
Dialogue: 0,0:07:04.90,0:07:08.70,English,,0,0,0,,Enterprise is measured in some small number of x bytes
Dialogue: 0,0:07:04.90,0:07:08.70,Chinese,,0,0,0,,企业以少量x字节来衡量
Dialogue: 0,0:07:09.80,0:07:18.00,English,,0,0,0,,And it every day is getting several petabytes I don't know the numbers are of course secret
Dialogue: 0,0:07:09.80,0:07:18.00,Chinese,,0,0,0,,它每天都有几PB，我不知道这些数字当然是秘密的
Dialogue: 0,0:07:18.04,0:07:25.52,English,,0,0,0,,But maybe 10 petabytes or more per day of new data that it's ingesting into its system so
Dialogue: 0,0:07:18.04,0:07:25.52,Chinese,,0,0,0,,但是每天可能会有10 PB或更多的新数据被它摄入到它的系统中
Dialogue: 0,0:07:26.02,0:07:30.54,English,,0,0,0,,These numbers are pretty huge but not just totally off the charts
Dialogue: 0,0:07:26.02,0:07:30.54,Chinese,,0,0,0,,这些数字非常巨大，但不仅仅是完全脱离图表
Dialogue: 0,0:07:30.54,0:07:39.20,English,,0,0,0,,Do you know what 10^21 is? It's called a zettabyte with two t's
Dialogue: 0,0:07:30.54,0:07:39.20,Chinese,,0,0,0,,你知道10 ^ 21是什么吗？它被称为带有两个t的zettabyte
Dialogue: 0,0:07:41.54,0:07:45.90,English,,0,0,0,,And it's estimated if you add up all the digital content in the world
Dialogue: 0,0:07:41.54,0:07:45.90,Chinese,,0,0,0,,据估计，如果你将世界上所有的数字内容加起来
Dialogue: 0,0:07:45.90,0:07:49.90,English,,0,0,0,,That gets created everybody's cell phone camera every video
Dialogue: 0,0:07:45.90,0:07:49.90,Chinese,,0,0,0,,每个视频都会创建每个人的手机摄像头
Dialogue: 0,0:07:50.40,0:07:55.92,English,,0,0,0,,Taken by anyone anywhere all year long is a couple of zettabytes a year
Dialogue: 0,0:07:50.40,0:07:55.92,Chinese,,0,0,0,,全年任何人都可以使用一年两次的zettabytes
Dialogue: 0,0:07:55.96,0:08:02.30,English,,0,0,0,,So it'll be a while before we're really having to deal with that kind of memory
Dialogue: 0,0:07:55.96,0:08:02.30,Chinese,,0,0,0,,所以在我们真正处理这种记忆之前还需要一段时间
Dialogue: 0,0:08:03.18,0:08:10.36,English,,0,0,0,,So just to give you an idea so 128 terabytes is the address limit on these systems
Dialogue: 0,0:08:03.18,0:08:10.36,Chinese,,0,0,0,,所以只是为了给你一个想法，所以这些系统的地址限制为128太字节
Dialogue: 0,0:08:10.70,0:08:17.52,English,,0,0,0,,And so that's why you have to have seven because you remember that's one two three
Dialogue: 0,0:08:10.70,0:08:17.52,Chinese,,0,0,0,,所以这就是为什么你必须有七个，因为你记得那是一个二三
Dialogue: 0,0:08:18.22,0:08:26.10,English,,0,0,0,,And then there's f but there's 11 of them and this is 111 times 11
Dialogue: 0,0:08:18.22,0:08:26.10,Chinese,,0,0,0,,然后有f但是其中有11个，这是111次11
Dialogue: 0,0:08:26.10,0:08:31.32,English,,0,0,0,,So that's 44 ones and this is three ones
Dialogue: 0,0:08:26.10,0:08:31.32,Chinese,,0,0,0,,那是44个，这是三个
Dialogue: 0,0:08:33.44,0:08:36.44,English,,0,0,0,,And that's where you get 47
Dialogue: 0,0:08:33.44,0:08:36.44,Chinese,,0,0,0,,这就是你得到47的地方
Dialogue: 0,0:08:37.58,0:08:41.86,English,,0,0,0,,And that's the address of the in Linux
Dialogue: 0,0:08:37.58,0:08:41.86,Chinese,,0,0,0,,这就是Linux中的地址
Dialogue: 0,0:08:42.32,0:08:46.94,English,,0,0,0,,That's where they put the stack is up at the very top of the address space
Dialogue: 0,0:08:42.32,0:08:46.94,Chinese,,0,0,0,,这就是他们把堆栈放在地址空间最顶端的地方
Dialogue: 0,0:08:47.14,0:08:53.58,English,,0,0,0,,And I should tell you this picture is not at all to scale it would be impossible to draw this picture to scale
Dialogue: 0,0:08:47.14,0:08:53.58,Chinese,,0,0,0,,而且我应该告诉你，这张照片根本没有按比例绘制，因此无法按照比例绘制这张照片
Dialogue: 0,0:08:54.30,0:08:59.10,English,,0,0,0,,For example it shows that the stack starts way up at the top
Dialogue: 0,0:08:54.30,0:08:59.10,Chinese,,0,0,0,,例如，它显示堆栈从顶部开始向上
Dialogue: 0,0:08:59.10,0:09:03.10,English,,0,0,0,,And remember stacks grow to smaller addresses
Dialogue: 0,0:08:59.10,0:09:03.10,Chinese,,0,0,0,,并记住堆栈增长到较小的地址
Dialogue: 0,0:09:03.14,0:09:09.54,English,,0,0,0,,When you're pushing and also we show the them upside down just to make everything confusing
Dialogue: 0,0:09:03.14,0:09:09.54,Chinese,,0,0,0,,当你在推动时，我们也将它们颠倒过来，只是为了让一切变得混乱
Dialogue: 0,0:09:10.08,0:09:17.01,English,,0,0,0,,So the the stack starts there and it grows towards lower addresses
Dialogue: 0,0:09:10.08,0:09:17.01,Chinese,,0,0,0,,所以堆栈从那里开始，它朝着较低的地址增长
Dialogue: 0,0:09:17.32,0:09:20.50,English,,0,0,0,,And on a typical system it will be limited to 8 megabytes
Dialogue: 0,0:09:17.32,0:09:20.50,Chinese,,0,0,0,,在典型的系统上，它将限制在8兆字节
Dialogue: 0,0:09:20.78,0:09:23.98,English,,0,0,0,,And you can tell that on a Linux system at least
Dialogue: 0,0:09:20.78,0:09:23.98,Chinese,,0,0,0,,你至少可以在Linux系统上说出来
Dialogue: 0,0:09:25.38,0:09:28.78,English,,0,0,0,,With the the limit command
Dialogue: 0,0:09:25.38,0:09:28.78,Chinese,,0,0,0,,使用limit命令
Dialogue: 0,0:09:30.06,0:09:38.30,English,,0,0,0,,Which used to be more interesting than it was is now because a lot of things are unlimited
Dialogue: 0,0:09:30.06,0:09:38.30,Chinese,,0,0,0,,过去比现在更有趣，因为很多东西都是无限的
Dialogue: 0,0:09:38.76,0:09:43.76,English,,0,0,0,,But you see it says the stack size is limited to 8192 kbytes or kilobytes
Dialogue: 0,0:09:38.76,0:09:43.76,Chinese,,0,0,0,,但是你看到它表示堆栈大小限制为8192千字节或千字节
Dialogue: 0,0:09:43.76,0:09:46.12,English,,0,0,0,,So it's 8 megabytes
Dialogue: 0,0:09:43.76,0:09:46.12,Chinese,,0,0,0,,所以它是8兆字节
Dialogue: 0,0:09:49.96,0:10:00.77,English,,0,0,0,,And what that means is if you tried to access any memory via the stack pointer
Dialogue: 0,0:09:49.96,0:10:00.77,Chinese,,0,0,0,,这意味着如果你试图通过堆栈指针访问任何内存
Dialogue: 0,0:10:01.60,0:10:09.10,English,,0,0,0,,That was outside of the range of this 8 megabyte range you'd get a segmentation fault
Dialogue: 0,0:10:01.60,0:10:09.10,Chinese,,0,0,0,,这超出了这个8兆字节范围的范围，你会遇到分段错误
Dialogue: 0,0:10:10.40,0:10:17.74,English,,0,0,0,,And then down at the lower addresses what comes in what gets put into your program are the parts of the code
Dialogue: 0,0:10:10.40,0:10:17.74,Chinese,,0,0,0,,然后在较低的地址向下放入程序中的内容是代码的各个部分
Dialogue: 0,0:10:17.74,0:10:20.60,English,,0,0,0,,That that come out of the executable file
Dialogue: 0,0:10:17.74,0:10:20.60,Chinese,,0,0,0,,那个来自可执行文件
Dialogue: 0,0:10:20.94,0:10:25.10,English,,0,0,0,,And so there's a section and we'll talk more,when we talk about linking actually
Dialogue: 0,0:10:20.94,0:10:25.10,Chinese,,0,0,0,,所以有一个部分，当我们谈论实际链接时，我们会谈得更多
Dialogue: 0,0:10:25.10,0:10:28.36,English,,0,0,0,,About the way out of the memory and the different regions of it
Dialogue: 0,0:10:25.10,0:10:28.36,Chinese,,0,0,0,,关于记忆的方式和它的不同区域
Dialogue: 0,0:10:28.82,0:10:36.80,English,,0,0,0,,But for some obscure reason they call where the code is sitting the executable program the text segment
Dialogue: 0,0:10:28.82,0:10:36.80,Chinese,,0,0,0,,但是由于一些不明原因，他们称代码位于可执行程序的文本段
Dialogue: 0,0:10:36.81,0:10:41.90,English,,0,0,0,,I don't know why that's true, but it's the way it is and that's across many machines
Dialogue: 0,0:10:36.81,0:10:41.90,Chinese,,0,0,0,,我不知道为什么会这样，但它就是它的方式而且是在许多机器上
Dialogue: 0,0:10:42.30,0:10:49.89,English,,0,0,0,,And then the data is first of all there'll be a section for the data that's allocated at the program begins
Dialogue: 0,0:10:42.30,0:10:49.89,Chinese,,0,0,0,,然后数据首先会有一个部分用于在程序中分配的数据开始
Dialogue: 0,0:10:49.89,0:10:55.54,English,,0,0,0,,So any global variables that you've declared will be in that section
Dialogue: 0,0:10:49.89,0:10:55.54,Chinese,,0,0,0,,因此，你声明的任何全局变量都将出现在该部分中
Dialogue: 0,0:10:56.26,0:11:05.04,English,,0,0,0,,And then the heap is the part of memory that is x is allocated via call to malloc or one of its related functions
Dialogue: 0,0:10:56.26,0:11:05.04,Chinese,,0,0,0,,然后堆是内存的一部分，x是通过调用malloc或其相关函数之一来分配的
Dialogue: 0,0:11:05.06,0:11:08.16,English,,0,0,0,,And so that varies dynamically as the program runs
Dialogue: 0,0:11:05.06,0:11:08.16,Chinese,,0,0,0,,因此，程序运行时会动态变化
Dialogue: 0,0:11:08.72,0:11:13.30,English,,0,0,0,,It starts off with a very small allocation and every time you call malloc
Dialogue: 0,0:11:08.72,0:11:13.30,Chinese,,0,0,0,,它从一个非常小的分配开始，每次你调用malloc
Dialogue: 0,0:11:14.08,0:11:19.96,English,,0,0,0,,If you're not freeing memory and so your memory requirements keep growing
Dialogue: 0,0:11:14.08,0:11:19.96,Chinese,,0,0,0,,如果你没有释放内存，那么你的内存需求会不断增长
Dialogue: 0,0:11:20.20,0:11:25.68,English,,0,0,0,,It will crease keep up moving up larger and larger addresses
Dialogue: 0,0:11:20.20,0:11:25.68,Chinese,,0,0,0,,它会随着地址越来越大而不断增加
Dialogue: 0,0:11:26.16,0:11:30.18,English,,0,0,0,,And then somewhere in the code too and this can vary by system is
Dialogue: 0,0:11:26.16,0:11:30.18,Chinese,,0,0,0,,然后在代码中的某个地方，这可能因系统而异
Dialogue: 0,0:11:30.50,0:11:37.76,English,,0,0,0,,The code that gets brought in that represents the library functions things like printf and malloc itself
Dialogue: 0,0:11:30.50,0:11:37.76,Chinese,,0,0,0,,引入的代码表示库函数类似printf和malloc本身
Dialogue: 0,0:11:38.28,0:11:40.98,English,,0,0,0,,Our own library code they're stored off on disk
Dialogue: 0,0:11:38.28,0:11:40.98,Chinese,,0,0,0,,我们自己的库代码存储在磁盘上
Dialogue: 0,0:11:40.98,0:11:44.32,English,,0,0,0,,And they get brought in they get linked into your program
Dialogue: 0,0:11:40.98,0:11:44.32,Chinese,,0,0,0,,他们被引入，他们被链接到你的程序
Dialogue: 0,0:11:44.32,0:11:48.16,English,,0,0,0,,When it first starts executing by a process known as dynamic linking
Dialogue: 0,0:11:44.32,0:11:48.16,Chinese,,0,0,0,,当它首次通过称为动态链接的过程开始执行时
Dialogue: 0,0:11:48.32,0:11:51.74,English,,0,0,0,,Which we'll talk about later in the course too with the linking
Dialogue: 0,0:11:48.32,0:11:51.74,Chinese,,0,0,0,,我们将在后面的课程中讨论链接
Dialogue: 0,0:11:52.38,0:11:54.74,English,,0,0,0,,And what you'll find in general is that
Dialogue: 0,0:11:52.38,0:11:54.74,Chinese,,0,0,0,,你会发现一般的是
Dialogue: 0,0:11:55.30,0:11:59.02,English,,0,0,0,,Allocations will tend to be either at these very low addresses
Dialogue: 0,0:11:55.30,0:11:59.02,Chinese,,0,0,0,,分配将倾向于在这些非常低的地址
Dialogue: 0,0:11:59.38,0:12:03.74,English,,0,0,0,,Or these very high addresses as your program is running
Dialogue: 0,0:11:59.38,0:12:03.74,Chinese,,0,0,0,,或者在程序运行时这些非常高的地址
Dialogue: 0,0:12:06.72,0:12:09.44,English,,0,0,0,,So just as an example here is some code
Dialogue: 0,0:12:06.72,0:12:09.44,Chinese,,0,0,0,,所以这里只是一些代码
Dialogue: 0,0:12:09.84,0:12:15.08,English,,0,0,0,,Um that it's only value is to show you different where things get located
Dialogue: 0,0:12:09.84,0:12:15.08,Chinese,,0,0,0,,嗯它唯一的价值就是向你展示不同的地方
Dialogue: 0,0:12:15.50,0:12:19.50,English,,0,0,0,,And so you'll see I allocated some a fairly large arrays here
Dialogue: 0,0:12:15.50,0:12:19.50,Chinese,,0,0,0,,所以你会看到我在这里分配了一些相当大的数组
Dialogue: 0,0:12:19.50,0:12:26.60,English,,0,0,0,,This one is there all cares but this is 1<<24 so it's 16
Dialogue: 0,0:12:19.50,0:12:26.60,Chinese,,0,0,0,,这个是关注所有，但这是1 << 24所以它是16
Dialogue: 0,0:12:27.20,0:12:31.10,English,,0,0,0,,A megabyte array and this one is 1<<31
Dialogue: 0,0:12:27.20,0:12:31.10,Chinese,,0,0,0,,一个兆字节数组，这个是1 << 31
Dialogue: 0,0:12:31.88,0:12:37.10,English,,0,0,0,,So it's 2 gigabytes worth of array
Dialogue: 0,0:12:31.88,0:12:37.10,Chinese,,0,0,0,,所以这是2千兆字节的数组
Dialogue: 0,0:12:37.10,0:12:43.84,English,,0,0,0,,I found that if I tried to allocate larger ones it the program wouldn't run
Dialogue: 0,0:12:37.10,0:12:43.84,Chinese,,0,0,0,,我发现如果我试图分配更大的那个程序就不会运行
Dialogue: 0,0:12:44.82,0:12:51.92,English,,0,0,0,,And I also do some here's just a sort of global variable and here's a function
Dialogue: 0,0:12:44.82,0:12:51.92,Chinese,,0,0,0,,我也在这里做一些全局变量，这是一个函数
Dialogue: 0,0:12:52.90,0:12:56.94,English,,0,0,0,,And then there's a single function here with some local variable
Dialogue: 0,0:12:52.90,0:12:56.94,Chinese,,0,0,0,,然后这里有一个函数，带有一些局部变量
Dialogue: 0,0:12:56.94,0:12:59.60,English,,0,0,0,,And that will be allocated somewhere on the stack
Dialogue: 0,0:12:56.94,0:12:59.60,Chinese,,0,0,0,,这将被分配到堆栈的某个地方
Dialogue: 0,0:13:00.38,0:13:05.72,English,,0,0,0,,And then there's several calls to milk some of which are for some very small chunks of memory
Dialogue: 0,0:13:00.38,0:13:05.72,Chinese,,0,0,0,,然后有几次调用牛奶，其中一些用于一些非常小的内存
Dialogue: 0,0:13:06.04,0:13:08.94,English,,0,0,0,,And somewhere for some very large chunks of memory
Dialogue: 0,0:13:06.04,0:13:08.94,Chinese,,0,0,0,,还有某些非常大的内存块
Dialogue: 0,0:13:09.52,0:13:15.87,English,,0,0,0,,And so we can run this program and see what addresses pop out of it
Dialogue: 0,0:13:09.52,0:13:15.87,Chinese,,0,0,0,,所以我们可以运行这个程序，看看它弹出的地址
Dialogue: 0,0:13:16.34,0:13:19.08,English,,0,0,0,,And what you'll see is the stack
Dialogue: 0,0:13:16.34,0:13:19.08,Chinese,,0,0,0,,而你会看到的是堆栈
Dialogue: 0,0:13:19.48,0:13:24.94,English,,0,0,0,,This local variable is somewhere up with an address in the range of the stack
Dialogue: 0,0:13:19.48,0:13:24.94,Chinese,,0,0,0,,这个局部变量在某个地方有一个堆栈范围内的地址
Dialogue: 0,0:13:24.94,0:13:28.44,English,,0,0,0,,And you see the 7 and a couple fs and then it goes to something else
Dialogue: 0,0:13:24.94,0:13:28.44,Chinese,,0,0,0,,你看到7和几个fs然后它去了别的东西
Dialogue: 0,0:13:29.40,0:13:35.54,English,,0,0,0,,And you'll see also interestingly enough that the code and then looking down at the bottom
Dialogue: 0,0:13:29.40,0:13:35.54,Chinese,,0,0,0,,而且你会看到有趣的代码然后俯视底部
Dialogue: 0,0:13:36.60,0:13:42.62,English,,0,0,0,,Of this yellow color is things get relegated to the text segment the main function
Dialogue: 0,0:13:36.60,0:13:42.62,Chinese,,0,0,0,,这种黄色的东西被降级为文本段的主要功能
Dialogue: 0,0:13:42.94,0:13:46.50,English,,0,0,0,,And this function I called I declared called useless
Dialogue: 0,0:13:42.94,0:13:46.50,Chinese,,0,0,0,,而这个函数我叫我声称无用
Dialogue: 0,0:13:47.10,0:13:49.42,English,,0,0,0,,And then the predefined arrays
Dialogue: 0,0:13:47.10,0:13:49.42,Chinese,,0,0,0,,然后是预定义的数组
Dialogue: 0,0:13:50.58,0:13:55.16,English,,0,0,0,,That were in other words globally declared not declared by malloc
Dialogue: 0,0:13:50.58,0:13:55.16,Chinese,,0,0,0,,换句话说，全局声明不是由malloc声明的
Dialogue: 0,0:13:55.16,0:14:02.18,English,,0,0,0,,They're declared as part of the program itself are down here in this data section
Dialogue: 0,0:13:55.16,0:14:02.18,Chinese,,0,0,0,,它们被声明为程序本身的一部分，在此数据部分中
Dialogue: 0,0:14:02.75,0:14:08.52,English,,0,0,0,,And because it's a very large array, the huge array you actually get some fairly large addresses
Dialogue: 0,0:14:02.75,0:14:08.52,Chinese,,0,0,0,,而且因为它是一个非常大的数组，你实际上得到了一个相当大的地址
Dialogue: 0,0:14:09.26,0:14:11.12,English,,0,0,0,,And then interestingly enough
Dialogue: 0,0:14:09.26,0:14:11.12,Chinese,,0,0,0,,然后有趣的是
Dialogue: 0,0:14:11.66,0:14:15.56,English,,0,0,0,,Or I don't know why it's interesting but for one reason or another
Dialogue: 0,0:14:11.66,0:14:15.56,Chinese,,0,0,0,,或者我不知道为什么它有趣但是出于某种原因
Dialogue: 0,0:14:16.46,0:14:22.02,English,,0,0,0,,It happen that the smaller chunks of memory allocations
Dialogue: 0,0:14:16.46,0:14:22.02,Chinese,,0,0,0,,它发生在较小的内存分配块上
Dialogue: 0,0:14:22.34,0:14:28.74,English,,0,0,0,,Are down here at addresses that are actually just a little bit above  the the pink section right
Dialogue: 0,0:14:22.34,0:14:28.74,Chinese,,0,0,0,,在这里的地址实际上只是粉红色部分的正上方
Dialogue: 0,0:14:29.06,0:14:32.30,English,,0,0,0,,And similarly the really big chunks of memory I allocate
Dialogue: 0,0:14:29.06,0:14:32.30,Chinese,,0,0,0,,同样，我分配的内存非常庞大
Dialogue: 0,0:14:32.48,0:14:38.62,English,,0,0,0,,Are way up here near the stack limit
Dialogue: 0,0:14:32.48,0:14:38.62,Chinese,,0,0,0,,是在堆栈限制附近的方式
Dialogue: 0,0:14:39.28,0:14:43.60,English,,0,0,0,,And they are...
Dialogue: 0,0:14:39.28,0:14:43.60,Chinese,,0,0,0,,他们是......
Dialogue: 0,0:14:43.68,0:14:47.94,English,,0,0,0,,And so they're there and in general what's happening is if I were to try and reference
Dialogue: 0,0:14:43.68,0:14:47.94,Chinese,,0,0,0,,所以他们就在那里，总的来说，如果我试着参考的话会发生什么
Dialogue: 0,0:14:48.50,0:14:53.07,English,,0,0,0,,A memory address in this empty range I'd get a segmentation fault
Dialogue: 0,0:14:48.50,0:14:53.07,Chinese,,0,0,0,,在这个空范围内的内存地址我会得到一个分段错误
Dialogue: 0,0:14:53.46,0:14:57.96,English,,0,0,0,,It's a valid address in terms of its bit of properties
Dialogue: 0,0:14:53.46,0:14:57.96,Chinese,,0,0,0,,就其位属性而言，它是一个有效的地址
Dialogue: 0,0:14:57.96,0:15:03.10,English,,0,0,0,,But it hasn't actually been set up and allocated by the memory the virtual memory allocator
Dialogue: 0,0:14:57.96,0:15:03.10,Chinese,,0,0,0,,但它实际上并没有由内存设置和分配虚拟内存分配器
Dialogue: 0,0:15:03.10,0:15:06.10,English,,0,0,0,,So at any given time the valid addresses
Dialogue: 0,0:15:03.10,0:15:06.10,Chinese,,0,0,0,,所以在任何给定时间有效地址
Dialogue: 0,0:15:06.46,0:15:12.00,English,,0,0,0,,Are just those in the lower portion or the upper portion of this address ranges
Dialogue: 0,0:15:06.46,0:15:12.00,Chinese,,0,0,0,,只是位于此地址范围的下部或上部的那些
Dialogue: 0,0:15:12.24,0:15:14.16,English,,0,0,0,,And the middle is sort of no-man's land
Dialogue: 0,0:15:12.24,0:15:14.16,Chinese,,0,0,0,,中间是一种无人的土地
Dialogue: 0,0:15:14.38,0:15:17.44,English,,0,0,0,,And then what happens is you keep allocating more with malloc
Dialogue: 0,0:15:14.38,0:15:17.44,Chinese,,0,0,0,,然后会发生什么事情，你继续用malloc分配更多
Dialogue: 0,0:15:17.86,0:15:22.46,English,,0,0,0,,And it will push the limits of what's addressable in toward it
Dialogue: 0,0:15:17.86,0:15:22.46,Chinese,,0,0,0,,它将推动可解决的极限
Dialogue: 0,0:15:22.86,0:15:29.46,English,,0,0,0,,And in principle if you ever got too much of a memory request
Dialogue: 0,0:15:22.86,0:15:29.46,Chinese,,0,0,0,,原则上，如果你有太多的内存请求
Dialogue: 0,0:15:29.48,0:15:35.26,English,,0,0,0,,These two would hit each other and you and malik would return zero at that point
Dialogue: 0,0:15:29.48,0:15:35.26,Chinese,,0,0,0,,这两个会相互碰撞，你和malik会在那时返回零
Dialogue: 0,0:15:35.64,0:15:43.26,English,,0,0,0,,But it's highly unlikely given that you have 128 terabytes of (memory) address range here
Dialogue: 0,0:15:35.64,0:15:43.26,Chinese,,0,0,0,,但鉴于此处有128 TB的（内存）地址范围，这种可能性极小
Dialogue: 0,0:15:44.06,0:15:46.94,English,,0,0,0,,So that just and you've probably seen this when you're running
Dialogue: 0,0:15:44.06,0:15:46.94,Chinese,,0,0,0,,所以你刚刚跑步时就已经看过这个了
Dialogue: 0,0:15:47.48,0:15:50.50,English,,0,0,0,,You're looking at disassembled code with GDB
Dialogue: 0,0:15:47.48,0:15:50.50,Chinese,,0,0,0,,你正在查看使用GDB的反汇编代码
Dialogue: 0,0:15:50.50,0:15:56.76,English,,0,0,0,,You're seeing some addresses that are way up here with the 7 and some f so they're stack addresses
Dialogue: 0,0:15:50.50,0:15:56.76,Chinese,,0,0,0,,你看到一些地址在这里与7和一些f，所以他们是堆栈地址
Dialogue: 0,0:15:57.20,0:15:58.82,English,,0,0,0,,And you see these fours
Dialogue: 0,0:15:57.20,0:15:58.82,Chinese,,0,0,0,,而且你看到了这些四肢
Dialogue: 0,0:15:59.56,0:16:03.90,English,,0,0,0,,You know a lot of zeros and some fours those tend to be where the code is going
Dialogue: 0,0:15:59.56,0:16:03.90,Chinese,,0,0,0,,你知道很多零和四个那些往往是代码的地方
Dialogue: 0,0:16:04.32,0:16:09.28,English,,0,0,0,,Question
Dialogue: 0,0:16:04.32,0:16:09.28,Chinese,,0,0,0,,题
Dialogue: 0,0:16:09.42,0:16:12.34,English,,0,0,0,,Why doesn't the heat proceed in one direction I actually don't know
Dialogue: 0,0:16:09.42,0:16:12.34,Chinese,,0,0,0,,为什么热量不会沿着我实际上不知道的方向前进
Dialogue: 0,0:16:13.04,0:16:18.32,English,,0,0,0,,I'll just observe that it was had a strategy of putting big things here in small things here
Dialogue: 0,0:16:13.04,0:16:18.32,Chinese,,0,0,0,,我只是观察它有一个策略，在这里把小东西放在这里
Dialogue: 0,0:16:18.32,0:16:22.88,English,,0,0,0,,And it probably uses different slightly different management strategies for those two
Dialogue: 0,0:16:18.32,0:16:22.88,Chinese,,0,0,0,,它可能会对这两者采用不同的略有不同的管理策略
Dialogue: 0,0:16:33.10,0:16:38.74,English,,0,0,0,,Okay so that I think you'll find that kind of useful to have some sense when you're looking at
Dialogue: 0,0:16:33.10,0:16:38.74,Chinese,,0,0,0,,好的，所以我觉得你会发现在你看的时候有一点意义
Dialogue: 0,0:16:39.20,0:16:45.20,English,,0,0,0,,When you're running GDB it helps to just have some idea of what's going on when you're looking at these different addresses
Dialogue: 0,0:16:39.20,0:16:45.20,Chinese,,0,0,0,,当你运行GDB时，只需了解一下当你查看这些不同的地址时会发生什么
Dialogue: 0,0:16:47.36,0:16:50.44,English,,0,0,0,,Okay now let's talk about buffer overflow
Dialogue: 0,0:16:47.36,0:16:50.44,Chinese,,0,0,0,,好的，现在让我们谈谈缓冲区溢出
Dialogue: 0,0:16:50.92,0:16:55.34,English,,0,0,0,,And we'll start this you remember on the very first class
Dialogue: 0,0:16:50.92,0:16:55.34,Chinese,,0,0,0,,我们将在第一堂课时开始记得
Dialogue: 0,0:16:55.34,0:16:58.48,English,,0,0,0,,And I think we might have reviewed this part way along
Dialogue: 0,0:16:55.34,0:16:58.48,Chinese,,0,0,0,,我想我们可能已经审查了这一部分
Dialogue: 0,0:16:58.80,0:17:04.78,English,,0,0,0,,We showed this example of some programs where if you do an out-of-bounds
Dialogue: 0,0:16:58.80,0:17:04.78,Chinese,,0,0,0,,我们展示了一些程序的例子，如果你做了一个越界
Dialogue: 0,0:17:06.18,0:17:10.08,English,,0,0,0,,Reference and write a value that's out of bounds in particular
Dialogue: 0,0:17:06.18,0:17:10.08,Chinese,,0,0,0,,引用并写出特别超出范围的值
Dialogue: 0,0:17:10.96,0:17:14.60,English,,0,0,0,,I only have a array of two elements here
Dialogue: 0,0:17:10.96,0:17:14.60,Chinese,,0,0,0,,我这里只有两个元素的数组
Dialogue: 0,0:17:15.00,0:17:18.20,English,,0,0,0,,But this function will take an arbitrary value of i
Dialogue: 0,0:17:15.00,0:17:18.20,Chinese,,0,0,0,,但是这个函数将取i的任意值
Dialogue: 0,0:17:18.54,0:17:23.04,English,,0,0,0,,And assign some magic number to element i of the array
Dialogue: 0,0:17:18.54,0:17:23.04,Chinese,,0,0,0,,并为数组的元素i分配一些魔法数字
Dialogue: 0,0:17:24.06,0:17:25.86,English,,0,0,0,,And it has the possibility of...
Dialogue: 0,0:17:24.06,0:17:25.86,Chinese,,0,0,0,,它有可能......
Dialogue: 0,0:17:27.88,0:17:30.28,English,,0,0,0,,And we saw that when you do that
Dialogue: 0,0:17:27.88,0:17:30.28,Chinese,,0,0,0,,当你这样做时，我们看到了
Dialogue: 0,0:17:30.38,0:17:33.24,English,,0,0,0,,If I gets too big it will first
Dialogue: 0,0:17:30.38,0:17:33.24,Chinese,,0,0,0,,如果我变得太大，它将首先
Dialogue: 0,0:17:33.98,0:17:39.12,English,,0,0,0,,Corrupt the the double that stored is part of the struct
Dialogue: 0,0:17:33.98,0:17:39.12,Chinese,,0,0,0,,腐蚀存储的双重结构的一部分
Dialogue: 0,0:17:39.52,0:17:42.42,English,,0,0,0,,And then when it gets bigger it seems to
Dialogue: 0,0:17:39.52,0:17:42.42,Chinese,,0,0,0,,然后当它变大时，它似乎
Dialogue: 0,0:17:42.92,0:17:47.16,English,,0,0,0,,Not have any effect until it gets too big and then you start corrupting memory
Dialogue: 0,0:17:42.92,0:17:47.16,Chinese,,0,0,0,,在它变得太大然后你开始破坏内存之前没有任何影响
Dialogue: 0,0:17:47.74,0:17:54.20,English,,0,0,0,,So the basic point is that it's very easy in a program, a C program in particular
Dialogue: 0,0:17:47.74,0:17:54.20,Chinese,,0,0,0,,所以基本点是它在程序中非常容易，特别是C程序
Dialogue: 0,0:17:54.56,0:17:59.60,English,,0,0,0,,To a reference memory that's not part of the sort of intent of the program
Dialogue: 0,0:17:54.56,0:17:59.60,Chinese,,0,0,0,,对于不属于程序意图类型的参考存储器
Dialogue: 0,0:18:02.20,0:18:09.50,English,,0,0,0,,And this can happen in programs that aren't properly written that
Dialogue: 0,0:18:02.20,0:18:09.50,Chinese,,0,0,0,,这可能发生在没有正确编写的程序中
Dialogue: 0,0:18:10.32,0:18:19.66,English,,0,0,0,,And it becomes a security vulnerability if there's some way for an outsider to overflow a buffer
Dialogue: 0,0:18:10.32,0:18:19.66,Chinese,,0,0,0,,如果局外人有一些方法来溢出缓冲区，它就成了一个安全漏洞
Dialogue: 0,0:18:20.24,0:18:25.20,English,,0,0,0,,For example if there is some way for an outsider to give a larger value of i and ask that
Dialogue: 0,0:18:20.24,0:18:25.20,Chinese,,0,0,0,,例如，如果局外人有某种方式可以给出更大的i值并且要求它
Dialogue: 0,0:18:25.70,0:18:28.42,English,,0,0,0,,That value be stored there it could crash the program
Dialogue: 0,0:18:25.70,0:18:28.42,Chinese,,0,0,0,,该值存储在那里可能导致程序崩溃
Dialogue: 0,0:18:29.34,0:18:33.98,English,,0,0,0,,And so in general when you write in code you try to think about  can I trust this value
Dialogue: 0,0:18:29.34,0:18:33.98,Chinese,,0,0,0,,所以一般来说，当你在代码中编写时，你试着想一想我是否可以相信这个价值
Dialogue: 0,0:18:33.98,0:18:39.84,English,,0,0,0,,This a value that's been computed by my program and I'm sure that it's within bounds
Dialogue: 0,0:18:33.98,0:18:39.84,Chinese,,0,0,0,,这个值是由我的程序计算出来的，我确信它在界限范围内
Dialogue: 0,0:18:40.20,0:18:43.36,English,,0,0,0,,Or is it something that's come from an external source
Dialogue: 0,0:18:40.20,0:18:43.36,Chinese,,0,0,0,,或者它是来自外部来源的东西
Dialogue: 0,0:18:43.36,0:18:48.16,English,,0,0,0,,And there is potentially that risk of being a vulnerability
Dialogue: 0,0:18:43.36,0:18:48.16,Chinese,,0,0,0,,并且存在潜在的漏洞风险
Dialogue: 0,0:18:49.58,0:18:53.22,English,,0,0,0,,And so in particular there's a lot a huge class of errors
Dialogue: 0,0:18:49.58,0:18:53.22,Chinese,,0,0,0,,特别是有很多错误
Dialogue: 0,0:18:53.22,0:18:57.68,English,,0,0,0,,That have to do with overflowing buffers where
Dialogue: 0,0:18:53.22,0:18:57.68,Chinese,,0,0,0,,这与溢出缓冲区有关
Dialogue: 0,0:18:58.16,0:19:04.94,English,,0,0,0,,Where they're trying to store a string of some type that's been read from a message
Dialogue: 0,0:18:58.16,0:19:04.94,Chinese,,0,0,0,,他们试图存储从消息中读取的某种类型的字符串
Dialogue: 0,0:19:05.70,0:19:10.38,English,,0,0,0,,And without knowing in advance how big that string is
Dialogue: 0,0:19:05.70,0:19:10.38,Chinese,,0,0,0,,并且事先不知道该字符串有多大
Dialogue: 0,0:19:10.38,0:19:14.90,English,,0,0,0,,It's possible that it will be too big for the buffer that's been allocated
Dialogue: 0,0:19:10.38,0:19:14.90,Chinese,,0,0,0,,对于已分配的缓冲区，它可能太大了
Dialogue: 0,0:19:15.48,0:19:21.72,English,,0,0,0,,And so one of the culprits is there's a whole class of library functions that
Dialogue: 0,0:19:15.48,0:19:21.72,Chinese,,0,0,0,,因此，其中一个罪魁祸首就是有一整套库函数
Dialogue: 0,0:19:22.32,0:19:30.04,English,,0,0,0,,Let you store something a string somewhere without any kind of bounds checking even being possible
Dialogue: 0,0:19:22.32,0:19:30.04,Chinese,,0,0,0,,让你在某个地方存储一些字符串，即使可能也没有任何边界检查
Dialogue: 0,0:19:30.73,0:19:34.70,English,,0,0,0,,So the sort of worst one is one called gets
Dialogue: 0,0:19:30.73,0:19:34.70,Chinese,,0,0,0,,所以最糟糕的一种叫做获取
Dialogue: 0,0:19:35.20,0:19:39.58,English,,0,0,0,,And the purpose of gets is normally it's used to read a string from
Dialogue: 0,0:19:35.20,0:19:39.58,Chinese,,0,0,0,,get的目的通常是用来从中读取字符串
Dialogue: 0,0:19:40.18,0:19:46.00,English,,0,0,0,,An input from a terminal input something that somebody's typed into a terminal
Dialogue: 0,0:19:40.18,0:19:46.00,Chinese,,0,0,0,,来自终端的输入输入某人键入终端的内容
Dialogue: 0,0:19:46.38,0:19:50.14,English,,0,0,0,,And so what it's doing is it's scanning this input string
Dialogue: 0,0:19:46.38,0:19:50.14,Chinese,,0,0,0,,所以它正在做的是扫描这个输入字符串
Dialogue: 0,0:19:50.46,0:19:54.76,English,,0,0,0,,And looking for a character that represents the end of the line
Dialogue: 0,0:19:50.46,0:19:54.76,Chinese,,0,0,0,,并寻找代表该行结束的角色
Dialogue: 0,0:19:54.94,0:19:59.14,English,,0,0,0,,Which we write in of cea's is backslash n
Dialogue: 0,0:19:54.94,0:19:59.14,Chinese,,0,0,0,,我们用cea写的是反斜杠n
Dialogue: 0,0:19:59.48,0:20:02.94,English,,0,0,0,,And it has a character code at hex of 0a
Dialogue: 0,0:19:59.48,0:20:02.94,Chinese,,0,0,0,,它有一个十六进制的字符代码
Dialogue: 0,0:20:04.58,0:20:11.28,English,,0,0,0,,And so gets this is sort of an approximate version of what the code for gets looks like
Dialogue: 0,0:20:04.58,0:20:11.28,Chinese,,0,0,0,,因此得到这是一个近似版本的代码获取的样子
Dialogue: 0,0:20:11.78,0:20:17.02,English,,0,0,0,,That and it's as an argument it's just given a destination of where to store the result
Dialogue: 0,0:20:11.78,0:20:17.02,Chinese,,0,0,0,,那就是它作为一个参数，它只是给出了存储结果的目的地
Dialogue: 0,0:20:17.48,0:20:20.76,English,,0,0,0,,And all it does is it reads one character at a time
Dialogue: 0,0:20:17.48,0:20:20.76,Chinese,,0,0,0,,它所做的只是一次读取一个字符
Dialogue: 0,0:20:21.16,0:20:27.63,English,,0,0,0,,Looks for an end-of-file meaning that the input stream is closed or an end-of-line
Dialogue: 0,0:20:21.16,0:20:27.63,Chinese,,0,0,0,,查找文件结尾意味着输入流已关闭或行尾
Dialogue: 0,0:20:27.66,0:20:34.80,English,,0,0,0,,But as long as it until it sees that it just keeps adding more things to the end of this buffer
Dialogue: 0,0:20:27.66,0:20:34.80,Chinese,,0,0,0,,但只要它看到它只是不断添加更多的东西到这个缓冲区的末尾
Dialogue: 0,0:20:37.66,0:20:39.28,English,,0,0,0,,And so typically
Dialogue: 0,0:20:37.66,0:20:39.28,Chinese,,0,0,0,,通常如此
Dialogue: 0,0:20:43.98,0:20:50.66,English,,0,0,0,,When somebody calls gets they'll pass it a pointer to some buffer that they've allocated
Dialogue: 0,0:20:43.98,0:20:50.66,Chinese,,0,0,0,,当有人调用时，他们会向它传递一个指向他们已分配的缓冲区的指针
Dialogue: 0,0:20:51.36,0:20:56.00,English,,0,0,0,,But the function and it will just gets we'll just fill that buffer up
Dialogue: 0,0:20:51.36,0:20:56.00,Chinese,,0,0,0,,但是功能和它只会让我们只填充缓冲区
Dialogue: 0,0:20:56.80,0:21:00.76,English,,0,0,0,,But it can potentially just keep going there's nothing in the function
Dialogue: 0,0:20:56.80,0:21:00.76,Chinese,,0,0,0,,但它可能只是继续发挥作用
Dialogue: 0,0:21:00.96,0:21:03.44,English,,0,0,0,,There's not even an argument to the function
Dialogue: 0,0:21:00.96,0:21:03.44,Chinese,,0,0,0,,这个功能甚至没有争论
Dialogue: 0,0:21:03.90,0:21:10.26,English,,0,0,0,,That tells the function when it has to stop When it's reached the limit of it
Dialogue: 0,0:21:03.90,0:21:10.26,Chinese,,0,0,0,,这告诉函数何时必须停止它何时达到它的极限
Dialogue: 0,0:21:10.58,0:21:13.30,English,,0,0,0,,So it was written it actually gets is
Dialogue: 0,0:21:10.58,0:21:13.30,Chinese,,0,0,0,,所以写的它实际得到了
Dialogue: 0,0:21:13.30,0:21:17.62,English,,0,0,0,,If you try to compile code would gets it will flash up a big warning that says
Dialogue: 0,0:21:13.30,0:21:17.62,Chinese,,0,0,0,,如果你试图编译代码会得到它会闪现一个大警告说
Dialogue: 0,0:21:17.62,0:21:21.10,English,,0,0,0,,This is really an unsafe function you probably shouldn't even be using it
Dialogue: 0,0:21:17.62,0:21:21.10,Chinese,,0,0,0,,这实际上是一个不安全的功能，你甚至可能不应该使用它
Dialogue: 0,0:21:21.50,0:21:28.74,English,,0,0,0,,Because it was written in the 1970s
Dialogue: 0,0:21:21.50,0:21:28.74,Chinese,,0,0,0,,因为它写于20世纪70年代
Dialogue: 0,0:21:28.74,0:21:31.40,English,,0,0,0,,When the early UNIX distributions were coming out
Dialogue: 0,0:21:28.74,0:21:31.40,Chinese,,0,0,0,,当早期的UNIX发行版问世时
Dialogue: 0,0:21:31.76,0:21:34.60,English,,0,0,0,,Where people just weren't worried about security vulnerabilities
Dialogue: 0,0:21:31.76,0:21:34.60,Chinese,,0,0,0,,人们只是不担心安全漏洞
Dialogue: 0,0:21:34.78,0:21:40.94,English,,0,0,0,,And they just assumed that if you allocated a big enough buffer
Dialogue: 0,0:21:34.78,0:21:40.94,Chinese,,0,0,0,,他们只是假设你分配了足够大的缓冲区
Dialogue: 0,0:21:41.32,0:21:46.44,English,,0,0,0,,That there's no reason why a string should be bigger than what you've allocated
Dialogue: 0,0:21:41.32,0:21:46.44,Chinese,,0,0,0,,没有理由为什么字符串应该大于你分配的字符串
Dialogue: 0,0:21:47.90,0:21:53.16,English,,0,0,0,,And that's actually true with other functions like strcpy
Dialogue: 0,0:21:47.90,0:21:53.16,Chinese,,0,0,0,,对于像strcpy这样的其他函数来说，这实际上是正确的
Dialogue: 0,0:21:53.68,0:21:58.80,English,,0,0,0,,You recall strcpy has two arguments
Dialogue: 0,0:21:53.68,0:21:58.80,Chinese,,0,0,0,,你记得strcpy有两个参数
Dialogue: 0,0:21:59.40,0:22:02.86,English,,0,0,0,,Excuse me a destination and a source
Dialogue: 0,0:21:59.40,0:22:02.86,Chinese,,0,0,0,,对不起，目的地和来源
Dialogue: 0,0:22:03.78,0:22:08.64,English,,0,0,0,,And its purpose is to copy the string at the source into the destination
Dialogue: 0,0:22:03.78,0:22:08.64,Chinese,,0,0,0,,其目的是将源头处的字符串复制到目的地
Dialogue: 0,0:22:09.08,0:22:13.14,English,,0,0,0,,And the way it determines the end of the string and the source is when it hits a null character
Dialogue: 0,0:22:09.08,0:22:13.14,Chinese,,0,0,0,,它确定字符串结束的方式和源是它命中空字符的方式
Dialogue: 0,0:22:13.60,0:22:17.86,English,,0,0,0,,That just keeps copying one by one well until it hits it
Dialogue: 0,0:22:13.60,0:22:17.86,Chinese,,0,0,0,,这只是一个接一个地复制，直到它击中它
Dialogue: 0,0:22:18.10,0:22:22.38,English,,0,0,0,,But it has no way of knowing there's nothing no information there about how much
Dialogue: 0,0:22:18.10,0:22:22.38,Chinese,,0,0,0,,但它无法知道没有任何关于多少信息的信息
Dialogue: 0,0:22:22.76,0:22:27.38,English,,0,0,0,,How big is the the buffer allocated at the destination
Dialogue: 0,0:22:22.76,0:22:27.38,Chinese,,0,0,0,,在目的地分配的缓冲区有多大
Dialogue: 0,0:22:27.70,0:22:29.66,English,,0,0,0,,And so it can easily overrun that
Dialogue: 0,0:22:27.70,0:22:29.66,Chinese,,0,0,0,,所以它很容易超支
Dialogue: 0,0:22:29.92,0:22:36.66,English,,0,0,0,,That a similar one called strcat which is used to concatenate two strings copy another destination
Dialogue: 0,0:22:29.92,0:22:36.66,Chinese,,0,0,0,,类似的一个名为strcat，用于连接两个字符串复制另一个目标
Dialogue: 0,0:22:37.34,0:22:44.30,English,,0,0,0,,And the scanf functions also have possible in the format string
Dialogue: 0,0:22:37.34,0:22:44.30,Chinese,,0,0,0,,scanf函数也可以在格式字符串中使用
Dialogue: 0,0:22:44.30,0:22:46.06,English,,0,0,0,,You can give the %s
Dialogue: 0,0:22:44.30,0:22:46.06,Chinese,,0,0,0,,你可以给％s
Dialogue: 0,0:22:46.82,0:22:52.84,English,,0,0,0,,A directive to the format string which says read in a string and store it someplace
Dialogue: 0,0:22:46.82,0:22:52.84,Chinese,,0,0,0,,指向格式字符串的指令，该字符串表示读取字符串并将其存储在某个位置
Dialogue: 0,0:22:53.56,0:22:56.74,English,,0,0,0,,And it doesn't say how long the string is limited to be
Dialogue: 0,0:22:53.56,0:22:56.74,Chinese,,0,0,0,,并且它没有说明字符串被限制为多长时间
Dialogue: 0,0:22:56.74,0:23:00.52,English,,0,0,0,,And it doesn't say how much memory is available at the destination
Dialogue: 0,0:22:56.74,0:23:00.52,Chinese,,0,0,0,,并没有说目的地有多少内存可用
Dialogue: 0,0:23:00.78,0:23:04.52,English,,0,0,0,,So again it can easily just write over that a buffer
Dialogue: 0,0:23:00.78,0:23:04.52,Chinese,,0,0,0,,因此，它可以轻松地写入缓冲区
Dialogue: 0,0:23:05.72,0:23:10.84,English,,0,0,0,,So these are real vulnerabilities and they we'll talk in a minute a little later about
Dialogue: 0,0:23:05.72,0:23:10.84,Chinese,,0,0,0,,所以这些都是真正的漏洞，我们稍后会谈一会儿
Dialogue: 0,0:23:11.22,0:23:14.74,English,,0,0,0,,How you as a programmer can be a little smarter than this
Dialogue: 0,0:23:11.22,0:23:14.74,Chinese,,0,0,0,,作为一名程序员，你如何比这更聪明
Dialogue: 0,0:23:15.12,0:23:22.50,English,,0,0,0,,But in their suit of raw form as presented they have this vulnerability to them
Dialogue: 0,0:23:15.12,0:23:22.50,Chinese,,0,0,0,,但是在他们提出的原始形式的诉讼中，他们对他们有这种脆弱性
Dialogue: 0,0:23:23.68,0:23:29.30,English,,0,0,0,,So let's look at an example of what this can...what can happen there
Dialogue: 0,0:23:23.68,0:23:29.30,Chinese,,0,0,0,,那么让我们看一下这可以做什么的例子......那里会发生什么
Dialogue: 0,0:23:29.74,0:23:34.96,English,,0,0,0,,So imagine for example we want a to implement echo function
Dialogue: 0,0:23:29.74,0:23:34.96,Chinese,,0,0,0,,所以想象一下，例如我们想要实现echo函数
Dialogue: 0,0:23:34.96,0:23:40.02,English,,0,0,0,,So an echo function is one that you just type something in and prints it back out
Dialogue: 0,0:23:34.96,0:23:40.02,Chinese,,0,0,0,,因此，echo函数是你只需输入内容并将其打印出来的函数
Dialogue: 0,0:23:40.02,0:23:43.80,English,,0,0,0,,It's very uninteresting function except it's very useful to demonstrate things
Dialogue: 0,0:23:40.02,0:23:43.80,Chinese,,0,0,0,,这是非常无趣的功能，除了它展示事物非常有用
Dialogue: 0,0:23:44.58,0:23:49.32,English,,0,0,0,,So the idea is it has this little buffer it's only enough to hold four characters
Dialogue: 0,0:23:44.58,0:23:49.32,Chinese,,0,0,0,,所以这个想法是它有这个小缓冲区，它只能容纳四个字符
Dialogue: 0,0:23:49.78,0:23:55.44,English,,0,0,0,,Because get us to read a string from the input and then it calls puts
Dialogue: 0,0:23:49.78,0:23:55.44,Chinese,,0,0,0,,因为让我们从输入中读取一个字符串然后调用puts
Dialogue: 0,0:23:56.06,0:23:59.78,English,,0,0,0,,Which simply writes back out the output
Dialogue: 0,0:23:56.06,0:23:59.78,Chinese,,0,0,0,,这只是简单地写回输出
Dialogue: 0,0:24:00.80,0:24:01.58,English,,0,0,0,,And
Dialogue: 0,0:24:00.80,0:24:01.58,Chinese,,0,0,0,,和
Dialogue: 0,0:24:09.38,0:24:14.06,English,,0,0,0,,And so let me just demo this not very interesting function
Dialogue: 0,0:24:09.38,0:24:14.06,Chinese,,0,0,0,,所以让我演示这个不是很有趣的功能
Dialogue: 0,0:24:21.14,0:24:24.98,English,,0,0,0,,So I call here buffdemo-nsp
Dialogue: 0,0:24:21.14,0:24:24.98,Chinese,,0,0,0,,所以我在这里叫buffdemo-nsp
Dialogue: 0,0:24:26.74,0:24:31.04,English,,0,0,0,,Meaning as no stack protector we'll see in a minute what a stack protector is
Dialogue: 0,0:24:26.74,0:24:31.04,Chinese,,0,0,0,,意思是没有堆栈保护器我们会在一分钟内看到堆栈保护器是什么
Dialogue: 0,0:24:31.46,0:24:35.60,English,,0,0,0,,But you see if you type a reasonably strong small string
Dialogue: 0,0:24:31.46,0:24:35.60,Chinese,,0,0,0,,但是你看是否输入了一个相当强大的小字符串
Dialogue: 0,0:24:41.92,0:24:47.08,English,,0,0,0,,Let's see what remember it can handle more than four
Dialogue: 0,0:24:41.92,0:24:47.08,Chinese,,0,0,0,,让我们看看它能处理四个以上的东西
Dialogue: 0,0:24:48.04,0:24:50.98,English,,0,0,0,,Actually as written it can't handle more than three right
Dialogue: 0,0:24:48.04,0:24:50.98,Chinese,,0,0,0,,实际上，正如所写，它不能处理超过三个权利
Dialogue: 0,0:24:50.98,0:24:55.26,English,,0,0,0,,Because there should be room for the null character to on terminator
Dialogue: 0,0:24:50.98,0:24:55.26,Chinese,,0,0,0,,因为在终结符上应该有空字符的空间
Dialogue: 0,0:25:02.00,0:25:07.92,English,,0,0,0,,So it turns out with this particular one if I type in a string of 24 characters
Dialogue: 0,0:25:02.00,0:25:07.92,Chinese,,0,0,0,,因此，如果我输入一个包含24个字符的字符串，则会发现这个特定的一个
Dialogue: 0,0:25:09.72,0:25:11.04,English,,0,0,0,,It'll be okay
Dialogue: 0,0:25:09.72,0:25:11.04,Chinese,,0,0,0,,没关系
Dialogue: 0,0:25:22.36,0:25:24.86,English,,0,0,0,,But if I type in a string of 24 characters
Dialogue: 0,0:25:22.36,0:25:24.86,Chinese,,0,0,0,,但是如果我输入一个24个字符的字符串
Dialogue: 0,0:25:27.52,0:25:30.02,English,,0,0,0,,It will hit a segmentation fault
Dialogue: 0,0:25:27.52,0:25:30.02,Chinese,,0,0,0,,它会遇到分段错误
Dialogue: 0,0:25:33.12,0:25:35.90,English,,0,0,0,,So where do those numbers 23 and 24 come in
Dialogue: 0,0:25:33.12,0:25:35.90,Chinese,,0,0,0,,那么23号和24号的位置在哪里呢？
Dialogue: 0,0:25:35.90,0:25:39.04,English,,0,0,0,,Well that's something we can learn by looking at the assembly code
Dialogue: 0,0:25:35.90,0:25:39.04,Chinese,,0,0,0,,那么我们可以通过查看汇编代码来学习
Dialogue: 0,0:25:56.22,0:25:59.18,English,,0,0,0,,So here's and we'll go through this code
Dialogue: 0,0:25:56.22,0:25:59.18,Chinese,,0,0,0,,所以这里，我们将通过这段代码
Dialogue: 0,0:26:00.08,0:26:04.70,English,,0,0,0,,So first of all, this is the code for echo then
Dialogue: 0,0:26:00.08,0:26:04.70,Chinese,,0,0,0,,首先，这是echo的代码
Dialogue: 0,0:26:05.58,0:26:09.18,English,,0,0,0,,And you see the echo calls gets and it calls puts
Dialogue: 0,0:26:05.58,0:26:09.18,Chinese,,0,0,0,,你看到echo调用得到它并调用puts
Dialogue: 0,0:26:13.34,0:26:19.56,English,,0,0,0,,And here's the part of the code where you can tell how much memory got allocated for the buffer
Dialogue: 0,0:26:13.34,0:26:19.56,Chinese,,0,0,0,,这里是代码的一部分，你可以告诉我们为缓冲区分配了多少内存
Dialogue: 0,0:26:20.06,0:26:29.34,English,,0,0,0,,And 0x18 is what in decimal
Dialogue: 0,0:26:20.06,0:26:29.34,Chinese,,0,0,0,,而0x18是十进制的
Dialogue: 0,0:26:34.04,0:26:34.98,English,,0,0,0,,24 right?
Dialogue: 0,0:26:34.04,0:26:34.98,Chinese,,0,0,0,,24对吗？
Dialogue: 0,0:26:39.64,0:26:45.54,English,,0,0,0,,And just saw that the thing actually segfaults with a input string of 24
Dialogue: 0,0:26:39.64,0:26:45.54,Chinese,,0,0,0,,只是看到这个东西实际上是一个输入字符串为24的段错误
Dialogue: 0,0:26:45.54,0:26:46.60,English,,0,0,0,,So we'll see that in a minute
Dialogue: 0,0:26:45.54,0:26:46.60,Chinese,,0,0,0,,所以我们会在一分钟内看到
Dialogue: 0,0:26:47.50,0:26:55.28,English,,0,0,0,,But anyways you can see here that it's allocating on the stack a region of 24 bytes
Dialogue: 0,0:26:47.50,0:26:55.28,Chinese,,0,0,0,,但无论如何你可以在这里看到它在堆栈上分配一个24字节的区域
Dialogue: 0,0:26:56.00,0:27:04.14,English,,0,0,0,,And it's copying that into %rdi which is of course the argument for gets
Dialogue: 0,0:26:56.00,0:27:04.14,Chinese,,0,0,0,,它正在将其复制到％rdi中，这当然是获取的参数
Dialogue: 0,0:27:04.20,0:27:12.76,English,,0,0,0,,So gets is being called with a pointer to a buffer of size 24 of maximum 24
Dialogue: 0,0:27:04.20,0:27:12.76,Chinese,,0,0,0,,因此，使用指向最大24的大小为24的缓冲区的指针调用gets
Dialogue: 0,0:27:12.80,0:27:16.62,English,,0,0,0,,Or even though you saw the original declaration was just four
Dialogue: 0,0:27:12.80,0:27:16.62,Chinese,,0,0,0,,或者即使你看到原始声明只有四个
Dialogue: 0,0:27:20.20,0:27:25.84,English,,0,0,0,,Um and then it calls gets and then gets does it thing
Dialogue: 0,0:27:20.20,0:27:25.84,Chinese,,0,0,0,,嗯然后它调用得到然后得到它做的事情
Dialogue: 0,0:27:26.44,0:27:30.10,English,,0,0,0,,And just one last little bit to keep in mind is
Dialogue: 0,0:27:26.44,0:27:30.10,Chinese,,0,0,0,,最后一点要记住的是
Dialogue: 0,0:27:31.16,0:27:32.72,English,,0,0,0,,We'll get back to them
Dialogue: 0,0:27:31.16,0:27:32.72,Chinese,,0,0,0,,我们会回复他们
Dialogue: 0,0:27:33.14,0:27:36.10,English,,0,0,0,,Oh yes and remember echo
Dialogue: 0,0:27:33.14,0:27:36.10,Chinese,,0,0,0,,哦，是的，记得回声
Dialogue: 0,0:27:38.36,0:27:42.74,English,,0,0,0,,I there's a function called call_echo which is the thing that calls echo
Dialogue: 0,0:27:38.36,0:27:42.74,Chinese,,0,0,0,,我有一个名为call_echo的函数，它调用echo
Dialogue: 0,0:27:43.46,0:27:48.84,English,,0,0,0,,And just to keep in mind this red is the return address  for call_echo
Dialogue: 0,0:27:43.46,0:27:48.84,Chinese,,0,0,0,,并且要记住这个红色是call_echo的返回地址
Dialogue: 0,0:27:49.94,0:27:51.88,English,,0,0,0,,And that's going to be important
Dialogue: 0,0:27:49.94,0:27:51.88,Chinese,,0,0,0,,这将是重要的
Dialogue: 0,0:27:55.94,0:27:59.66,English,,0,0,0,,So what we see then is the memory layout is
Dialogue: 0,0:27:55.94,0:27:59.66,Chinese,,0,0,0,,所以我们看到的是内存布局
Dialogue: 0,0:28:01.22,0:28:05.86,English,,0,0,0,,The buff is normally big enough for four characters
Dialogue: 0,0:28:01.22,0:28:05.86,Chinese,,0,0,0,,buff通常足以容纳四个字符
Dialogue: 0,0:28:06.58,0:28:10.60,English,,0,0,0,,There's a sort of 20 bytes of unused or wasted space here
Dialogue: 0,0:28:06.58,0:28:10.60,Chinese,,0,0,0,,这里有20个字节的未使用或浪费的空间
Dialogue: 0,0:28:10.96,0:28:17.86,English,,0,0,0,,And then the actual return address which is the return address for back to call_echo is stored on the stack
Dialogue: 0,0:28:10.96,0:28:17.86,Chinese,,0,0,0,,然后将实际返回地址（返回call_echo的返回地址）存储在堆栈中
Dialogue: 0,0:28:23.56,0:28:28.80,English,,0,0,0,,So when this program begins running when echo starts to run
Dialogue: 0,0:28:23.56,0:28:28.80,Chinese,,0,0,0,,所以当这个程序开始运行时，echo开始运行
Dialogue: 0,0:28:29.12,0:28:34.38,English,,0,0,0,,We'll find that this is the value on the stack for the return pointer
Dialogue: 0,0:28:29.12,0:28:34.38,Chinese,,0,0,0,,我们会发现这是返回指针的堆栈值
Dialogue: 0,0:28:35.98,0:28:43.04,English,,0,0,0,,And if we type in a string of up here of 23 characters
Dialogue: 0,0:28:35.98,0:28:43.04,Chinese,,0,0,0,,如果我们输入一个23个字符的字符串
Dialogue: 0,0:28:43.88,0:28:50.22,English,,0,0,0,,You'll see that it uses up this entire buffer and remember a string is terminated with 00
Dialogue: 0,0:28:43.88,0:28:50.22,Chinese,,0,0,0,,你会看到它耗尽了整个缓冲区并记住字符串以00结尾
Dialogue: 0,0:28:51.10,0:28:57.40,English,,0,0,0,,But it still hasn't...it's still within the region that was allocated on the stack for that
Dialogue: 0,0:28:51.10,0:28:57.40,Chinese,,0,0,0,,但它仍然没有...它仍然在为堆栈分配的区域内
Dialogue: 0,0:28:57.48,0:29:01.60,English,,0,0,0,,So it just barely fits into the the stack
Dialogue: 0,0:28:57.48,0:29:01.60,Chinese,,0,0,0,,所以它几乎不适合堆栈
Dialogue: 0,0:29:02.18,0:29:06.20,English,,0,0,0,,And that's why we technically we overflowed the buffer
Dialogue: 0,0:29:02.18,0:29:06.20,Chinese,,0,0,0,,这就是为什么我们在技术上会溢出缓冲区
Dialogue: 0,0:29:06.20,0:29:10.40,English,,0,0,0,,But we didn't really cause any harm because there was this extra space available
Dialogue: 0,0:29:06.20,0:29:10.40,Chinese,,0,0,0,,但是我们并没有真正造成任何伤害，因为有这个额外的空间可用
Dialogue: 0,0:29:11.38,0:29:17.96,English,,0,0,0,,And so that's why I could type in that string of 23 characters and it worked fine
Dialogue: 0,0:29:11.38,0:29:17.96,Chinese,,0,0,0,,这就是为什么我可以键入23个字符的字符串，它工作正常
Dialogue: 0,0:29:18.98,0:29:20.36,English,,0,0,0,,But now if I type in...
Dialogue: 0,0:29:18.98,0:29:20.36,Chinese,,0,0,0,,但现在如果我输入...
Dialogue: 0,0:29:21.76,0:29:23.92,English,,0,0,0,,This is an example showing...
Dialogue: 0,0:29:21.76,0:29:23.92,Chinese,,0,0,0,,这是一个显示......的例子
Dialogue: 0,0:29:29.44,0:29:31.12,English,,0,0,0,,I actually 25 characters
Dialogue: 0,0:29:29.44,0:29:31.12,Chinese,,0,0,0,,我实际上是25个字符
Dialogue: 0,0:29:32.74,0:29:40.14,English,,0,0,0,,So once I go beyond the 23 characters plus the null character you'll see
Dialogue: 0,0:29:32.74,0:29:40.14,Chinese,,0,0,0,,所以，一旦我超越了23个字符加上你将看到的空字符
Dialogue: 0,0:29:40.14,0:29:49.72,English,,0,0,0,,what I'm slowly starting to do is corrupt the the the byte representation of the return address
Dialogue: 0,0:29:40.14,0:29:49.72,Chinese,,0,0,0,,我正在慢慢开始做的是破坏返回地址的字节表示
Dialogue: 0,0:29:50.38,0:29:52.64,English,,0,0,0,,And so what happens for example here
Dialogue: 0,0:29:50.38,0:29:52.64,Chinese,,0,0,0,,所以这里发生了什么
Dialogue: 0,0:29:53.00,0:30:00.98,English,,0,0,0,,Is that rather than trying to return back to the where call_echo was supposed to where it was supposed to go back to
Dialogue: 0,0:29:53.00,0:30:00.98,Chinese,,0,0,0,,是不是试图回到call_echo所应该回到的地方
Dialogue: 0,0:30:01.32,0:30:03.74,English,,0,0,0,,It goes back to some other part of your code
Dialogue: 0,0:30:01.32,0:30:03.74,Chinese,,0,0,0,,它可以追溯到代码的其他部分
Dialogue: 0,0:30:04.20,0:30:08.08,English,,0,0,0,,That may or may not be a valid address or
Dialogue: 0,0:30:04.20,0:30:08.08,Chinese,,0,0,0,,这可能是也可能不是有效的地址或
Dialogue: 0,0:30:08.22,0:30:11.00,English,,0,0,0,,Might not have anything to do with the program you're trying to run
Dialogue: 0,0:30:08.22,0:30:11.00,Chinese,,0,0,0,,可能与你尝试运行的程序无关
Dialogue: 0,0:30:12.56,0:30:16.56,English,,0,0,0,,So this example shows it and if I typed in the 24
Dialogue: 0,0:30:12.56,0:30:16.56,Chinese,,0,0,0,,所以这个例子显示了它，如果我输入24
Dialogue: 0,0:30:22.10,0:30:26.04,English,,0,0,0,,Let's see...before I got it to run
Dialogue: 0,0:30:22.10,0:30:26.04,Chinese,,0,0,0,,在我开始运行之前，让我们看看......
Dialogue: 0,0:30:26.04,0:30:29.94,English,,0,0,0,,Like this you know this thing depends on the what happens
Dialogue: 0,0:30:26.04,0:30:29.94,Chinese,,0,0,0,,像这样你知道这件事取决于发生了什么
Dialogue: 0,0:30:31.04,0:30:33.48,English,,0,0,0,,How the code happens to get compiled
Dialogue: 0,0:30:31.04,0:30:33.48,Chinese,,0,0,0,,如何编译代码
Dialogue: 0,0:30:36.04,0:30:42.70,English,,0,0,0,,Oh yeah so okay, so actually you see here
Dialogue: 0,0:30:36.04,0:30:42.70,Chinese,,0,0,0,,哦，是的，所以你真的看到了这里
Dialogue: 0,0:30:43.90,0:30:49.12,English,,0,0,0,,This first string I typed is actually 24 characters long plus the null pointer
Dialogue: 0,0:30:43.90,0:30:49.12,Chinese,,0,0,0,,我输入的第一个字符串实际上是24个字符加上空指针
Dialogue: 0,0:30:49.80,0:30:54.12,English,,0,0,0,,So uh and we'll see why it didn't...it should have crashed
Dialogue: 0,0:30:49.80,0:30:54.12,Chinese,,0,0,0,,所以呃，我们会明白为什么它没有......它应该崩溃了
Dialogue: 0,0:30:54.38,0:30:58.86,English,,0,0,0,,Because we actually overwrite wrote the low order byte of the return address
Dialogue: 0,0:30:54.38,0:30:58.86,Chinese,,0,0,0,,因为我们实际上覆盖了写入返回地址的低位字节
Dialogue: 0,0:30:59.68,0:31:02.10,English,,0,0,0,,Here we typed in this is 25 characters
Dialogue: 0,0:30:59.68,0:31:02.10,Chinese,,0,0,0,,这里我们输入的是25个字符
Dialogue: 0,0:31:02.10,0:31:07.46,English,,0,0,0,,And so that's the one I just showed where it really whacked the two bytes of the return address
Dialogue: 0,0:31:02.10,0:31:07.46,Chinese,,0,0,0,,这就是我刚才展示的那个它真正打击了返回地址的两个字节的地方
Dialogue: 0,0:31:08.02,0:31:10.22,English,,0,0,0,,So here we actually did overflow the buffer
Dialogue: 0,0:31:08.02,0:31:10.22,Chinese,,0,0,0,,所以这里我们确实溢出了缓冲区
Dialogue: 0,0:31:11.24,0:31:17.22,English,,0,0,0,,And let's try and figure out why that didn't harm the the program execution
Dialogue: 0,0:31:11.24,0:31:17.22,Chinese,,0,0,0,,让我们试着弄清楚为什么这不会损害程序的执行
Dialogue: 0,0:31:17.22,0:31:18.20,English,,0,0,0,,I see a question
Dialogue: 0,0:31:17.22,0:31:18.20,Chinese,,0,0,0,,我看到一个问题
Dialogue: 0,0:31:18.20,0:31:22.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:18.20,0:31:22.78,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:31:22.78,0:31:25.58,English,,0,0,0,,Yes it could have been various other things could have there's nothing
Dialogue: 0,0:31:22.78,0:31:25.58,Chinese,,0,0,0,,是的它可能是其他各种事情可能没有什么
Dialogue: 0,0:31:26.26,0:31:28.68,English,,0,0,0,,It hit a segmentation fault
Dialogue: 0,0:31:26.26,0:31:28.68,Chinese,,0,0,0,,它遇到了分段错误
Dialogue: 0,0:31:28.98,0:31:33.14,English,,0,0,0,,It probably went to some weird part of the code and just started executing some random stuff
Dialogue: 0,0:31:28.98,0:31:33.14,Chinese,,0,0,0,,它可能去了一些奇怪的代码部分，并开始执行一些随机的东西
Dialogue: 0,0:31:33.48,0:31:35.14,English,,0,0,0,,And just got itself into trouble
Dialogue: 0,0:31:33.48,0:31:35.14,Chinese,,0,0,0,,然后就陷入了麻烦
Dialogue: 0,0:31:35.58,0:31:40.48,English,,0,0,0,,But that's the point is it's not predictable exactly what will happen when you do this
Dialogue: 0,0:31:35.58,0:31:40.48,Chinese,,0,0,0,,但重点是，当你这样做时，确切地说会发生什么是不可预测的
Dialogue: 0,0:31:52.40,0:31:56.10,English,,0,0,0,,So this is that the example of what actually happened the first time
Dialogue: 0,0:31:52.40,0:31:56.10,Chinese,,0,0,0,,所以这就是第一次实际发生的事例
Dialogue: 0,0:31:56.42,0:31:59.84,English,,0,0,0,,When I typed in a string that had 24 characters
Dialogue: 0,0:31:56.42,0:31:59.84,Chinese,,0,0,0,,当我输入一个包含24个字符的字符串时
Dialogue: 0,0:32:00.24,0:32:04.02,English,,0,0,0,,And so this null byte at the end actually corrupted the return address
Dialogue: 0,0:32:00.24,0:32:04.02,Chinese,,0,0,0,,所以最后这个空字节实际上破坏了返回地址
Dialogue: 0,0:32:05.68,0:32:12.30,English,,0,0,0,,And so it was supposed to return back to this address 0x4006f6
Dialogue: 0,0:32:05.68,0:32:12.30,Chinese,,0,0,0,,所以它应该返回到这个地址0x4006f6
Dialogue: 0,0:32:12.92,0:32:16.98,English,,0,0,0,,And instead it will return back to the address 0x400600
Dialogue: 0,0:32:12.92,0:32:16.98,Chinese,,0,0,0,,而它将返回到地址0x400600
Dialogue: 0,0:32:18.04,0:32:21.64,English,,0,0,0,,Which happens to be in some other weird function that's there
Dialogue: 0,0:32:18.04,0:32:21.64,Chinese,,0,0,0,,这恰好出现在其他一些奇怪的功能中
Dialogue: 0,0:32:21.94,0:32:26.16,English,,0,0,0,,And it just sort of landed at some place here
Dialogue: 0,0:32:21.94,0:32:26.16,Chinese,,0,0,0,,它只是落在这里的某个地方
Dialogue: 0,0:32:26.16,0:32:33.28,English,,0,0,0,,And it's doing various things but somehow it didn't really (didn't) crash the program
Dialogue: 0,0:32:26.16,0:32:33.28,Chinese,,0,0,0,,它正在做各种各样的事情，但不知何故，它并没有真正（没有）使程序崩溃
Dialogue: 0,0:32:33.28,0:32:38.62,English,,0,0,0,,And that's one of the frustrating things about this is that things can go wrong in a program
Dialogue: 0,0:32:33.28,0:32:38.62,Chinese,,0,0,0,,而这令人沮丧的事情之一是，程序中的事情可能会出错
Dialogue: 0,0:32:39.12,0:32:41.80,English,,0,0,0,,And they don't always cause a crash
Dialogue: 0,0:32:39.12,0:32:41.80,Chinese,,0,0,0,,而且他们并不总是导致崩溃
Dialogue: 0,0:32:42.14,0:32:47.36,English,,0,0,0,,And so often a bug that's working there might be doing some weird stuff that you don't even know about
Dialogue: 0,0:32:42.14,0:32:47.36,Chinese,,0,0,0,,因此，经常在那里工作的bug可能会做一些你甚至不知道的奇怪的东西
Dialogue: 0,0:32:51.44,0:32:56.90,English,,0,0,0,,So that's all a fine if it's just a way of crashing programs and
Dialogue: 0,0:32:51.44,0:32:56.90,Chinese,,0,0,0,,如果它只是一种崩溃程序的方式，那就没关系了
Dialogue: 0,0:32:57.26,0:33:01.54,English,,0,0,0,,I mean that's not great if it's controlling your pacemaker or something like that
Dialogue: 0,0:32:57.26,0:33:01.54,Chinese,,0,0,0,,我的意思是，如果它控制你的心脏起搏器或类似的东西，那就不好了
Dialogue: 0,0:33:01.54,0:33:08.42,English,,0,0,0,,But if it's just a homework assignment it's like not a big deal so
Dialogue: 0,0:33:01.54,0:33:08.42,Chinese,,0,0,0,,但如果它只是一个家庭作业，那就不是什么大不了的事了
Dialogue: 0,0:33:10.46,0:33:15.78,English,,0,0,0,,But what actually and this is sort of only happened since
Dialogue: 0,0:33:10.46,0:33:15.78,Chinese,,0,0,0,,但事实上，这种情况只发生在那之后
Dialogue: 0,0:33:16.00,0:33:22.22,English,,0,0,0,,Attacking became a normal activity which has only been the last 30 years
Dialogue: 0,0:33:16.00,0:33:22.22,Chinese,,0,0,0,,攻击成为一种正常活动，仅仅是过去30年
Dialogue: 0,0:33:22.62,0:33:32.48,English,,0,0,0,,Is that it gives an opportunity for a hacker or a attacker to inject code into the program and execute it
Dialogue: 0,0:33:22.62,0:33:32.48,Chinese,,0,0,0,,是否为黑客或攻击者提供了将代码注入程序并执行它的机会
Dialogue: 0,0:33:32.48,0:33:35.52,English,,0,0,0,,And that's what's called a code injection attack
Dialogue: 0,0:33:32.48,0:33:35.52,Chinese,,0,0,0,,这就是所谓的代码注入攻击
Dialogue: 0,0:33:36.34,0:33:43.18,English,,0,0,0,,And so that the general scheme of it is I have this buffer that I can fill up with whatever bytes I want
Dialogue: 0,0:33:36.34,0:33:43.18,Chinese,,0,0,0,,因此，它的一般方案是我有这个缓冲区，我可以填写我想要的任何字节
Dialogue: 0,0:33:43.52,0:33:47.68,English,,0,0,0,,By feeding them to gets or whatever function is doing this copying
Dialogue: 0,0:33:43.52,0:33:47.68,Chinese,,0,0,0,,通过喂他们获取或任何功能正在进行此复制
Dialogue: 0,0:33:48.00,0:33:51.36,English,,0,0,0,,And what I can do then is set up and pass to it
Dialogue: 0,0:33:48.00,0:33:51.36,Chinese,,0,0,0,,然后我可以做的就是设置并传递给它
Dialogue: 0,0:33:51.46,0:33:57.48,English,,0,0,0,,Some bytes of actually that encode an executable a little bit of executable code
Dialogue: 0,0:33:51.46,0:33:57.48,Chinese,,0,0,0,,实际上有些字节可编码可执行代码的一些可执行代码
Dialogue: 0,0:33:57.48,0:34:03.32,English,,0,0,0,,You've seen an object dump it's printing out these byte code representations of instructions
Dialogue: 0,0:33:57.48,0:34:03.32,Chinese,,0,0,0,,你已经看到了一个对象转储，它打印出这些指令的字节代码表示
Dialogue: 0,0:34:03.32,0:34:09.24,English,,0,0,0,,So imagine you fed some of those bytes into your string
Dialogue: 0,0:34:03.32,0:34:09.24,Chinese,,0,0,0,,所以想象一下，你把这些字节中的一些输入到字符串中
Dialogue: 0,0:34:09.26,0:34:11.90,English,,0,0,0,,You encoded them in the string that you pass to gets
Dialogue: 0,0:34:09.26,0:34:11.90,Chinese,,0,0,0,,你在传递给它的字符串中对它们进行了编码
Dialogue: 0,0:34:13.04,0:34:22.56,English,,0,0,0,,And then you might have to add some more sort of padding characters ,that characters whose value doesn't matter
Dialogue: 0,0:34:13.04,0:34:22.56,Chinese,,0,0,0,,然后你可能需要添加更多类型的填充字符，这些字符的值无关紧要
Dialogue: 0,0:34:23.03,0:34:30.14,English,,0,0,0,,In order to then get a number back into the position where the return pointer is supposed to be
Dialogue: 0,0:34:23.03,0:34:30.14,Chinese,,0,0,0,,然后将数字返回到返回指针所在的位置
Dialogue: 0,0:34:30.64,0:34:33.76,English,,0,0,0,,And so what's call that number B,it's going to be an address
Dialogue: 0,0:34:30.64,0:34:33.76,Chinese,,0,0,0,,所以叫做B号，它就是一个地址
Dialogue: 0,0:34:34.20,0:34:39.22,English,,0,0,0,,One of these ones with the you know that represents a stack location
Dialogue: 0,0:34:34.20,0:34:39.22,Chinese,,0,0,0,,其中一个与你知道代表堆栈位置的那些
Dialogue: 0,0:34:39.58,0:34:44.24,English,,0,0,0,,And that value B that is the the starting address of the buffer
Dialogue: 0,0:34:39.58,0:34:44.24,Chinese,,0,0,0,,而那个值B是缓冲区的起始地址
Dialogue: 0,0:34:44.72,0:34:53.20,English,,0,0,0,,Which happens to be where your exploit code remember this is just executable instructions or stored here
Dialogue: 0,0:34:44.72,0:34:53.20,Chinese,,0,0,0,,这恰好是你的漏洞利用代码记住这只是可执行指令或存储在此处的地方
Dialogue: 0,0:34:53.78,0:35:00.46,English,,0,0,0,,So now what will happen is when the program does its return here
Dialogue: 0,0:34:53.78,0:35:00.46,Chinese,,0,0,0,,所以现在将会发生什么，当程序在这里返回时
Dialogue: 0,0:35:01.54,0:35:06.12,English,,0,0,0,,It was supposed to return back to wherever it got called from P
Dialogue: 0,0:35:01.54,0:35:06.12,Chinese,,0,0,0,,它应该回到从P调用的任何地方
Dialogue: 0,0:35:11.18,0:35:14.58,English,,0,0,0,,This is a typo, P calls Q not the bar
Dialogue: 0,0:35:11.18,0:35:14.58,Chinese,,0,0,0,,这是一个错字，P称Q不是吧
Dialogue: 0,0:35:18.25,0:35:20.62,English,,0,0,0,,So it's supposed to return back to P
Dialogue: 0,0:35:18.25,0:35:20.62,Chinese,,0,0,0,,所以它应该回到P
Dialogue: 0,0:35:21.46,0:35:26.66,English,,0,0,0,,And we're and the address the return address was stored here
Dialogue: 0,0:35:21.46,0:35:26.66,Chinese,,0,0,0,,我们和返回地址的地址都存储在这里
Dialogue: 0,0:35:26.66,0:35:31.54,English,,0,0,0,,But now I've overwritten that return address  with this buffer position
Dialogue: 0,0:35:26.66,0:35:31.54,Chinese,,0,0,0,,但现在我用这个缓冲区位置覆盖了该返回地址
Dialogue: 0,0:35:31.54,0:35:37.40,English,,0,0,0,,So what will happen is the the program counter will happily jump to this bar
Dialogue: 0,0:35:31.54,0:35:37.40,Chinese,,0,0,0,,所以会发生什么是程序计数器会愉快地跳到这个栏
Dialogue: 0,0:35:37.40,0:35:43.04,English,,0,0,0,,And start executing whatever it encounters which are the instructions that you've inserted
Dialogue: 0,0:35:37.40,0:35:43.04,Chinese,,0,0,0,,并开始执行它遇到的任何内容，这些是你插入的指令
Dialogue: 0,0:35:43.70,0:35:51.70,English,,0,0,0,,And by that means then you can inject code into a machine potentially Somewhere else in the internet
Dialogue: 0,0:35:43.70,0:35:51.70,Chinese,,0,0,0,,通过这种方式，你可以将代码注入到可能位于互联网其他地方的计算机中
Dialogue: 0,0:35:51.70,0:35:53.72,English,,0,0,0,,If you could set up a scheme like this
Dialogue: 0,0:35:51.70,0:35:53.72,Chinese,,0,0,0,,如果你可以设置这样的方案
Dialogue: 0,0:35:53.72,0:35:58.28,English,,0,0,0,,That would feed these bytes into that machine
Dialogue: 0,0:35:53.72,0:35:58.28,Chinese,,0,0,0,,这会将这些字节输入该机器
Dialogue: 0,0:35:58.54,0:36:01.06,English,,0,0,0,,And it would read it in with a function like gets
Dialogue: 0,0:35:58.54,0:36:01.06,Chinese,,0,0,0,,并且它会使用像gets这样的函数来读取它
Dialogue: 0,0:36:01.44,0:36:05.28,English,,0,0,0,,And then it would try to do its return but it would start executing your code
Dialogue: 0,0:36:01.44,0:36:05.28,Chinese,,0,0,0,,然后它会尝试返回但它会开始执行你的代码
Dialogue: 0,0:36:06.22,0:36:09.24,English,,0,0,0,,So that's a classic code injection attack
Dialogue: 0,0:36:06.22,0:36:09.24,Chinese,,0,0,0,,这是一个典型的代码注入攻击
Dialogue: 0,0:36:09.54,0:36:14.36,English,,0,0,0,,And in fact in this lab that you're going to start,comes out at midnight
Dialogue: 0,0:36:09.54,0:36:14.36,Chinese,,0,0,0,,事实上，在你即将开始的这个实验室中，午夜时分出来
Dialogue: 0,0:36:14.68,0:36:24.50,English,,0,0,0,,It's called the attack lab because you're going to do this yourself for part of the lab
Dialogue: 0,0:36:14.68,0:36:24.50,Chinese,,0,0,0,,它被称为攻击实验室，因为你将自己为实验室的一部分做这件事
Dialogue: 0,0:36:25.06,0:36:26.80,English,,0,0,0,,I think you'll find it pretty interesting
Dialogue: 0,0:36:25.06,0:36:26.80,Chinese,,0,0,0,,我想你会发现它非常有趣
Dialogue: 0,0:36:31.64,0:36:35.20,English,,0,0,0,,So this used to be a huge problem on programs
Dialogue: 0,0:36:31.64,0:36:35.20,Chinese,,0,0,0,,所以这曾经是程序上的一个大问题
Dialogue: 0,0:36:35.20,0:36:46.44,English,,0,0,0,,-yes-so when you're trying to replace read how do you make sure that your new submitted read provides that exact line
Dialogue: 0,0:36:35.20,0:36:46.44,Chinese,,0,0,0,,-yes-所以当你试图替换读取时如何确保新提交的读取提供了确切的行
Dialogue: 0,0:36:46.46,0:36:49.04,English,,0,0,0,,Well that's part of the cleverness of being a hacker
Dialogue: 0,0:36:46.46,0:36:49.04,Chinese,,0,0,0,,那就是成为黑客的聪明之处
Dialogue: 0,0:36:49.70,0:36:51.92,English,,0,0,0,,You have to make sure it's in the right spot
Dialogue: 0,0:36:49.70,0:36:51.92,Chinese,,0,0,0,,你必须确保它在正确的位置
Dialogue: 0,0:36:51.92,0:36:54.40,English,,0,0,0,,But it's that's actually one of the easier parts
Dialogue: 0,0:36:51.92,0:36:54.40,Chinese,,0,0,0,,但它实际上是更容易的部分之一
Dialogue: 0,0:36:54.98,0:37:03.72,English,,0,0,0,,Because for example you have to know the binary code To be able to do this or be able to guess
Dialogue: 0,0:36:54.98,0:37:03.72,Chinese,,0,0,0,,因为例如你必须知道二进制代码才能做到这一点或能够猜测
Dialogue: 0,0:37:04.44,0:37:09.44,English,,0,0,0,,So for example in that previous one I could tell that it was allocating 24 bytes for that buffer
Dialogue: 0,0:37:04.44,0:37:09.44,Chinese,,0,0,0,,所以例如在前一个我可以告诉它为该缓冲区分配24个字节
Dialogue: 0,0:37:10.20,0:37:15.58,English,,0,0,0,,And so if I just made sure that the length of my exploit code plus the padding is 24 bytes
Dialogue: 0,0:37:10.20,0:37:15.58,Chinese,,0,0,0,,因此，如果我确保我的漏洞利用代码的长度加上填充是24字节
Dialogue: 0,0:37:16.30,0:37:18.96,English,,0,0,0,,Then right after that comes the return address
Dialogue: 0,0:37:16.30,0:37:18.96,Chinese,,0,0,0,,然后就在那之后返回地址
Dialogue: 0,0:37:18.96,0:37:20.60,English,,0,0,0,,So that's actually pretty easy to do
Dialogue: 0,0:37:18.96,0:37:20.60,Chinese,,0,0,0,,所以这实际上很容易做到
Dialogue: 0,0:37:20.60,0:37:22.80,English,,0,0,0,,There was certainly how much memory program is that
Dialogue: 0,0:37:20.60,0:37:22.80,Chinese,,0,0,0,,肯定有多少内存程序
Dialogue: 0,0:37:22.80,0:37:29.72,English,,0,0,0,,No you have to have access,you have to know what the reason why this works is
Dialogue: 0,0:37:22.80,0:37:29.72,Chinese,,0,0,0,,不，你必须有访问权限，你必须知道它的工作原因是什么
Dialogue: 0,0:37:30.84,0:37:35.90,English,,0,0,0,,It works if you have enough knowledge about the operating system that's running at the other end
Dialogue: 0,0:37:30.84,0:37:35.90,Chinese,,0,0,0,,如果你对在另一端运行的操作系统有足够的了解，它就可以工作
Dialogue: 0,0:37:36.30,0:37:37.84,English,,0,0,0,,For example you know it's Linux
Dialogue: 0,0:37:36.30,0:37:37.84,Chinese,,0,0,0,,例如，你知道它是Linux
Dialogue: 0,0:37:38.18,0:37:44.10,English,,0,0,0,,You know that you can look at you know what GCC tends to allocate for
Dialogue: 0,0:37:38.18,0:37:44.10,Chinese,,0,0,0,,你知道你可以看看你知道GCC倾向于分配什么
Dialogue: 0,0:37:44.10,0:37:47.40,English,,0,0,0,,It you somehow have access to information about the code itself
Dialogue: 0,0:37:44.10,0:37:47.40,Chinese,,0,0,0,,它以某种方式可以访问有关代码本身的信息
Dialogue: 0,0:37:48.18,0:37:50.14,English,,0,0,0,,Let's you do this
Dialogue: 0,0:37:48.18,0:37:50.14,Chinese,,0,0,0,,我们你这样做
Dialogue: 0,0:37:56.48,0:37:59.14,English,,0,0,0,,Oh so anyways this used to be a huge problem
Dialogue: 0,0:37:56.48,0:37:59.14,Chinese,,0,0,0,,哦，所以无论如何这曾经是一个巨大的问题
Dialogue: 0,0:37:59.16,0:38:05.32,English,,0,0,0,,And it started way back in 1988 the first internet attack with called the Morris worm
Dialogue: 0,0:37:59.16,0:38:05.32,Chinese,,0,0,0,,它始于1988年第一次被称为莫里斯蠕虫的互联网攻击
Dialogue: 0,0:38:05.86,0:38:10.24,English,,0,0,0,,And it at the time the internet was not a very big place
Dialogue: 0,0:38:05.86,0:38:10.24,Chinese,,0,0,0,,当时互联网并不是一个非常大的地方
Dialogue: 0,0:38:11.16,0:38:14.08,English,,0,0,0,,And it basically brought down a huge fraction of the machines
Dialogue: 0,0:38:11.16,0:38:14.08,Chinese,,0,0,0,,它基本上耗尽了很大一部分机器
Dialogue: 0,0:38:14.48,0:38:17.00,English,,0,0,0,,That were on the internet at the time
Dialogue: 0,0:38:14.48,0:38:17.00,Chinese,,0,0,0,,那是当时的互联网
Dialogue: 0,0:38:17.00,0:38:22.18,English,,0,0,0,,Interestingly enough CMU did not fall victim to this attack
Dialogue: 0,0:38:17.00,0:38:22.18,Chinese,,0,0,0,,有趣的是，CMU并没有成为这次袭击的牺牲品
Dialogue: 0,0:38:22.18,0:38:28.48,English,,0,0,0,,Because we'd patched already the vulnerabilities that this particular program exploited
Dialogue: 0,0:38:22.18,0:38:28.48,Chinese,,0,0,0,,因为我们已经修补了这个特定程序利用的漏洞
Dialogue: 0,0:38:32.22,0:38:39.96,English,,0,0,0,,And that was the cause that the software engineering institute runs an organization called cert the computer emergency response team
Dialogue: 0,0:38:32.22,0:38:39.96,Chinese,,0,0,0,,这就是软件工程学院运行一个名为cert的计算机应急响应团队的原因
Dialogue: 0,0:38:40.34,0:38:46.76,English,,0,0,0,,And that team was set up in response to this attack the Morris worm attack
Dialogue: 0,0:38:40.34,0:38:46.76,Chinese,,0,0,0,,该团队成立是为了应对莫里斯蠕虫攻击这一攻击
Dialogue: 0,0:38:48.10,0:38:56.03,English,,0,0,0,,We'll also see an interesting example between two companies in messaging services
Dialogue: 0,0:38:48.10,0:38:56.03,Chinese,,0,0,0,,我们还将看到两家公司在消息服务方面的一个有趣的例子
Dialogue: 0,0:38:56.38,0:39:02.54,English,,0,0,0,,And many others it's been the sort of standard attack mechanism for many years
Dialogue: 0,0:38:56.38,0:39:02.54,Chinese,,0,0,0,,许多其他人多年来一直是那种标准的攻击机制
Dialogue: 0,0:39:03.06,0:39:09.36,English,,0,0,0,,And fortunately nowadays there's a few things that make the attacking a less likely to be successful
Dialogue: 0,0:39:03.06,0:39:09.36,Chinese,,0,0,0,,幸运的是，现在有一些事情使得攻击不太可能成功
Dialogue: 0,0:39:09.86,0:39:12.22,English,,0,0,0,,And so it's not as huge a problem as it used to be
Dialogue: 0,0:39:09.86,0:39:12.22,Chinese,,0,0,0,,因此它不像以前那么大
Dialogue: 0,0:39:12.52,0:39:17.04,English,,0,0,0,,But still it's a source of many vulnerabilities in programs
Dialogue: 0,0:39:12.52,0:39:17.04,Chinese,,0,0,0,,但它仍然是程序中许多漏洞的来源
Dialogue: 0,0:39:18.90,0:39:22.58,English,,0,0,0,,So let's see I won't talk too much about this
Dialogue: 0,0:39:18.90,0:39:22.58,Chinese,,0,0,0,,所以，让我们看看我不会谈论太多
Dialogue: 0,0:39:22.64,0:39:25.84,English,,0,0,0,,But it used to be in the original implementation of
Dialogue: 0,0:39:22.64,0:39:25.84,Chinese,,0,0,0,,但它曾经是最初的实现
Dialogue: 0,0:39:26.42,0:39:30.70,English,,0,0,0,,There's a command that most systems have now disabled that
Dialogue: 0,0:39:26.42,0:39:30.70,Chinese,,0,0,0,,现在大多数系统都禁用了这个命令
Dialogue: 0,0:39:30.70,0:39:33.96,English,,0,0,0,,You could finger you could across to information about
Dialogue: 0,0:39:30.70,0:39:33.96,Chinese,,0,0,0,,你可以指点你可以了解有关的信息
Dialogue: 0,0:39:34.36,0:39:38.66,English,,0,0,0,,Somebody in some remote location it would send a message to that location
Dialogue: 0,0:39:34.36,0:39:38.66,Chinese,,0,0,0,,在某个偏远位置的某个人会向该位置发送消息
Dialogue: 0,0:39:39.48,0:39:41.28,English,,0,0,0,,And then it would reply back
Dialogue: 0,0:39:39.48,0:39:41.28,Chinese,,0,0,0,,然后它会回复
Dialogue: 0,0:39:41.74,0:39:46.70,English,,0,0,0,,And it used gets the honor the actual original implementation called gets
Dialogue: 0,0:39:41.74,0:39:46.70,Chinese,,0,0,0,,它使用得到荣誉的实际原始实现称为获取
Dialogue: 0,0:39:47.24,0:39:51.40,English,,0,0,0,,To read the input string from that was being sent to it
Dialogue: 0,0:39:47.24,0:39:51.40,Chinese,,0,0,0,,从正在发送的输入字符串中读取输入字符串
Dialogue: 0,0:39:55.82,0:39:57.84,English,,0,0,0,,And then there is an interesting one
Dialogue: 0,0:39:55.82,0:39:57.84,Chinese,,0,0,0,,然后有一个有趣的
Dialogue: 0,0:39:57.84,0:40:01.26,English,,0,0,0,,You guys don't remember messaging instant messaging
Dialogue: 0,0:39:57.84,0:40:01.26,Chinese,,0,0,0,,你们不记得消息即时消息
Dialogue: 0,0:40:01.26,0:40:08.52,English,,0,0,0,,But before it used to be that people would talk to each other on their computers  by sending messages
Dialogue: 0,0:40:01.26,0:40:08.52,Chinese,,0,0,0,,但在此之前，人们会通过发送消息在他们的计算机上互相交谈
Dialogue: 0,0:40:08.86,0:40:11.18,English,,0,0,0,,Sort of like you send text messages today
Dialogue: 0,0:40:08.86,0:40:11.18,Chinese,,0,0,0,,有点像你今天发送短信
Dialogue: 0,0:40:11.70,0:40:14.56,English,,0,0,0,,But there is an interesting thing that
Dialogue: 0,0:40:11.70,0:40:14.56,Chinese,,0,0,0,,但有一件有趣的事情
Dialogue: 0,0:40:15.78,0:40:19.00,English,,0,0,0,,There's a company still exists
Dialogue: 0,0:40:15.78,0:40:19.00,Chinese,,0,0,0,,有一家公司仍然存在
Dialogue: 0,0:40:19.00,0:40:23.02,English,,0,0,0,,But it's a shadow of its former self called AOL
Dialogue: 0,0:40:19.00,0:40:23.02,Chinese,,0,0,0,,但这是它以前称为AOL的自我的阴影
Dialogue: 0,0:40:23.36,0:40:28.88,English,,0,0,0,,Which ran the most popular internet services and had the most popular instant messaging program
Dialogue: 0,0:40:23.36,0:40:28.88,Chinese,,0,0,0,,其中有最受欢迎的互联网服务，并拥有最受欢迎的即时通讯程序
Dialogue: 0,0:40:29.38,0:40:32.36,English,,0,0,0,,And Microsoft came out with its own client
Dialogue: 0,0:40:29.38,0:40:32.36,Chinese,,0,0,0,,微软推出了自己的客户端
Dialogue: 0,0:40:32.78,0:40:35.20,English,,0,0,0,,Its own program that you could run on your machine
Dialogue: 0,0:40:32.78,0:40:35.20,Chinese,,0,0,0,,它自己的程序，你可以在你的机器上运行
Dialogue: 0,0:40:35.48,0:40:40.06,English,,0,0,0,,And communicate to other people on this a messaging system
Dialogue: 0,0:40:35.48,0:40:40.06,Chinese,,0,0,0,,并通过这个消息系统与其他人沟通
Dialogue: 0,0:40:40.06,0:40:42.52,English,,0,0,0,,So the Microsoft code was running on your machine
Dialogue: 0,0:40:40.06,0:40:42.52,Chinese,,0,0,0,,因此Microsoft代码在你的计算机上运行
Dialogue: 0,0:40:42.90,0:40:49.74,English,,0,0,0,,But it would use the servers that were being run by AOL to manage this messaging traffic
Dialogue: 0,0:40:42.90,0:40:49.74,Chinese,,0,0,0,,但它会使用AOL运行的服务器来管理此消息传递流量
Dialogue: 0,0:40:50.38,0:40:57.62,English,,0,0,0,,And the funny story was...
Dialogue: 0,0:40:50.38,0:40:57.62,Chinese,,0,0,0,,有趣的故事是......
Dialogue: 0,0:40:59.18,0:41:01.78,English,,0,0,0,,The this Microsoft program would work fine
Dialogue: 0,0:40:59.18,0:41:01.78,Chinese,,0,0,0,,这个Microsoft程序可以正常工作
Dialogue: 0,0:41:02.54,0:41:08.44,English,,0,0,0,,You can communicate with your friends who had different messaging clients and it all seemed compatible
Dialogue: 0,0:41:02.54,0:41:08.44,Chinese,,0,0,0,,你可以与拥有不同邮件客户端的朋友进行交流，这一切似乎都是兼容的
Dialogue: 0,0:41:08.44,0:41:13.94,English,,0,0,0,,But then suddenly the people that were running the Microsoft version of the software,it wouldn't work
Dialogue: 0,0:41:08.44,0:41:13.94,Chinese,,0,0,0,,但突然之间，那些运行微软版软件的人却无法工作
Dialogue: 0,0:41:14.52,0:41:16.96,English,,0,0,0,,And then Microsoft people figured out how to patch it
Dialogue: 0,0:41:14.52,0:41:16.96,Chinese,,0,0,0,,然后微软人们想出了如何修补它
Dialogue: 0,0:41:17.68,0:41:20.00,English,,0,0,0,,And then it would work for a while and then it wouldn't work
Dialogue: 0,0:41:17.68,0:41:20.00,Chinese,,0,0,0,,然后它会工作一段时间然后它将无法工作
Dialogue: 0,0:41:20.00,0:41:24.64,English,,0,0,0,,And the way what was happening was AOL was using a bug in its own code
Dialogue: 0,0:41:20.00,0:41:24.64,Chinese,,0,0,0,,发生的事情是AOL在自己的代码中使用了一个错误
Dialogue: 0,0:41:25.30,0:41:33.86,English,,0,0,0,,To be able to determine who's basically peek into the the machines on the client side
Dialogue: 0,0:41:25.30,0:41:33.86,Chinese,,0,0,0,,能够确定谁基本上窥视客户端的机器
Dialogue: 0,0:41:34.44,0:41:39.90,English,,0,0,0,,And do a buffer overflow attack on your code that you're running on your machine
Dialogue: 0,0:41:34.44,0:41:39.90,Chinese,,0,0,0,,并对你在计算机上运行的代码执行缓冲区溢出攻击
Dialogue: 0,0:41:40.22,0:41:44.70,English,,0,0,0,,And then basically peek around and see does this look like AOL code
Dialogue: 0,0:41:40.22,0:41:44.70,Chinese,,0,0,0,,然后基本上偷看，看看这看起来像AOL代码
Dialogue: 0,0:41:44.70,0:41:46.95,English,,0,0,0,,Or is it something or is it some foreign code
Dialogue: 0,0:41:44.70,0:41:46.95,Chinese,,0,0,0,,或者它是什么或是一些外国代码
Dialogue: 0,0:41:47.38,0:41:54.80,English,,0,0,0,,And so is basic be able to use its own security weakness to figure out this information
Dialogue: 0,0:41:47.38,0:41:54.80,Chinese,,0,0,0,,因此基本能够利用自身的安全弱点来弄清楚这些信息
Dialogue: 0,0:41:56.28,0:42:01.90,English,,0,0,0,,And that got disclosed by a sort of funny message
Dialogue: 0,0:41:56.28,0:42:01.90,Chinese,,0,0,0,,这是通过一种有趣的信息披露的
Dialogue: 0,0:42:02.42,0:42:06.26,English,,0,0,0,,From somebody who called himself Phil Bucking
Dialogue: 0,0:42:02.42,0:42:06.26,Chinese,,0,0,0,,来自一个自称Phil Bucking的人
Dialogue: 0,0:42:07.02,0:42:12.36,English,,0,0,0,,And it was determined that this email originated from somewhere within Microsoft
Dialogue: 0,0:42:07.02,0:42:12.36,Chinese,,0,0,0,,并且确定此电子邮件来自Microsoft内部的某个地方
Dialogue: 0,0:42:15.86,0:42:21.52,English,,0,0,0,,So anyways that and you can read more about it in the book around the slide fun choice
Dialogue: 0,0:42:15.86,0:42:21.52,Chinese,,0,0,0,,所以无论如何，你可以在书中围绕幻灯片乐趣选择阅读更多相关内容
Dialogue: 0,0:42:21.78,0:42:26.78,English,,0,0,0,,So in general in the security world you're supposed to distinguish between the idea of a worm and a virus
Dialogue: 0,0:42:21.78,0:42:26.78,Chinese,,0,0,0,,因此，一般来说，在安全领域，你应该区分蠕虫和病毒的概念
Dialogue: 0,0:42:26.78,0:42:28.70,English,,0,0,0,,Although people aren't very good at doing that
Dialogue: 0,0:42:26.78,0:42:28.70,Chinese,,0,0,0,,虽然人们并不擅长这样做
Dialogue: 0,0:42:29.06,0:42:35.58,English,,0,0,0,,So worm is a program that can run on its own and propagate itself from one place to the other replicated
Dialogue: 0,0:42:29.06,0:42:35.58,Chinese,,0,0,0,,因此蠕虫是一个可以独立运行并从一个地方传播到另一个地方的程序
Dialogue: 0,0:42:35.96,0:42:40.80,English,,0,0,0,,A virus is like a biological virus it doesn't live on its own
Dialogue: 0,0:42:35.96,0:42:40.80,Chinese,,0,0,0,,病毒就像一种生物病毒，它本身并不存在
Dialogue: 0,0:42:40.90,0:42:45.78,English,,0,0,0,,It works by attacking a program and basically modifying that program's behavior
Dialogue: 0,0:42:40.90,0:42:45.78,Chinese,,0,0,0,,它通过攻击程序并基本上修改该程序的行为来工作
Dialogue: 0,0:42:51.30,0:42:56.72,English,,0,0,0,,So that gives you the basic idea of buffer overflows and you'll see it more first hand
Dialogue: 0,0:42:51.30,0:42:56.72,Chinese,,0,0,0,,这样就可以了解缓冲区溢出的基本概念，你会更直接地看到它
Dialogue: 0,0:42:57.20,0:43:02.44,English,,0,0,0,,So let's look at it techniques that machines can use to avoid
Dialogue: 0,0:42:57.20,0:43:02.44,Chinese,,0,0,0,,那么让我们来看看机器可以用来避免的技术
Dialogue: 0,0:43:02.72,0:43:05.12,English,,0,0,0,,To make themselves less vulnerable to these attacks
Dialogue: 0,0:43:02.72,0:43:05.12,Chinese,,0,0,0,,使自己不那么容易受到这些攻击
Dialogue: 0,0:43:05.60,0:43:13.38,English,,0,0,0,,Well first of all you the application or the cert the writer on the server-side can write code that's more secure
Dialogue: 0,0:43:05.60,0:43:13.38,Chinese,,0,0,0,,首先，你应用程序或证书服务器端的编写者可以编写更安全的代码
Dialogue: 0,0:43:14.90,0:43:18.32,English,,0,0,0,,So for example what you're supposed to do instead of gets
Dialogue: 0,0:43:14.90,0:43:18.32,Chinese,,0,0,0,,所以例如你应该做什么而不是获取
Dialogue: 0,0:43:18.84,0:43:20.76,English,,0,0,0,,Is use a function called fgets
Dialogue: 0,0:43:18.84,0:43:20.76,Chinese,,0,0,0,,是使用一个名为fgets的函数
Dialogue: 0,0:43:21.28,0:43:26.18,English,,0,0,0,,And fgets has a property that it passes a parameter
Dialogue: 0,0:43:21.28,0:43:26.18,Chinese,,0,0,0,,并且fgets具有传递参数的属性
Dialogue: 0,0:43:26.48,0:43:31.40,English,,0,0,0,,Which is the maximum number of bytes that the program should read
Dialogue: 0,0:43:26.48,0:43:31.40,Chinese,,0,0,0,,这是程序应该读取的最大字节数
Dialogue: 0,0:43:31.84,0:43:37.86,English,,0,0,0,,And if there's more bytes than that in the input it will just truncate the input
Dialogue: 0,0:43:31.84,0:43:37.86,Chinese,,0,0,0,,如果输入中的字节数多于输入中的字节数，则只会截断输入
Dialogue: 0,0:43:38.62,0:43:43.40,English,,0,0,0,,So you're really supposed to use fgets and give a limit
Dialogue: 0,0:43:38.62,0:43:43.40,Chinese,,0,0,0,,所以你真的应该使用fgets并给出一个限制
Dialogue: 0,0:43:43.92,0:43:49.16,English,,0,0,0,,Similarly a strcpy there is a version of it called strncpy where you can give a limit
Dialogue: 0,0:43:43.92,0:43:49.16,Chinese,,0,0,0,,类似地，strcpy有一个名为strncpy的版本，你可以在其中给出限制
Dialogue: 0,0:43:49.98,0:43:55.22,English,,0,0,0,,And with a scanf you're supposed to be careful about using the percent s
Dialogue: 0,0:43:49.98,0:43:55.22,Chinese,,0,0,0,,使用scanf你应该小心使用百分比s
Dialogue: 0,0:43:55.62,0:43:59.28,English,,0,0,0,,There's even a terminology you can say percent give a number
Dialogue: 0,0:43:55.62,0:43:59.28,Chinese,,0,0,0,,甚至还有一个术语可以说百分比给出一个数字
Dialogue: 0,0:43:59.84,0:44:03.58,English,,0,0,0,,That's the maximum length of the string it should read
Dialogue: 0,0:43:59.84,0:44:03.58,Chinese,,0,0,0,,这是它应该读取的字符串的最大长度
Dialogue: 0,0:44:03.58,0:44:09.39,English,,0,0,0,,So these various places you can protect your code  to make sure it won't overflow buffers
Dialogue: 0,0:44:03.58,0:44:09.39,Chinese,,0,0,0,,所以这些不同的地方你可以保护你的代码，以确保它不会溢出缓冲区
Dialogue: 0,0:44:09.80,0:44:15.00,English,,0,0,0,,Unfortunately a lot of code has been you'd call it hardening
Dialogue: 0,0:44:09.80,0:44:15.00,Chinese,,0,0,0,,不幸的是，很多代码都被称为硬化
Dialogue: 0,0:44:15.14,0:44:18.94,English,,0,0,0,,It's been people have gone through it and it's a lot of work
Dialogue: 0,0:44:15.14,0:44:18.94,Chinese,,0,0,0,,人们已经经历过它，这是很多工作
Dialogue: 0,0:44:19.04,0:44:23.64,English,,0,0,0,,Because there's a lot of places in programs where you're copying strings from one place to another
Dialogue: 0,0:44:19.04,0:44:23.64,Chinese,,0,0,0,,因为程序中有很多地方可以将字符串从一个地方复制到另一个地方
Dialogue: 0,0:44:24.14,0:44:31.56,English,,0,0,0,,And there are a lot of real subtleties like when you're converting from unicode to bytes and so forth
Dialogue: 0,0:44:24.14,0:44:31.56,Chinese,,0,0,0,,当你从unicode转换为字节等等时，有很多真正的微妙之处
Dialogue: 0,0:44:31.56,0:44:34.68,English,,0,0,0,,That you're going back and forth between different character encodings
Dialogue: 0,0:44:31.56,0:44:34.68,Chinese,,0,0,0,,你在不同的角色编码之间来回走动
Dialogue: 0,0:44:35.20,0:44:42.70,English,,0,0,0,,But for the large part and there's tools that the code developers have created to help  track down these bugs
Dialogue: 0,0:44:35.20,0:44:42.70,Chinese,,0,0,0,,但是对于大部分代码开发人员已经创建的工具来帮助追踪这些错误
Dialogue: 0,0:44:43.24,0:44:47.72,English,,0,0,0,,So it's become a little bit safer out there but there's still vulnerabilities
Dialogue: 0,0:44:43.24,0:44:47.72,Chinese,,0,0,0,,所以它在那里变得更安全但是仍然存在漏洞
Dialogue: 0,0:44:48.50,0:44:53.80,English,,0,0,0,,So then there's other parts where you just try to build in safeguards into the system
Dialogue: 0,0:44:48.50,0:44:53.80,Chinese,,0,0,0,,那么还有其他部分，你只是尝试在系统中构建安全措施
Dialogue: 0,0:44:54.22,0:44:59.38,English,,0,0,0,,That would make it much harder to do a buffer overflow exploit like I showed you
Dialogue: 0,0:44:54.22,0:44:59.38,Chinese,,0,0,0,,这会让我更难以像我向你展示的那样进行缓冲区溢出漏洞利用
Dialogue: 0,0:45:00.04,0:45:03.20,English,,0,0,0,,And so one of them is called stack randomization
Dialogue: 0,0:45:00.04,0:45:03.20,Chinese,,0,0,0,,因此其中一个被称为堆栈随机化
Dialogue: 0,0:45:03.68,0:45:05.64,English,,0,0,0,,Where it goes by a more general term
Dialogue: 0,0:45:03.68,0:45:05.64,Chinese,,0,0,0,,它是一个更通用的术语
Dialogue: 0,0:45:09.34,0:45:12.06,English,,0,0,0,,That's abbreviated ASLR
Dialogue: 0,0:45:09.34,0:45:12.06,Chinese,,0,0,0,,这是缩写为ASLR
Dialogue: 0,0:45:12.86,0:45:25.04,English,,0,0,0,,Which stands for Address,Space,Layout,Randomization
Dialogue: 0,0:45:12.86,0:45:25.04,Chinese,,0,0,0,,其中代表地址，空间，布局，随机化
Dialogue: 0,0:45:25.50,0:45:29.04,English,,0,0,0,,And the idea of it is to make it so every time a program runs
Dialogue: 0,0:45:25.50,0:45:29.04,Chinese,,0,0,0,,它的想法是每次程序运行时都这样做
Dialogue: 0,0:45:29.54,0:45:33.84,English,,0,0,0,,The addresses change a little bit or a lot
Dialogue: 0,0:45:29.54,0:45:33.84,Chinese,,0,0,0,,地址改变了一点点或很多
Dialogue: 0,0:45:34.24,0:45:39.50,English,,0,0,0,,So that you can't reliably know where things are going to be in the code
Dialogue: 0,0:45:34.24,0:45:39.50,Chinese,,0,0,0,,因此，你无法可靠地知道代码中的内容
Dialogue: 0,0:45:39.96,0:45:45.84,English,,0,0,0,,So imagine for example the and the way it's implemented is before
Dialogue: 0,0:45:39.96,0:45:45.84,Chinese,,0,0,0,,因此，想象一下例如以及之前实施的方式
Dialogue: 0,0:45:46.10,0:45:49.52,English,,0,0,0,,In the sort of run-up of your program when it first starts up
Dialogue: 0,0:45:46.10,0:45:49.52,Chinese,,0,0,0,,在程序第一次启动时的运行状态
Dialogue: 0,0:45:50.24,0:45:52.76,English,,0,0,0,,But before your main routine gets called
Dialogue: 0,0:45:50.24,0:45:52.76,Chinese,,0,0,0,,但在你的主要例程被调用之前
Dialogue: 0,0:45:53.92,0:45:58.72,English,,0,0,0,,It will just do a allocation on the stack of some random number of bytes of storage
Dialogue: 0,0:45:53.92,0:45:58.72,Chinese,,0,0,0,,它只会在一些随机数量的存储字节的堆栈上进行分配
Dialogue: 0,0:45:59.36,0:46:05.70,English,,0,0,0,,A fair amount like maybe a megabyte roughly of storage where the exact number is randomly chosen
Dialogue: 0,0:45:59.36,0:46:05.70,Chinese,,0,0,0,,一个相当大的数量，可能是大约几兆字节的存储空间，其中确切的数字是随机选择的
Dialogue: 0,0:46:06.70,0:46:10.50,English,,0,0,0,,And what that means is that the the dress of the stack
Dialogue: 0,0:46:06.70,0:46:10.50,Chinese,,0,0,0,,这意味着堆叠的衣服
Dialogue: 0,0:46:10.66,0:46:14.66,English,,0,0,0,,Of all the different positions of your
Dialogue: 0,0:46:10.66,0:46:14.66,Chinese,,0,0,0,,在你的所有不同的位置
Dialogue: 0,0:46:15.26,0:46:20.04,English,,0,0,0,,All the local storage on the stack will shift up and down from one run to another
Dialogue: 0,0:46:15.26,0:46:20.04,Chinese,,0,0,0,,堆栈上的所有本地存储将从一次运行上下移动到另一次运行
Dialogue: 0,0:46:20.92,0:46:22.62,English,,0,0,0,,And we can actually see that
Dialogue: 0,0:46:20.92,0:46:22.62,Chinese,,0,0,0,,我们实际上可以看到这一点
Dialogue: 0,0:46:24.54,0:46:27.54,English,,0,0,0,,In this example I showed
Dialogue: 0,0:46:24.54,0:46:27.54,Chinese,,0,0,0,,在这个例子中我展示了
Dialogue: 0,0:46:33.30,0:46:38.22,English,,0,0,0,,So I have a program here it's not a very interesting program I'll show you
Dialogue: 0,0:46:33.30,0:46:38.22,Chinese,,0,0,0,,所以我在这里有一个程序，这不是一个非常有趣的程序，我会告诉你
Dialogue: 0,0:46:39.44,0:46:41.40,English,,0,0,0,,Except to demonstrate these ideas
Dialogue: 0,0:46:39.44,0:46:41.40,Chinese,,0,0,0,,除了展示这些想法
Dialogue: 0,0:46:45.40,0:46:50.42,English,,0,0,0,,All it's doing is there's some code it's based on that one
Dialogue: 0,0:46:45.40,0:46:50.42,Chinese,,0,0,0,,所有它正在做的是它有一些基于那个的代码
Dialogue: 0,0:46:50.42,0:46:51.92,English,,0,0,0,,I already showed called locate
Dialogue: 0,0:46:50.42,0:46:51.92,Chinese,,0,0,0,,我已经展示了名为locate
Dialogue: 0,0:46:51.92,0:46:54.72,English,,0,0,0,,But this one there's a global variable
Dialogue: 0,0:46:51.92,0:46:54.72,Chinese,,0,0,0,,但是这个有一个全局变量
Dialogue: 0,0:46:55.40,0:47:00.51,English,,0,0,0,,There's some functions there's something that gets allocated by malloc
Dialogue: 0,0:46:55.40,0:47:00.51,Chinese,,0,0,0,,有一些函数可以通过malloc分配
Dialogue: 0,0:47:00.92,0:47:04.98,English,,0,0,0,,And there's something that is a local variable stored on the stack
Dialogue: 0,0:47:00.92,0:47:04.98,Chinese,,0,0,0,,而且有一些东西是存储在堆栈中的局部变量
Dialogue: 0,0:47:05.58,0:47:09.10,English,,0,0,0,,And so what I'll do is show addresses that are chosen
Dialogue: 0,0:47:05.58,0:47:09.10,Chinese,,0,0,0,,所以我要做的就是显示所选择的地址
Dialogue: 0,0:47:09.46,0:47:15.66,English,,0,0,0,,The address of this variable then will be a stack address a local of a local variable
Dialogue: 0,0:47:09.46,0:47:15.66,Chinese,,0,0,0,,然后，此变量的地址将是堆栈地址本地变量的本地
Dialogue: 0,0:47:16.30,0:47:19.34,English,,0,0,0,,Global will be this one that gets allocated globally
Dialogue: 0,0:47:16.30,0:47:19.34,Chinese,,0,0,0,,全球将是这个全球分配的
Dialogue: 0,0:47:19.94,0:47:22.10,English,,0,0,0,,The heap is something allocated with malloc
Dialogue: 0,0:47:19.94,0:47:22.10,Chinese,,0,0,0,,堆是用malloc分配的
Dialogue: 0,0:47:22.82,0:47:27.38,English,,0,0,0,,And then the this function useless will count as a code address
Dialogue: 0,0:47:22.82,0:47:27.38,Chinese,,0,0,0,,然后这个函数无用将被视为代码地址
Dialogue: 0,0:47:29.08,0:47:30.32,English,,0,0,0,,And now when I run it
Dialogue: 0,0:47:29.08,0:47:30.32,Chinese,,0,0,0,,而现在当我运行它
Dialogue: 0,0:47:34.56,0:47:39.62,English,,0,0,0,,You'll see from one run to another that if some of these stay the same and some of them change
Dialogue: 0,0:47:34.56,0:47:39.62,Chinese,,0,0,0,,从一次运行到另一次运行，你会看到其中一些保持不变，其中一些会发生变化
Dialogue: 0,0:47:40.36,0:47:46.02,English,,0,0,0,,So in particular the global variable is the same 0x60102c
Dialogue: 0,0:47:40.36,0:47:46.02,Chinese,,0,0,0,,所以特别是全局变量是相同的0x60102c
Dialogue: 0,0:47:47.70,0:47:56.22,English,,0,0,0,,And the code is the same 0x400590 is the same every execution
Dialogue: 0,0:47:47.70,0:47:56.22,Chinese,,0,0,0,,并且代码是相同的0x400590每次执行都是一样的
Dialogue: 0,0:47:56.66,0:48:00.80,English,,0,0,0,,But you'll see this local variable it's on its a stack address
Dialogue: 0,0:47:56.66,0:48:00.80,Chinese,,0,0,0,,但是你会在它的堆栈地址上看到这个局部变量
Dialogue: 0,0:48:01.50,0:48:07.34,English,,0,0,0,,But you see that the lower half dozen or so bytes are actually changing from one run to another
Dialogue: 0,0:48:01.50,0:48:07.34,Chinese,,0,0,0,,但是你看到下半部分的十几个字节实际上是从一个运行变为另一个运行
Dialogue: 0,0:48:07.84,0:48:12.88,English,,0,0,0,,1,2,3,4,5 so 5 bytes so that's
Dialogue: 0,0:48:07.84,0:48:12.88,Chinese,,0,0,0,,1,2,3,4,5所以这是5个字节
Dialogue: 0,0:48:15.92,0:48:17.68,English,,0,0,0,,What 5 hex digits I'm sorry
Dialogue: 0,0:48:15.92,0:48:17.68,Chinese,,0,0,0,,什么5个十六进制数字我很抱歉
Dialogue: 0,0:48:17.68,0:48:20.10,English,,0,0,0,,So that's 2^20
Dialogue: 0,0:48:17.68,0:48:20.10,Chinese,,0,0,0,,那是2 ^ 20
Dialogue: 0,0:48:20.70,0:48:25.26,English,,0,0,0,,So roughly a megabyte of variation is going on in stack addresses there
Dialogue: 0,0:48:20.70,0:48:25.26,Chinese,,0,0,0,,因此，堆栈地址大约有一兆字节的变化
Dialogue: 0,0:48:25.80,0:48:32.06,English,,0,0,0,,And similarly you'll see that the heap addresses are also varying from one to another
Dialogue: 0,0:48:25.80,0:48:32.06,Chinese,,0,0,0,,同样地，你会看到堆地址也各不相同
Dialogue: 0,0:48:32.26,0:48:33.76,English,,0,0,0,,From one execution to the other
Dialogue: 0,0:48:32.26,0:48:33.76,Chinese,,0,0,0,,从一次执行到另一次执行
Dialogue: 0,0:48:33.78,0:48:38.62,English,,0,0,0,,So malloc has built into it some amount of randomness to in its allocation
Dialogue: 0,0:48:33.78,0:48:38.62,Chinese,,0,0,0,,所以malloc在其分配中已经建立了一些随机性
Dialogue: 0,0:48:39.34,0:48:43.38,English,,0,0,0,,So why is that...you know what's the purpose of that well
Dialogue: 0,0:48:39.34,0:48:43.38,Chinese,,0,0,0,,那么为什么......你知道那个目的是什么
Dialogue: 0,0:48:45.46,0:48:49.14,English,,0,0,0,,As I told you this code injection vulnerability
Dialogue: 0,0:48:45.46,0:48:49.14,Chinese,,0,0,0,,正如我告诉你这个代码注入漏洞
Dialogue: 0,0:48:51.42,0:48:57.30,English,,0,0,0,,Relies on the fact that you can load up this buffer with some executable code
Dialogue: 0,0:48:51.42,0:48:57.30,Chinese,,0,0,0,,依赖于你可以使用一些可执行代码加载此缓冲区的事实
Dialogue: 0,0:48:57.74,0:49:03.38,English,,0,0,0,,But somehow you have to know how to get to the start of that code
Dialogue: 0,0:48:57.74,0:49:03.38,Chinese,,0,0,0,,但不知何故，你必须知道如何开始该代码
Dialogue: 0,0:49:04.00,0:49:08.32,English,,0,0,0,,And so this is relying the attack is relying on the fact
Dialogue: 0,0:49:04.00,0:49:08.32,Chinese,,0,0,0,,所以这依赖于攻击依赖的事实
Dialogue: 0,0:49:08.32,0:49:13.28,English,,0,0,0,,That it can somehow predict what the this address of the buffer is
Dialogue: 0,0:49:08.32,0:49:13.28,Chinese,,0,0,0,,它可以某种方式预测缓冲区的这个地址是什么
Dialogue: 0,0:49:14.36,0:49:18.04,English,,0,0,0,,And so that it can store it in the right part of the string
Dialogue: 0,0:49:14.36,0:49:18.04,Chinese,,0,0,0,,这样它就可以将它存储在字符串的正确部分
Dialogue: 0,0:49:18.16,0:49:22.98,English,,0,0,0,,Put it encode it in the right part of the string so it will show up where the return pointer is supposed to be
Dialogue: 0,0:49:18.16,0:49:22.98,Chinese,,0,0,0,,把它编码在字符串的右边部分，这样就会显示返回指针的位置
Dialogue: 0,0:49:24.36,0:49:26.52,English,,0,0,0,,And and have it jump to that location
Dialogue: 0,0:49:24.36,0:49:26.52,Chinese,,0,0,0,,然后让它跳到那个位置
Dialogue: 0,0:49:26.92,0:49:28.66,English,,0,0,0,,But now with this randomization
Dialogue: 0,0:49:26.92,0:49:28.66,Chinese,,0,0,0,,但现在有了这种随机化
Dialogue: 0,0:49:29.26,0:49:33.24,English,,0,0,0,,This number is varying by quite a bit
Dialogue: 0,0:49:29.26,0:49:33.24,Chinese,,0,0,0,,这个数字变化很大
Dialogue: 0,0:49:33.40,0:49:37.50,English,,0,0,0,,Sort of million over a range of a million or so values
Dialogue: 0,0:49:33.40,0:49:37.50,Chinese,,0,0,0,,在一百万左右的价值范围内排序百万
Dialogue: 0,0:49:37.88,0:49:39.24,English,,0,0,0,,So there's no way in advance
Dialogue: 0,0:49:37.88,0:49:39.24,Chinese,,0,0,0,,所以没有办法提前
Dialogue: 0,0:49:39.48,0:49:44.41,English,,0,0,0,,Even if I have an exact copy of the code not even had access to the system itself
Dialogue: 0,0:49:39.48,0:49:44.41,Chinese,,0,0,0,,即使我有完整的代码副本，甚至无法访问系统本身
Dialogue: 0,0:49:44.72,0:49:46.13,English,,0,0,0,,And could run it
Dialogue: 0,0:49:44.72,0:49:46.13,Chinese,,0,0,0,,并且可以运行它
Dialogue: 0,0:49:46.54,0:49:50.04,English,,0,0,0,,I can't predict from one run to the next where it's going to be
Dialogue: 0,0:49:46.54,0:49:50.04,Chinese,,0,0,0,,我不能预测从一次奔跑到下一次奔跑的地方
Dialogue: 0,0:49:50.68,0:49:54.82,English,,0,0,0,,So that gives it sort of thoughts this particular attack
Dialogue: 0,0:49:50.68,0:49:54.82,Chinese,,0,0,0,,所以这给了这种特殊攻击的想法
Dialogue: 0,0:49:55.40,0:49:59.86,English,,0,0,0,,To make it using this randomization
Dialogue: 0,0:49:55.40,0:49:59.86,Chinese,,0,0,0,,使用这种随机化来实现它
Dialogue: 0,0:50:03.14,0:50:07.24,English,,0,0,0,,Another idea that's fairly straightforward
Dialogue: 0,0:50:03.14,0:50:07.24,Chinese,,0,0,0,,另一个相当直接的想法
Dialogue: 0,0:50:07.24,0:50:11.32,English,,0,0,0,,But it took a long time for the hardware people to implement this
Dialogue: 0,0:50:07.24,0:50:11.32,Chinese,,0,0,0,,但硬件人员花了很长时间才实现这一点
Dialogue: 0,0:50:12.04,0:50:17.98,English,,0,0,0,,Is well why is there supposed to be code on the stack in the first place
Dialogue: 0,0:50:12.04,0:50:17.98,Chinese,,0,0,0,,好吧，为什么首先应该在堆栈上有代码
Dialogue: 0,0:50:18.00,0:50:21.10,English,,0,0,0,, The code supposed to be located down in the text segment
Dialogue: 0,0:50:18.00,0:50:21.10,Chinese,,0,0,0,,代码应该位于文本段中
Dialogue: 0,0:50:21.70,0:50:25.82,English,,0,0,0,,Where it can be sort of specially identified as being executable
Dialogue: 0,0:50:21.70,0:50:25.82,Chinese,,0,0,0,,它可以被特别标识​​为可执行的
Dialogue: 0,0:50:26.58,0:50:29.02,English,,0,0,0,,So in the original x86
Dialogue: 0,0:50:26.58,0:50:29.02,Chinese,,0,0,0,,所以在原来的x86中
Dialogue: 0,0:50:29.64,0:50:33.44,English,,0,0,0,,There's a one bit flag for each region of memory
Dialogue: 0,0:50:29.64,0:50:33.44,Chinese,,0,0,0,,每个内存区域都有一位标志
Dialogue: 0,0:50:34.20,0:50:37.08,English,,0,0,0,,Saying is it actually to one bit flags
Dialogue: 0,0:50:34.20,0:50:37.08,Chinese,,0,0,0,,说它实际上是一个标志
Dialogue: 0,0:50:37.62,0:50:40.04,English,,0,0,0,,One is can this be written to
Dialogue: 0,0:50:37.62,0:50:40.04,Chinese,,0,0,0,,一个是可以这样写的
Dialogue: 0,0:50:41.04,0:50:45.46,English,,0,0,0,,So that you can prevent over writes of things like string constants
Dialogue: 0,0:50:41.04,0:50:45.46,Chinese,,0,0,0,,这样你就可以防止像字符串常量这样的事情的过度写入
Dialogue: 0,0:50:46.88,0:50:50.59,English,,0,0,0,,And so and then the other is am I can I read it
Dialogue: 0,0:50:46.88,0:50:50.59,Chinese,,0,0,0,,所以然后另一个是我可以阅读它
Dialogue: 0,0:50:51.32,0:50:53.46,English,,0,0,0,,And read means access those bytes
Dialogue: 0,0:50:51.32,0:50:53.46,Chinese,,0,0,0,,读取意味着访问这些字节
Dialogue: 0,0:50:53.46,0:50:57.18,English,,0,0,0,,It was interpreted that readable and executable were the same thing
Dialogue: 0,0:50:53.46,0:50:57.18,Chinese,,0,0,0,,它被解释为可读和可执行是相同的
Dialogue: 0,0:50:57.66,0:51:01.30,English,,0,0,0,,I can read it I can execute it and that was the rules
Dialogue: 0,0:50:57.66,0:51:01.30,Chinese,,0,0,0,,我可以读它我可以执行它，这就是规则
Dialogue: 0,0:51:02.48,0:51:08.78,English,,0,0,0,,In a sort of last 10 years or so starting first with AMD and then intel
Dialogue: 0,0:51:02.48,0:51:08.78,Chinese,,0,0,0,,在过去10年左右的时间里，首先是AMD，然后是英特尔
Dialogue: 0,0:51:09.06,0:51:12.54,English,,0,0,0,,Have added a third bit that says is this executable or not
Dialogue: 0,0:51:09.06,0:51:12.54,Chinese,,0,0,0,,添加了第三位，说是这个可执行文件
Dialogue: 0,0:51:13.02,0:51:18.16,English,,0,0,0,,Similarly to the permissions you have on a file on unix is it readable,writable,executable
Dialogue: 0,0:51:13.02,0:51:18.16,Chinese,,0,0,0,,与你在unix上的文件上拥有的权限类似，它是可读，可写，可执行的
Dialogue: 0,0:51:18.58,0:51:21.30,English,,0,0,0,,Those are three separate permission bits that are alone
Dialogue: 0,0:51:18.58,0:51:21.30,Chinese,,0,0,0,,这些是三个独立的权限位
Dialogue: 0,0:51:22.72,0:51:26.50,English,,0,0,0,,So by simply marking the stack is not executable
Dialogue: 0,0:51:22.72,0:51:26.50,Chinese,,0,0,0,,所以通过简单地标记堆栈是不可执行的
Dialogue: 0,0:51:26.84,0:51:29.22,English,,0,0,0,,It'll also fort this particular attack
Dialogue: 0,0:51:26.84,0:51:29.22,Chinese,,0,0,0,,它也会对这种特殊攻击有所帮助
Dialogue: 0,0:51:29.22,0:51:33.28,English,,0,0,0,,Because I have to be able to execute these bytes that I've injected into the system
Dialogue: 0,0:51:29.22,0:51:33.28,Chinese,,0,0,0,,因为我必须能够执行我注入系统的这些字节
Dialogue: 0,0:51:37.18,0:51:41.76,English,,0,0,0,,And then there's the final idea which is actually fairly effective too
Dialogue: 0,0:51:37.18,0:51:41.76,Chinese,,0,0,0,,然后是最终的想法，实际上也是相当有效的
Dialogue: 0,0:51:42.24,0:51:45.72,English,,0,0,0,,Which they call a canary that they built into the stack
Dialogue: 0,0:51:42.24,0:51:45.72,Chinese,,0,0,0,,他们称之为金丝雀，他们建立在堆栈中
Dialogue: 0,0:51:45.72,0:51:49.20,English,,0,0,0,,And some of you actually encountered this code already and looking at your bombs
Dialogue: 0,0:51:45.72,0:51:49.20,Chinese,,0,0,0,,你们中的一些人实际上已经遇到过这个代码并且看着你的炸弹
Dialogue: 0,0:51:49.20,0:51:51.34,English,,0,0,0,,Because we've been getting some questions about it
Dialogue: 0,0:51:49.20,0:51:51.34,Chinese,,0,0,0,,因为我们一直在问这个问题
Dialogue: 0,0:51:52.52,0:51:55.32,English,,0,0,0,,So let me just give you an example here
Dialogue: 0,0:51:52.52,0:51:55.32,Chinese,,0,0,0,,那么让我举一个例子吧
Dialogue: 0,0:52:05.70,0:52:08.20,English,,0,0,0,,And this one's called buffdemo-sp
Dialogue: 0,0:52:05.70,0:52:08.20,Chinese,,0,0,0,,而这个叫做buffdemo-sp
Dialogue: 0,0:52:08.20,0:52:11.28,English,,0,0,0,,Because it's been compiled with what they call stack protector
Dialogue: 0,0:52:08.20,0:52:11.28,Chinese,,0,0,0,,因为它已被编译为他们称之为堆栈保护器
Dialogue: 0,0:52:17.54,0:52:22.56,English,,0,0,0,,And this one on now it's the same code as before it's discompiled a little bit differently
Dialogue: 0,0:52:17.54,0:52:22.56,Chinese,,0,0,0,,而现在这个代码与之前的编译方式相同，有点不同
Dialogue: 0,0:52:23.14,0:52:26.70,English,,0,0,0,,What you'll find is I can give a string of length eight
Dialogue: 0,0:52:23.14,0:52:26.70,Chinese,,0,0,0,,你会发现我可以给出一串长度为8的字符串
Dialogue: 0,0:52:27.08,0:52:28.58,English,,0,0,0,,And not have a problem
Dialogue: 0,0:52:27.08,0:52:28.58,Chinese,,0,0,0,,并没有问题
Dialogue: 0,0:52:29.04,0:52:32.38,English,,0,0,0,,But if I now have nine characters
Dialogue: 0,0:52:29.04,0:52:32.38,Chinese,,0,0,0,,但如果我现在有九个字符
Dialogue: 0,0:52:33.00,0:52:38.80,English,,0,0,0,,It will dump out with this very strange exit error message
Dialogue: 0,0:52:33.00,0:52:38.80,Chinese,,0,0,0,,它会抛出这个非常奇怪的退出错误消息
Dialogue: 0,0:52:39.42,0:52:41.86,English,,0,0,0,,That is an indication...
Dialogue: 0,0:52:39.42,0:52:41.86,Chinese,,0,0,0,,这是一个迹象......
Dialogue: 0,0:52:45.18,0:52:49.78,English,,0,0,0,,That it's detected I attempt to smash the stack
Dialogue: 0,0:52:45.18,0:52:49.78,Chinese,,0,0,0,,它被检测到我试图粉碎堆栈
Dialogue: 0,0:52:49.78,0:52:52.66,English,,0,0,0,,So buffer overflow is sometimes called stack smashing
Dialogue: 0,0:52:49.78,0:52:52.66,Chinese,,0,0,0,,因此缓冲区溢出有时被称为堆栈粉碎
Dialogue: 0,0:52:53.68,0:52:59.58,English,,0,0,0,,So it detected somehow that even though my code was still the same old crappy code from before
Dialogue: 0,0:52:53.68,0:52:59.58,Chinese,,0,0,0,,因此它以某种方式检测到即使我的代码仍然是以前的旧的糟糕代码
Dialogue: 0,0:53:00.70,0:53:03.96,English,,0,0,0,,Of a very small buffer allocation and no protection
Dialogue: 0,0:53:00.70,0:53:03.96,Chinese,,0,0,0,,一个非常小的缓冲区分配，没有保护
Dialogue: 0,0:53:03.96,0:53:08.36,English,,0,0,0,,Somehow the system protected me from myself
Dialogue: 0,0:53:03.96,0:53:08.36,Chinese,,0,0,0,,不知怎的，系统保护我自己
Dialogue: 0,0:53:10.30,0:53:15.66,English,,0,0,0,,And that's a by a relatively simple trick that's a fairly clever though
Dialogue: 0,0:53:10.30,0:53:15.66,Chinese,,0,0,0,,而这是一个相对简单的技巧，虽然相当聪明
Dialogue: 0,0:53:17.40,0:53:19.62,English,,0,0,0,,What they call stack canary
Dialogue: 0,0:53:17.40,0:53:19.62,Chinese,,0,0,0,,他们称之为堆栈金丝雀
Dialogue: 0,0:53:20.36,0:53:27.32,English,,0,0,0,,So that the term canary comes back from a back in the coal mining days of old
Dialogue: 0,0:53:20.36,0:53:27.32,Chinese,,0,0,0,,因此，金丝雀这个词在古老的采煤时代从后面回来了
Dialogue: 0,0:53:27.68,0:53:33.38,English,,0,0,0,,Before they had very good ways of measuring things they take a bird down with them in a cage
Dialogue: 0,0:53:27.68,0:53:33.38,Chinese,,0,0,0,,在他们有很好的测量方法之前，他们会把一只鸟放在笼子里
Dialogue: 0,0:53:33.92,0:53:40.64,English,,0,0,0,,And a canary is a property that's very susceptible to dying
Dialogue: 0,0:53:33.92,0:53:40.64,Chinese,,0,0,0,,金丝雀是一种非常容易死亡的财产
Dialogue: 0,0:53:42.06,0:53:44.96,English,,0,0,0,,If there's nothing if there's methane gas present
Dialogue: 0,0:53:42.06,0:53:44.96,Chinese,,0,0,0,,如果存在甲烷气体则没有任何东西
Dialogue: 0,0:53:44.96,0:53:48.84,English,,0,0,0,,So these miners would be down there working and they'd see their bird
Dialogue: 0,0:53:44.96,0:53:48.84,Chinese,,0,0,0,,所以这些矿工会在那里工作，他们会看到他们的鸟
Dialogue: 0,0:53:49.56,0:53:52.92,English,,0,0,0,,Keel over and say oh we got a problem here let's get out fast
Dialogue: 0,0:53:49.56,0:53:52.92,Chinese,,0,0,0,,Keel over并说哦我们在这里遇到问题让我们快点出去吧
Dialogue: 0,0:53:53.42,0:53:57.14,English,,0,0,0,,So that's why they call it a canary in a coal mine sometimes
Dialogue: 0,0:53:53.42,0:53:57.14,Chinese,,0,0,0,,所以这就是为什么他们有时称它为煤矿中的金丝雀
Dialogue: 0,0:53:57.14,0:54:00.60,English,,0,0,0,,Some kind of warning signal that that something's not right here
Dialogue: 0,0:53:57.14,0:54:00.60,Chinese,,0,0,0,,某种警告表明某事不在这里
Dialogue: 0,0:54:01.82,0:54:08.28,English,,0,0,0,,And in general we see a GCC if you invoke it with a stack protector
Dialogue: 0,0:54:01.82,0:54:08.28,Chinese,,0,0,0,,一般来说，如果你用堆栈保护器调用它，我们会看到一个GCC
Dialogue: 0,0:54:08.28,0:54:09.90,English,,0,0,0,,Nowadays that's the default
Dialogue: 0,0:54:08.28,0:54:09.90,Chinese,,0,0,0,,现在这是默认的
Dialogue: 0,0:54:10.82,0:54:15.48,English,,0,0,0,,So even without you saying anything this code will get built into it
Dialogue: 0,0:54:10.82,0:54:15.48,Chinese,,0,0,0,,所以即使没有你说任何东西，这些代码也会被嵌入其中
Dialogue: 0,0:54:18.62,0:54:21.80,English,,0,0,0,,And so let's look at at what that canary code looks like
Dialogue: 0,0:54:18.62,0:54:21.80,Chinese,,0,0,0,,让我们来看看那些金丝雀代码是什么样的
Dialogue: 0,0:54:21.80,0:54:24.84,English,,0,0,0,,And how it does its thing it's really pretty clever as I said
Dialogue: 0,0:54:21.80,0:54:24.84,Chinese,,0,0,0,,它如何做到这一点它就像我说的那样非常聪明
Dialogue: 0,0:54:25.24,0:54:29.24,English,,0,0,0,,And some of you have already observed this strange kind of memory reference
Dialogue: 0,0:54:25.24,0:54:29.24,Chinese,,0,0,0,,你们中的一些人已经观察到了这种奇怪的记忆参考
Dialogue: 0,0:54:29.34,0:54:34.46,English,,0,0,0,,In a register reference in the code and your boom labs
Dialogue: 0,0:54:29.34,0:54:34.46,Chinese,,0,0,0,,在代码中的寄存器参考和你的繁荣实验室中
Dialogue: 0,0:54:34.46,0:54:39.08,English,,0,0,0,,Because it was compiled with this deck protecting enabled because that's the default
Dialogue: 0,0:54:34.46,0:54:39.08,Chinese,,0,0,0,,因为它是在启用了这个甲板保护的情况下编译的，因为这是默认设置
Dialogue: 0,0:54:40.26,0:54:48.36,English,,0,0,0,,And so in particular what this code shows is it's allocating as before 24 bytes on the stack
Dialogue: 0,0:54:40.26,0:54:48.36,Chinese,,0,0,0,,所以特别是这个代码显示的是它在堆栈上分配24个字节之前
Dialogue: 0,0:54:49.22,0:54:53.92,English,,0,0,0,,But now it's getting some number and we'll talk in a second what that means
Dialogue: 0,0:54:49.22,0:54:53.92,Chinese,,0,0,0,,但现在它已经得到了一些数字，我们将在一秒钟内谈论这意味着什么
Dialogue: 0,0:54:54.42,0:55:01.22,English,,0,0,0,,And storing it at position 8 offset from the stack pointer
Dialogue: 0,0:54:54.42,0:55:01.22,Chinese,,0,0,0,,并将其存储在偏离堆栈指针的位置8处
Dialogue: 0,0:55:01.80,0:55:06.42,English,,0,0,0,,And then the rest of the code and then it zeros it out that's not to worry
Dialogue: 0,0:55:01.80,0:55:06.42,Chinese,,0,0,0,,然后是剩下的代码，然后把它归零，不用担心
Dialogue: 0,0:55:06.64,0:55:12.36,English,,0,0,0,,And then it looks like the your previous code that it's passing a pointer to the stack
Dialogue: 0,0:55:06.64,0:55:12.36,Chinese,,0,0,0,,然后它看起来像你以前的代码，它传递指向堆栈的指针
Dialogue: 0,0:55:13.14,0:55:15.82,English,,0,0,0,,Top of the stack as the argument to gets
Dialogue: 0,0:55:13.14,0:55:15.82,Chinese,,0,0,0,,作为获取参数的堆栈顶部
Dialogue: 0,0:55:17.04,0:55:21.66,English,,0,0,0,,And gets it gets called and then puts gets called
Dialogue: 0,0:55:17.04,0:55:21.66,Chinese,,0,0,0,,得到它被调用然后put被调用
Dialogue: 0,0:55:22.28,0:55:28.80,English,,0,0,0,,But now there's some more code here that is it involves this strange looking register
Dialogue: 0,0:55:22.28,0:55:28.80,Chinese,,0,0,0,,但现在这里有更多的代码，它涉及这个奇怪的寄存器
Dialogue: 0,0:55:29.22,0:55:33.82,English,,0,0,0,,And then there's some kind of test and then if that test fails
Dialogue: 0,0:55:29.22,0:55:33.82,Chinese,,0,0,0,,然后是某种测试然后如果测试失败
Dialogue: 0,0:55:34.64,0:55:40.72,English,,0,0,0,,It will call this a code that you just saw printed out this error message
Dialogue: 0,0:55:34.64,0:55:40.72,Chinese,,0,0,0,,它将调用此代码，你刚刚看到打印出此错误消息
Dialogue: 0,0:55:42.68,0:55:44.76,English,,0,0,0,,So let's see what that all means
Dialogue: 0,0:55:42.68,0:55:44.76,Chinese,,0,0,0,,那么让我们看看这一切意味着什么
Dialogue: 0,0:55:45.00,0:55:51.30,English,,0,0,0,,What that means is that at offset 8 from the stack pointer
Dialogue: 0,0:55:45.00,0:55:51.30,Chinese,,0,0,0,,这意味着在堆栈指针偏移8处
Dialogue: 0,0:55:51.30,0:55:54.70,English,,0,0,0,,It's putting in 8 bytes a value
Dialogue: 0,0:55:51.30,0:55:54.70,Chinese,,0,0,0,,它输入了8个字节的值
Dialogue: 0,0:55:55.52,0:55:59.84,English,,0,0,0,,That it's retrieving from a special register
Dialogue: 0,0:55:55.52,0:55:59.84,Chinese,,0,0,0,,它是从特殊寄存器中检索的
Dialogue: 0,0:55:59.84,0:56:07.84,English,,0,0,0,,So fs is a reference to a type of register that was created for the original 8086
Dialogue: 0,0:55:59.84,0:56:07.84,Chinese,,0,0,0,,所以fs是对为原始8086创建的一种寄存器的引用
Dialogue: 0,0:56:07.84,0:56:12.26,English,,0,0,0,,And is now completely obsolete but it's still there for backward compatibility mode
Dialogue: 0,0:56:07.84,0:56:12.26,Chinese,,0,0,0,,现在已经完全过时，但它仍然存在向后兼容模式
Dialogue: 0,0:56:12.78,0:56:18.64,English,,0,0,0,,But what it is it and I actually I looked and I've never fully been able to find the documentation on it
Dialogue: 0,0:56:12.78,0:56:18.64,Chinese,,0,0,0,,但它是什么，我实际上看了，我从来没有完全找到它的文档
Dialogue: 0,0:56:19.16,0:56:21.90,English,,0,0,0,,It's able to read from a part of memory
Dialogue: 0,0:56:19.16,0:56:21.90,Chinese,,0,0,0,,它能够从内存的一部分读取
Dialogue: 0,0:56:22.40,0:56:28.08,English,,0,0,0,,A set of values that you can't otherwise get to
Dialogue: 0,0:56:22.40,0:56:28.08,Chinese,,0,0,0,,一组你无法获得的值
Dialogue: 0,0:56:28.56,0:56:35.70,English,,0,0,0,,And so that's the canary it's getting a somehow it's grabbing eight bytes from somewhere
Dialogue: 0,0:56:28.56,0:56:35.70,Chinese,,0,0,0,,所以这就是金丝雀它正在以某种方式从某个地方获取8个字节
Dialogue: 0,0:56:36.42,0:56:38.62,English,,0,0,0,,Storing it as this canary value
Dialogue: 0,0:56:36.42,0:56:38.62,Chinese,,0,0,0,,存储它作为这个金丝雀的价值
Dialogue: 0,0:56:40.08,0:56:43.82,English,,0,0,0,,And then if you give like a seven character input
Dialogue: 0,0:56:40.08,0:56:43.82,Chinese,,0,0,0,,然后，如果你给出一个七字符输入
Dialogue: 0,0:56:45.32,0:56:50.06,English,,0,0,0,,So you would affect the canary and so what happens when it returns from
Dialogue: 0,0:56:45.32,0:56:50.06,Chinese,,0,0,0,,所以你会影响金丝雀，所以当它返回时会发生什么
Dialogue: 0,0:56:51.96,0:56:57.60,English,,0,0,0,,The two calls from gets and puts before it exits
Dialogue: 0,0:56:51.96,0:56:57.60,Chinese,,0,0,0,,来自get和puts的两个调用在它退出之前
Dialogue: 0,0:56:57.60,0:57:05.12,English,,0,0,0,,What it's trying to detect is has anything as this buffer somehow overflowed
Dialogue: 0,0:56:57.60,0:57:05.12,Chinese,,0,0,0,,它试图检测的是什么，因为这个缓冲区以某种方式溢出
Dialogue: 0,0:57:05.50,0:57:09.90,English,,0,0,0,,And potentially at risk of corrupting some other part of the stack
Dialogue: 0,0:57:05.50,0:57:09.90,Chinese,,0,0,0,,并且可能存在损坏堆栈的其他部分的风险
Dialogue: 0,0:57:10.52,0:57:16.14,English,,0,0,0,,So basically what it does is it retrieves back from the stack
Dialogue: 0,0:57:10.52,0:57:16.14,Chinese,,0,0,0,,所以基本上它的作用是从堆栈中检索回来
Dialogue: 0,0:57:16.54,0:57:19.06,English,,0,0,0,,What is the current value of this canary
Dialogue: 0,0:57:16.54,0:57:19.06,Chinese,,0,0,0,,这只金丝雀的当前价值是多少？
Dialogue: 0,0:57:19.62,0:57:26.50,English,,0,0,0,,And it's comparing it to what it should be by retrieving that back from this special region
Dialogue: 0,0:57:19.62,0:57:26.50,Chinese,,0,0,0,,它通过从这个特殊区域检索回来将它与它应该是什么进行比较
Dialogue: 0,0:57:26.94,0:57:29.94,English,,0,0,0,,And if they're equal it says fine
Dialogue: 0,0:57:26.94,0:57:29.94,Chinese,,0,0,0,,如果他们是平等的，那就说得很好
Dialogue: 0,0:57:30.34,0:57:35.54,English,,0,0,0,,But if they're not equal it's detecting this got corrupted so just like the canary in the coalmine
Dialogue: 0,0:57:30.34,0:57:35.54,Chinese,,0,0,0,,但是，如果它们不相等，它就会发现它已被腐蚀，就像煤矿中的金丝雀一样
Dialogue: 0,0:57:35.96,0:57:40.94,English,,0,0,0,,If these bytes get corrupted in any form,it's an indication that something went wrong
Dialogue: 0,0:57:35.96,0:57:40.94,Chinese,,0,0,0,,如果这些字节以任何形式被破坏，则表明出现了问题
Dialogue: 0,0:57:42.42,0:57:48.52,English,,0,0,0,,Now that example shows that if I have a seven characters string
Dialogue: 0,0:57:42.42,0:57:48.52,Chinese,,0,0,0,,现在该示例显示如果我有一个七个字符的字符串
Dialogue: 0,0:57:48.88,0:57:51.34,English,,0,0,0,,Then I'm not going to corrupt the canary
Dialogue: 0,0:57:48.88,0:57:51.34,Chinese,,0,0,0,,那我就不会腐败金丝雀
Dialogue: 0,0:57:52.42,0:57:55.70,English,,0,0,0,,But you notice I just got away with an eight character string
Dialogue: 0,0:57:52.42,0:57:55.70,Chinese,,0,0,0,,但是你注意到我刚刚拿走了八个字符的字符串
Dialogue: 0,0:57:57.62,0:58:03.20,English,,0,0,0,,So let me just see what's going on here
Dialogue: 0,0:57:57.62,0:58:03.20,Chinese,,0,0,0,,那么让我看看这里发生了什么
Dialogue: 0,0:58:30.60,0:58:32.54,English,,0,0,0,,Okay I want a character string right
Dialogue: 0,0:58:30.60,0:58:32.54,Chinese,,0,0,0,,好的，我想要一个正确的字符串
Dialogue: 0,0:58:35.30,0:58:36.60,English,,0,0,0,,Oh wait wait wait
Dialogue: 0,0:58:35.30,0:58:36.60,Chinese,,0,0,0,,哦等等等
Dialogue: 0,0:58:42.74,0:58:47.20,English,,0,0,0,,Ah sorry I have to look I don't have the code in front of me,so I have to look at
Dialogue: 0,0:58:42.74,0:58:47.20,Chinese,,0,0,0,,对不起，我要看看我面前没有代码，所以我要看一下
Dialogue: 0,0:58:52.98,0:59:00.20,English,,0,0,0,,So anyways here's where it's subtracting 24 from the stack pointer
Dialogue: 0,0:58:52.98,0:59:00.20,Chinese,,0,0,0,,所以无论如何它在这里从堆栈指针中减去24
Dialogue: 0,0:59:00.76,0:59:04.80,English,,0,0,0,,And then the next instruction is retrieving this canary value
Dialogue: 0,0:59:00.76,0:59:04.80,Chinese,,0,0,0,,然后下一条指令就是检索这个金丝雀值
Dialogue: 0,0:59:04.80,0:59:09.12,English,,0,0,0,,So let's figure out what the canary is right now we are at
Dialogue: 0,0:59:04.80,0:59:09.12,Chinese,,0,0,0,,那么让我们弄清楚我们现在所处的金丝雀是什么
Dialogue: 0,0:59:16.25,0:59:20.00,English,,0,0,0,,72f so we're at the first instruction here
Dialogue: 0,0:59:16.25,0:59:20.00,Chinese,,0,0,0,,72f所以我们在这里的第一个指令
Dialogue: 0,0:59:25.84,0:59:39.48,English,,0,0,0,,Let's do another step
Dialogue: 0,0:59:25.84,0:59:39.48,Chinese,,0,0,0,,让我们再做一步
Dialogue: 0,0:59:40.06,0:59:41.74,English,,0,0,0,,So this is the canary
Dialogue: 0,0:59:40.06,0:59:41.74,Chinese,,0,0,0,,这就是金丝雀
Dialogue: 0,0:59:44.46,0:59:48.96,English,,0,0,0,,And it's you'll see actually when from one run to another you get a different value of it
Dialogue: 0,0:59:44.46,0:59:48.96,Chinese,,0,0,0,,实际上，当你从一次奔跑到另一次奔跑时，你会看到它的不同价值
Dialogue: 0,0:59:49.04,0:59:52.82,English,,0,0,0,,So it's purposely put in there in a way that it's unpredictable
Dialogue: 0,0:59:49.04,0:59:52.82,Chinese,,0,0,0,,所以它故意以一种不可预测的方式放在那里
Dialogue: 0,0:59:53.42,0:59:56.94,English,,0,0,0,,The one thing you'll notice is that the lower byte is zeroes
Dialogue: 0,0:59:53.42,0:59:56.94,Chinese,,0,0,0,,你会注意到的一件事是低位字节是零
Dialogue: 0,0:59:57.80,1:00:04.78,English,,0,0,0,,And so apparently they knew that it's so common to have suit off-by-one bugs with strings
Dialogue: 0,0:59:57.80,1:00:04.78,Chinese,,0,0,0,,所以显然他们知道，通过字符串逐个出现错误是很常见的
Dialogue: 0,1:00:04.78,1:00:08.42,English,,0,0,0,,Where you don't allocate enough space for the null terminator
Dialogue: 0,1:00:04.78,1:00:08.42,Chinese,,0,0,0,,你没有为null终止符分配足够空间的地方
Dialogue: 0,1:00:08.82,1:00:10.46,English,,0,0,0,,That they said well rather
Dialogue: 0,1:00:08.82,1:00:10.46,Chinese,,0,0,0,,他们说的很好
Dialogue: 0,1:00:10.94,1:00:16.08,English,,0,0,0,,Than having a canary that will detect that bite being corrupted we'll just sort of give that bite away
Dialogue: 0,1:00:10.94,1:00:16.08,Chinese,,0,0,0,,如果有一只金丝雀会检测到这种叮咬被腐蚀，我们只会把它咬掉
Dialogue: 0,1:00:16.96,1:00:21.76,English,,0,0,0,,And so that's why it's letting me type in eight characters
Dialogue: 0,1:00:16.96,1:00:21.76,Chinese,,0,0,0,,这就是为什么它让我输入八个字符
Dialogue: 0,1:00:21.84,1:00:26.28,English,,0,0,0,,And it's overriding this low order byte of the canary later on
Dialogue: 0,1:00:21.84,1:00:26.28,Chinese,,0,0,0,,它稍后会覆盖金丝雀的这个低位字节
Dialogue: 0,1:00:26.76,1:00:28.96,English,,0,0,0,,But that's not going to affect anything
Dialogue: 0,1:00:26.76,1:00:28.96,Chinese,,0,0,0,,但这不会影响任何事情
Dialogue: 0,1:00:53.44,1:00:59.60,English,,0,0,0,,But let's give it, 9 characters,10 character string,a 9 character string
Dialogue: 0,1:00:53.44,1:00:59.60,Chinese,,0,0,0,,但是让我们给它，9个字符，10个字符串，一个9个字符的字符串
Dialogue: 0,1:01:52.17,1:01:54.78,English,,0,0,0,,All right chars mark
Dialogue: 0,1:01:52.17,1:01:54.78,Chinese,,0,0,0,,好的字符标记
Dialogue: 0,1:01:55.12,1:02:01.14,English,,0,0,0,,Oh well I'm not finding it where I thought it would be
Dialogue: 0,1:01:55.12,1:02:01.14,Chinese,,0,0,0,,哦，我找不到我想的那样
Dialogue: 0,1:02:01.34,1:02:08.58,English,,0,0,0,,Anyways oh this will crop this deck
Dialogue: 0,1:02:01.34,1:02:08.58,Chinese,,0,0,0,,无论如何哦，这将裁剪这个甲板
Dialogue: 0,1:02:08.80,1:02:12.20,English,,0,0,0,,But what I showing you the main idea is the canaries some value
Dialogue: 0,1:02:08.80,1:02:12.20,Chinese,,0,0,0,,但是我向你展示的主要想法是金丝雀有些价值
Dialogue: 0,1:02:12.20,1:02:15.18,English,,0,0,0,,That gets pulled out and it will vary from one time to the next
Dialogue: 0,1:02:12.20,1:02:15.18,Chinese,,0,0,0,,它被拉出来，它会随着时间的推移而变化
Dialogue: 0,1:02:16.00,1:02:20.72,English,,0,0,0,,And it's letting you get away with eight characters plus the null terminator
Dialogue: 0,1:02:16.00,1:02:20.72,Chinese,,0,0,0,,它让你逃脱八个字符加上空终结符
Dialogue: 0,1:02:20.92,1:02:23.90,English,,0,0,0,,But anything more and it will detect that corruption
Dialogue: 0,1:02:20.92,1:02:23.90,Chinese,,0,0,0,,但更重要的是它会发现腐败
Dialogue: 0,1:02:38.60,1:02:44.16,English,,0,0,0,,Okay so now we've seen three different protection well for one is write better code
Dialogue: 0,1:02:38.60,1:02:44.16,Chinese,,0,0,0,,好的，现在我们已经看到三种不同的保护，一种是写更好的代码
Dialogue: 0,1:02:46.30,1:02:51.50,English,,0,0,0,,But there's three protections that are done by the system that have nothing to do with your code
Dialogue: 0,1:02:46.30,1:02:51.50,Chinese,,0,0,0,,但是系统完成了三项与你的代码无关的保护措施
Dialogue: 0,1:02:51.74,1:02:58.24,English,,0,0,0,,Right one is to randomize the stack position
Dialogue: 0,1:02:51.74,1:02:58.24,Chinese,,0,0,0,,正确的是将堆栈位置随机化
Dialogue: 0,1:02:58.26,1:03:01.20,English,,0,0,0,,So it's harder to figure out where the start addresses are
Dialogue: 0,1:02:58.26,1:03:01.20,Chinese,,0,0,0,,所以很难弄清楚起始地址在哪里
Dialogue: 0,1:03:01.72,1:03:07.48,English,,0,0,0,,The second is to make the stack so it's not executable so you can't put code on that
Dialogue: 0,1:03:01.72,1:03:07.48,Chinese,,0,0,0,,第二个是使堆栈成为不可执行的，所以你不能把代码放在那里
Dialogue: 0,1:03:08.04,1:03:12.20,English,,0,0,0,,And then the third is to use a stack canary or other mechanisms to detect
Dialogue: 0,1:03:08.04,1:03:12.20,Chinese,,0,0,0,,然后第三个是使用堆栈金丝雀或其他机制来检测
Dialogue: 0,1:03:13.00,1:03:15.68,English,,0,0,0,,A potential buffer overflow at the source
Dialogue: 0,1:03:13.00,1:03:15.68,Chinese,,0,0,0,,源处的潜在缓冲区溢出
Dialogue: 0,1:03:16.94,1:03:22.34,English,,0,0,0,,So now there's another attack that was developed in response to some of these
Dialogue: 0,1:03:16.94,1:03:22.34,Chinese,,0,0,0,,所以现在还有另一个针对其中一些攻击而开发的攻击
Dialogue: 0,1:03:25.00,1:03:30.02,English,,0,0,0,,That is still often successful it's called return I did programming
Dialogue: 0,1:03:25.00,1:03:30.02,Chinese,,0,0,0,,这仍然是成功的，它被称为返回我编程
Dialogue: 0,1:03:30.42,1:03:33.26,English,,0,0,0,,And for your attack lab you're going to be doing these attacks too
Dialogue: 0,1:03:30.42,1:03:33.26,Chinese,,0,0,0,,而对于你的攻击实验室，你也会做这些攻击
Dialogue: 0,1:03:33.26,1:03:36.10,English,,0,0,0,,That's why the attack lab is different than the old lab
Dialogue: 0,1:03:33.26,1:03:36.10,Chinese,,0,0,0,,这就是攻击实验室与旧实验室不同的原因
Dialogue: 0,1:03:36.10,1:03:41.22,English,,0,0,0,,Way of the old web just code injection exploits now you're doing both code injection
Dialogue: 0,1:03:36.10,1:03:41.22,Chinese,,0,0,0,,旧网的方式只是代码注入利用现在你正在做代码注入
Dialogue: 0,1:03:41.79,1:03:43.56,English,,0,0,0,,And return oriented programming
Dialogue: 0,1:03:41.79,1:03:43.56,Chinese,,0,0,0,,并返回面向编程
Dialogue: 0,1:03:44.38,1:03:51.12,English,,0,0,0,,So the idea this is if you are a hacker you're frustrated
Dialogue: 0,1:03:44.38,1:03:51.12,Chinese,,0,0,0,,所以，如果你是一名黑客，那么你就会感到沮丧
Dialogue: 0,1:03:51.12,1:03:58.72,English,,0,0,0,,Because of these these three techniques stack randomization non-executable stack and canaries
Dialogue: 0,1:03:51.12,1:03:58.72,Chinese,,0,0,0,,由于这些技术，这三种技术堆叠随机化非可执行堆栈和金丝雀
Dialogue: 0,1:03:59.10,1:04:07.48,English,,0,0,0,,Well I can't fix the canary problem that actually the canary is a pretty secure technique
Dialogue: 0,1:03:59.10,1:04:07.48,Chinese,,0,0,0,,好吧，我无法修复金丝雀问题，实际上金丝雀是一种非常安全的技术
Dialogue: 0,1:04:07.58,1:04:12.28,English,,0,0,0,,There's very I've never seen anyone able to bypass a stet canary
Dialogue: 0,1:04:07.58,1:04:12.28,Chinese,,0,0,0,,我从未见过有人能绕过金丝雀
Dialogue: 0,1:04:13.04,1:04:15.90,English,,0,0,0,,But the other two you can do it using this technique
Dialogue: 0,1:04:13.04,1:04:15.90,Chinese,,0,0,0,,但是另外两个你可以使用这种技术来做到这一点
Dialogue: 0,1:04:16.44,1:04:20.48,English,,0,0,0,,And the strategy is so we don't know where the stack is
Dialogue: 0,1:04:16.44,1:04:20.48,Chinese,,0,0,0,,策略是如此，我们不知道堆栈在哪里
Dialogue: 0,1:04:21.42,1:04:23.26,English,,0,0,0,,But we could still
Dialogue: 0,1:04:21.42,1:04:23.26,Chinese,,0,0,0,,但我们仍然可以
Dialogue: 0,1:04:24.04,1:04:27.74,English,,0,0,0,,But we know where the code is because you saw in that example the code
Dialogue: 0,1:04:24.04,1:04:27.74,Chinese,,0,0,0,,但我们知道代码的位置，因为你在该示例中看到了代码
Dialogue: 0,1:04:28.26,1:04:33.94,English,,0,0,0,,My layout randomization was shifting the stack positions in the heap positions
Dialogue: 0,1:04:28.26,1:04:33.94,Chinese,,0,0,0,,我的布局随机化正在改变堆位置的堆栈位置
Dialogue: 0,1:04:34.54,1:04:40.34,English,,0,0,0,,But it wasn't changing either global variables or or the code itself
Dialogue: 0,1:04:34.54,1:04:40.34,Chinese,,0,0,0,,但它并没有改变全局变量或代码本身
Dialogue: 0,1:04:41.32,1:04:50.04,English,,0,0,0,,So what if I can find some code that sort of already there in the existing part of the program
Dialogue: 0,1:04:41.32,1:04:50.04,Chinese,,0,0,0,,那么，如果我能在程序的现有部分找到一些已经存在的代码，该怎么办呢？
Dialogue: 0,1:04:50.60,1:04:55.30,English,,0,0,0,,And I'll use that instead of my own code that I've injected
Dialogue: 0,1:04:50.60,1:04:55.30,Chinese,,0,0,0,,而且我将使用它而不是我注入的自己的代码
Dialogue: 0,1:04:55.98,1:05:00.94,English,,0,0,0,,And of course in general you're not going to find exactly lying there the exact program
Dialogue: 0,1:04:55.98,1:05:00.94,Chinese,,0,0,0,,当然，一般来说，你不会找到准确的程序
Dialogue: 0,1:05:00.94,1:05:05.76,English,,0,0,0,,You want to execute that will cause whatever harm you intend to do
Dialogue: 0,1:05:00.94,1:05:05.76,Chinese,,0,0,0,,你想执行它会导致你想要做的任何伤害
Dialogue: 0,1:05:06.50,1:05:09.74,English,,0,0,0,,Because that's not usually compiled into most programs
Dialogue: 0,1:05:06.50,1:05:09.74,Chinese,,0,0,0,,因为这通常不会编译到大多数程序中
Dialogue: 0,1:05:09.76,1:05:15.34,English,,0,0,0,,But if I could set a string together little segments of code
Dialogue: 0,1:05:09.76,1:05:15.34,Chinese,,0,0,0,,但是，如果我可以将一小段代码设置在一起
Dialogue: 0,1:05:15.90,1:05:22.54,English,,0,0,0,,And somehow put together a series of little sequences of code
Dialogue: 0,1:05:15.90,1:05:22.54,Chinese,,0,0,0,,并以某种方式汇集了一系列小代码序列
Dialogue: 0,1:05:22.78,1:05:24.86,English,,0,0,0,,Maybe I can get something useful done
Dialogue: 0,1:05:22.78,1:05:24.86,Chinese,,0,0,0,,也许我可以做一些有用的事情
Dialogue: 0,1:05:25.54,1:05:28.38,English,,0,0,0,,And so that's the idea of this return oriented programming
Dialogue: 0,1:05:25.54,1:05:28.38,Chinese,,0,0,0,,这就是这种面向回归编程的想法
Dialogue: 0,1:05:28.94,1:05:33.38,English,,0,0,0,,And the idea of it is to find what are known as gadgets
Dialogue: 0,1:05:28.94,1:05:33.38,Chinese,,0,0,0,,而它的想法是找到所谓的小工具
Dialogue: 0,1:05:34.28,1:05:40.52,English,,0,0,0,,And a gadget is a sequence of bytes  that are represent part of the executable program
Dialogue: 0,1:05:34.28,1:05:40.52,Chinese,,0,0,0,,小工具是一系列字节，代表可执行程序的一部分
Dialogue: 0,1:05:40.86,1:05:47.38,English,,0,0,0,,Where the last byte this is x86 talking here  has a hex value c3
Dialogue: 0,1:05:40.86,1:05:47.38,Chinese,,0,0,0,,这是x86说话的最后一个字节在这里有一个十六进制值c3
Dialogue: 0,1:05:47.60,1:05:56.64,English,,0,0,0,,Which is how the ret instruction the return instruction is encoded  in x86 both IA32 and x64
Dialogue: 0,1:05:47.60,1:05:56.64,Chinese,,0,0,0,,这是返回指令在x86中对IA32和x64进行编码的ret指令的方式
Dialogue: 0,1:05:59.04,1:06:01.32,English,,0,0,0,,And so as an example
Dialogue: 0,1:05:59.04,1:06:01.32,Chinese,,0,0,0,,以此为例
Dialogue: 0,1:06:02.20,1:06:05.48,English,,0,0,0,,On the easy case is where there's some function
Dialogue: 0,1:06:02.20,1:06:05.48,Chinese,,0,0,0,,在简单的情况下，有一些功能
Dialogue: 0,1:06:07.00,1:06:12.96,English,,0,0,0,,And it implements some operation that I might find useful as an attacker to be able to do
Dialogue: 0,1:06:07.00,1:06:12.96,Chinese,,0,0,0,,并且它实现了一些我可能会发现作为攻击者能够做的有用的操作
Dialogue: 0,1:06:13.48,1:06:18.16,English,,0,0,0,,So for example this function is computing a*b+c
Dialogue: 0,1:06:13.48,1:06:18.16,Chinese,,0,0,0,,因此，例如，此函数计算a * b + c
Dialogue: 0,1:06:18.94,1:06:25.64,English,,0,0,0,,And if I look at just the last two instructions from there one of them is a lea which is performing addition
Dialogue: 0,1:06:18.94,1:06:25.64,Chinese,,0,0,0,,如果我只看那里的最后两条指令，其中一条是执行加法的lea
Dialogue: 0,1:06:26.50,1:06:29.58,English,,0,0,0,,And the other is doing a return
Dialogue: 0,1:06:26.50,1:06:29.58,Chinese,,0,0,0,,另一个是回报
Dialogue: 0,1:06:29.92,1:06:33.90,English,,0,0,0,,So I can think of this good old five bunk byte chunk
Dialogue: 0,1:06:29.92,1:06:33.90,Chinese,,0,0,0,,所以我可以想到这个好旧的五个双层字节块
Dialogue: 0,1:06:34.26,1:06:40.24,English,,0,0,0,,Is a way if I could get some data in registers %rdi and %rdx
Dialogue: 0,1:06:34.26,1:06:40.24,Chinese,,0,0,0,,如果我可以在寄存器％rdi和％rdx中获取一些数据，这是一种方法
Dialogue: 0,1:06:40.92,1:06:44.34,English,,0,0,0,,Then I could compute their sum and stick it in %rax
Dialogue: 0,1:06:40.92,1:06:44.34,Chinese,,0,0,0,,然后我可以计算他们的总和并坚持在％rax
Dialogue: 0,1:06:44.48,1:06:47.12,English,,0,0,0,,So imagine taking your program you're trying to execute
Dialogue: 0,1:06:44.48,1:06:47.12,Chinese,,0,0,0,,所以想象你正在尝试执行你的程序
Dialogue: 0,1:06:47.46,1:06:49.40,English,,0,0,0,,And breaking it up into these good old fragments
Dialogue: 0,1:06:47.46,1:06:49.40,Chinese,,0,0,0,,并将其分解为这些优秀的旧片段
Dialogue: 0,1:06:49.76,1:06:55.10,English,,0,0,0,,And you want to somehow find little block of code somewhere to implement each of these fragments
Dialogue: 0,1:06:49.76,1:06:55.10,Chinese,,0,0,0,,并且你希望以某种方式在某处找到一小块代码来实现这些片段
Dialogue: 0,1:06:55.96,1:07:00.52,English,,0,0,0,,And then the interesting part is because they each end in c3 this return
Dialogue: 0,1:06:55.96,1:07:00.52,Chinese,,0,0,0,,然后有趣的部分是因为它们各自以c3结束这一回归
Dialogue: 0,1:07:00.84,1:07:04.50,English,,0,0,0,,It has is it,well let me get to that in it
Dialogue: 0,1:07:00.84,1:07:04.50,Chinese,,0,0,0,,它就是它，让我在其中得到它
Dialogue: 0,1:07:05.12,1:07:10.96,English,,0,0,0,,So that's sort of the obvious way that you pull out this is an addition which you'd expect
Dialogue: 0,1:07:05.12,1:07:10.96,Chinese,,0,0,0,,因此，你可以选择这种方式，这是你所期望的一种补充
Dialogue: 0,1:07:10.96,1:07:13.04,English,,0,0,0,,Because that was in the original C code
Dialogue: 0,1:07:10.96,1:07:13.04,Chinese,,0,0,0,,因为那是原始的C代码
Dialogue: 0,1:07:13.92,1:07:19.52,English,,0,0,0,,But here's an example of a gadget that has nothing to do with the original C code
Dialogue: 0,1:07:13.92,1:07:19.52,Chinese,,0,0,0,,但这是一个与原始C代码无关的小工具示例
Dialogue: 0,1:07:19.80,1:07:26.14,English,,0,0,0,,It just happens to match the byte pattern of of some existing code
Dialogue: 0,1:07:19.80,1:07:26.14,Chinese,,0,0,0,,它碰巧匹配一些现有代码的字节模式
Dialogue: 0,1:07:26.66,1:07:36.04,English,,0,0,0,,So this function seems to not do anything too terribly useful from a hackers point of view
Dialogue: 0,1:07:26.66,1:07:36.04,Chinese,,0,0,0,,因此，从黑客的角度来看，这个功能似乎没有做任何非常有用的功能
Dialogue: 0,1:07:36.70,1:07:39.46,English,,0,0,0,,But if you look at this particular byte sequence
Dialogue: 0,1:07:36.70,1:07:39.46,Chinese,,0,0,0,,但是如果你看一下这个特定的字节序列
Dialogue: 0,1:07:39.56,1:07:43.82,English,,0,0,0,,That happens to encode the instruction movq are %rax to %rdi
Dialogue: 0,1:07:39.56,1:07:43.82,Chinese,,0,0,0,,这恰好编码指令movq是％rax到％rdi
Dialogue: 0,1:07:44.56,1:07:46.44,English,,0,0,0,,And c3 encodes repped
Dialogue: 0,1:07:44.56,1:07:46.44,Chinese,,0,0,0,,并且c3编码重新编写
Dialogue: 0,1:07:47.14,1:07:51.68,English,,0,0,0,,So and you can see if this is at address for d9
Dialogue: 0,1:07:47.14,1:07:51.68,Chinese,,0,0,0,,所以你可以看看这是否在d9的地址
Dialogue: 0,1:07:52.26,1:07:55.48,English,,0,0,0,,That's 4da, 4db,4dc
Dialogue: 0,1:07:52.26,1:07:55.48,Chinese,,0,0,0,,那是4da，4db，4dc
Dialogue: 0,1:07:55.50,1:08:00.06,English,,0,0,0,,So at address 0x4004dc
Dialogue: 0,1:07:55.50,1:08:00.06,Chinese,,0,0,0,,所以在地址0x4004dc
Dialogue: 0,1:08:00.48,1:08:06.84,English,,0,0,0,,If you could start executing here it would first do a move and then it would do a return
Dialogue: 0,1:08:00.48,1:08:06.84,Chinese,,0,0,0,,如果你可以在这里开始执行它首先会做一个移动，然后它会返回
Dialogue: 0,1:08:07.62,1:08:13.66,English,,0,0,0,,So I'm sort of taking advantage of the fact in x86 it's this buy donated instruction sequence
Dialogue: 0,1:08:07.62,1:08:13.66,Chinese,,0,0,0,,所以我有点利用x86中的这个事实，就是这个购买捐赠的指令序列
Dialogue: 0,1:08:14.36,1:08:23.34,English,,0,0,0,,And if I sort of go off the aligned instructions I can often find useful things to do
Dialogue: 0,1:08:14.36,1:08:23.34,Chinese,,0,0,0,,如果我按照一致的指示去做，我经常可以找到有用的事情
Dialogue: 0,1:08:24.48,1:08:25.96,English,,0,0,0,,So that's what's called a gadget
Dialogue: 0,1:08:24.48,1:08:25.96,Chinese,,0,0,0,,这就是所谓的小工具
Dialogue: 0,1:08:26.00,1:08:30.23,English,,0,0,0,,And you might ask well what's so special about having them end in a return
Dialogue: 0,1:08:26.00,1:08:30.23,Chinese,,0,0,0,,而你可能会问，让他们以回报结束会有什么特别之处
Dialogue: 0,1:08:30.86,1:08:36.06,English,,0,0,0,,Well imagine I could fill up my buffer instead of with executable code
Dialogue: 0,1:08:30.86,1:08:36.06,Chinese,,0,0,0,,好吧，我想我可以填充缓冲区而不是可执行代码
Dialogue: 0,1:08:36.48,1:08:39.58,English,,0,0,0,,I could fill it up with a series of gadget addresses
Dialogue: 0,1:08:36.48,1:08:39.58,Chinese,,0,0,0,,我可以填写一系列小工具地址
Dialogue: 0,1:08:41.72,1:08:46.02,English,,0,0,0,,So each gadget then is some series of bytes where the final byte is c3
Dialogue: 0,1:08:41.72,1:08:46.02,Chinese,,0,0,0,,因此，每个小工具都是一些字节序列，其中最后一个字节是c3
Dialogue: 0,1:08:49.92,1:08:52.34,English,,0,0,0,,And I'll actually position this
Dialogue: 0,1:08:49.92,1:08:52.34,Chinese,,0,0,0,,而我实际上会定位这个
Dialogue: 0,1:08:53.10,1:08:56.18,English,,0,0,0,,And not the all positions at some place
Dialogue: 0,1:08:53.10,1:08:56.18,Chinese,,0,0,0,,而不是某个地方的所有职位
Dialogue: 0,1:08:56.18,1:09:02.22,English,,0,0,0,,Where you're actually going to do the initial return instruction of from before
Dialogue: 0,1:08:56.18,1:09:02.22,Chinese,,0,0,0,,你实际上要去做之前的初始返回指令
Dialogue: 0,1:09:02.32,1:09:08.84,English,,0,0,0,,So if I can somehow get the program to return execute a rest
Dialogue: 0,1:09:02.32,1:09:08.84,Chinese,,0,0,0,,所以，如果我能以某种方式让程序返回执行休息
Dialogue: 0,1:09:09.34,1:09:14.48,English,,0,0,0,,Right now what it will do is return will pick an address off of the stack
Dialogue: 0,1:09:09.34,1:09:14.48,Chinese,,0,0,0,,现在它将做的是返回将从堆栈中选择一个地址
Dialogue: 0,1:09:15.08,1:09:18.02,English,,0,0,0,,Pop an address and begin executing
Dialogue: 0,1:09:15.08,1:09:18.02,Chinese,,0,0,0,,弹出一个地址并开始执行
Dialogue: 0,1:09:18.02,1:09:20.14,English,,0,0,0,,So that will start this code executing
Dialogue: 0,1:09:18.02,1:09:20.14,Chinese,,0,0,0,,这将启动此代码执行
Dialogue: 0,1:09:20.50,1:09:23.58,English,,0,0,0,,And it will hit the c3 the ret instruction at the end
Dialogue: 0,1:09:20.50,1:09:23.58,Chinese,,0,0,0,,它会在最后命中c3 ret指令
Dialogue: 0,1:09:24.24,1:09:29.18,English,,0,0,0,,Which will again take a address pop it off the stack and begin executing
Dialogue: 0,1:09:24.24,1:09:29.18,Chinese,,0,0,0,,这将再次将一个地址弹出堆栈并开始执行
Dialogue: 0,1:09:29.20,1:09:31.92,English,,0,0,0,,So we'll start executing the second gadget
Dialogue: 0,1:09:29.20,1:09:31.92,Chinese,,0,0,0,,所以我们将开始执行第二个小工具
Dialogue: 0,1:09:32.26,1:09:38.68,English,,0,0,0,,And so you'll see what will happen is we're effectively concatenating these pieces of code together
Dialogue: 0,1:09:32.26,1:09:38.68,Chinese,,0,0,0,,因此，你将看到将要发生的事情是我们有效地将这些代码段连接在一起
Dialogue: 0,1:09:38.98,1:09:44.24,English,,0,0,0,,Where it's using a ret to get from one part the end of one gadget to the start of the next
Dialogue: 0,1:09:38.98,1:09:44.24,Chinese,,0,0,0,,它使用ret从一个部件到一个小工具的末端到下一个小工具的开头
Dialogue: 0,1:09:44.82,1:09:47.40,English,,0,0,0,,And so that's why it's called return oriented programming
Dialogue: 0,1:09:44.82,1:09:47.40,Chinese,,0,0,0,,所以这就是为什么它被称为回归导向编程
Dialogue: 0,1:09:47.88,1:09:52.64,English,,0,0,0,,It's a way to instead of sequencing programs using a program counter like you normally do
Dialogue: 0,1:09:47.88,1:09:52.64,Chinese,,0,0,0,,这是一种方法，而不是像往常一样使用程序计数器对程序进行排序
Dialogue: 0,1:09:53.16,1:09:59.42,English,,0,0,0,,Your sequencing programs using the sort of peculiar behavior of this particular x86
Dialogue: 0,1:09:53.16,1:09:59.42,Chinese,,0,0,0,,你的测序程序使用了这种特殊x86的特殊行为
Dialogue: 0,1:10:00.68,1:10:04.62,English,,0,0,0,,How returns work and in that program
Dialogue: 0,1:10:00.68,1:10:04.62,Chinese,,0,0,0,,如何返回工作和该计划
Dialogue: 0,1:10:04.84,1:10:09.80,English,,0,0,0,,And remember there's enough x86 out there that if I can find a way to attack them
Dialogue: 0,1:10:04.84,1:10:09.80,Chinese,,0,0,0,,记住那里有足够的x86，如果我能找到攻击他们的方法
Dialogue: 0,1:10:10.36,1:10:14.18,English,,0,0,0,,I'm in pretty,I'm in a pretty good place
Dialogue: 0,1:10:10.36,1:10:14.18,Chinese,,0,0,0,,我很漂亮，我在一个非常好的地方
Dialogue: 0,1:10:15.50,1:10:19.32,English,,0,0,0,,It's also possible to attack other processors this way to
Dialogue: 0,1:10:15.50,1:10:19.32,Chinese,,0,0,0,,也可以通过这种方式攻击其他处理器
Dialogue: 0,1:10:19.32,1:10:22.12,English,,0,0,0,,It's just particularly nice on x86
Dialogue: 0,1:10:19.32,1:10:22.12,Chinese,,0,0,0,,它在x86上特别好看
Dialogue: 0,1:10:23.06,1:10:25.60,English,,0,0,0,,So that's the idea of return oriented programming
Dialogue: 0,1:10:23.06,1:10:25.60,Chinese,,0,0,0,,这就是面向回归编程的想法
Dialogue: 0,1:10:25.60,1:10:33.24,English,,0,0,0,,And you'll do this yourself you'll find gadgets string them together to do different things in the attack way
Dialogue: 0,1:10:25.60,1:10:33.24,Chinese,,0,0,0,,你会自己做的，你会发现小工具将它们串在一起，以攻击方式做不同的事情
Dialogue: 0,1:10:35.60,1:10:42.70,English,,0,0,0,,But I'll point out that this still doesn't...so that
Dialogue: 0,1:10:35.60,1:10:42.70,Chinese,,0,0,0,,但我会指出，这仍然不是......所以
Dialogue: 0,1:10:43.40,1:10:52.16,English,,0,0,0,,This stack canary idea is still successful detecting a buffer overflows  fairly effectively
Dialogue: 0,1:10:43.40,1:10:52.16,Chinese,,0,0,0,,这种堆栈金丝雀的想法仍然能够相当有效地检测到缓冲区溢出
Dialogue: 0,1:10:52.16,1:10:54.82,English,,0,0,0,,So in your attack lab for example
Dialogue: 0,1:10:52.16,1:10:54.82,Chinese,,0,0,0,,所以在你的攻击实验室里
Dialogue: 0,1:10:55.22,1:11:00.68,English,,0,0,0,,We've carefully compiled the code to make it vulnerable to these attacks
Dialogue: 0,1:10:55.22,1:11:00.68,Chinese,,0,0,0,,我们仔细编译了代码，使其容易受到这些攻击
Dialogue: 0,1:11:01.62,1:11:05.16,English,,0,0,0,,Otherwise it would be a lot harder lab
Dialogue: 0,1:11:01.62,1:11:05.16,Chinese,,0,0,0,,否则这将是一个更难实验室
Dialogue: 0,1:11:05.78,1:11:12.34,English,,0,0,0,,Like if you could do this you could probably go into the dark world and be very successful
Dialogue: 0,1:11:05.78,1:11:12.34,Chinese,,0,0,0,,就像你可以做到这一点，你可能会进入黑暗的世界并且非常成功
Dialogue: 0,1:11:15.34,1:11:21.48,English,,0,0,0,,So we're actually sort of exposing the vulnerability
Dialogue: 0,1:11:15.34,1:11:21.48,Chinese,,0,0,0,,所以我们实际上暴露了这个漏洞
Dialogue: 0,1:11:21.48,1:11:26.22,English,,0,0,0,,But in the first part of the lab you're using code injection attacks
Dialogue: 0,1:11:21.48,1:11:26.22,Chinese,,0,0,0,,但在实验的第一部分，你正在使用代码注入攻击
Dialogue: 0,1:11:26.22,1:11:31.78,English,,0,0,0,,So we've had to disable stack randomization and also make the stack executable
Dialogue: 0,1:11:26.22,1:11:31.78,Chinese,,0,0,0,,所以我们必须禁用堆栈随机化并使堆栈可执行
Dialogue: 0,1:11:32.26,1:11:39.32,English,,0,0,0,,So we had to sort of...but the return rated programming  we reenable that
Dialogue: 0,1:11:32.26,1:11:39.32,Chinese,,0,0,0,,所以我们不得不......但是我们启用了返回额定编程
Dialogue: 0,1:11:39.50,1:11:44.62,English,,0,0,0,,So that the stack is not executable it keeps jumping around randomly
Dialogue: 0,1:11:39.50,1:11:44.62,Chinese,,0,0,0,,因此堆栈不可执行，它会随机跳转
Dialogue: 0,1:11:45.22,1:11:47.62,English,,0,0,0,,But we've turned off the stack canary
Dialogue: 0,1:11:45.22,1:11:47.62,Chinese,,0,0,0,,但我们已经关闭了堆栈金丝雀
Dialogue: 0,1:11:47.62,1:11:49.84,English,,0,0,0,,So you'll be able to overflow the buffer
Dialogue: 0,1:11:47.62,1:11:49.84,Chinese,,0,0,0,,所以你将能够溢出缓冲区
Dialogue: 0,1:11:50.48,1:11:55.68,English,,0,0,0,,And put in your gadget addresses and build up attacks that way
Dialogue: 0,1:11:50.48,1:11:55.68,Chinese,,0,0,0,,并放入你的小工具地址并以此方式构建攻击
Dialogue: 0,1:11:57.48,1:12:02.78,English,,0,0,0,,So I think you'll find by actually doing it you'll earn a lot more than you can by just hearing about it
Dialogue: 0,1:11:57.48,1:12:02.78,Chinese,,0,0,0,,因此，我认为通过实际操作你会发现，只要听到它，你就会获得比你更多的收入
Dialogue: 0,1:12:05.10,1:12:07.44,English,,0,0,0,,Oh you might ask why do we teach you this stuff right
Dialogue: 0,1:12:05.10,1:12:07.44,Chinese,,0,0,0,,哦，你可能会问为什么我们教你这些东西吧
Dialogue: 0,1:12:07.96,1:12:10.54,English,,0,0,0,,And if we supposed to teach you to be good and not evil
Dialogue: 0,1:12:07.96,1:12:10.54,Chinese,,0,0,0,,如果我们应该教你善良而不是邪恶
Dialogue: 0,1:12:11.12,1:12:17.86,English,,0,0,0,,Well there's a couple reasons one is you're going to learn a lot about machine program execution
Dialogue: 0,1:12:11.12,1:12:17.86,Chinese,,0,0,0,,那么有几个原因你要学习很多关于机器程序执行的知识
Dialogue: 0,1:12:18.10,1:12:22.12,English,,0,0,0,,And how stacks work and how byte instructions are encoded and stuff like that
Dialogue: 0,1:12:18.10,1:12:22.12,Chinese,,0,0,0,,堆栈如何工作以及字节指令如何编码以及类似的东西
Dialogue: 0,1:12:22.64,1:12:28.42,English,,0,0,0,,You'll use the tools GDB object dump and all those even more than you did with the bomb lab
Dialogue: 0,1:12:22.64,1:12:28.42,Chinese,,0,0,0,,你将使用工具GDB对象转储以及所有这些工具甚至比使用炸弹实验室更多
Dialogue: 0,1:12:28.42,1:12:34.72,English,,0,0,0,,So you'll learn a lot the other is we assume that you will work for forces of good
Dialogue: 0,1:12:28.42,1:12:34.72,Chinese,,0,0,0,,所以你会学到很多，另一个是我们假设你会为善的力量而努力
Dialogue: 0,1:12:34.72,1:12:40.86,English,,0,0,0,,But to be a good person you also know what the bet have to know what the bad people do
Dialogue: 0,1:12:34.72,1:12:40.86,Chinese,,0,0,0,,但要成为一个好人，你也知道赌注必须知道坏人做了什么
Dialogue: 0,1:12:40.86,1:12:48.44,English,,0,0,0,,So part of it is to become more effective as a force for good
Dialogue: 0,1:12:40.86,1:12:48.44,Chinese,,0,0,0,,因此，部分原因是要成为一种有益的力量
Dialogue: 0,1:12:51.44,1:12:54.80,English,,0,0,0,,Okay so the final thing to talk about today is unions
Dialogue: 0,1:12:51.44,1:12:54.80,Chinese,,0,0,0,,好的，所以今天谈论的最后一件事是工会
Dialogue: 0,1:12:55.58,1:13:02.00,English,,0,0,0,,And the observation about a union is the declaration of it looks a lot like a struct
Dialogue: 0,1:12:55.58,1:13:02.00,Chinese,,0,0,0,,关于联合的观察是它的声明看起来很像结构
Dialogue: 0,1:13:03.14,1:13:07.04,English,,0,0,0,,Where there's these different fields and they're named and they can have different types
Dialogue: 0,1:13:03.14,1:13:07.04,Chinese,,0,0,0,,哪里有这些不同的领域，他们被命名，他们可以有不同的类型
Dialogue: 0,1:13:07.06,1:13:11.38,English,,0,0,0,,And there can be pointers to unions and all that stuff
Dialogue: 0,1:13:07.06,1:13:11.38,Chinese,,0,0,0,,并且可以指向工会和所有这些东西
Dialogue: 0,1:13:11.86,1:13:14.52,English,,0,0,0,,But they're actually totally different what they do
Dialogue: 0,1:13:11.86,1:13:14.52,Chinese,,0,0,0,,但他们实际上完全不同于他们所做的事情
Dialogue: 0,1:13:15.08,1:13:21.22,English,,0,0,0,,You recall with a struct what happens is it allocates enough memory for all the fields to coexist
Dialogue: 0,1:13:15.08,1:13:21.22,Chinese,,0,0,0,,你回忆一下结构会发生什么，它为所有字段分配足够的内存来共存
Dialogue: 0,1:13:22.30,1:13:28.32,English,,0,0,0,,And potentially adding padding bytes for what a union does is it
Dialogue: 0,1:13:22.30,1:13:28.32,Chinese,,0,0,0,,并且可能为联盟做的事情添加填充字节
Dialogue: 0,1:13:29.20,1:13:33.40,English,,0,0,0,,Only k allocates enough storage for the maximum field in it
Dialogue: 0,1:13:29.20,1:13:33.40,Chinese,,0,0,0,,只有k为其中的最大字段分配足够的存储空间
Dialogue: 0,1:13:33.74,1:13:37.20,English,,0,0,0,,And it assumes that you're only going to be using one of the possible fields
Dialogue: 0,1:13:33.74,1:13:37.20,Chinese,,0,0,0,,并假设你只会使用其中一个可能的字段
Dialogue: 0,1:13:37.76,1:13:43.60,English,,0,0,0,,And it will literally a store on top of it these fields get stored on top of each other
Dialogue: 0,1:13:37.76,1:13:43.60,Chinese,,0,0,0,,它实际上是一个存储在它上面的这些字段存储在彼此之上
Dialogue: 0,1:13:43.60,1:13:49.50,English,,0,0,0,,So that if you try to use multiple fields you can mess things up
Dialogue: 0,1:13:43.60,1:13:49.50,Chinese,,0,0,0,,因此，如果你尝试使用多个字段，则可能会搞砸
Dialogue: 0,1:13:50.18,1:13:52.88,English,,0,0,0,,And it's not for that purpose of doing multiple values
Dialogue: 0,1:13:50.18,1:13:52.88,Chinese,,0,0,0,,并不是为了达到多重价值的目的
Dialogue: 0,1:13:52.88,1:13:57.66,English,,0,0,0,,It's for the purpose of for example if I know I'm only going to use one of these
Dialogue: 0,1:13:52.88,1:13:57.66,Chinese,,0,0,0,,例如，如果我知道我只会使用其中一个，那就是为了这个目的
Dialogue: 0,1:13:58.20,1:14:05.28,English,,0,0,0,,Or it's another also a way to create essentially an alias that will let you reference memory in different ways
Dialogue: 0,1:13:58.20,1:14:05.28,Chinese,,0,0,0,,或者它也是另一种创建一个别名的方法，它可以让你以不同的方式引用内存
Dialogue: 0,1:14:07.02,1:14:11.10,English,,0,0,0,,So for example in your data lab you are using
Dialogue: 0,1:14:07.02,1:14:11.10,Chinese,,0,0,0,,例如，你正在使用的数据实验室中
Dialogue: 0,1:14:12.44,1:14:18.16,English,,0,0,0,,You were manipulating the bit level representations of floating point numbers
Dialogue: 0,1:14:12.44,1:14:18.16,Chinese,,0,0,0,,你正在操纵浮点数的位级表示
Dialogue: 0,1:14:18.74,1:14:22.88,English,,0,0,0,,And in our code that would then convert that to an actual float
Dialogue: 0,1:14:18.74,1:14:22.88,Chinese,,0,0,0,,然后在我们的代码中，然后将其转换为实际的浮点数
Dialogue: 0,1:14:23.22,1:14:24.66,English,,0,0,0,,We used a union
Dialogue: 0,1:14:23.22,1:14:24.66,Chinese,,0,0,0,,我们用了工会
Dialogue: 0,1:14:25.20,1:14:33.32,English,,0,0,0,,Where the union is either to view this field of four bytes is an unsigned or is a float
Dialogue: 0,1:14:25.20,1:14:33.32,Chinese,,0,0,0,,联合要么是要查看这个四字节的字段是无符号的还是浮点数
Dialogue: 0,1:14:33.76,1:14:46.69,English,,0,0,0,,And so I can convert from unsigned to its float representation by just storing the unsigned value  in this union
Dialogue: 0,1:14:33.76,1:14:46.69,Chinese,,0,0,0,,因此，我可以通过在此联合中存储无符号值来将无符号转换为其浮点表示
Dialogue: 0,1:14:46.88,1:14:48.92,English,,0,0,0,,And retrieving it as if it were float
Dialogue: 0,1:14:46.88,1:14:48.92,Chinese,,0,0,0,,并将其检索为好像是浮动的
Dialogue: 0,1:14:49.36,1:14:53.64,English,,0,0,0,,And this is a fundamentally different operation than casting
Dialogue: 0,1:14:49.36,1:14:53.64,Chinese,,0,0,0,,这是一种与铸造完全不同的操作
Dialogue: 0,1:14:53.64,1:14:57.68,English,,0,0,0,,Because you recall when you take a unsigned value and you cast it to a float
Dialogue: 0,1:14:53.64,1:14:57.68,Chinese,,0,0,0,,因为你记得当你采用无符号值并将其转换为浮点值时
Dialogue: 0,1:14:58.02,1:14:59.28,English,,0,0,0,,You actually change the bits
Dialogue: 0,1:14:58.02,1:14:59.28,Chinese,,0,0,0,,你实际上改变了比特
Dialogue: 0,1:14:59.32,1:15:07.27,English,,0,0,0,,You change it into the floating point number that's the closest a match to this particular number
Dialogue: 0,1:14:59.32,1:15:07.27,Chinese,,0,0,0,,你将其更改为与此特定数字最匹配的浮点数
Dialogue: 0,1:15:07.27,1:15:11.22,English,,0,0,0,,It would be the equivalent of the function you implemented float underscore u2f
Dialogue: 0,1:15:07.27,1:15:11.22,Chinese,,0,0,0,,它将相当于你实现浮动下划线u2f的函数
Dialogue: 0,1:15:12.14,1:15:17.94,English,,0,0,0,,But this one actually doesn't change bits it just changes the numeric value changes quite a bit
Dialogue: 0,1:15:12.14,1:15:17.94,Chinese,,0,0,0,,但是这个实际上并没有改变位，只是改变了数值的变化
Dialogue: 0,1:15:19.04,1:15:26.80,English,,0,0,0,,So it's a useful technique to do that to be able to override the the type system and get two bit representations
Dialogue: 0,1:15:19.04,1:15:26.80,Chinese,,0,0,0,,因此，这是一种有用的技术，可以覆盖类型系统并获得两位表示
Dialogue: 0,1:15:28.78,1:15:32.54,English,,0,0,0,,And this actually turns out to be one of the places to where byte ordering
Dialogue: 0,1:15:28.78,1:15:32.54,Chinese,,0,0,0,,实际上这实际上是字节排序的地方之一
Dialogue: 0,1:15:32.54,1:15:35.62,English,,0,0,0,,Will show up in programs if you're not careful
Dialogue: 0,1:15:32.54,1:15:35.62,Chinese,,0,0,0,,如果你不小心，会出现在节目中
Dialogue: 0,1:15:37.36,1:15:42.44,English,,0,0,0,,So in particular with this union I can view a block of eight bytes
Dialogue: 0,1:15:37.36,1:15:42.44,Chinese,,0,0,0,,所以特别是对于这个联合，我可以查看一个8字节的块
Dialogue: 0,1:15:42.46,1:15:49.06,English,,0,0,0,,As either eight characters for shorts two ints or one long
Dialogue: 0,1:15:42.46,1:15:49.06,Chinese,,0,0,0,,短至两个整数或一个长整数的八个字符
Dialogue: 0,1:15:49.64,1:15:53.88,English,,0,0,0,,And on a 64-bit machine like is shown here where along is 64 bits
Dialogue: 0,1:15:49.64,1:15:53.88,Chinese,,0,0,0,,在这里显示的64位机器上，沿着64位
Dialogue: 0,1:15:54.54,1:16:03.32,English,,0,0,0,,You'll see that you're able to look at things as either as a the individual byte making it up
Dialogue: 0,1:15:54.54,1:16:03.32,Chinese,,0,0,0,,你将看到，你可以将事物看作是构成它的单个字节
Dialogue: 0,1:16:04.00,1:16:07.44,English,,0,0,0,,Or some longer aggregation of those byte
Dialogue: 0,1:16:04.00,1:16:07.44,Chinese,,0,0,0,,或者那些字节的一些更长的聚合
Dialogue: 0,1:16:08.56,1:16:11.94,English,,0,0,0,,And you'll actually find that depending on what machine you run it on
Dialogue: 0,1:16:08.56,1:16:11.94,Chinese,,0,0,0,,而且你会发现这取决于你运行它的机器
Dialogue: 0,1:16:12.34,1:16:17.32,English,,0,0,0,,You'll get a different result because of the byte ordering of the different machines
Dialogue: 0,1:16:12.34,1:16:17.32,Chinese,,0,0,0,,由于不同机器的字节顺序，你将得到不同的结果
Dialogue: 0,1:16:17.88,1:16:22.50,English,,0,0,0,,So this goes through it what happens when you run on different machines
Dialogue: 0,1:16:17.88,1:16:22.50,Chinese,,0,0,0,,因此，当你在不同的计算机上运行时会发生这种情况
Dialogue: 0,1:16:23.28,1:16:26.42,English,,0,0,0,,But you'll notice in particular that
Dialogue: 0,1:16:23.28,1:16:26.42,Chinese,,0,0,0,,但你会特别注意到这一点
Dialogue: 0,1:16:27.92,1:16:31.28,English,,0,0,0,,On an IA32 machine a 32-bit machine
Dialogue: 0,1:16:27.92,1:16:31.28,Chinese,,0,0,0,,在IA32机器上是一台32位机器
Dialogue: 0,1:16:33.62,1:16:38.92,English,,0,0,0,,It's coming off in this byte pattern 0xf3f2f1f0
Dialogue: 0,1:16:33.62,1:16:38.92,Chinese,,0,0,0,,它以字节模式0xf3f2f1f0结束
Dialogue: 0,1:16:39.94,1:16:46.34,English,,0,0,0,,And on a sun back when they existed you'd get the opposite because of the byte ordering
Dialogue: 0,1:16:39.94,1:16:46.34,Chinese,,0,0,0,,在它们存在的太阳背上，由于字节排序，你会得到相反的结果
Dialogue: 0,1:16:47.06,1:16:50.60,English,,0,0,0,,And now on an x86-64 where a
Dialogue: 0,1:16:47.06,1:16:50.60,Chinese,,0,0,0,,现在在x86-64上有一个
Dialogue: 0,1:16:51.20,1:16:57.60,English,,0,0,0,,Along is 64 bits you get eight bytes
Dialogue: 0,1:16:51.20,1:16:57.60,Chinese,,0,0,0,,沿着64位你得到8个字节
Dialogue: 0,1:16:58.20,1:17:02.42,English,,0,0,0,,And you can also determine from this if you look carefully that it's in
Dialogue: 0,1:16:58.20,1:17:02.42,Chinese,,0,0,0,,如果你仔细观察它是否存在，你也可以从中确定
Dialogue: 0,1:17:02.84,1:17:07.28,English,,0,0,0,,It's a little endian order because this is the we significant byte is f0
Dialogue: 0,1:17:02.84,1:17:07.28,Chinese,,0,0,0,,这是一个小端序，因为这是我们的重要字节是f0
Dialogue: 0,1:17:08.10,1:17:10.30,English,,0,0,0,,Which is the first byte f0
Dialogue: 0,1:17:08.10,1:17:10.30,Chinese,,0,0,0,,这是第一个字节f0
Dialogue: 0,1:17:11.12,1:17:16.68,English,,0,0,0,,So it's also way to get to the low level bytes
Dialogue: 0,1:17:11.12,1:17:16.68,Chinese,,0,0,0,,所以这也是获得低级别字节的方法
Dialogue: 0,1:17:16.74,1:17:23.06,English,,0,0,0,,But when you use this kind of thing you're sort of intentionally telling the C compiler
Dialogue: 0,1:17:16.74,1:17:23.06,Chinese,,0,0,0,,但是当你使用这种东西时，你有点故意告诉C编译器
Dialogue: 0,1:17:23.62,1:17:27.76,English,,0,0,0,,Trust me I know what I'm doing,you don't have to protect me from myself
Dialogue: 0,1:17:23.62,1:17:27.76,Chinese,,0,0,0,,相信我，我知道我在做什么，你不必保护我自己
Dialogue: 0,1:17:28.14,1:17:30.92,English,,0,0,0,,And so if you're not careful you can write code where
Dialogue: 0,1:17:28.14,1:17:30.92,Chinese,,0,0,0,,所以，如果你不小心，你可以在哪里编写代码
Dialogue: 0,1:17:30.92,1:17:33.40,English,,0,0,0,,Because of a byte ordering problem or something like that
Dialogue: 0,1:17:30.92,1:17:33.40,Chinese,,0,0,0,,由于字节排序问题或类似的问题
Dialogue: 0,1:17:33.80,1:17:36.64,English,,0,0,0,,we'll run properly on some machines
Dialogue: 0,1:17:33.80,1:17:36.64,Chinese,,0,0,0,,我们会在某些机器上正常运行
Dialogue: 0,1:17:38.36,1:17:41.12,English,,0,0,0,,So just to summarize then we looked on it
Dialogue: 0,1:17:38.36,1:17:41.12,Chinese,,0,0,0,,所以只是总结然后我们看了它
Dialogue: 0,1:17:41.70,1:17:44.92,English,,0,0,0,,We've looked then at the three compound types in c
Dialogue: 0,1:17:41.70,1:17:44.92,Chinese,,0,0,0,,我们看了c中的三种化合物类型
Dialogue: 0,1:17:44.92,1:17:48.80,English,,0,0,0,,The ways you can aggregate smaller types into larger ones
Dialogue: 0,1:17:44.92,1:17:48.80,Chinese,,0,0,0,,你可以将较小类型聚合为较大类型的方法
Dialogue: 0,1:17:48.80,1:17:54.56,English,,0,0,0,,You can make an array of identical elements indexed by a number the position
Dialogue: 0,1:17:48.80,1:17:54.56,Chinese,,0,0,0,,你可以创建一个由数字位置索引的相同元素的数组
Dialogue: 0,1:17:54.90,1:18:00.76,English,,0,0,0,,And that usually turns into some kind of scaled computation to get to the particular place
Dialogue: 0,1:17:54.90,1:18:00.76,Chinese,,0,0,0,,而这通常会变成某种规模的计算来到达特定的地方
Dialogue: 0,1:18:01.60,1:18:05.66,English,,0,0,0,,We've seen structures where it's a fixed number of fields
Dialogue: 0,1:18:01.60,1:18:05.66,Chinese,,0,0,0,,我们已经看到了固定数量的字段的结构
Dialogue: 0,1:18:06.16,1:18:09.82,English,,0,0,0,,But the fields can be of different type and the reference by their names
Dialogue: 0,1:18:06.16,1:18:09.82,Chinese,,0,0,0,,但是这些字段可以是不同类型的，也可以是它们的名称引用
Dialogue: 0,1:18:10.20,1:18:14.92,English,,0,0,0,,And that usually turns into some type of displacement off of the original position
Dialogue: 0,1:18:10.20,1:18:14.92,Chinese,,0,0,0,,而这通常会变成原始位置的某种类型的位移
Dialogue: 0,1:18:15.58,1:18:21.76,English,,0,0,0,,And then a union is just a way of sort of piling up in one place
Dialogue: 0,1:18:15.58,1:18:21.76,Chinese,,0,0,0,,然后工会只是一种堆积在一个地方的方式
Dialogue: 0,1:18:21.91,1:18:24.48,English,,0,0,0,,A number of different fields
Dialogue: 0,1:18:21.91,1:18:24.48,Chinese,,0,0,0,,许多不同的领域
Dialogue: 0,1:18:24.76,1:18:28.38,English,,0,0,0,,And so all it does is allocate the maximum number of bytes
Dialogue: 0,1:18:24.76,1:18:28.38,Chinese,,0,0,0,,所以它所做的只是分配最大字节数
Dialogue: 0,1:18:28.72,1:18:33.14,English,,0,0,0,,And doesn't create enough space for them all to be there at the same time
Dialogue: 0,1:18:28.72,1:18:33.14,Chinese,,0,0,0,,并没有为他们创造足够的空间同时在那里
Dialogue: 0,1:18:34.94,1:18:40.19,English,,0,0,0,,Okay that's it for today then
Dialogue: 0,1:18:34.94,1:18:40.19,Chinese,,0,0,0,,好的，那就是今天
