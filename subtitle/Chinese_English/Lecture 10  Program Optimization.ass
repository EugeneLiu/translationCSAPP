[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 10  Program Optimization.mp4
Video File: ../../../../Desktop/csapp/Lecture 10  Program Optimization.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.140624
Scroll Position: 824
Active Line: 835
Video Position: 132216

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:04.92,English,,0,0,0,,So we've now gotten through all the lectures on machine code
Dialogue: 0,0:00:00.03,0:00:04.92,Chinese,,0,0,0,,所以我们现在已经完成了机器代码的所有讲座
Dialogue: 0,0:00:04.92,0:00:07.00,English,,0,0,0,,And we're starting to talk about...
Dialogue: 0,0:00:04.92,0:00:07.00,Chinese,,0,0,0,,我们开始谈论......
Dialogue: 0,0:00:07.34,0:00:10.12,English,,0,0,0,,Okay now that you know this stuff what can you do with it
Dialogue: 0,0:00:07.34,0:00:10.12,Chinese,,0,0,0,,好了，现在你知道这些东西，你能用它做什么
Dialogue: 0,0:00:10.88,0:00:14.30,English,,0,0,0,,And this lecture is along the lines of that
Dialogue: 0,0:00:10.88,0:00:14.30,Chinese,,0,0,0,,这个讲座就是这样的
Dialogue: 0,0:00:14.30,0:00:21.06,English,,0,0,0,,This is sort of what you are now empowered to do now that you can look at an understand machine code
Dialogue: 0,0:00:14.30,0:00:21.06,Chinese,,0,0,0,,这就是你现在有权做的事情，你可以看一下理解机器代码
Dialogue: 0,0:00:21.44,0:00:29.10,English,,0,0,0,,This material is a little this actually there's a whole chapter of the book chapter five on performance optimization
Dialogue: 0,0:00:21.44,0:00:29.10,Chinese,,0,0,0,,这篇材料有点实际上有关于性能优化的第五章的整章
Dialogue: 0,0:00:29.10,0:00:30.96,English,,0,0,0,,And we're only going to do one lecture on it 
Dialogue: 0,0:00:29.10,0:00:30.96,Chinese,,0,0,0,,我们只打算做一个讲座
Dialogue: 0,0:00:31.50,0:00:32.88,English,,0,0,0,,And we don't have any labs
Dialogue: 0,0:00:31.50,0:00:32.88,Chinese,,0,0,0,,我们没有任何实验室
Dialogue: 0,0:00:33.28,0:00:38.36,English,,0,0,0,,Unfortunately that really get you to push your limits on this which is too bad
Dialogue: 0,0:00:33.28,0:00:38.36,Chinese,,0,0,0,,不幸的是，这真的让你在这个问题上施加限制
Dialogue: 0,0:00:38.36,0:00:40.12,English,,0,0,0,,Because it's a very interesting topic
Dialogue: 0,0:00:38.36,0:00:40.12,Chinese,,0,0,0,,因为这是一个非常有趣的话题
Dialogue: 0,0:00:40.52,0:00:43.02,English,,0,0,0,,One I think you'd find yourself well equipped for
Dialogue: 0,0:00:40.52,0:00:43.02,Chinese,,0,0,0,,一个我认为你会发现自己装备精良
Dialogue: 0,0:00:43.56,0:00:50.26,English,,0,0,0,,There are typically a few small exam problems that are sort of based on some of the material here
Dialogue: 0,0:00:43.56,0:00:50.26,Chinese,,0,0,0,,通常有一些小的考试问题，这些问题基于这里的一些材料
Dialogue: 0,0:00:50.26,0:00:51.76,English,,0,0,0,,You'll find in old exams
Dialogue: 0,0:00:50.26,0:00:51.76,Chinese,,0,0,0,,你会在旧考试中找到
Dialogue: 0,0:00:52.72,0:00:56.02,English,,0,0,0,,But really the idea is how can I make programs run fast
Dialogue: 0,0:00:52.72,0:00:56.02,Chinese,,0,0,0,,但真正的想法是如何让程序快速运行
Dialogue: 0,0:00:56.66,0:01:02.30,English,,0,0,0,,Given that I sort of know what algorithm I'm using
Dialogue: 0,0:00:56.66,0:01:02.30,Chinese,,0,0,0,,鉴于我有点知道我正在使用什么算法
Dialogue: 0,0:01:02.30,0:01:05.66,English,,0,0,0,,And I've perhaps gotten a program that runs
Dialogue: 0,0:01:02.30,0:01:05.66,Chinese,,0,0,0,,而且我可能已经开始运行一个程序
Dialogue: 0,0:01:05.96,0:01:07.64,English,,0,0,0,,How can I make it run faster 
Dialogue: 0,0:01:05.96,0:01:07.64,Chinese,,0,0,0,,如何让它运行得更快
Dialogue: 0,0:01:08.26,0:01:12.28,English,,0,0,0,,And one of the the themes of it is
Dialogue: 0,0:01:08.26,0:01:12.28,Chinese,,0,0,0,,其中一个主题是
Dialogue: 0,0:01:12.66,0:01:14.62,English,,0,0,0,,You can sort of do this in layers
Dialogue: 0,0:01:12.66,0:01:14.62,Chinese,,0,0,0,,你可以在图层中执行此操作
Dialogue: 0,0:01:14.68,0:01:28.36,English,,0,0,0,,You can sort of first of do the stuff to avoid a sort of things that make programs run slow across a wide variety of machines
Dialogue: 0,0:01:14.68,0:01:28.36,Chinese,,0,0,0,,你可以先做一些事情来避免一些让程序在各种各样的机器上运行缓慢的事情
Dialogue: 0,0:01:28.66,0:01:30.10,English,,0,0,0,,Just make your...
Dialogue: 0,0:01:28.66,0:01:30.10,Chinese,,0,0,0,,只是让你...
Dialogue: 0,0:01:30.12,0:01:36.04,English,,0,0,0,,And I would describe it as making your code more compiler friendly, we'll talk about what that means
Dialogue: 0,0:01:30.12,0:01:36.04,Chinese,,0,0,0,,我会将其描述为使你的代码更易于编译，我们将讨论这意味着什么
Dialogue: 0,0:01:36.60,0:01:40.74,English,,0,0,0,,And you have to have some understanding and appreciation for what compilers are good at
Dialogue: 0,0:01:36.60,0:01:40.74,Chinese,,0,0,0,,你必须对编译器擅长的东西有一些了解和欣赏
Dialogue: 0,0:01:41.20,0:01:43.94,English,,0,0,0,,And what they're not good at to be able to do that
Dialogue: 0,0:01:41.20,0:01:43.94,Chinese,,0,0,0,,他们不能做到这一点并不擅长
Dialogue: 0,0:01:43.94,0:01:48.82,English,,0,0,0,,And I describe these is the kind of things that you should just be in the habit of
Dialogue: 0,0:01:43.94,0:01:48.82,Chinese,,0,0,0,,而且我描述的是那些你应该养成习惯的东西
Dialogue: 0,0:01:49.20,0:01:53.24,English,,0,0,0,,When you write programs writing this code that I'll describe is compiler friendly
Dialogue: 0,0:01:49.20,0:01:53.24,Chinese,,0,0,0,,编写编写此代码的程序时，我将描述编译器友好
Dialogue: 0,0:01:53.92,0:02:03.04,English,,0,0,0,,And then the next level is okay given that I've sort of taken away the things that really shouldn't have been there in the first place
Dialogue: 0,0:01:53.92,0:02:03.04,Chinese,,0,0,0,,然后下一个级别是可以的，因为我已经把那些本来不应该存在的东西带走了
Dialogue: 0,0:02:03.40,0:02:06.38,English,,0,0,0,,Now how can I make my programs run faster
Dialogue: 0,0:02:03.40,0:02:06.38,Chinese,,0,0,0,,现在我如何让我的程序运行得更快
Dialogue: 0,0:02:06.38,0:02:14.12,English,,0,0,0,,In particular,how can I adapt it to the capabilities of the types of machines that this program is going to run on
Dialogue: 0,0:02:06.38,0:02:14.12,Chinese,,0,0,0,,特别是，我如何使其适应该程序将要运行的机器类型的功能
Dialogue: 0,0:02:14.44,0:02:22.26,English,,0,0,0,,And that can again go from ones that will generally make programs run fast across a wide variety of machines to ones that 
Dialogue: 0,0:02:14.44,0:02:22.26,Chinese,,0,0,0,,而这又可以从那些通常会使程序在各种各样的机器上快速运行到那些机器的程序
Dialogue: 0,0:02:22.30,0:02:24.08,English,,0,0,0,,Become very specific
Dialogue: 0,0:02:22.30,0:02:24.08,Chinese,,0,0,0,,变得非常具体
Dialogue: 0,0:02:24.46,0:02:30.08,English,,0,0,0,,Very specificIs a risky thing because even in the world of  say x86 machines
Dialogue: 0,0:02:24.46,0:02:30.08,Chinese,,0,0,0,,非常具体是一个冒险的事情，因为即使在说x86机器的世界
Dialogue: 0,0:02:30.32,0:02:34.56,English,,0,0,0,,There's quite a variety of them that are available at any given point in time
Dialogue: 0,0:02:30.32,0:02:34.56,Chinese,,0,0,0,,在任何给定的时间点都可以使用它们
Dialogue: 0,0:02:35.04,0:02:37.02,English,,0,0,0,,And they evolve over time as well
Dialogue: 0,0:02:35.04,0:02:37.02,Chinese,,0,0,0,,它们也随着时间的推移而发展
Dialogue: 0,0:02:37.02,0:02:44.44,English,,0,0,0,,So you can make a program run really fast on one particular model of one x86 processor
Dialogue: 0,0:02:37.02,0:02:44.44,Chinese,,0,0,0,,因此，你可以在一个x86处理器的特定型号上快速运行程序
Dialogue: 0,0:02:44.82,0:02:46.48,English,,0,0,0,,But it might not that...
Dialogue: 0,0:02:44.82,0:02:46.48,Chinese,,0,0,0,,但它可能不是......
Dialogue: 0,0:02:47.10,0:02:51.54,English,,0,0,0,,If you're trying too hard you'll find your effort is sort of wasted when you move it to another
Dialogue: 0,0:02:47.10,0:02:51.54,Chinese,,0,0,0,,如果你太努力了，当你把它移到另一个时，你会发现你的努力有点浪费
Dialogue: 0,0:02:51.94,0:02:57.38,English,,0,0,0,,On the other hand these general ideas I'm going to describe actually work across quite a range of machines
Dialogue: 0,0:02:51.94,0:02:57.38,Chinese,,0,0,0,,另一方面，我将要描述的这些一般性想法实际上适用于各种各样的机器
Dialogue: 0,0:02:58.62,0:03:01.10,English,,0,0,0,,So and I'll talk about that more as we go along
Dialogue: 0,0:02:58.62,0:03:01.10,Chinese,,0,0,0,,所以，随着我们的进展，我会更多地谈论这个问题
Dialogue: 0,0:03:02.96,0:03:06.58,English,,0,0,0,,So it used to be in the bad old days that
Dialogue: 0,0:03:02.96,0:03:06.58,Chinese,,0,0,0,,所以它曾经是过去的糟糕时期
Dialogue: 0,0:03:06.62,0:03:09.88,English,,0,0,0,,If you wanted a program to run fast you had to write an assembly code
Dialogue: 0,0:03:06.62,0:03:09.88,Chinese,,0,0,0,,如果你希望程序快速运行，则必须编写汇编代码
Dialogue: 0,0:03:10.20,0:03:13.60,English,,0,0,0,,And that's just plain not true anymore and if anyone tells you it's true
Dialogue: 0,0:03:10.20,0:03:13.60,Chinese,,0,0,0,,而这显然不再是真的，如果有人告诉你这是真的
Dialogue: 0,0:03:13.94,0:03:16.70,English,,0,0,0,,It's because they're full of it, it's just not true
Dialogue: 0,0:03:13.94,0:03:16.70,Chinese,,0,0,0,,这是因为他们充满了它，但事实并非如此
Dialogue: 0,0:03:17.04,0:03:23.32,English,,0,0,0,,Unless except for the exceptional case where you're running on a very small resource constrained machine
Dialogue: 0,0:03:17.04,0:03:23.32,Chinese,,0,0,0,,除非你在非常小的资源受限机器上运行的例外情况除外
Dialogue: 0,0:03:23.98,0:03:27.56,English,,0,0,0,,Such as a very small underpowered embedded system
Dialogue: 0,0:03:23.98,0:03:27.56,Chinese,,0,0,0,,比如一个非常小的动力不足的嵌入式系统
Dialogue: 0,0:03:29.09,0:03:32.56,English,,0,0,0,,So let's just assume that we're going to use a compiler
Dialogue: 0,0:03:29.09,0:03:32.56,Chinese,,0,0,0,,所以我们假设我们将使用编译器
Dialogue: 0,0:03:33.02,0:03:36.66,English,,0,0,0,,And we'll assume for this course we're going to use gcc because it's generally available
Dialogue: 0,0:03:33.02,0:03:36.66,Chinese,,0,0,0,,我们假设这个课程我们将使用gcc，因为它通常可用
Dialogue: 0,0:03:37.06,0:03:44.40,English,,0,0,0,,It's not actually the best compiler out there intel makes a compiler that costs money to license and stuff
Dialogue: 0,0:03:37.06,0:03:44.40,Chinese,,0,0,0,,它实际上并不是最好的编译器，因为英特尔制造的编译器需要花钱才能获得许可证
Dialogue: 0,0:03:44.40,0:03:49.88,English,,0,0,0,,But it really can do some amazing things and other compilers exist
Dialogue: 0,0:03:44.40,0:03:49.88,Chinese,,0,0,0,,但它真的可以做一些惊人的事情和其他编译器存在
Dialogue: 0,0:03:49.88,0:03:53.96,English,,0,0,0,,But GCC is sort of a a good enough compiler for most people
Dialogue: 0,0:03:49.88,0:03:53.96,Chinese,,0,0,0,,但对于大多数人来说，GCC对于一个足够好的编译器来说
Dialogue: 0,0:03:56.80,0:04:02.80,English,,0,0,0,,But there's some features of some things that sort of puzzle compilers that they don't really understand
Dialogue: 0,0:03:56.80,0:04:02.80,Chinese,,0,0,0,,但是有些东西的某些特征是他们并不真正理解的拼图编译器
Dialogue: 0,0:04:02.80,0:04:07.80,English,,0,0,0,,Compilers don't really understand for example that the numbers you're using
Dialogue: 0,0:04:02.80,0:04:07.80,Chinese,,0,0,0,,编译器并不真正理解你正在使用的数字
Dialogue: 0,0:04:08.24,0:04:13.14,English,,0,0,0,,When you say it's an int might actually range over a much smaller set of values
Dialogue: 0,0:04:08.24,0:04:13.14,Chinese,,0,0,0,,当你说它是一个int实际上可能范围超过一个更小的值集
Dialogue: 0,0:04:14.18,0:04:21.18,English,,0,0,0,,And they have a very hard time understanding memory referencing patterns and the effect of procedure calls
Dialogue: 0,0:04:14.18,0:04:21.18,Chinese,,0,0,0,,他们很难理解内存引用模式和过程调用的影响
Dialogue: 0,0:04:26.50,0:04:29.62,English,,0,0,0,,And so in general what happens with the compiler is it
Dialogue: 0,0:04:26.50,0:04:29.62,Chinese,,0,0,0,,所以一般来说编译器会发生什么呢
Dialogue: 0,0:04:29.92,0:04:35.92,English,,0,0,0,,Has a whole sort of cookbook of optimization strategies
Dialogue: 0,0:04:29.92,0:04:35.92,Chinese,,0,0,0,,有一整套优化策略的食谱
Dialogue: 0,0:04:35.92,0:04:40.84,English,,0,0,0,,And some recipes for how to try out different strategies and apply them
Dialogue: 0,0:04:35.92,0:04:40.84,Chinese,,0,0,0,,以及如何尝试不同策略并应用它们的一些方法
Dialogue: 0,0:04:41.44,0:04:46.14,English,,0,0,0,,But in general if it ever feels like this code is something that
Dialogue: 0,0:04:41.44,0:04:46.14,Chinese,,0,0,0,,但总的来说，如果它感觉这个代码是那样的话
Dialogue: 0,0:04:46.14,0:04:50.14,English,,0,0,0,,It doesn't feel confident about being able to make certain transformations
Dialogue: 0,0:04:46.14,0:04:50.14,Chinese,,0,0,0,,它对能够进行某些转换并不自信
Dialogue: 0,0:04:50.48,0:04:56.98,English,,0,0,0,,That it just won't,it will keep things sort of a more direct implementation of exactly what you described
Dialogue: 0,0:04:50.48,0:04:56.98,Chinese,,0,0,0,,它只是不会，它会使事情更直接地实现你所描述的
Dialogue: 0,0:04:57.36,0:05:00.04,English,,0,0,0,,We'll show examples of that as we go along
Dialogue: 0,0:04:57.36,0:05:00.04,Chinese,,0,0,0,,我们将继续展示这方面的例子
Dialogue: 0,0:05:00.70,0:05:06.82,English,,0,0,0,,So the thing about it optimizing compilers it always has a fallback position which is to not optimize
Dialogue: 0,0:05:00.70,0:05:06.82,Chinese,,0,0,0,,因此关于它优化编译器的事情总是有一个后备位置，即不优化
Dialogue: 0,0:05:07.42,0:05:11.86,English,,0,0,0,,And sometimes that will get in trouble if you want your program to run faster
Dialogue: 0,0:05:07.42,0:05:11.86,Chinese,,0,0,0,,如果你希望程序运行得更快，有时会遇到麻烦
Dialogue: 0,0:05:12.28,0:05:19.10,English,,0,0,0,,And the compiler just in its own conservative white decides not to do that optimization
Dialogue: 0,0:05:12.28,0:05:19.10,Chinese,,0,0,0,,并且编译器只是在自己的保守白色中决定不进行优化
Dialogue: 0,0:05:19.30,0:05:22.18,English,,0,0,0,,And one of the tricks that you'll find is pretty useful
Dialogue: 0,0:05:19.30,0:05:22.18,Chinese,,0,0,0,,你会发现其中一个技巧非常有用
Dialogue: 0,0:05:22.56,0:05:25.80,English,,0,0,0,,Now that you can read assembly code is you run the compiler
Dialogue: 0,0:05:22.56,0:05:25.80,Chinese,,0,0,0,,既然你可以阅读汇编代码，那么你可以运行编译器
Dialogue: 0,0:05:26.22,0:05:28.32,English,,0,0,0,,You see what optimizations it does
Dialogue: 0,0:05:26.22,0:05:28.32,Chinese,,0,0,0,,你会看到它做了哪些优化
Dialogue: 0,0:05:28.90,0:05:33.38,English,,0,0,0,,And if it doesn't make something that you expect it to be able to do you go back and figure it out
Dialogue: 0,0:05:28.90,0:05:33.38,Chinese,,0,0,0,,如果它没有做出你期望它能够做到的事情，你就回去搞清楚
Dialogue: 0,0:05:33.44,0:05:42.30,English,,0,0,0,,So it's very common by the way to rewrite your program in the same language
Dialogue: 0,0:05:33.44,0:05:42.30,Chinese,,0,0,0,,因此，用同一种语言重写程序的方式非常普遍
Dialogue: 0,0:05:42.30,0:05:49.74,English,,0,0,0,,And sort of tune it in and up to make it run faster to make it more compiler friendly
Dialogue: 0,0:05:42.30,0:05:49.74,Chinese,,0,0,0,,并对其进行调整以使其运行得更快以使其更易于编译
Dialogue: 0,0:05:49.74,0:05:51.32,English,,0,0,0,,That's there's nothing wrong with that
Dialogue: 0,0:05:49.74,0:05:51.32,Chinese,,0,0,0,,那是没有错的
Dialogue: 0,0:05:51.78,0:05:55.96,English,,0,0,0,,As long as you don't then just totally obliterate the program and make it totally illegible
Dialogue: 0,0:05:51.78,0:05:55.96,Chinese,,0,0,0,,只要你不这样做就完全抹掉这个程序，让它完全难以辨认
Dialogue: 0,0:05:57.66,0:06:01.50,English,,0,0,0,,So let's just describe some sort of general optimizations
Dialogue: 0,0:05:57.66,0:06:01.50,Chinese,,0,0,0,,所以我们只是描述某种一般的优化
Dialogue: 0,0:06:01.50,0:06:06.82,English,,0,0,0,,And you've actually seen versions of this,in some of the assembly code we've already looked at
Dialogue: 0,0:06:01.50,0:06:06.82,Chinese,,0,0,0,,而且你已经看到了我们已经看过的一些汇编代码中的这个版本
Dialogue: 0,0:06:08.02,0:06:13.70,English,,0,0,0,,Oh and I'll use mostly sort of examples from multi-dimensional arrays
Dialogue: 0,0:06:08.02,0:06:13.70,Chinese,,0,0,0,,哦，我将使用多维数组中的大多数示例
Dialogue: 0,0:06:13.70,0:06:17.68,English,,0,0,0,,Because those are actually fairly easy optimization type of tasks
Dialogue: 0,0:06:13.70,0:06:17.68,Chinese,,0,0,0,,因为那些实际上是相当容易的优化类型的任务
Dialogue: 0,0:06:18.40,0:06:21.16,English,,0,0,0,,But these applied to other types of program as well
Dialogue: 0,0:06:18.40,0:06:21.16,Chinese,,0,0,0,,但这些也适用于其他类型的程序
Dialogue: 0,0:06:21.98,0:06:29.58,English,,0,0,0,,So you saw before when we described how to do array indexing in multi-dimensional arrays
Dialogue: 0,0:06:21.98,0:06:29.58,Chinese,,0,0,0,,所以你之前我们描述了如何在多维数组中进行数组索引
Dialogue: 0,0:06:30.22,0:06:36.63,English,,0,0,0,,That the old style of code was if you had a a variable sized array
Dialogue: 0,0:06:30.22,0:06:36.63,Chinese,,0,0,0,,如果你有一个可变大小的数组，旧的代码风格
Dialogue: 0,0:06:36.84,0:06:46.66,English,,0,0,0,,It was up to you the programmer to write the formula of how you convert row i column j into a position in a one-dimensional array
Dialogue: 0,0:06:36.84,0:06:46.66,Chinese,,0,0,0,,编程人员可以编写如何将第i列j列转换为一维数组中的位置的公式
Dialogue: 0,0:06:47.58,0:06:53.46,English,,0,0,0,,So remember it's just the number of columns times the row number plus the column numbers standard one
Dialogue: 0,0:06:47.58,0:06:53.46,Chinese,,0,0,0,,所以请记住，它只是列数乘以行数加上列号标准值
Dialogue: 0,0:06:54.12,0:06:57.68,English,,0,0,0,,So that would give this would be pretty typical code
Dialogue: 0,0:06:54.12,0:06:57.68,Chinese,,0,0,0,,所以这将是非常典型的代码
Dialogue: 0,0:06:57.68,0:07:00.72,English,,0,0,0,,Then it would give you a notation like this
Dialogue: 0,0:06:57.68,0:07:00.72,Chinese,,0,0,0,,然后它会给你一个这样的符号
Dialogue: 0,0:07:00.72,0:07:09.60,English,,0,0,0,,If you wanted to set one row in array 'a' to the values in a one dimensional row of 'b'
Dialogue: 0,0:07:00.72,0:07:09.60,Chinese,,0,0,0,,如果要将数组'a'中的一行设置为'b'的一维行中的值
Dialogue: 0,0:07:10.98,0:07:13.08,English,,0,0,0,,This is a code you'd write
Dialogue: 0,0:07:10.98,0:07:13.08,Chinese,,0,0,0,,这是你要编写的代码
Dialogue: 0,0:07:13.52,0:07:16.28,English,,0,0,0,,And the main observation is within this loop
Dialogue: 0,0:07:13.52,0:07:16.28,Chinese,,0,0,0,,主要观察是在这个循环内
Dialogue: 0,0:07:16.74,0:07:19.04,English,,0,0,0,,The only variable that's changing is j
Dialogue: 0,0:07:16.74,0:07:19.04,Chinese,,0,0,0,,唯一变化的变量是j
Dialogue: 0,0:07:20.24,0:07:25.82,English,,0,0,0,,And so from the array perspective your this computation n*i··
Dialogue: 0,0:07:20.24,0:07:25.82,Chinese,,0,0,0,,所以从数组的角度来看你的这个计算n * i··
Dialogue: 0,0:07:25.82,0:07:28.56,English,,0,0,0,,If it gets repeated over and over again within this loop
Dialogue: 0,0:07:25.82,0:07:28.56,Chinese,,0,0,0,,如果它在这个循环中反复重复
Dialogue: 0,0:07:29.22,0:07:32.52,English,,0,0,0,,Then you're just wasting,it's a wasted effort
Dialogue: 0,0:07:29.22,0:07:32.52,Chinese,,0,0,0,,然后你只是在浪费，这是一种浪费的努力
Dialogue: 0,0:07:32.92,0:07:35.16,English,,0,0,0,,So you can do what's called code motion
Dialogue: 0,0:07:32.92,0:07:35.16,Chinese,,0,0,0,,所以你可以做所谓的代码运动
Dialogue: 0,0:07:35.42,0:07:40.54,English,,0,0,0,,Which is to precompute the value of n*i outside of the loop
Dialogue: 0,0:07:35.42,0:07:40.54,Chinese,,0,0,0,,这是预先计算循环外的n * i的值
Dialogue: 0,0:07:40.96,0:07:45.74,English,,0,0,0,,And then use it over and over again inside and compilers will generally do this
Dialogue: 0,0:07:40.96,0:07:45.74,Chinese,,0,0,0,,然后在内部一遍又一遍地使用它，编译器通常会这样做
Dialogue: 0,0:07:47.36,0:07:53.78,English,,0,0,0,,When they can detect for example that it's a array access code and it has this technique
Dialogue: 0,0:07:47.36,0:07:53.78,Chinese,,0,0,0,,当他们可以检测到例如它是一个数组访问代码并且它有这种技术时
Dialogue: 0,0:07:54.14,0:08:03.42,English,,0,0,0,,It will generally do optimizations like this if you set say an optimization level of 1 or higher to GCC
Dialogue: 0,0:07:54.14,0:08:03.42,Chinese,,0,0,0,,如果你将GCC的优化级别设置为1或更高，它通常会进行这样的优化
Dialogue: 0,0:08:07.14,0:08:14.42,English,,0,0,0,,And we can see this in fact this is this code that I ran it through GCC using optimization 1
Dialogue: 0,0:08:07.14,0:08:14.42,Chinese,,0,0,0,,我们可以看到这实际上这是我使用优化1通过GCC运行的代码
Dialogue: 0,0:08:14.68,0:08:19.22,English,,0,0,0,,And you see as this read instruction shows it boosted this multiplication outside of the loop
Dialogue: 0,0:08:14.68,0:08:19.22,Chinese,,0,0,0,,并且你看到这个读指令显示它在循环之外增加了这个乘法
Dialogue: 0,0:08:20.60,0:08:25.90,English,,0,0,0,,And it's a little as if you actually this code does even more
Dialogue: 0,0:08:20.60,0:08:25.90,Chinese,,0,0,0,,这有点像你实际上这个代码做得更多
Dialogue: 0,0:08:25.90,0:08:29.50,English,,0,0,0,,It turns the code into something that looks more like a pointer code
Dialogue: 0,0:08:25.90,0:08:29.50,Chinese,,0,0,0,,它将代码转换为更像是指针代码的东西
Dialogue: 0,0:08:29.78,0:08:38.34,English,,0,0,0,,Accessing array 'a' and stepping through that element by element of the array
Dialogue: 0,0:08:29.78,0:08:38.34,Chinese,,0,0,0,,访问数组'a'并按数组元素单步执行该元素
Dialogue: 0,0:08:39.62,0:08:42.46,English,,0,0,0,,Another one and we've seen this already that when
Dialogue: 0,0:08:39.62,0:08:42.46,Chinese,,0,0,0,,另一个，我们已经看到了这一点
Dialogue: 0,0:08:42.94,0:08:49.30,English,,0,0,0,,GCC turns a multiplication or a division by shifting and adding an operations like that
Dialogue: 0,0:08:42.94,0:08:49.30,Chinese,,0,0,0,,GCC通过移位和添加类似的操作来转换乘法或除法
Dialogue: 0,0:08:49.67,0:08:51.97,English,,0,0,0,,Multiplication or division by constants
Dialogue: 0,0:08:49.67,0:08:51.97,Chinese,,0,0,0,,常数乘法或除法
Dialogue: 0,0:08:52.12,0:08:55.90,English,,0,0,0,,We've seen examples of that and a similar one would happen if
Dialogue: 0,0:08:52.12,0:08:55.90,Chinese,,0,0,0,,我们已经看到过这样的例子，如果有的话会发生类似的例子
Dialogue: 0,0:09:01.58,0:09:09.82,English,,0,0,0,,If we took that program I showed before and applied it to every row
Dialogue: 0,0:09:01.58,0:09:09.82,Chinese,,0,0,0,,如果我们采用之前显示的程序并将其应用于每一行
Dialogue: 0,0:09:09.96,0:09:16.78,English,,0,0,0,,So we want to set for array 'a' we wanted to set every one of its rows to the value of the one dimensional array 'b'
Dialogue: 0,0:09:09.96,0:09:16.78,Chinese,,0,0,0,,所以我们要为数组'a'设置我们想要将其每一行设置为一维数组'b'的值
Dialogue: 0,0:09:19.22,0:09:24.80,English,,0,0,0,,Then again if we took that code we boosted the n*i in there
Dialogue: 0,0:09:19.22,0:09:24.80,Chinese,,0,0,0,,然后，如果我们采用该代码，我们在那里提升了n * i
Dialogue: 0,0:09:25.62,0:09:31.32,English,,0,0,0,,So now the inner loop is good but you realize that this multiplication isn't necessary either
Dialogue: 0,0:09:25.62,0:09:31.32,Chinese,,0,0,0,,所以现在内循环很好，但你意识到这种乘法也是不必要的
Dialogue: 0,0:09:31.32,0:09:36.20,English,,0,0,0,,Because what we're doing from i=0 to i=1 to i=2
Dialogue: 0,0:09:31.32,0:09:36.20,Chinese,,0,0,0,,因为我们正在做什么，从i = 0到i = 1到i = 2
Dialogue: 0,0:09:36.68,0:09:41.26,English,,0,0,0,,Is we're just increasing the parameter ni by we're adding m to it
Dialogue: 0,0:09:36.68,0:09:41.26,Chinese,,0,0,0,,我们只是通过增加m来增加参数ni
Dialogue: 0,0:09:41.86,0:09:49.12,English,,0,0,0,,So we can...and that's called a reduction in strength we've taken a multiplication and turned it into addition
Dialogue: 0,0:09:41.86,0:09:49.12,Chinese,,0,0,0,,所以我们可以...而这被称为力量的减少，我们已经采取了倍增并将其转化为额外的
Dialogue: 0,0:09:49.12,0:09:56.02,English,,0,0,0,,Because there's some predictable pattern of how this variable ni is going to be updated
Dialogue: 0,0:09:49.12,0:09:56.02,Chinese,,0,0,0,,因为有一些可预测的模式可以更新这个变量ni
Dialogue: 0,0:09:56.34,0:10:02.30,English,,0,0,0,,Another example and again array indexing is a good example for optimizations
Dialogue: 0,0:09:56.34,0:10:02.30,Chinese,,0,0,0,,另一个示例和数组索引是优化的一个很好的例子
Dialogue: 0,0:10:02.64,0:10:10.60,English,,0,0,0,,Imagine we had a image that we represent as a two-dimensional array of pixel values
Dialogue: 0,0:10:02.64,0:10:10.60,Chinese,,0,0,0,,想象一下，我们有一个图像，我们表示为像素值的二维数组
Dialogue: 0,0:10:11.38,0:10:15.58,English,,0,0,0,,And we want to do something that's what a filtering operation
Dialogue: 0,0:10:11.38,0:10:15.58,Chinese,,0,0,0,,我们想要做一些过滤操作
Dialogue: 0,0:10:15.58,0:10:22.62,English,,0,0,0,,Where we want to take the sum of the four neighbors of a given pixel north,south,east and west
Dialogue: 0,0:10:15.58,0:10:22.62,Chinese,,0,0,0,,我们想要得到北，南，东，西两个给定像素的四个邻居的总和
Dialogue: 0,0:10:23.14,0:10:26.56,English,,0,0,0,,And average those together or sum them together
Dialogue: 0,0:10:23.14,0:10:26.56,Chinese,,0,0,0,,并将它们放在一起或将它们加在一起
Dialogue: 0,0:10:27.68,0:10:37.20,English,,0,0,0,,And so the natural way you'd write this and see is to say I want usually i
Dialogue: 0,0:10:27.68,0:10:37.20,Chinese,,0,0,0,,所以你写这篇文章的自然方式就是说我经常想要
Dialogue: 0,0:10:38.04,0:10:40.94,English,,0,0,0,,Images you count from the top down and so
Dialogue: 0,0:10:38.04,0:10:40.94,Chinese,,0,0,0,,你自上而下计算的图像等等
Dialogue: 0,0:10:41.28,0:10:50.00,English,,0,0,0,,You'd say this is the the pixel above,this is the pixel below,this is the pixel to the left,this is the pixel to the right
Dialogue: 0,0:10:41.28,0:10:50.00,Chinese,,0,0,0,,你会说这是上面的像素，这是下面的像素，这是左边的像素，这是右边的像素
Dialogue: 0,0:10:50.98,0:10:56.60,English,,0,0,0,,And if you do this in and just compile it straight through
Dialogue: 0,0:10:50.98,0:10:56.60,Chinese,,0,0,0,,如果你这样做并直接编译它
Dialogue: 0,0:10:56.94,0:11:02.36,English,,0,0,0,,Unfortunately it appears as if there's three different multiplications by n
Dialogue: 0,0:10:56.94,0:11:02.36,Chinese,,0,0,0,,不幸的是，好像有三个不同的乘法乘以n
Dialogue: 0,0:11:02.74,0:11:05.08,English,,0,0,0,,i-1, i+1 and i
Dialogue: 0,0:11:02.74,0:11:05.08,Chinese,,0,0,0,,i-1，i + 1和i
Dialogue: 0,0:11:05.56,0:11:11.94,English,,0,0,0,,And if the compiler isn't too clever it won't realize that these are related to each other
Dialogue: 0,0:11:05.56,0:11:11.94,Chinese,,0,0,0,,如果编译器不是太聪明，它就不会意识到它们彼此相关
Dialogue: 0,0:11:11.94,0:11:16.02,English,,0,0,0,,And it will issue three different multiply operations just to do this one pixel thing
Dialogue: 0,0:11:11.94,0:11:16.02,Chinese,,0,0,0,,并且它将发出三个不同的乘法运算，只是为了做这个像素的事情
Dialogue: 0,0:11:16.78,0:11:18.94,English,,0,0,0,,Whereas if I'm a little more clever
Dialogue: 0,0:11:16.78,0:11:18.94,Chinese,,0,0,0,,如果我更聪明一点
Dialogue: 0,0:11:19.40,0:11:22.76,English,,0,0,0,,And this is one where I manually rewrote the code
Dialogue: 0,0:11:19.40,0:11:22.76,Chinese,,0,0,0,,这是我手动重写代码的地方
Dialogue: 0,0:11:22.76,0:11:24.42,English,,0,0,0,,So the compiler would pick it up
Dialogue: 0,0:11:22.76,0:11:24.42,Chinese,,0,0,0,,所以编译器会把它拿起来
Dialogue: 0,0:11:25.00,0:11:30.84,English,,0,0,0,,I'd say well if I ...so inj is i*n+j
Dialogue: 0,0:11:25.00,0:11:30.84,Chinese,,0,0,0,,如果我......我会说得好...所以注意力是i * n + j
Dialogue: 0,0:11:31.52,0:11:39.74,English,,0,0,0,,And I can get the the pixel above the pixel below by shifting that off setting that by a value of m
Dialogue: 0,0:11:31.52,0:11:39.74,Chinese,,0,0,0,,我可以通过将设置值移动m来获得下面像素上方的像素
Dialogue: 0,0:11:42.06,0:11:46.42,English,,0,0,0,,And then it will issue the code this will compile with the code with just one multiply
Dialogue: 0,0:11:42.06,0:11:46.42,Chinese,,0,0,0,,然后它将发出代码，这将使用只有一个乘法的代码进行编译
Dialogue: 0,0:11:46.54,0:11:51.36,English,,0,0,0,,And in general by the way multiply used to be a very expensive instruction
Dialogue: 0,0:11:46.54,0:11:51.36,Chinese,,0,0,0,,而且一般来说，乘法使用的方式非常昂贵
Dialogue: 0,0:11:51.80,0:11:57.20,English,,0,0,0,,Nowadays is enough hardware resources that it takes about three clock cycles,so it's not a huge deal
Dialogue: 0,0:11:51.80,0:11:57.20,Chinese,,0,0,0,,现在有足够的硬件资源需要大约三个时钟周期，所以这不是一个大问题
Dialogue: 0,0:11:57.74,0:12:02.38,English,,0,0,0,,But anytime you can take three multiplies and use just one instead that's generally a good idea
Dialogue: 0,0:11:57.74,0:12:02.38,Chinese,,0,0,0,,但是，任何时候你可以采取三个乘法，而只使用一个，这通常是一个好主意
Dialogue: 0,0:12:02.54,0:12:02.96,English,,0,0,0,,Question
Dialogue: 0,0:12:02.54,0:12:02.96,Chinese,,0,0,0,,题
Dialogue: 0,0:12:02.96,0:12:08.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:12:02.96,0:12:08.54,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:12:08.60,0:12:11.48,English,,0,0,0,,So the question is what if you're trying to optimize for space
Dialogue: 0,0:12:08.60,0:12:11.48,Chinese,,0,0,0,,所以问题是，如果你正在尝试优化空间
Dialogue: 0,0:12:11.48,0:12:13.84,English,,0,0,0,,And there are a lot of optimizations that will
Dialogue: 0,0:12:11.48,0:12:13.84,Chinese,,0,0,0,,并且会有很多优化
Dialogue: 0,0:12:14.54,0:12:19.48,English,,0,0,0,,Make your code be bigger at the expense of in order to go faster right
Dialogue: 0,0:12:14.54,0:12:19.48,Chinese,,0,0,0,,为了更快地运行，以牺牲代价为代价使代码更大
Dialogue: 0,0:12:19.90,0:12:22.78,English,,0,0,0,,This one though I'd argue this is actually shorter code right
Dialogue: 0,0:12:19.90,0:12:22.78,Chinese,,0,0,0,,这个虽然我认为这实际上是更短的代码权利
Dialogue: 0,0:12:24.10,0:12:26.30,English,,0,0,0,,And just look at the number of instructions so
Dialogue: 0,0:12:24.10,0:12:26.30,Chinese,,0,0,0,,然后只看一下指令的数量
Dialogue: 0,0:12:26.64,0:12:32.02,English,,0,0,0,,And usually so code you know that used to be a bigger concern when memory was sort of
Dialogue: 0,0:12:26.64,0:12:32.02,Chinese,,0,0,0,,通常这样的代码你知道在内存有点时曾经是一个更大的问题
Dialogue: 0,0:12:32.44,0:12:37.16,English,,0,0,0,,You know back the original IBM pc had 640 kilobytes of memory so
Dialogue: 0,0:12:32.44,0:12:37.16,Chinese,,0,0,0,,你知道原来的IBM pc有640千字节的内存
Dialogue: 0,0:12:37.56,0:12:42.34,English,,0,0,0,,In its maximum configuration and that was a big deal to actually buy it that much
Dialogue: 0,0:12:37.56,0:12:42.34,Chinese,,0,0,0,,在它的最大配置和实际购买它是一个很大的问题
Dialogue: 0,0:12:42.88,0:12:46.72,English,,0,0,0,,So you know back then that was a big deal memory but nowadays memory
Dialogue: 0,0:12:42.88,0:12:46.72,Chinese,,0,0,0,,所以你知道那是一个很大的记忆，但现在是记忆
Dialogue: 0,0:12:47.10,0:12:52.02,English,,0,0,0,,The size of the program is usually a pretty small fraction of what you're dealing with overall
Dialogue: 0,0:12:47.10,0:12:52.02,Chinese,,0,0,0,,程序的大小通常只是你整体处理的一小部分
Dialogue: 0,0:12:52.56,0:12:53.72,English,,0,0,0,,But it's a valid question
Dialogue: 0,0:12:52.56,0:12:53.72,Chinese,,0,0,0,,但这是一个有效的问题
Dialogue: 0,0:12:57.14,0:13:02.80,English,,0,0,0,,Okay so that just shows you an example and in general compilers are pretty good at doing
Dialogue: 0,0:12:57.14,0:13:02.80,Chinese,,0,0,0,,好的，这只是向你展示一个示例，一般编译器都非常擅长
Dialogue: 0,0:13:03.26,0:13:07.92,English,,0,0,0,,Those low-level optimizations like that if you write the code in a way that's reasonable
Dialogue: 0,0:13:03.26,0:13:07.92,Chinese,,0,0,0,,那些低级优化，如果你以合理的方式编写代码
Dialogue: 0,0:13:08.40,0:13:15.48,English,,0,0,0,,But there's some other ones that the compiler and even a the fanciest compiler you can buy might not be able to figure it out
Dialogue: 0,0:13:08.40,0:13:15.48,Chinese,,0,0,0,,但是还有一些其他的编译器，甚至是你可以购买的最好的编译器可能无法搞清楚
Dialogue: 0,0:13:15.90,0:13:20.70,English,,0,0,0,,And so I like to illustrate this with...when the first term we ever taught 213
Dialogue: 0,0:13:15.90,0:13:20.70,Chinese,,0,0,0,,所以我喜欢用...来说明这一点......当我们第一个学期的时候，213
Dialogue: 0,0:13:21.16,0:13:27.16,English,,0,0,0,,I was looking at some lab a code that some of the students wrote 
Dialogue: 0,0:13:21.16,0:13:27.16,Chinese,,0,0,0,,我在实验室里看到一些学生写的代码
Dialogue: 0,0:13:27.16,0:13:29.32,English,,0,0,0,,And I was horrified about this code
Dialogue: 0,0:13:27.16,0:13:29.32,Chinese,,0,0,0,,我对这段代码感到震惊
Dialogue: 0,0:13:30.08,0:13:33.68,English,,0,0,0,,And I showed it to the tas and none of them figured out what was wrong
Dialogue: 0,0:13:30.08,0:13:33.68,Chinese,,0,0,0,,我向它展示了它，但没有一个人弄清楚出了什么问题
Dialogue: 0,0:13:33.68,0:13:38.76,English,,0,0,0,,And I've shown it to many other highly-trained C programmers professionals
Dialogue: 0,0:13:33.68,0:13:38.76,Chinese,,0,0,0,,我已经向许多其他训练有素的C程序员专业人员展示过它
Dialogue: 0,0:13:39.04,0:13:42.16,English,,0,0,0,,They go looks ok to me
Dialogue: 0,0:13:39.04,0:13:42.16,Chinese,,0,0,0,,他们看起来对我很好
Dialogue: 0,0:13:42.22,0:13:45.40,English,,0,0,0,,So let's figure out what's why I was horrified by this code
Dialogue: 0,0:13:42.22,0:13:45.40,Chinese,,0,0,0,,那么让我们弄清楚为什么我被这段代码吓坏了
Dialogue: 0,0:13:45.86,0:13:49.56,English,,0,0,0,,So the idea of this code is supposed to be pretty straightforward there's a string s
Dialogue: 0,0:13:45.86,0:13:49.56,Chinese,,0,0,0,,所以这个代码的想法应该是非常简单的，有一个字符串s
Dialogue: 0,0:13:50.18,0:13:56.64,English,,0,0,0,,And I want to convert that string all the characters in it to lowercase
Dialogue: 0,0:13:50.18,0:13:56.64,Chinese,,0,0,0,,我想将该字符串中的所有字符转换为小写字母
Dialogue: 0,0:13:58.34,0:14:03.24,English,,0,0,0,,So I'm just going to read through the string and for each string position
Dialogue: 0,0:13:58.34,0:14:03.24,Chinese,,0,0,0,,所以我只是通读字符串和每个字符串位置
Dialogue: 0,0:14:04.02,0:14:09.06,English,,0,0,0,,Test that character and if it's somewhere between upper case a and upper case z
Dialogue: 0,0:14:04.02,0:14:09.06,Chinese,,0,0,0,,测试该字符，如果它在大写字母a和大写字母z之间的某处
Dialogue: 0,0:14:09.38,0:14:14.56,English,,0,0,0,,Then I'm going to shift it to being between a and z otherwise I will change it
Dialogue: 0,0:14:09.38,0:14:14.56,Chinese,,0,0,0,,然后我将它转移到a和z之间，否则我会改变它
Dialogue: 0,0:14:15.00,0:14:16.36,English,,0,0,0,,So pretty straightforward
Dialogue: 0,0:14:15.00,0:14:16.36,Chinese,,0,0,0,,非常简单明了
Dialogue: 0,0:14:17.30,0:14:20.52,English,,0,0,0,,But if you run this you see that
Dialogue: 0,0:14:17.30,0:14:20.52,Chinese,,0,0,0,,但如果你运行它，你会看到
Dialogue: 0,0:14:21.08,0:14:24.20,English,,0,0,0,,If you go up to half a million characters
Dialogue: 0,0:14:21.08,0:14:24.20,Chinese,,0,0,0,,如果你上升到五十万个字符
Dialogue: 0,0:14:25.26,0:14:33.66,English,,0,0,0,,Which might sound like a lot but it takes 240 or so so  so four minutes to run this code
Dialogue: 0,0:14:25.26,0:14:33.66,Chinese,,0,0,0,,这可能听起来很多，但需要240左右才能运行此代码四分钟
Dialogue: 0,0:14:35.30,0:14:37.78,English,,0,0,0,,And you go well that's a pretty big string
Dialogue: 0,0:14:35.30,0:14:37.78,Chinese,,0,0,0,,而你顺利，这是一个非常大的字符串
Dialogue: 0,0:14:37.78,0:14:43.04,English,,0,0,0,,It's really not a big string you should be able to do lowercase conversion of a string
Dialogue: 0,0:14:37.78,0:14:43.04,Chinese,,0,0,0,,它真的不是一个大字符串你应该能够做一个字符串的小写转换
Dialogue: 0,0:14:43.04,0:14:44.92,English,,0,0,0,,And a lot less than four seconds
Dialogue: 0,0:14:43.04,0:14:44.92,Chinese,,0,0,0,,而且不到四秒钟
Dialogue: 0,0:14:45.26,0:14:48.68,English,,0,0,0,,And you also notice this growth is nonlinear it's quadratic
Dialogue: 0,0:14:45.26,0:14:48.68,Chinese,,0,0,0,,你也注意到这种增长是非线性的，它是二次的
Dialogue: 0,0:14:48.68,0:14:52.78,English,,0,0,0,,It's growing as the square of the string length,so this is not good
Dialogue: 0,0:14:48.68,0:14:52.78,Chinese,,0,0,0,,它正在以字符串长度的平方增长，所以这并不好
Dialogue: 0,0:14:53.48,0:15:03.64,English,,0,0,0,,And unfortunately it's the kind and by the way this is one of the that is very easy surprisingly easy To have programs that have some hidden performance bug
Dialogue: 0,0:14:53.48,0:15:03.64,Chinese,,0,0,0,,不幸的是，这是一种类型，顺便说一下这是非常容易的一个非常简单容易有程序，有一些隐藏的性能错误
Dialogue: 0,0:15:03.90,0:15:05.40,English,,0,0,0,,That makes them run quadratic 
Dialogue: 0,0:15:03.90,0:15:05.40,Chinese,,0,0,0,,这使他们运行二次方
Dialogue: 0,0:15:05.42,0:15:11.26,English,,0,0,0,,And you run test and you test for strings of 10,000 or less
Dialogue: 0,0:15:05.42,0:15:11.26,Chinese,,0,0,0,,并且你运行测试并测试10,000或更少的字符串
Dialogue: 0,0:15:11.68,0:15:16.16,English,,0,0,0,,And it doesn't look like a big deal because the run time is insignificant so
Dialogue: 0,0:15:11.68,0:15:16.16,Chinese,,0,0,0,,它看起来并不是什么大不了的事，因为运行时间是微不足道的
Dialogue: 0,0:15:16.64,0:15:19.76,English,,0,0,0,,But then all of a sudden it hits a really bad case
Dialogue: 0,0:15:16.64,0:15:19.76,Chinese,,0,0,0,,但突然间它突然发生了非常糟糕的情况
Dialogue: 0,0:15:20.30,0:15:25.68,English,,0,0,0,,So this is... there's something wrong here
Dialogue: 0,0:15:20.30,0:15:25.68,Chinese,,0,0,0,,所以这就是......这里出了点问题
Dialogue: 0,0:15:26.30,0:15:28.72,English,,0,0,0,,So what's so bad about this program well
Dialogue: 0,0:15:26.30,0:15:28.72,Chinese,,0,0,0,,那么这个项目的好坏之处
Dialogue: 0,0:15:29.82,0:15:35.36,English,,0,0,0,,The key is when in a test like this of calling strlen
Dialogue: 0,0:15:29.82,0:15:35.36,Chinese,,0,0,0,,关键是在像这样调用strlen的测试中
Dialogue: 0,0:15:36.34,0:15:44.62,English,,0,0,0,,So the way it's determining whether it's reached the end of the string is by calling sterling to figure out how long the string is
Dialogue: 0,0:15:36.34,0:15:44.62,Chinese,,0,0,0,,因此，确定它是否到达字符串末尾的方式是通过调用英镑来计算字符串的长度
Dialogue: 0,0:15:46.66,0:15:54.82,English,,0,0,0,,Now and remember if we do the conversion of a for loop into a goto form like you've seen 
Dialogue: 0,0:15:46.66,0:15:54.82,Chinese,,0,0,0,,现在，请记住我们是否将for循环转换为你已经看过的goto形式
Dialogue: 0,0:15:54.82,0:15:56.94,English,,0,0,0,,There's various ways to convert it
Dialogue: 0,0:15:54.82,0:15:56.94,Chinese,,0,0,0,,有各种方法来转换它
Dialogue: 0,0:15:57.08,0:16:00.98,English,,0,0,0,,But all of them the test get built into the loop
Dialogue: 0,0:15:57.08,0:16:00.98,Chinese,,0,0,0,,但是所有这些测试都被构建到循环中
Dialogue: 0,0:16:02.02,0:16:08.94,English,,0,0,0,,So the main feature of that is this call to sterling will happen every time you go through the loop
Dialogue: 0,0:16:02.02,0:16:08.94,Chinese,,0,0,0,,因此，主要特征是每次进行循环时都会发生对英镑的调用
Dialogue: 0,0:16:11.14,0:16:13.28,English,,0,0,0,,And people overlook that fact
Dialogue: 0,0:16:11.14,0:16:13.28,Chinese,,0,0,0,,人们忽视了这一事实
Dialogue: 0,0:16:14.18,0:16:17.66,English,,0,0,0,,When you look at the different parts of a for loop
Dialogue: 0,0:16:14.18,0:16:17.66,Chinese,,0,0,0,,当你看到for循环的不同部分时
Dialogue: 0,0:16:18.20,0:16:20.70,English,,0,0,0,,The initialization only gets executed once
Dialogue: 0,0:16:18.20,0:16:20.70,Chinese,,0,0,0,,初始化只执行一次
Dialogue: 0,0:16:21.36,0:16:28.98,English,,0,0,0,,But both the tests and the update get incremented get applied every time you run through the loop
Dialogue: 0,0:16:21.36,0:16:28.98,Chinese,,0,0,0,,但是每次运行循环时，测试和更新都会增加
Dialogue: 0,0:16:30.14,0:16:36.44,English,,0,0,0,,So if that's getting called as many times as there are characters in the loop in the string right
Dialogue: 0,0:16:30.14,0:16:36.44,Chinese,,0,0,0,,因此，如果多次调用，则字符串右侧的循环中有字符
Dialogue: 0,0:16:37.60,0:16:39.20,English,,0,0,0,,And now how does strlen work
Dialogue: 0,0:16:37.60,0:16:39.20,Chinese,,0,0,0,,现在strlen如何工作
Dialogue: 0,0:16:39.22,0:16:42.58,English,,0,0,0,,Remember and see the only way you know how long a string is
Dialogue: 0,0:16:39.22,0:16:42.58,Chinese,,0,0,0,,记住并查看了解字符串长度的唯一方法
Dialogue: 0,0:16:43.06,0:16:47.26,English,,0,0,0,,Is to step through the whole thing and find the null character at the end
Dialogue: 0,0:16:43.06,0:16:47.26,Chinese,,0,0,0,,是逐步完成整个事情并在最后找到空字符
Dialogue: 0,0:16:48.18,0:16:52.28,English,,0,0,0,,So strlen itself is a linear time operation in the string
Dialogue: 0,0:16:48.18,0:16:52.28,Chinese,,0,0,0,,因此strlen本身就是字符串中的线性时间操作
Dialogue: 0,0:16:54.02,0:16:59.84,English,,0,0,0,,And you're doing that and so you're doing n calls to a function that takes time n
Dialogue: 0,0:16:54.02,0:16:59.84,Chinese,,0,0,0,,而你正在这样做，因此你正在调用一个需要时间的函数
Dialogue: 0,0:17:00.80,0:17:04.66,English,,0,0,0,,If the string is getting shorter as you go but not very fast so
Dialogue: 0,0:17:00.80,0:17:04.66,Chinese,,0,0,0,,如果字符串越来越短，但不是很快
Dialogue: 0,0:17:05.10,0:17:07.06,English,,0,0,0,,Basically that's quadratic performance
Dialogue: 0,0:17:05.10,0:17:07.06,Chinese,,0,0,0,,基本上是二次性能
Dialogue: 0,0:17:09.98,0:17:12.46,English,,0,0,0,,And that explains why you get that runtime
Dialogue: 0,0:17:09.98,0:17:12.46,Chinese,,0,0,0,,这就解释了为什么你得到那个运行时
Dialogue: 0,0:17:13.64,0:17:16.62,English,,0,0,0,,So in particular if I just make the following little change
Dialogue: 0,0:17:13.64,0:17:16.62,Chinese,,0,0,0,,所以特别是如果我做了以下一些小改动
Dialogue: 0,0:17:17.14,0:17:20.56,English,,0,0,0,,I introduce a local variable called len
Dialogue: 0,0:17:17.14,0:17:20.56,Chinese,,0,0,0,,我介绍一个名为len的局部变量
Dialogue: 0,0:17:21.38,0:17:24.50,English,,0,0,0,,And I pre compute strlen
Dialogue: 0,0:17:21.38,0:17:24.50,Chinese,,0,0,0,,我预先计算strlen
Dialogue: 0,0:17:24.50,0:17:29.26,English,,0,0,0,,Because the string isn't the length of the string isn't changing I'm just changing the characters in this string
Dialogue: 0,0:17:24.50,0:17:29.26,Chinese,,0,0,0,,因为字符串不是字符串的长度没有改变我只是改变了这个字符串中的字符
Dialogue: 0,0:17:30.10,0:17:34.46,English,,0,0,0,,Then so the the program will do the same thing
Dialogue: 0,0:17:30.10,0:17:34.46,Chinese,,0,0,0,,那么程序将做同样的事情
Dialogue: 0,0:17:34.78,0:17:38.22,English,,0,0,0,,But now the runtime is so short it doesn't even show up
Dialogue: 0,0:17:34.78,0:17:38.22,Chinese,,0,0,0,,但是现在运行时很短，甚至都没有显示出来
Dialogue: 0,0:17:38.60,0:17:43.68,English,,0,0,0,,It's maybe a second to do a million characters it's just not a big deal at all
Dialogue: 0,0:17:38.60,0:17:43.68,Chinese,,0,0,0,,这可能是一百万个字符，这根本不是什么大不了的事
Dialogue: 0,0:17:44.28,0:17:46.66,English,,0,0,0,,As it should be it's just running through
Dialogue: 0,0:17:44.28,0:17:46.66,Chinese,,0,0,0,,因为它应该是它刚刚运行
Dialogue: 0,0:17:47.22,0:17:53.72,English,,0,0,0,,And so that's just an example one of many that I've seen in my career where
Dialogue: 0,0:17:47.22,0:17:53.72,Chinese,,0,0,0,,所以这只是我职业生涯中见过的许多例子之一
Dialogue: 0,0:17:54.42,0:18:00.14,English,,0,0,0,,Something that seems almost insignificant turns out to be a serious performance problem
Dialogue: 0,0:17:54.42,0:18:00.14,Chinese,,0,0,0,,似乎几乎无足轻重的事情证明是一个严重的性能问题
Dialogue: 0,0:18:03.58,0:18:06.34,English,,0,0,0,,So why couldn't a compiler figure this out
Dialogue: 0,0:18:03.58,0:18:06.34,Chinese,,0,0,0,,那么为什么编译器无法解决这个问题
Dialogue: 0,0:18:07.62,0:18:09.58,English,,0,0,0,,Why couldn't a smart compiler
Dialogue: 0,0:18:07.62,0:18:09.58,Chinese,,0,0,0,,为什么不能使用智能编译器
Dialogue: 0,0:18:13.08,0:18:14.90,English,,0,0,0,,Look at the original code
Dialogue: 0,0:18:13.08,0:18:14.90,Chinese,,0,0,0,,看看原始代码
Dialogue: 0,0:18:17.14,0:18:22.68,English,,0,0,0,,And see, you know this is what the programmer wrote
Dialogue: 0,0:18:17.14,0:18:22.68,Chinese,,0,0,0,,看，你知道这是程序员写的
Dialogue: 0,0:18:22.68,0:18:26.52,English,,0,0,0,,But I know a better way to do it I'll precompute strlen in advance
Dialogue: 0,0:18:22.68,0:18:26.52,Chinese,,0,0,0,,但我知道更好的方法，我会提前预先计算strlen
Dialogue: 0,0:18:27.36,0:18:32.66,English,,0,0,0,,Well there's a couple reasons one is actually if you look at the code for strlen
Dialogue: 0,0:18:27.36,0:18:32.66,Chinese,,0,0,0,,好吧，如果你看一下strlen的代码，有几个原因
Dialogue: 0,0:18:32.90,0:18:35.80,English,,0,0,0,,You see that it's actually modifying the string
Dialogue: 0,0:18:32.90,0:18:35.80,Chinese,,0,0,0,,你看到它实际上正在修改字符串
Dialogue: 0,0:18:36.34,0:18:42.06,English,,0,0,0,,And strlen at this I mean the the code here is modifying the string and we're calling strlen on it
Dialogue: 0,0:18:36.34,0:18:42.06,Chinese,,0,0,0,,strlen在这里我的意思是这里的代码是修改字符串，我们正在调用strlen
Dialogue: 0,0:18:42.20,0:18:48.24,English,,0,0,0,,So you'd have to be pretty careful to do the analysis the compiler would to figure out that
Dialogue: 0,0:18:42.20,0:18:48.24,Chinese,,0,0,0,,因此，你必须非常小心地进行编译器可以解决的分析
Dialogue: 0,0:18:48.72,0:18:50.72,English,,0,0,0,,Even though the string is changing
Dialogue: 0,0:18:48.72,0:18:50.72,Chinese,,0,0,0,,即使字符串正在改变
Dialogue: 0,0:18:51.54,0:18:55.62,English,,0,0,0,,The result you're going to get from strlen is not going to change
Dialogue: 0,0:18:51.54,0:18:55.62,Chinese,,0,0,0,,你将从strlen获得的结果不会改变
Dialogue: 0,0:18:58.89,0:19:03.80,English,,0,0,0,,So that's a one reason
Dialogue: 0,0:18:58.89,0:19:03.80,Chinese,,0,0,0,,所以这是一个原因
Dialogue: 0,0:19:04.30,0:19:05.82,English,,0,0,0,,And the second is...
Dialogue: 0,0:19:04.30,0:19:05.82,Chinese,,0,0,0,,第二是......
Dialogue: 0,0:19:06.68,0:19:14.36,English,,0,0,0,,Well and how can the compiler be sure which version of strlen is actually going to get used
Dialogue: 0,0:19:06.68,0:19:14.36,Chinese,,0,0,0,,那么编译器如何确定哪个版本的strlen实际上将被使用
Dialogue: 0,0:19:14.80,0:19:18.66,English,,0,0,0,,You remember and see each of the files gets compiled separately
Dialogue: 0,0:19:14.80,0:19:18.66,Chinese,,0,0,0,,你记得并且看到每个文件都是单独编译的
Dialogue: 0,0:19:19.00,0:19:23.68,English,,0,0,0,,And only afterwards does it all get brought together in the linking phase
Dialogue: 0,0:19:19.00,0:19:23.68,Chinese,,0,0,0,,只有在此之后，它才会在链接阶段汇集在一起
Dialogue: 0,0:19:23.68,0:19:26.70,English,,0,0,0,,And some of that even happens after the program gets started
Dialogue: 0,0:19:23.68,0:19:26.70,Chinese,,0,0,0,,其中一些甚至在程序启动后发生
Dialogue: 0,0:19:27.48,0:19:30.74,English,,0,0,0,,So even though there's a standard strlen function
Dialogue: 0,0:19:27.48,0:19:30.74,Chinese,,0,0,0,,所以尽管有一个标准的strlen函数
Dialogue: 0,0:19:31.36,0:19:37.26,English,,0,0,0,,It's not necessarily the case that that's the one that will actually get used in the final program
Dialogue: 0,0:19:31.36,0:19:37.26,Chinese,,0,0,0,,实际上并不一定会在最终的程序中使用它
Dialogue: 0,0:19:37.26,0:19:40.98,English,,0,0,0,,So the compiler really can't be sure of that
Dialogue: 0,0:19:37.26,0:19:40.98,Chinese,,0,0,0,,所以编译器真的不能确定
Dialogue: 0,0:19:41.18,0:19:46.70,English,,0,0,0,,In particular imagine I provided a sort of customized strlen function like this
Dialogue: 0,0:19:41.18,0:19:46.70,Chinese,,0,0,0,,特别想象我提供了一种这样的自定义strlen函数
Dialogue: 0,0:19:47.40,0:19:53.26,English,,0,0,0,,That is keeping track of the sum of the lengths of all the strings that it's been called on
Dialogue: 0,0:19:47.40,0:19:53.26,Chinese,,0,0,0,,这是跟踪它被调用的所有字符串的长度之和
Dialogue: 0,0:19:53.72,0:19:57.12,English,,0,0,0,,Or some other side effect like that that
Dialogue: 0,0:19:53.72,0:19:57.12,Chinese,,0,0,0,,或者其他一些副作用
Dialogue: 0,0:19:57.84,0:20:02.20,English,,0,0,0,,Well that program would produce a very different result than if
Dialogue: 0,0:19:57.84,0:20:02.20,Chinese,,0,0,0,,那个程序会产生一个非常不同的结果
Dialogue: 0,0:20:02.78,0:20:05.86,English,,0,0,0,,If I whether or not I make the optimization
Dialogue: 0,0:20:02.78,0:20:05.86,Chinese,,0,0,0,,如果我是否进行优化
Dialogue: 0,0:20:05.98,0:20:12.36,English,,0,0,0,,So the compiler has to assume that strlen is just a black box that does whatever it does
Dialogue: 0,0:20:05.98,0:20:12.36,Chinese,,0,0,0,,所以编译器必须假设strlen只是一个黑盒子，无论它做什么
Dialogue: 0,0:20:12.76,0:20:19.68,English,,0,0,0,,And can't make any assumptions about what side effects it might have and so forth
Dialogue: 0,0:20:12.76,0:20:19.68,Chinese,,0,0,0,,并且不能对它可能产生的副作用做出任何假设，等等
Dialogue: 0,0:20:19.72,0:20:26.52,English,,0,0,0,,So it won't make that optimization on any machine even with the best compiler
Dialogue: 0,0:20:19.72,0:20:26.52,Chinese,,0,0,0,,所以即使使用最好的编译器，它也不会在任何机器上进行优化
Dialogue: 0,0:20:27.44,0:20:35.70,English,,0,0,0,,So that's just an example that and you can tell that I've gotten kind of sensitized to this
Dialogue: 0,0:20:27.44,0:20:35.70,Chinese,,0,0,0,,所以这只是一个例子，你可以告诉我，我已经对此敏感了
Dialogue: 0,0:20:36.24,0:20:39.06,English,,0,0,0,,So that I spot these but a lot of people don't
Dialogue: 0,0:20:36.24,0:20:39.06,Chinese,,0,0,0,,所以我发现了这些，但很多人没有
Dialogue: 0,0:20:42.52,0:20:44.12,English,,0,0,0,,Um so let's look at this
Dialogue: 0,0:20:42.52,0:20:44.12,Chinese,,0,0,0,,嗯，让我们看看这个
Dialogue: 0,0:20:44.98,0:20:47.12,English,,0,0,0,,Let's see
Dialogue: 0,0:20:44.98,0:20:47.12,Chinese,,0,0,0,,让我们来看看
Dialogue: 0,0:20:50.78,0:20:54.28,English,,0,0,0,,Oh this is another bad example a bad coding example
Dialogue: 0,0:20:50.78,0:20:54.28,Chinese,,0,0,0,,哦，这是一个糟糕的编码示例的另一个坏例子
Dialogue: 0,0:20:55.50,0:21:06.36,English,,0,0,0,,Of imagine I want to compute for a two-dimensional array a  and 'a' one-dimensional array 'b'
Dialogue: 0,0:20:55.50,0:21:06.36,Chinese,,0,0,0,,想象一下，我想计算一个二维数组a和'a'一维数组'b'
Dialogue: 0,0:21:06.76,0:21:14.90,English,,0,0,0,,I want to make b be b[i] be the sum of all the elements in row i of  a
Dialogue: 0,0:21:06.76,0:21:14.90,Chinese,,0,0,0,,我想使b为b [i]是a行i中所有元素的总和
Dialogue: 0,0:21:15.94,0:21:20.46,English,,0,0,0,,So again this is a fairly obvious kind of way to write this program that you
Dialogue: 0,0:21:15.94,0:21:20.46,Chinese,,0,0,0,,所以，这是一个相当明显的方式来编写这个程序，你
Dialogue: 0,0:21:21.60,0:21:27.64,English,,0,0,0,,Say well b[i]=0 and I'm going to just accumulate it,I'll step through the row and accumulate all the values
Dialogue: 0,0:21:21.60,0:21:27.64,Chinese,,0,0,0,,说好吧b [i] = 0，我只是积累它，我将逐步完成该行并积累所有值
Dialogue: 0,0:21:28.40,0:21:34.14,English,,0,0,0,,And of course we know now we could improve this by moving i*n out and so forth 
Dialogue: 0,0:21:28.40,0:21:34.14,Chinese,,0,0,0,,当然，我们现在知道我们可以通过移动i * n来改善这一点，等等
Dialogue: 0,0:21:34.18,0:21:35.56,English,,0,0,0,,I'm not trying to illustrate that 
Dialogue: 0,0:21:34.18,0:21:35.56,Chinese,,0,0,0,,我不想说明这一点
Dialogue: 0,0:21:36.64,0:21:39.52,English,,0,0,0,,But what you'll see in the program this is in the inner loop
Dialogue: 0,0:21:36.64,0:21:39.52,Chinese,,0,0,0,,但是你会在程序中看到这是在内循环中
Dialogue: 0,0:21:40.08,0:21:44.58,English,,0,0,0,,And we've looked briefly at some floating-point instructions
Dialogue: 0,0:21:40.08,0:21:44.58,Chinese,,0,0,0,,我们简要介绍了一些浮点指令
Dialogue: 0,0:21:44.82,0:21:47.18,English,,0,0,0,,And remember that the main feature of them is
Dialogue: 0,0:21:44.82,0:21:47.18,Chinese,,0,0,0,,请记住，它们的主要特征是
Dialogue: 0,0:21:47.74,0:21:51.24,English,,0,0,0,,The move instructions look like the move ones you're familiar with
Dialogue: 0,0:21:47.74,0:21:51.24,Chinese,,0,0,0,,移动指令看起来像你熟悉的移动指令
Dialogue: 0,0:21:51.50,0:21:56.08,English,,0,0,0,,Except when we put floating-point data in one of these %xmm registers
Dialogue: 0,0:21:51.50,0:21:56.08,Chinese,,0,0,0,,除非我们将浮点数据放在其中一个％xmm寄存器中
Dialogue: 0,0:21:57.32,0:22:02.42,English,,0,0,0,,So the main thing you see here is it's reading from memory
Dialogue: 0,0:21:57.32,0:22:02.42,Chinese,,0,0,0,,所以你在这里看到的主要是它从内存中读取
Dialogue: 0,0:22:02.94,0:22:06.42,English,,0,0,0,,It's adding something to it and then it's writing back to memory
Dialogue: 0,0:22:02.94,0:22:06.42,Chinese,,0,0,0,,它正在添加一些东西，然后它写回内存
Dialogue: 0,0:22:06.98,0:22:10.48,English,,0,0,0,,And what that memory location corresponds to b[i]
Dialogue: 0,0:22:06.98,0:22:10.48,Chinese,,0,0,0,,那个记忆位置对应b [i]
Dialogue: 0,0:22:11.30,0:22:18.64,English,,0,0,0,,So what it means is every time through this loop it's having to do a memory read and a memory write of b
Dialogue: 0,0:22:11.30,0:22:18.64,Chinese,,0,0,0,,所以这意味着每次通过这个循环都需要进行内存读取和b的内存写入
Dialogue: 0,0:22:19.08,0:22:21.12,English,,0,0,0,,In addition to the memory read of a
Dialogue: 0,0:22:19.08,0:22:21.12,Chinese,,0,0,0,,除了内存读取之外
Dialogue: 0,0:22:22.08,0:22:29.30,English,,0,0,0,,Even though presumably b[i] is the same of value that you just updated it to
Dialogue: 0,0:22:22.08,0:22:29.30,Chinese,,0,0,0,,尽管可能b [i]与你刚刚更新的价值相同
Dialogue: 0,0:22:30.46,0:22:33.56,English,,0,0,0,,Well in the previous execution of this loop right
Dialogue: 0,0:22:30.46,0:22:33.56,Chinese,,0,0,0,,好在上一次执行这个循环吧
Dialogue: 0,0:22:33.82,0:22:37.10,English,,0,0,0,,So why do you have to,why do you read it,why do you write it out
Dialogue: 0,0:22:33.82,0:22:37.10,Chinese,,0,0,0,,那么你为什么要这样做，为什么要阅读它，你为什么写出来呢？
Dialogue: 0,0:22:37.52,0:22:41.54,English,,0,0,0,,And then read it back in increment it and then again copy it back out
Dialogue: 0,0:22:37.52,0:22:41.54,Chinese,,0,0,0,,然后以增量方式读回来然后再将其复制回来
Dialogue: 0,0:22:41.54,0:22:47.78,English,,0,0,0,,Why does it have to go keep jumping back and forth between memory and registers over and over again
Dialogue: 0,0:22:41.54,0:22:47.78,Chinese,,0,0,0,,为什么必须一遍又一遍地在内存和寄存器之间来回跳转
Dialogue: 0,0:22:49.28,0:22:53.24,English,,0,0,0,,Well the reason is because in C you can't be sure
Dialogue: 0,0:22:49.28,0:22:53.24,Chinese,,0,0,0,,原因是因为在C中你无法确定
Dialogue: 0,0:22:53.78,0:22:57.86,English,,0,0,0,,That there isn't what's known as aliasing and I'm demonstrating it here
Dialogue: 0,0:22:53.78,0:22:57.86,Chinese,,0,0,0,,没有所谓的别名，我在这里展示它
Dialogue: 0,0:22:58.24,0:23:04.54,English,,0,0,0,,Imagine if row b is just declared to be that
Dialogue: 0,0:22:58.24,0:23:04.54,Chinese,,0,0,0,,想象一下，如果行b被宣布为那个
Dialogue: 0,0:23:05.32,0:23:10.10,English,,0,0,0,,Okay so imagine and you can do in C, this is legal C code
Dialogue: 0,0:23:05.32,0:23:10.10,Chinese,,0,0,0,,好吧，想象一下，你可以用C做，这是合法的C代码
Dialogue: 0,0:23:10.50,0:23:16.34,English,,0,0,0,,You can make one memory data structure overlay another data structure
Dialogue: 0,0:23:10.50,0:23:16.34,Chinese,,0,0,0,,你可以使一个内存数据结构覆盖另一个数据结构
Dialogue: 0,0:23:16.34,0:23:24.54,English,,0,0,0,,That's referred to as aliasing when too soon as separate parts of the program are referring to the same locations in memory
Dialogue: 0,0:23:16.34,0:23:24.54,Chinese,,0,0,0,,当程序的不同部分指向内存中的相同位置时，这称为别名
Dialogue: 0,0:23:25.04,0:23:27.28,English,,0,0,0,,And the C compiler has no way of knowing
Dialogue: 0,0:23:25.04,0:23:27.28,Chinese,,0,0,0,,并且C编译器无法知道
Dialogue: 0,0:23:29.14,0:23:35.44,English,,0,0,0,,Whether there's a lot of work and optimizing compilers to detect aliasing possibilities
Dialogue: 0,0:23:29.14,0:23:35.44,Chinese,,0,0,0,,是否有大量工作和优化编译器来检测混叠的可能性
Dialogue: 0,0:23:35.80,0:23:38.30,English,,0,0,0,,But in general as to assume aliasing might happen
Dialogue: 0,0:23:35.80,0:23:38.30,Chinese,,0,0,0,,但总的来说，假设可能会出现混叠
Dialogue: 0,0:23:38.84,0:23:47.72,English,,0,0,0,,So imagine this aliasing happened so that array 'b' can corresponds then to this row of array 'a'
Dialogue: 0,0:23:38.84,0:23:47.72,Chinese,,0,0,0,,所以想象一下这个别名发生了，所以数组'b'可以对应于这行数组'a'
Dialogue: 0,0:23:49.50,0:23:53.10,English,,0,0,0,,Well then of course its initial value is 4, 8, 16
Dialogue: 0,0:23:49.50,0:23:53.10,Chinese,,0,0,0,,那么当然它的初始值是4,8,16
Dialogue: 0,0:23:53.10,0:23:55.20,English,,0,0,0,,But if you trace through what this code will do
Dialogue: 0,0:23:53.10,0:23:55.20,Chinese,,0,0,0,,但是如果你追查这段代码会做什么
Dialogue: 0,0:23:55.58,0:24:00.76,English,,0,0,0,,It has a sort of odd behavior that is probably not useful for anything
Dialogue: 0,0:23:55.58,0:24:00.76,Chinese,,0,0,0,,它有一种奇怪的行为，可能对任何事情都没用
Dialogue: 0,0:24:01.28,0:24:09.30,English,,0,0,0,,But it just demonstrates that what will happen is as this as b gets updated
Dialogue: 0,0:24:01.28,0:24:09.30,Chinese,,0,0,0,,但它只是表明将会发生的事情就像b更新一样
Dialogue: 0,0:24:09.66,0:24:15.46,English,,0,0,0,,It's effectively changing a and it's changing then what's being read during the summation
Dialogue: 0,0:24:09.66,0:24:15.46,Chinese,,0,0,0,,它正在有效地改变a并且它正在改变然后在求和期间读取的内容
Dialogue: 0,0:24:17.70,0:24:20.86,English,,0,0,0,,And so this is a real possibility in C
Dialogue: 0,0:24:17.70,0:24:20.86,Chinese,,0,0,0,,所以这在C中是一个真正的可能性
Dialogue: 0,0:24:21.72,0:24:24.70,English,,0,0,0,,And so the compiler when it's given code like this
Dialogue: 0,0:24:21.72,0:24:24.70,Chinese,,0,0,0,,所以编译器在给出这样的代码时
Dialogue: 0,0:24:25.72,0:24:32.18,English,,0,0,0,,It has to assume that the these two memory locations might court overlap each other
Dialogue: 0,0:24:25.72,0:24:32.18,Chinese,,0,0,0,,它必须假设这两个存储位置可能相互重叠
Dialogue: 0,0:24:32.22,0:24:37.68,English,,0,0,0,,So that's why it's carefully writing it out and then reading it back in over and over again
Dialogue: 0,0:24:32.22,0:24:37.68,Chinese,,0,0,0,,所以这就是为什么它会仔细地写出来然后一遍又一遍地读回来
Dialogue: 0,0:24:40.50,0:24:45.32,English,,0,0,0,,And so if I just rewrite this code by introducing again a local variable
Dialogue: 0,0:24:40.50,0:24:45.32,Chinese,,0,0,0,,因此，如果我只是通过再次引入局部变量来重写此代码
Dialogue: 0,0:24:46.20,0:24:48.44,English,,0,0,0,,And accumulating in that local variable
Dialogue: 0,0:24:46.20,0:24:48.44,Chinese,,0,0,0,,并累积在该局部变量中
Dialogue: 0,0:24:49.06,0:24:52.98,English,,0,0,0,,And then only at the end do I sign that to b[i]
Dialogue: 0,0:24:49.06,0:24:52.98,Chinese,,0,0,0,,然后只在最后我签署b [i]
Dialogue: 0,0:24:53.64,0:24:57.18,English,,0,0,0,,Then you'll see this exact same loop all of a sudden gets a lot simpler
Dialogue: 0,0:24:53.64,0:24:57.18,Chinese,,0,0,0,,然后你会看到这个完全相同的循环突然变得更加简单
Dialogue: 0,0:24:57.24,0:25:02.82,English,,0,0,0,,It's just a read floating point, read and add to do that
Dialogue: 0,0:24:57.24,0:25:02.82,Chinese,,0,0,0,,它只是一个读取浮点，读取和添加来做到这一点
Dialogue: 0,0:25:03.80,0:25:12.90,English,,0,0,0,,And we'll see in fact the memory is actually one of the limiting perform performance limiters in a program
Dialogue: 0,0:25:03.80,0:25:12.90,Chinese,,0,0,0,,事实上，我们会看到内存实际上是程序中限制执行性能限制器之一
Dialogue: 0,0:25:12.90,0:25:16.71,English,,0,0,0,,So this is won't be a significantly faster
Dialogue: 0,0:25:12.90,0:25:16.71,Chinese,,0,0,0,,所以这不会明显加快
Dialogue: 0,0:25:16.88,0:25:22.08,English,,0,0,0,,And again that's something that you as a programmer would hardly think is a big deal
Dialogue: 0,0:25:16.88,0:25:22.08,Chinese,,0,0,0,,再一次，作为一名程序员，你很难想到的是一件大事
Dialogue: 0,0:25:23.08,0:25:25.32,English,,0,0,0,,But the C compiler can't do that in general
Dialogue: 0,0:25:23.08,0:25:25.32,Chinese,,0,0,0,,但是C编译器通常不能这样做
Dialogue: 0,0:25:25.56,0:25:30.62,English,,0,0,0,,Because it can't determine in advance what possible aliasing there can be
Dialogue: 0,0:25:25.56,0:25:30.62,Chinese,,0,0,0,,因为它无法预先确定可能存在的混叠
Dialogue: 0,0:25:35.20,0:25:41.84,English,,0,0,0,,So as is these two examples C sort of get in the habit of introducing local variables and using them
Dialogue: 0,0:25:35.20,0:25:41.84,Chinese,,0,0,0,,因此，这两个例子C就习惯于引入局部变量并使用它们
Dialogue: 0,0:25:42.12,0:25:47.74,English,,0,0,0,,And it's your way of telling the compiler don't call the same function over and over again
Dialogue: 0,0:25:42.12,0:25:47.74,Chinese,,0,0,0,,这是告诉编译器不要一遍又一遍地调用相同函数的方式
Dialogue: 0,0:25:47.74,0:25:53.38,English,,0,0,0,,Don't read and write the same memory location over and over again just hold it in a temporary one
Dialogue: 0,0:25:47.74,0:25:53.38,Chinese,,0,0,0,,不要一遍又一遍地读取和写入相同的内存位置，只需将其保存在临时位置即可
Dialogue: 0,0:25:53.58,0:25:58.26,English,,0,0,0,,And then it will automatically allocate a register and store it in that register and everything will be good
Dialogue: 0,0:25:53.58,0:25:58.26,Chinese,,0,0,0,,然后它会自动分配一个寄存器并将其存储在该寄存器中，一切都会很好
Dialogue: 0,0:26:01.40,0:26:09.88,English,,0,0,0,,Okay so that's sort of the the kind of what we call optimization blockers the kind of things that
Dialogue: 0,0:26:01.40,0:26:09.88,Chinese,,0,0,0,,好的，这就是我们称之为优化阻挡器的那种东西
Dialogue: 0,0:26:10.40,0:26:12.48,English,,0,0,0,,You as a programmer can make a difference on
Dialogue: 0,0:26:10.40,0:26:12.48,Chinese,,0,0,0,,作为程序员，你可以有所作为
Dialogue: 0,0:26:12.48,0:26:17.10,English,,0,0,0,,And the main blockers are memory referencing aliasing and function calls
Dialogue: 0,0:26:12.48,0:26:17.10,Chinese,,0,0,0,,主要的阻止程序是内存引用别名和函数调用
Dialogue: 0,0:26:17.60,0:26:21.54,English,,0,0,0,,And sort of understanding what might happen in that function call
Dialogue: 0,0:26:17.60,0:26:21.54,Chinese,,0,0,0,,并且理解在该函数调用中可能发生的事情
Dialogue: 0,0:26:22.38,0:26:24.70,English,,0,0,0,,And so now what we're going to do is transition
Dialogue: 0,0:26:22.38,0:26:24.70,Chinese,,0,0,0,,所以我们现在要做的就是过渡
Dialogue: 0,0:26:24.82,0:26:48.50,English,,0,0,0,,Question?equals three of this seem to be I think these two makes a distinction
Dialogue: 0,0:26:24.82,0:26:48.50,Chinese,,0,0,0,,问题？等于其中三个似乎是我认为这两个有所区别
Dialogue: 0,0:26:48.78,0:26:51.36,English,,0,0,0,,Oh no no this is alias C code
Dialogue: 0,0:26:48.78,0:26:51.36,Chinese,,0,0,0,,哦不，不，这是别名C代码
Dialogue: 0,0:26:53.96,0:26:57.12,English,,0,0,0,,I'm sure this is known C code because it ran
Dialogue: 0,0:26:53.96,0:26:57.12,Chinese,,0,0,0,,我确定这是已知的C代码，因为它运行了
Dialogue: 0,0:26:59.86,0:27:08.50,English,,0,0,0,,This is initializing calling it an array b remember these are in stars these aren't two-dimensional arrays right
Dialogue: 0,0:26:59.86,0:27:08.50,Chinese,,0,0,0,,这是初始化称它为数组b记住这些是星星，这些不是二维数组
Dialogue: 0,0:27:11.24,0:27:14.82,English,,0,0,0,,So this is saying a is low a
Dialogue: 0,0:27:11.24,0:27:14.82,Chinese,,0,0,0,,所以这就是说a低了
Dialogue: 0,0:27:15.80,0:27:19.72,English,,0,0,0,,Think of it as a linear array of four elements of nine elements
Dialogue: 0,0:27:15.80,0:27:19.72,Chinese,,0,0,0,,可以把它想象成九个元素的四个元素的线性数组
Dialogue: 0,0:27:20.38,0:27:24.68,English,,0,0,0,,And a plus three is just to go in three
Dialogue: 0,0:27:20.38,0:27:24.68,Chinese,,0,0,0,,加三只是三分之一
Dialogue: 0,0:27:25.02,0:27:28.80,English,,0,0,0,,So this is it is declaring b is not a pointer it's an array
Dialogue: 0,0:27:25.02,0:27:28.80,Chinese,,0,0,0,,所以这就是声明b不是指针它是一个数组
Dialogue: 0,0:27:29.10,0:27:35.60,English,,0,0,0,,But remember with an array you can refuse that the name of that array as a reference to a pointer 
Dialogue: 0,0:27:29.10,0:27:35.60,Chinese,,0,0,0,,但请记住，使用数组，你可以拒绝该数组的名称作为指针的引用
Dialogue: 0,0:27:35.84,0:27:38.02,English,,0,0,0,,A readable reference not a writable reference right
Dialogue: 0,0:27:35.84,0:27:38.02,Chinese,,0,0,0,,可读引用而非可写引用权
Dialogue: 0,0:27:38.34,0:27:44.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:27:38.34,0:27:44.54,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:27:44.72,0:27:48.02,English,,0,0,0,,Right for this exact code well I'll double check it
Dialogue: 0,0:27:44.72,0:27:48.02,Chinese,,0,0,0,,对于这个确切的代码，我会仔细检查它
Dialogue: 0,0:27:48.02,0:28:05.78,English,,0,0,0,,[student speaking]This design of the seafront language use null terminated strange instead of like hot dogs ice cream
Dialogue: 0,0:27:48.02,0:28:05.78,Chinese,,0,0,0,,[学生说话]这种海滨语言的设计使用null终止奇怪而不是像热狗冰淇淋
Dialogue: 0,0:28:05.80,0:28:08.58,English,,0,0,0,,So the question is why the C use null terminated strings
Dialogue: 0,0:28:05.80,0:28:08.58,Chinese,,0,0,0,,所以问题是为什么C使用null终止字符串
Dialogue: 0,0:28:09.20,0:28:14.28,English,,0,0,0,,And it does and it might be a bad decision for multiple reasons right but
Dialogue: 0,0:28:09.20,0:28:14.28,Chinese,,0,0,0,,确实如此，由于多种原因，这可能是一个糟糕的决定
Dialogue: 0,0:28:14.84,0:28:22.12,English,,0,0,0,,I think in general think of C was somebody who had or a couple people
Dialogue: 0,0:28:14.84,0:28:22.12,Chinese,,0,0,0,,我想一般认为C是有人或有几个人
Dialogue: 0,0:28:22.12,0:28:28.16,English,,0,0,0,,Who had been writing a lot of assembly code and wanted to lift up that level
Dialogue: 0,0:28:22.12,0:28:28.16,Chinese,,0,0,0,,谁曾写过很多汇编代码，想要提升那个级别
Dialogue: 0,0:28:28.16,0:28:30.80,English,,0,0,0,,So they weren't writing the same stuff over and over again
Dialogue: 0,0:28:28.16,0:28:30.80,Chinese,,0,0,0,,所以他们不是一遍又一遍地写同样的东西
Dialogue: 0,0:28:31.16,0:28:35.98,English,,0,0,0,,But not thinking in terms of how can I be the most abstract possible
Dialogue: 0,0:28:31.16,0:28:35.98,Chinese,,0,0,0,,但不要考虑如何才能成为最抽象的可能
Dialogue: 0,0:28:35.98,0:28:41.54,English,,0,0,0,,So they were trying to provide sort of a minimum layer on top of machine level programming
Dialogue: 0,0:28:35.98,0:28:41.54,Chinese,,0,0,0,,因此，他们试图在机器级编程之上提供最小层
Dialogue: 0,0:28:41.84,0:28:45.00,English,,0,0,0,,That would let them write code that could run from one machine to another
Dialogue: 0,0:28:41.84,0:28:45.00,Chinese,,0,0,0,,这会让他们编写可以从一台机器运行到另一台机器的代码
Dialogue: 0,0:28:45.38,0:28:51.84,English,,0,0,0,,So in everything they do they sort of use the most simple representation and don't assume any kind of
Dialogue: 0,0:28:45.38,0:28:51.84,Chinese,,0,0,0,,因此，在他们所做的每件事中，他们都使用最简单的表示法而不是任何形式
Dialogue: 0,0:28:52.06,0:28:58.74,English,,0,0,0,,There's no array you know most languages would have array bounds checking
Dialogue: 0,0:28:52.06,0:28:58.74,Chinese,,0,0,0,,没有数组你知道大多数语言都有数组边界检查
Dialogue: 0,0:28:58.86,0:29:07.24,English,,0,0,0,,And array would be a data structure that would include its size you know range of values and stuff and C just doesn't 
Dialogue: 0,0:28:58.86,0:29:07.24,Chinese,,0,0,0,,数组将是一个数据结构，包括它的大小，你知道值的范围和东西，而C只是没有
Dialogue: 0,0:29:07.40,0:29:09.68,English,,0,0,0,,So everything about C is sort of the minimum
Dialogue: 0,0:29:07.40,0:29:09.68,Chinese,,0,0,0,,所以关于C的一切都是最低限度的
Dialogue: 0,0:29:10.46,0:29:15.78,English,,0,0,0,,And you know it's been around for a 40 or something year so
Dialogue: 0,0:29:10.46,0:29:15.78,Chinese,,0,0,0,,而且你知道它已经存在了40年左右的时间
Dialogue: 0,0:29:15.78,0:29:20.68,English,,0,0,0,,[student speaking]
Dialogue: 0,0:29:15.78,0:29:20.68,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:29:20.70,0:29:25.78,English,,0,0,0,,No pascal does not proceed C no as simply not true
Dialogue: 0,0:29:20.70,0:29:25.78,Chinese,,0,0,0,,没有pascal不进行C不，因为根本不是真的
Dialogue: 0,0:29:26.04,0:29:31.10,English,,0,0,0,,Pascal was created as a language for teaching by this phone and nick was very
Dialogue: 0,0:29:26.04,0:29:31.10,Chinese,,0,0,0,,帕斯卡是用这种手机教学语言创造的，而尼克非常
Dialogue: 0,0:29:31.80,0:29:35.02,English,,0,0,0,,And it was very much an instructional language
Dialogue: 0,0:29:31.80,0:29:35.02,Chinese,,0,0,0,,它本身就是一种教学语言
Dialogue: 0,0:29:35.02,0:29:39.88,English,,0,0,0,,So it was really designed to help students who needed help
Dialogue: 0,0:29:35.02,0:29:39.88,Chinese,,0,0,0,,所以它真的旨在帮助需要帮助的学生
Dialogue: 0,0:29:40.34,0:29:48.72,English,,0,0,0,,And C was designed by professional programmers to let them write their code and not get in their way
Dialogue: 0,0:29:40.34,0:29:48.72,Chinese,,0,0,0,,C由专业程序员设计，让他们编写代码而不是妨碍他们
Dialogue: 0,0:29:48.86,0:29:52.74,English,,0,0,0,,So they're very different theory between the two languages right
Dialogue: 0,0:29:48.86,0:29:52.74,Chinese,,0,0,0,,所以他们两种语言之间的理论非常不同
Dialogue: 0,0:29:54.02,0:30:08.04,English,,0,0,0,,Yes...what's that....
Dialogue: 0,0:29:54.02,0:30:08.04,Chinese,,0,0,0,,是的......那是什么......
Dialogue: 0,0:30:08.04,0:30:11.16,English,,0,0,0,,I'm sorry,oh yes,that's a mistake there
Dialogue: 0,0:30:08.04,0:30:11.16,Chinese,,0,0,0,,对不起，哦，是的，那是一个错误
Dialogue: 0,0:30:12.36,0:30:17.58,English,,0,0,0,,I'll double-check this or people could check it,I'm pretty sure this code is okay though
Dialogue: 0,0:30:12.36,0:30:17.58,Chinese,,0,0,0,,我会仔细检查这个，或者人们可以检查一下，我很确定这个代码是可以的
Dialogue: 0,0:30:20.72,0:30:25.02,English,,0,0,0,,If not you can certainly say double star b equals a plus three and that would work right
Dialogue: 0,0:30:20.72,0:30:25.02,Chinese,,0,0,0,,如果没有，你当然可以说双星b等于加3，这将是正常的
Dialogue: 0,0:30:26.24,0:30:26.80,English,,0,0,0,,Question
Dialogue: 0,0:30:26.24,0:30:26.80,Chinese,,0,0,0,,题
Dialogue: 0,0:30:26.80,0:30:35.10,English,,0,0,0,,[student speaking]
Dialogue: 0,0:30:26.80,0:30:35.10,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:30:35.10,0:30:40.52,English,,0,0,0,,You think what...
Dialogue: 0,0:30:35.10,0:30:40.52,Chinese,,0,0,0,,你觉得......
Dialogue: 0,0:30:40.62,0:30:46.56,English,,0,0,0,,-You think this is 28 -Yeah -Well I'm not going to try and execute it here
Dialogue: 0,0:30:40.62,0:30:46.56,Chinese,,0,0,0,, - 你认为这是28岁 - 是的 - 我不会尝试在这里执行它
Dialogue: 0,0:30:46.56,0:30:49.28,English,,0,0,0,,But let's check it you and I will check this code out
Dialogue: 0,0:30:46.56,0:30:49.28,Chinese,,0,0,0,,但是让我们检查你，我会检查这个代码
Dialogue: 0,0:30:49.80,0:30:53.30,English,,0,0,0,,And we'll fix it if it needs to be fixed okay, thanks for pointing it out
Dialogue: 0,0:30:49.80,0:30:53.30,Chinese,,0,0,0,,如果它需要修复好的话我们会解决它，谢谢你指出它
Dialogue: 0,0:30:53.80,0:30:54.40,English,,0,0,0,,Yeah
Dialogue: 0,0:30:53.80,0:30:54.40,Chinese,,0,0,0,,是啊
Dialogue: 0,0:30:54.54,0:31:01.92,English,,0,0,0,,[student speaking]
Dialogue: 0,0:30:54.54,0:31:01.92,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:31:01.98,0:31:04.86,English,,0,0,0,,No that doesn't make any difference at all in this code
Dialogue: 0,0:31:01.98,0:31:04.86,Chinese,,0,0,0,,不，这在代码中完全没有任何区别
Dialogue: 0,0:31:06.10,0:31:09.08,English,,0,0,0,,No know where it's allocated makes no difference at all here
Dialogue: 0,0:31:06.10,0:31:09.08,Chinese,,0,0,0,,不知道它在哪里分配在这里完全没有区别
Dialogue: 0,0:31:10.38,0:31:13.76,English,,0,0,0,,So I'll check that might have to be **b=a+3
Dialogue: 0,0:31:10.38,0:31:13.76,Chinese,,0,0,0,,所以我会检查可能必须是** b = a + 3
Dialogue: 0,0:31:13.76,0:31:18.02,English,,0,0,0,,But I this was a while ago that I wrote this code oh double-check it number
Dialogue: 0,0:31:13.76,0:31:18.02,Chinese,,0,0,0,,但我这是不久前我写的这段代码哦，仔细检查它的号码
Dialogue: 0,0:31:19.76,0:31:33.04,English,,0,0,0,,Ok so anyway sets the sort of end of the story for simple simple optima 
Dialogue: 0,0:31:19.76,0:31:33.04,Chinese,,0,0,0,,好吧无论如何，为简单的简单最佳设定故事的结尾
Dialogue: 0,0:31:33.08,0:31:36.38,English,,0,0,0,,and they are simple optimizations it's just you have to get in the habit of doing it
Dialogue: 0,0:31:33.08,0:31:36.38,Chinese,,0,0,0,,它们是简单的优化，只是你必须养成这样做的习惯
Dialogue: 0,0:31:38.44,0:31:41.80,English,,0,0,0,,Ok now what we're going to do is go a little bit fancier than this
Dialogue: 0,0:31:38.44,0:31:41.80,Chinese,,0,0,0,,好吧，现在我们要做的就是比这更有趣
Dialogue: 0,0:31:41.96,0:31:45.94,English,,0,0,0,,And as I said this becomes somewhat more system dependent but
Dialogue: 0,0:31:41.96,0:31:45.94,Chinese,,0,0,0,,正如我所说，这变得更依赖于系统，但是
Dialogue: 0,0:31:46.22,0:31:51.88,English,,0,0,0,,Pretty much nowadays all processors are have similar implementation
Dialogue: 0,0:31:46.22,0:31:51.88,Chinese,,0,0,0,,现在几乎所有处理器都有类似的实现
Dialogue: 0,0:31:51.88,0:31:55.24,English,,0,0,0,,They all do what's known as out of order execution
Dialogue: 0,0:31:51.88,0:31:55.24,Chinese,,0,0,0,,他们都做了所谓的无序执行
Dialogue: 0,0:31:56.68,0:31:59.38,English,,0,0,0,,Except for the most primitive micro controllers
Dialogue: 0,0:31:56.68,0:31:59.38,Chinese,,0,0,0,,除了最原始的微控制器
Dialogue: 0,0:31:59.92,0:32:02.84,English,,0,0,0,,And so this is a the kind of optimization oh sure
Dialogue: 0,0:31:59.92,0:32:02.84,Chinese,,0,0,0,,所以这是一种优化哦肯定
Dialogue: 0,0:32:03.12,0:32:09.46,English,,0,0,0,,You'll find well this general approach will work across quite a variety machines
Dialogue: 0,0:32:03.12,0:32:09.46,Chinese,,0,0,0,,你会发现这种通用方法适用于各种各样的机器
Dialogue: 0,0:32:11.64,0:32:15.68,English,,0,0,0,,So what I'm going to do is do this by a series of examples
Dialogue: 0,0:32:11.64,0:32:15.68,Chinese,,0,0,0,,所以我要做的是通过一系列例子来做到这一点
Dialogue: 0,0:32:15.76,0:32:19.70,English,,0,0,0,,Starting from some not very efficient code and making it run faster and faster
Dialogue: 0,0:32:15.76,0:32:19.70,Chinese,,0,0,0,,从一些不是非常有效的代码开始，使其运行得更快更快
Dialogue: 0,0:32:19.70,0:32:24.24,English,,0,0,0,,And we'll get a speed-up of around 40
Dialogue: 0,0:32:19.70,0:32:24.24,Chinese,,0,0,0,,而且我们的速度将达到40左右
Dialogue: 0,0:32:25.02,0:32:27.02,English,,0,0,0,,Just in doing what we're doing
Dialogue: 0,0:32:25.02,0:32:27.02,Chinese,,0,0,0,,只是在做我们正在做的事情
Dialogue: 0,0:32:28.08,0:32:33.10,English,,0,0,0,,So as I'll start by saying well assume I have a data structure
Dialogue: 0,0:32:28.08,0:32:33.10,Chinese,,0,0,0,,因此，我首先要说好我假设我有一个数据结构
Dialogue: 0,0:32:33.10,0:32:35.48,English,,0,0,0,,That looks like the way pascal implements arrays
Dialogue: 0,0:32:33.10,0:32:35.48,Chinese,,0,0,0,,这看起来像pascal实现数组的方式
Dialogue: 0,0:32:37.08,0:32:38.86,English,,0,0,0,,Sorry I have nothing against pascal
Dialogue: 0,0:32:37.08,0:32:38.86,Chinese,,0,0,0,,对不起，我没有反对帕斯卡尔
Dialogue: 0,0:32:40.18,0:32:43.46,English,,0,0,0,,We used to teach it back in the old days but um
Dialogue: 0,0:32:40.18,0:32:43.46,Chinese,,0,0,0,,过去我们曾经教过它，但是嗯
Dialogue: 0,0:32:43.72,0:32:47.46,English,,0,0,0,,So a typical way you'd implement an array in a language is
Dialogue: 0,0:32:43.72,0:32:47.46,Chinese,,0,0,0,,因此，在一种语言中实现数组的典型方法是
Dialogue: 0,0:32:47.72,0:32:51.66,English,,0,0,0,,You'd provide both the values that are stored in that array
Dialogue: 0,0:32:47.72,0:32:51.66,Chinese,,0,0,0,,你将提供存储在该数组中的两个值
Dialogue: 0,0:32:51.94,0:32:57.28,English,,0,0,0,,And then there'd be other information associated with it for example what size it is
Dialogue: 0,0:32:51.94,0:32:57.28,Chinese,,0,0,0,,然后会有与之相关的其他信息，例如它的大小
Dialogue: 0,0:32:58.02,0:33:02.64,English,,0,0,0,,And so this is sort of the sort of nice abstract way to do it
Dialogue: 0,0:32:58.02,0:33:02.64,Chinese,,0,0,0,,所以这是一种很好的抽象方式
Dialogue: 0,0:33:03.26,0:33:10.26,English,,0,0,0,,And you write code that makes sure that if you ever try to exceed C the bounds on the array
Dialogue: 0,0:33:03.26,0:33:10.26,Chinese,,0,0,0,,你编写的代码可以确保如果你试图超过C数组的边界
Dialogue: 0,0:33:10.52,0:33:13.20,English,,0,0,0,,You'd return an error signal
Dialogue: 0,0:33:10.52,0:33:13.20,Chinese,,0,0,0,,你会返回一个错误信号
Dialogue: 0,0:33:13.56,0:33:23.54,English,,0,0,0,,And so this particular function you're seeing is what I want to retrieve an element I passed an a pointer
Dialogue: 0,0:33:13.56,0:33:23.54,Chinese,,0,0,0,,所以你看到的这个特殊功能就是我想要检索一个传递指针的元素
Dialogue: 0,0:33:23.74,0:33:30.08,English,,0,0,0,,And then that value the pointer gets used to retrieve the value from the array
Dialogue: 0,0:33:23.74,0:33:30.08,Chinese,,0,0,0,,然后该指针用于从数组中检索值
Dialogue: 0,0:33:30.82,0:33:36.20,English,,0,0,0,,And the return value of this function is then to 0 or 1 0 meaning failure in one meaning success
Dialogue: 0,0:33:30.82,0:33:36.20,Chinese,,0,0,0,,然后，此函数的返回值为0或1 0表示失败意味着成功
Dialogue: 0,0:33:36.86,0:33:41.98,English,,0,0,0,,And I'm writing it this way that I use a datatype I'll call data_t
Dialogue: 0,0:33:36.86,0:33:41.98,Chinese,,0,0,0,,我这样写的是我使用的数据类型我将调用data_t
Dialogue: 0,0:33:42.40,0:33:45.26,English,,0,0,0,,And that way I can run this I can compile this code
Dialogue: 0,0:33:42.40,0:33:45.26,Chinese,,0,0,0,,这样我可以运行这个我可以编译这段代码
Dialogue: 0,0:33:45.46,0:33:50.48,English,,0,0,0,,Using different definitions of data_t to get int,long,floats and doubles
Dialogue: 0,0:33:45.46,0:33:50.48,Chinese,,0,0,0,,使用data_t的不同定义来获取int，long，float和double
Dialogue: 0,0:33:50.98,0:33:57.08,English,,0,0,0,,And we'll see how the performance characteristics of those shift with the different data types
Dialogue: 0,0:33:50.98,0:33:57.08,Chinese,,0,0,0,,我们将看到那些性能特征如何随着不同的数据类型而变化
Dialogue: 0,0:33:59.38,0:34:03.30,English,,0,0,0,,And the benchmark I'm going to use is a fairly simple one
Dialogue: 0,0:33:59.38,0:34:03.30,Chinese,,0,0,0,,我要使用的基准测试非常简单
Dialogue: 0,0:34:03.30,0:34:10.06,English,,0,0,0,,It's just to for a an array or one of these vectors
Dialogue: 0,0:34:03.30,0:34:10.06,Chinese,,0,0,0,,这只是一个数组或这些向量之一
Dialogue: 0,0:34:10.88,0:34:15.76,English,,0,0,0,,I just want to combine all the elements of it either compute their sum or their product
Dialogue: 0,0:34:10.88,0:34:15.76,Chinese,,0,0,0,,我只是想结合它的所有元素来计算它们的总和或它们的产品
Dialogue: 0,0:34:16.52,0:34:20.14,English,,0,0,0,,And again I'm going to use macros here IDENT and OP 
Dialogue: 0,0:34:16.52,0:34:20.14,Chinese,,0,0,0,,再次，我将在这里使用IDENT和OP
Dialogue: 0,0:34:20.76,0:34:26.30,English,,0,0,0,,And define those so that OP is addition and the IDENT value is 0
Dialogue: 0,0:34:20.76,0:34:26.30,Chinese,,0,0,0,,并定义那些以便OP是加法并且IDENT值为0
Dialogue: 0,0:34:26.88,0:34:31.36,English,,0,0,0,,Or the OP is multiplication and the IDENT element is 1
Dialogue: 0,0:34:26.88,0:34:31.36,Chinese,,0,0,0,,或者OP是乘法，IDENT元素是1
Dialogue: 0,0:34:31.66,0:34:34.24,English,,0,0,0,,So that I can compare addition in multiplication
Dialogue: 0,0:34:31.66,0:34:34.24,Chinese,,0,0,0,,这样我就可以在乘法中比较加法
Dialogue: 0,0:34:35.10,0:34:37.66,English,,0,0,0,,So that gives us sort of eight possibilities here
Dialogue: 0,0:34:35.10,0:34:37.66,Chinese,,0,0,0,,所以这给了我们八种可能性
Dialogue: 0,0:34:37.88,0:34:40.24,English,,0,0,0,,Two different operations in four different data types
Dialogue: 0,0:34:37.88,0:34:40.24,Chinese,,0,0,0,,四种不同数据类型中的两种不同操作
Dialogue: 0,0:34:42.06,0:34:45.84,English,,0,0,0,,And so this is written in the sort of most straightforward manner that
Dialogue: 0,0:34:42.06,0:34:45.84,Chinese,,0,0,0,,因此，这是以最直接的方式编写的
Dialogue: 0,0:34:45.84,0:34:52.46,English,,0,0,0,,I'm using this function called get_vac_element to retrieve the successive values of this array
Dialogue: 0,0:34:45.84,0:34:52.46,Chinese,,0,0,0,,我正在使用名为get_vac_element的函数来检索此数组的连续值
Dialogue: 0,0:34:53.04,0:34:55.96,English,,0,0,0,,And then performing this operation on them
Dialogue: 0,0:34:53.04,0:34:55.96,Chinese,,0,0,0,,然后对它们执行此操作
Dialogue: 0,0:34:57.48,0:35:01.98,English,,0,0,0,,So now to express a performance of this
Dialogue: 0,0:34:57.48,0:35:01.98,Chinese,,0,0,0,,所以现在来表达一下这个表现
Dialogue: 0,0:35:02.62,0:35:06.58,English,,0,0,0,,We're going to use a metric I introduced called CPE
Dialogue: 0,0:35:02.62,0:35:06.58,Chinese,,0,0,0,,我们将使用我引入的名为CPE的指标
Dialogue: 0,0:35:06.82,0:35:10.68,English,,0,0,0,,Which stands for cycles per element
Dialogue: 0,0:35:06.82,0:35:10.68,Chinese,,0,0,0,,它代表每个元素的周期
Dialogue: 0,0:35:11.16,0:35:15.04,English,,0,0,0,,And the idea is that usually when you write code that say steps through a vector
Dialogue: 0,0:35:11.16,0:35:15.04,Chinese,,0,0,0,,而这个想法通常是当你编写代码通过向量的步骤时
Dialogue: 0,0:35:15.04,0:35:18.40,English,,0,0,0,,Anything that has sort of some linear performance as you get bigger
Dialogue: 0,0:35:15.04,0:35:18.40,Chinese,,0,0,0,,随着你变得更大，任何具有某种线性性能的东西
Dialogue: 0,0:35:19.02,0:35:28.88,English,,0,0,0,,You don't really want to know for exactly it takes this many seconds or microseconds or nanoseconds to do an operation
Dialogue: 0,0:35:19.02,0:35:28.88,Chinese,,0,0,0,,你真的不想知道它需要这么多秒或微秒或纳秒来进行操作
Dialogue: 0,0:35:29.32,0:35:33.66,English,,0,0,0,,You kind of want to know often more what's its overall performance characteristics
Dialogue: 0,0:35:29.32,0:35:33.66,Chinese,,0,0,0,,你有点想知道它的整体性能特征是什么
Dialogue: 0,0:35:34.38,0:35:38.90,English,,0,0,0,,And also it turns out when you're doing low-level code optimization
Dialogue: 0,0:35:34.38,0:35:38.90,Chinese,,0,0,0,,当你进行低级代码优化时，结果也证明了这一点
Dialogue: 0,0:35:38.90,0:35:44.94,English,,0,0,0,,It's much more useful to think in terms of clock cycles of the inner clock of the processor
Dialogue: 0,0:35:38.90,0:35:44.94,Chinese,,0,0,0,,根据处理器内部时钟的时钟周期来考虑更有用
Dialogue: 0,0:35:45.12,0:35:48.36,English,,0,0,0,,Rather than an absolute term such as nanoseconds
Dialogue: 0,0:35:45.12,0:35:48.36,Chinese,,0,0,0,,而不是像纳秒这样的绝对术语
Dialogue: 0,0:35:48.66,0:35:52.88,English,,0,0,0,,Because whether a processor is running at two gigahertz through 2.3 gigahertz
Dialogue: 0,0:35:48.66,0:35:52.88,Chinese,,0,0,0,,因为处理器是否以2千兆赫兹运行到2.3千兆赫兹
Dialogue: 0,0:35:53.68,0:35:57.68,English,,0,0,0,,I don't really I have no control over that as a programmer
Dialogue: 0,0:35:53.68,0:35:57.68,Chinese,,0,0,0,,作为一名程序员，我并不是真的无法控制它
Dialogue: 0,0:35:57.96,0:36:05.08,English,,0,0,0,,But I can control sort of it the low-level how many clock cycles are being used for different parts of the computation
Dialogue: 0,0:35:57.96,0:36:05.08,Chinese,,0,0,0,,但我可以控制它的低级别，计算的不同部分使用了多少个时钟周期
Dialogue: 0,0:36:06.64,0:36:09.62,English,,0,0,0,,So that's why it's called cycles per element
Dialogue: 0,0:36:06.64,0:36:09.62,Chinese,,0,0,0,,所以这就是为什么它被称为每个元素的循环
Dialogue: 0,0:36:09.72,0:36:13.84,English,,0,0,0,,And you can think of it as and this shows some actual measurements
Dialogue: 0,0:36:09.72,0:36:13.84,Chinese,,0,0,0,,你可以将其视为，并显示一些实际测量值
Dialogue: 0,0:36:14.36,0:36:21.48,English,,0,0,0,,But typically a function like this get what I showed the combine will have some overhead
Dialogue: 0,0:36:14.36,0:36:21.48,Chinese,,0,0,0,,但通常像这样的函数得到我所展示的组合将会有一些开销
Dialogue: 0,0:36:21.78,0:36:27.42,English,,0,0,0,,A fixed amount that's associated with setting up the loop doing the top level call and all that stuff
Dialogue: 0,0:36:21.78,0:36:27.42,Chinese,,0,0,0,,与设置执行顶级调用的循环和所有内容相关联的固定数量
Dialogue: 0,0:36:27.82,0:36:31.20,English,,0,0,0,,And then some component that's linear in the size
Dialogue: 0,0:36:27.82,0:36:31.20,Chinese,,0,0,0,,然后是一些线性大小的组件
Dialogue: 0,0:36:31.68,0:36:35.00,English,,0,0,0,,And so what I want to know is the slope of that linear component
Dialogue: 0,0:36:31.68,0:36:35.00,Chinese,,0,0,0,,所以我想知道的是线性分量的斜率
Dialogue: 0,0:36:37.66,0:36:41.56,English,,0,0,0,,I'll and that will determine that's what I'll call the cycles per element
Dialogue: 0,0:36:37.66,0:36:41.56,Chinese,,0,0,0,,我将会确定这就是我称之为每个元素的周期
Dialogue: 0,0:36:41.56,0:36:48.36,English,,0,0,0,,You can think that the sort of incremental cost of adding one more element to the array
Dialogue: 0,0:36:41.56,0:36:48.36,Chinese,,0,0,0,,你可以认为向阵列添加一个元素的增量成本
Dialogue: 0,0:36:53.88,0:36:56.64,English,,0,0,0,,So now if I run this function
Dialogue: 0,0:36:53.88,0:36:56.64,Chinese,,0,0,0,,所以现在如果我运行这个功能
Dialogue: 0,0:36:57.12,0:37:01.26,English,,0,0,0,,I showed you and I'm only showing I'll mostly only show four results
Dialogue: 0,0:36:57.12,0:37:01.26,Chinese,,0,0,0,,我告诉你，我只是展示我大多只展示四个结果
Dialogue: 0,0:37:01.26,0:37:07.44,English,,0,0,0,,Because it turns out whether it's int or long or float or double
Dialogue: 0,0:37:01.26,0:37:07.44,Chinese,,0,0,0,,因为事实证明它是int还是long还是float或double
Dialogue: 0,0:37:07.92,0:37:12.26,English,,0,0,0,,Is not going to actually have any effect on performance for most of the cases
Dialogue: 0,0:37:07.92,0:37:12.26,Chinese,,0,0,0,,对于大多数情况，实际上不会对性能产生任何影响
Dialogue: 0,0:37:13.04,0:37:15.56,English,,0,0,0,,So if I just run this code through a compiler
Dialogue: 0,0:37:13.04,0:37:15.56,Chinese,,0,0,0,,所以，如果我只是通过编译器运行此代码
Dialogue: 0,0:37:15.56,0:37:19.66,English,,0,0,0,,And don't do any optimizations it takes around 20 cycles per element
Dialogue: 0,0:37:15.56,0:37:19.66,Chinese,,0,0,0,,并且不做任何优化，每个元素需要大约20个周期
Dialogue: 0,0:37:20.22,0:37:27.92,English,,0,0,0,,And if I turn on optimization level 1 which is sort of the first serious optimization it takes the time in half
Dialogue: 0,0:37:20.22,0:37:27.92,Chinese,,0,0,0,,如果我打开优化级别1，这是第一次严重的优化，它需要花费一半的时间
Dialogue: 0,0:37:28.06,0:37:33.30,English,,0,0,0,,So I'm down to 10 clock cycles per element just by changing the compilation
Dialogue: 0,0:37:28.06,0:37:33.30,Chinese,,0,0,0,,因此，只需更改编译，我就可以将每个元素降低到10个时钟周期
Dialogue: 0,0:37:33.90,0:37:37.28,English,,0,0,0,,And that's using the most unoptimized code I could think of here
Dialogue: 0,0:37:33.90,0:37:37.28,Chinese,,0,0,0,,这是我在这里想到的最优化的代码
Dialogue: 0,0:37:41.20,0:37:44.72,English,,0,0,0,,And then I won't go through it all but using sort of...
Dialogue: 0,0:37:41.20,0:37:44.72,Chinese,,0,0,0,,然后我不会经历这一切，只是使用...
Dialogue: 0,0:37:46.10,0:37:53.08,English,,0,0,0,,The kind of things I described earlier of sort of cut away some of the redundancy in this program
Dialogue: 0,0:37:46.10,0:37:53.08,Chinese,,0,0,0,,我之前描述的那种东西削减了这个程序中的一些冗余
Dialogue: 0,0:37:53.42,0:37:55.98,English,,0,0,0,,You can get it down to something a little bit simpler
Dialogue: 0,0:37:53.42,0:37:55.98,Chinese,,0,0,0,,你可以把它简化为更简单的东西
Dialogue: 0,0:37:56.10,0:37:59.58,English,,0,0,0,,And so one thing instead of you saw before I was making a call to this
Dialogue: 0,0:37:56.10,0:37:59.58,Chinese,,0,0,0,,所以在我打电话之前，有一件事而不是你看到的
Dialogue: 0,0:38:00.12,0:38:04.10,English,,0,0,0,,get_vec_element and every time it did that it went bounds checking
Dialogue: 0,0:38:00.12,0:38:04.10,Chinese,,0,0,0,,get_vec_element并且每次执行时都会进行检查
Dialogue: 0,0:38:04.44,0:38:08.50,English,,0,0,0,,And it's kind of silly to keep bounds checking the same array over and over again
Dialogue: 0,0:38:04.44,0:38:08.50,Chinese,,0,0,0,,保持边界一遍又一遍地检查同一个数组是很愚蠢的
Dialogue: 0,0:38:08.72,0:38:15.58,English,,0,0,0,,When I'm stepping I'm using its length as the determinate of how many elements to access
Dialogue: 0,0:38:08.72,0:38:15.58,Chinese,,0,0,0,,当我踩到时，我正在使用它的长度来确定要访问的元素数量
Dialogue: 0,0:38:16.14,0:38:18.68,English,,0,0,0,,So if I'm willing to suit a forgo bounds checking
Dialogue: 0,0:38:16.14,0:38:18.68,Chinese,,0,0,0,,所以如果我愿意适合放弃边界检查
Dialogue: 0,0:38:19.04,0:38:26.14,English,,0,0,0,,What I can do is introduce a function that will just give me the actual data storage part of this vector
Dialogue: 0,0:38:19.04,0:38:26.14,Chinese,,0,0,0,,我能做的是引入一个函数，它只是给我这个向量的实际数据存储部分
Dialogue: 0,0:38:26.50,0:38:28.30,English,,0,0,0,,And skip over all the other stuff
Dialogue: 0,0:38:26.50,0:38:28.30,Chinese,,0,0,0,,并跳过所有其他的东西
Dialogue: 0,0:38:29.26,0:38:35.82,English,,0,0,0,,And so I can write a loop that and I introduce you know local variables and all the kind of things we described
Dialogue: 0,0:38:29.26,0:38:35.82,Chinese,,0,0,0,,所以我可以编写一个循环，并向你介绍局部变量和我们描述的所有类型的东西
Dialogue: 0,0:38:37.28,0:38:41.82,English,,0,0,0,,And accumulating temporaries and things like that
Dialogue: 0,0:38:37.28,0:38:41.82,Chinese,,0,0,0,,并积累临时和类似的东西
Dialogue: 0,0:38:42.64,0:38:45.62,English,,0,0,0,,Then the program actually gets a lot faster
Dialogue: 0,0:38:42.64,0:38:45.62,Chinese,,0,0,0,,然后程序实际上变得更快
Dialogue: 0,0:38:46.38,0:38:49.90,English,,0,0,0,,Again with this is everything from here out is optimization level 1
Dialogue: 0,0:38:46.38,0:38:49.90,Chinese,,0,0,0,,再说一遍，这里的一切都是优化级别1
Dialogue: 0,0:38:50.54,0:38:56.94,English,,0,0,0,,And so it drops it down to a little over a clock cycle for integers addition of
Dialogue: 0,0:38:50.54,0:38:56.94,Chinese,,0,0,0,,所以它会在一个时钟周期内将其降低到整数加法
Dialogue: 0,0:38:57.44,0:39:01.70,English,,0,0,0,,Or three clock cycles up to five clock cycles for double precision multiplier
Dialogue: 0,0:38:57.44,0:39:01.70,Chinese,,0,0,0,,或者双精度乘法器可以有三个时钟周期，最多五个时钟周期
Dialogue: 0,0:39:02.14,0:39:06.14,English,,0,0,0,,So that's pretty good I've sort of definitely improved things
Dialogue: 0,0:39:02.14,0:39:06.14,Chinese,,0,0,0,,所以这很好，我肯定有所改进
Dialogue: 0,0:39:06.52,0:39:09.70,English,,0,0,0,,But the question is well is that the best there is
Dialogue: 0,0:39:06.52,0:39:09.70,Chinese,,0,0,0,,但问题是，有最好的
Dialogue: 0,0:39:09.88,0:39:15.84,English,,0,0,0,,And first and well so try to understand what is it about these numbers three five
Dialogue: 0,0:39:09.88,0:39:15.84,Chinese,,0,0,0,,首先，好好了解一下这三个数字是什么
Dialogue: 0,0:39:16.38,0:39:19.02,English,,0,0,0,,And this seems to be something close to one point two five
Dialogue: 0,0:39:16.38,0:39:19.02,Chinese,,0,0,0,,而这似乎接近一点二五
Dialogue: 0,0:39:19.02,0:39:25.58,English,,0,0,0,,So where those numbers coming from and does that indicate some fundamental limitation in my program
Dialogue: 0,0:39:19.02,0:39:25.58,Chinese,,0,0,0,,那些来自这些数字的数字表明我的程序存在一些基本限制
Dialogue: 0,0:39:27.92,0:39:32.74,English,,0,0,0,,Well in order to do that you have to have some understanding of the underlying hardware
Dialogue: 0,0:39:27.92,0:39:32.74,Chinese,,0,0,0,,那么为了做到这一点，你必须对底层硬件有一些了解
Dialogue: 0,0:39:32.82,0:39:38.62,English,,0,0,0,,And there's a really good course you can take I think it's called ECE 741
Dialogue: 0,0:39:32.82,0:39:38.62,Chinese,,0,0,0,,你可以采取一个非常好的课程，我认为它被称为ECE 741
Dialogue: 0,0:39:39.82,0:39:44.02,English,,0,0,0,,That will tell you everything you ever could imagine wanting to know about processor design
Dialogue: 0,0:39:39.82,0:39:44.02,Chinese,,0,0,0,,这将告诉你你想象的有关处理器设计的一切
Dialogue: 0,0:39:44.86,0:39:47.50,English,,0,0,0,,And you actually design processors like this
Dialogue: 0,0:39:44.86,0:39:47.50,Chinese,,0,0,0,,你实际上设计了这样的处理器
Dialogue: 0,0:39:47.98,0:39:50.36,English,,0,0,0,,But I'm assuming you're not going to do that for a while
Dialogue: 0,0:39:47.98,0:39:50.36,Chinese,,0,0,0,,但我假设你暂时不打算那样做
Dialogue: 0,0:39:50.36,0:39:53.28,English,,0,0,0,,Because you have up seven prerequisites to do before that happens
Dialogue: 0,0:39:50.36,0:39:53.28,Chinese,,0,0,0,,因为在此之前你有七个先决条件要做
Dialogue: 0,0:39:55.82,0:39:59.28,English,,0,0,0,,So let me just give you the simple version
Dialogue: 0,0:39:55.82,0:39:59.28,Chinese,,0,0,0,,那么，让我给你一个简单的版本
Dialogue: 0,0:39:59.80,0:40:05.52,English,,0,0,0,,And this is sort of a an idea of what a processor has looked like since about 1995
Dialogue: 0,0:39:59.80,0:40:05.52,Chinese,,0,0,0,,这有点像处理器自1995年以来的样子
Dialogue: 0,0:40:05.86,0:40:12.34,English,,0,0,0,,So this is old stuff but it's enough actually to really understand it
Dialogue: 0,0:40:05.86,0:40:12.34,Chinese,,0,0,0,,所以这是旧的东西，但它实际上足以真正理解它
Dialogue: 0,0:40:12.34,0:40:16.82,English,,0,0,0,,It's so hard it's really the details are pretty massive
Dialogue: 0,0:40:12.34,0:40:16.82,Chinese,,0,0,0,,这太难了，真正的细节非常庞大
Dialogue: 0,0:40:17.26,0:40:23.70,English,,0,0,0,,And so it's not even taught for example 447 is the ECE is the computer architecture course
Dialogue: 0,0:40:17.26,0:40:23.70,Chinese,,0,0,0,,因此它甚至没有教过例如447是ECE是计算机架构课程
Dialogue: 0,0:40:23.70,0:40:26.60,English,,0,0,0,,And they don't really go into this kind of design here
Dialogue: 0,0:40:23.70,0:40:26.60,Chinese,,0,0,0,,他们并没有真正进入这种设计
Dialogue: 0,0:40:26.92,0:40:29.32,English,,0,0,0,,Because they're pretty hard,they're actually hard to design on your own
Dialogue: 0,0:40:26.92,0:40:29.32,Chinese,,0,0,0,,因为它们很难，所以它们实际上很难自己设计
Dialogue: 0,0:40:30.14,0:40:34.24,English,,0,0,0,,But the the basic idea is you think about a program as
Dialogue: 0,0:40:30.14,0:40:34.24,Chinese,,0,0,0,,但基本的想法是你认为一个程序
Dialogue: 0,0:40:34.78,0:40:39.94,English,,0,0,0,,As the computer just reads in an instruction does whatever it says to do
Dialogue: 0,0:40:34.78,0:40:39.94,Chinese,,0,0,0,,因为计算机只是读入一条指令就可以完成它所说的任何事情
Dialogue: 0,0:40:40.64,0:40:43.52,English,,0,0,0,,Reads in another instruction does what that says to do
Dialogue: 0,0:40:40.64,0:40:43.52,Chinese,,0,0,0,,读取另一条指令可以完成所要做的事情
Dialogue: 0,0:40:44.14,0:40:46.98,English,,0,0,0,,And that has nothing to do with how programs actually execute
Dialogue: 0,0:40:44.14,0:40:46.98,Chinese,,0,0,0,,这与程序实际执行方式无关
Dialogue: 0,0:40:47.30,0:40:51.02,English,,0,0,0,,What they've built up is this massive hardware infrastructure
Dialogue: 0,0:40:47.30,0:40:51.02,Chinese,,0,0,0,,他们建立的是这个庞大的硬件基础设施
Dialogue: 0,0:40:51.46,0:40:54.20,English,,0,0,0,,To make a program run way faster than
Dialogue: 0,0:40:51.46,0:40:54.20,Chinese,,0,0,0,,使程序运行速度比
Dialogue: 0,0:40:54.90,0:40:57.74,English,,0,0,0,,It would if it were just doing one instruction at a time
Dialogue: 0,0:40:54.90,0:40:57.74,Chinese,,0,0,0,,如果它一次只做一条指令就会这样
Dialogue: 0,0:40:58.26,0:41:03.12,English,,0,0,0,,And it employs a technique that's called superscalar out of order execution
Dialogue: 0,0:40:58.26,0:41:03.12,Chinese,,0,0,0,,它采用了一种称为超标量乱序执行的技术
Dialogue: 0,0:41:03.76,0:41:06.18,English,,0,0,0,,And the idea is roughly speaking it
Dialogue: 0,0:41:03.76,0:41:06.18,Chinese,,0,0,0,,这个想法粗略地说出来
Dialogue: 0,0:41:06.40,0:41:10.84,English,,0,0,0,,It takes your program If you think of your program as a linear sequence of instructions
Dialogue: 0,0:41:06.40,0:41:10.84,Chinese,,0,0,0,,它需要你的程序如果你认为你的程序是一个线性的指令序列
Dialogue: 0,0:41:11.40,0:41:14.12,English,,0,0,0,,And it just sucks in as many of those as it can
Dialogue: 0,0:41:11.40,0:41:14.12,Chinese,,0,0,0,,而且它尽可能地吸引了尽可能多的人
Dialogue: 0,0:41:14.68,0:41:18.48,English,,0,0,0,,And it pulls it apart to realize that certain operations
Dialogue: 0,0:41:14.68,0:41:18.48,Chinese,,0,0,0,,它将它拉开以实现某些操作
Dialogue: 0,0:41:18.96,0:41:23.76,English,,0,0,0,,Don't really depend on each other so I can start one even though it's later in the program
Dialogue: 0,0:41:18.96,0:41:23.76,Chinese,,0,0,0,,不要真的相互依赖，所以我可以开始一个，即使它是在程序的后期
Dialogue: 0,0:41:24.18,0:41:27.51,English,,0,0,0,,Than the one I'm working on right now because they're independent of each other
Dialogue: 0,0:41:24.18,0:41:27.51,Chinese,,0,0,0,,而不是我现在正在努力的那个，因为它们彼此独立
Dialogue: 0,0:41:27.82,0:41:32.34,English,,0,0,0,,And it's extracting what they call instruction level parallelism place is where
Dialogue: 0,0:41:27.82,0:41:32.34,Chinese,,0,0,0,,它正在提取他们称之为指令级并行性的地方
Dialogue: 0,0:41:32.94,0:41:36.24,English,,0,0,0,,Even though your program is a linear sequence of instruction
Dialogue: 0,0:41:32.94,0:41:36.24,Chinese,,0,0,0,,即使你的程序是一个线性的指令序列
Dialogue: 0,0:41:37.12,0:41:43.42,English,,0,0,0,,Buried in there is actually a sort of forest of different computations that need to be done
Dialogue: 0,0:41:37.12,0:41:43.42,Chinese,,0,0,0,,埋藏在那里实际上是一种需要完成不同计算的森林
Dialogue: 0,0:41:43.78,0:41:46.18,English,,0,0,0,,Some which depend on each other and some which don't
Dialogue: 0,0:41:43.78,0:41:46.18,Chinese,,0,0,0,,一些相互依赖，一些不相依
Dialogue: 0,0:41:47.24,0:41:49.44,English,,0,0,0,,And then it has a bunch of hardware
Dialogue: 0,0:41:47.24,0:41:49.44,Chinese,,0,0,0,,然后它有一堆硬件
Dialogue: 0,0:41:50.34,0:41:57.70,English,,0,0,0,,And so that's up here this upper part shows this idea of fetching instructions
Dialogue: 0,0:41:50.34,0:41:57.70,Chinese,,0,0,0,,因此，这里的上半部分显示了获取指令的想法
Dialogue: 0,0:41:57.70,0:42:02.88,English,,0,0,0,,So there's a cache memory a high performance high speed local memory
Dialogue: 0,0:41:57.70,0:42:02.88,Chinese,,0,0,0,,因此，高速缓存具有高性能高速本地存储器
Dialogue: 0,0:42:03.42,0:42:07.05,English,,0,0,0,,That is just pulling in your instructions as fast as it can
Dialogue: 0,0:42:03.42,0:42:07.05,Chinese,,0,0,0,,这只是尽可能快地提取你的指示
Dialogue: 0,0:42:07.72,0:42:14.00,English,,0,0,0,,And those instructions are then feeding a big pile of hardware that will extract out of it
Dialogue: 0,0:42:07.72,0:42:14.00,Chinese,,0,0,0,,然后这些指令就会提供一大堆硬件，这些硬件将从中提取出来
Dialogue: 0,0:42:14.36,0:42:19.00,English,,0,0,0,,These low-level operations and figure out which ones depend on which others
Dialogue: 0,0:42:14.36,0:42:19.00,Chinese,,0,0,0,,这些低级操作并确定哪些操作取决于哪些操作
Dialogue: 0,0:42:21.20,0:42:26.78,English,,0,0,0,,And then the there is a set of functional units in this part of it
Dialogue: 0,0:42:21.20,0:42:26.78,Chinese,,0,0,0,,然后在这部分中有一组功能单元
Dialogue: 0,0:42:26.78,0:42:33.90,English,,0,0,0,,That are able to perform these low-level operations to do arithmetic floating-point operations
Dialogue: 0,0:42:26.78,0:42:33.90,Chinese,,0,0,0,,能够执行这些低级操作来执行算术浮点运算
Dialogue: 0,0:42:34.28,0:42:39.24,English,,0,0,0,,To read data from memory to store data back to memory
Dialogue: 0,0:42:34.28,0:42:39.24,Chinese,,0,0,0,,从内存中读取数据以将数据存储回内存
Dialogue: 0,0:42:39.40,0:42:43.34,English,,0,0,0,,All using a cache which is something you're going to learn about fairly soon
Dialogue: 0,0:42:39.40,0:42:43.34,Chinese,,0,0,0,,所有人都使用缓存，这是你很快就会学到的东西
Dialogue: 0,0:42:43.68,0:42:50.08,English,,0,0,0,,How what all this cache is but think of this as a high speed copy of some of the data memory
Dialogue: 0,0:42:43.68,0:42:50.08,Chinese,,0,0,0,,所有这些缓存是怎样的，但将其视为某些数据内存的高速副本
Dialogue: 0,0:42:51.44,0:43:02.48,English,,0,0,0,,And so what this logic tries to do is keep a forking out ,spawning off operations based on your program
Dialogue: 0,0:42:51.44,0:43:02.48,Chinese,,0,0,0,,所以这个逻辑试图做的就是保持分叉，根据你的程序产生操作
Dialogue: 0,0:43:02.76,0:43:05.58,English,,0,0,0,,And keeping these as busy as they can be
Dialogue: 0,0:43:02.76,0:43:05.58,Chinese,,0,0,0,,并保持这些尽可能繁忙
Dialogue: 0,0:43:05.90,0:43:11.40,English,,0,0,0,,Doing different fragments of your code, doing different instructions in a different order from before
Dialogue: 0,0:43:05.90,0:43:11.40,Chinese,,0,0,0,,执行代码的不同片段，以与以前不同的顺序执行不同的指令
Dialogue: 0,0:43:12.02,0:43:20.96,English,,0,0,0,,And it turns out you think of a register as a little the set of registers is a part of memory that  get read and written
Dialogue: 0,0:43:12.02,0:43:20.96,Chinese,,0,0,0,,事实证明，你认为寄存器只是一组寄存器是读取和写入的内存的一部分
Dialogue: 0,0:43:21.34,0:43:25.98,English,,0,0,0,,It turns out that in executing a register now just becomes the name
Dialogue: 0,0:43:21.34,0:43:25.98,Chinese,,0,0,0,,事实证明，现在执行一个寄存器就成了名字
Dialogue: 0,0:43:26.32,0:43:30.82,English,,0,0,0,,Of something that one instruction produces and some other instructions consume
Dialogue: 0,0:43:26.32,0:43:30.82,Chinese,,0,0,0,,一条指令产生的东西和一些其他指令消耗的东西
Dialogue: 0,0:43:30.82,0:43:34.18,English,,0,0,0,,It's a destination for some, it's a source for other
Dialogue: 0,0:43:30.82,0:43:34.18,Chinese,,0,0,0,,这是一些目的地，它是其他人的来源
Dialogue: 0,0:43:34.72,0:43:39.84,English,,0,0,0,,And this whole a bunch of stuff here just sort of magically passes
Dialogue: 0,0:43:34.72,0:43:39.84,Chinese,,0,0,0,,而这里的一大堆东西只是神奇的传递
Dialogue: 0,0:43:40.40,0:43:45.38,English,,0,0,0,,The results of one computation to the input to another computation
Dialogue: 0,0:43:40.40,0:43:45.38,Chinese,,0,0,0,,一次计算结果到另一次计算的输入
Dialogue: 0,0:43:45.70,0:43:50.92,English,,0,0,0,,Based on register names without ever storing them in an explicit register file
Dialogue: 0,0:43:45.70,0:43:50.92,Chinese,,0,0,0,,基于寄存器名称而不将它们存储在显式寄存器文件中
Dialogue: 0,0:43:51.26,0:43:55.90,English,,0,0,0,,There is a register file when things kind of settle down they get stored away
Dialogue: 0,0:43:51.26,0:43:55.90,Chinese,,0,0,0,,有一个寄存器文件，当事情有点安定下来，他们被存储
Dialogue: 0,0:43:56.68,0:43:59.14,English,,0,0,0,,Anyways there's a lot of stuff going on here
Dialogue: 0,0:43:56.68,0:43:59.14,Chinese,,0,0,0,,无论如何，这里有很多东西
Dialogue: 0,0:43:59.58,0:44:07.74,English,,0,0,0,,But the main thing to think about is your machine has resources to do multiple operations all at the same time
Dialogue: 0,0:43:59.58,0:44:07.74,Chinese,,0,0,0,,但要考虑的主要事情是你的机器有资源同时进行多项操作
Dialogue: 0,0:44:07.74,0:44:13.74,English,,0,0,0,,If you can somehow structure your program so that those can all get used
Dialogue: 0,0:44:07.74,0:44:13.74,Chinese,,0,0,0,,如果你能以某种方式构建你的程序，那么这些都可以被使用
Dialogue: 0,0:44:16.04,0:44:20.42,English,,0,0,0,,So this is as I mentioned it's called a superscalar instruct  processor
Dialogue: 0,0:44:16.04,0:44:20.42,Chinese,,0,0,0,,所以这就像我提到的那样，它被称为超标量指令处理器
Dialogue: 0,0:44:20.42,0:44:23.84,English,,0,0,0,,Is one that can do more than one instruction every clock cycle
Dialogue: 0,0:44:20.42,0:44:23.84,Chinese,,0,0,0,,是每个时钟周期可以执行多条指令的一个
Dialogue: 0,0:44:25.38,0:44:32.96,English,,0,0,0,,And actually intel started in 1993 the very first Pentium could do two instructions at once
Dialogue: 0,0:44:25.38,0:44:32.96,Chinese,,0,0,0,,实际上，intel于1993年开始，第一台Pentium可以同时执行两条指令
Dialogue: 0,0:44:33.50,0:44:36.86,English,,0,0,0,,But then a little later they came out with one called the Pentium Pro
Dialogue: 0,0:44:33.50,0:44:36.86,Chinese,,0,0,0,,但稍后他们推出了一款名为Pentium Pro的产品
Dialogue: 0,0:44:37.04,0:44:40.08,English,,0,0,0,,Which is sort of the basis of all modern processors
Dialogue: 0,0:44:37.04,0:44:40.08,Chinese,,0,0,0,,这是所有现代处理器的基础
Dialogue: 0,0:44:40.52,0:44:43.22,English,,0,0,0,,And the lead architect by the way was a CMU graduate
Dialogue: 0,0:44:40.52,0:44:43.22,Chinese,,0,0,0,,顺便说一下，首席架构师是CMU毕业生
Dialogue: 0,0:44:45.14,0:44:50.38,English,,0,0,0,,But this out order execution is the model that's used nowadays
Dialogue: 0,0:44:45.14,0:44:50.38,Chinese,,0,0,0,,但是这个订单执行是现在使用的模型
Dialogue: 0,0:44:51.86,0:44:58.53,English,,0,0,0,,So the other thing is those functional units are more complex than you think they might be
Dialogue: 0,0:44:51.86,0:44:58.53,Chinese,,0,0,0,,所以另一件事是那些功能单元比你想象的更复杂
Dialogue: 0,0:44:58.90,0:45:00.92,English,,0,0,0,,And that they have what's called pipelining
Dialogue: 0,0:44:58.90,0:45:00.92,Chinese,,0,0,0,,他们拥有所谓的流水线技术
Dialogue: 0,0:45:01.46,0:45:07.38,English,,0,0,0,,And the ideas of pipelining is imagine you can break up a computation into a series of distinct stages
Dialogue: 0,0:45:01.46,0:45:07.38,Chinese,,0,0,0,,流水线的想法是想象你可以将计算分解为一系列不同的阶段
Dialogue: 0,0:45:09.24,0:45:13.50,English,,0,0,0,,A simple example is if you want to compute a*b+c
Dialogue: 0,0:45:09.24,0:45:13.50,Chinese,,0,0,0,,一个简单的例子是你想要计算一个* b + c
Dialogue: 0,0:45:13.88,0:45:16.16,English,,0,0,0,,You first do the times then you do the plus
Dialogue: 0,0:45:13.88,0:45:16.16,Chinese,,0,0,0,,你先做时间，然后你做加号
Dialogue: 0,0:45:17.06,0:45:21.22,English,,0,0,0,,But it actually gets more deep than that you can take something like multiplication
Dialogue: 0,0:45:17.06,0:45:21.22,Chinese,,0,0,0,,但它实际上比你可以采取像乘法这样的东西更深
Dialogue: 0,0:45:22.24,0:45:26.16,English,,0,0,0,,And break it up into smaller steps
Dialogue: 0,0:45:22.24,0:45:26.16,Chinese,,0,0,0,,并将其分解为更小的步骤
Dialogue: 0,0:45:26.76,0:45:28.88,English,,0,0,0,,That can be done one after the other
Dialogue: 0,0:45:26.76,0:45:28.88,Chinese,,0,0,0,,这可以一个接一个地完成
Dialogue: 0,0:45:29.50,0:45:34.16,English,,0,0,0,,In a way that and then if you have a separate dedicated hardware for each of those stages
Dialogue: 0,0:45:29.50,0:45:34.16,Chinese,,0,0,0,,以某种方式，然后如果你为每个阶段都有一个单独的专用硬件
Dialogue: 0,0:45:34.62,0:45:37.22,English,,0,0,0,,Then you can do what's called pipelining which is
Dialogue: 0,0:45:34.62,0:45:37.22,Chinese,,0,0,0,,然后你可以做所谓的流水线操作
Dialogue: 0,0:45:37.86,0:45:40.94,English,,0,0,0,,When one operation moves from one stage to the next
Dialogue: 0,0:45:37.86,0:45:40.94,Chinese,,0,0,0,,当一个操作从一个阶段移动到下一个阶段时
Dialogue: 0,0:45:41.40,0:45:45.22,English,,0,0,0,,A new operation can come in behind and start start its thing
Dialogue: 0,0:45:41.40,0:45:45.22,Chinese,,0,0,0,,一个新的操作可以进入并开始启动它的事情
Dialogue: 0,0:45:45.82,0:45:51.98,English,,0,0,0,,So this example shows imagine I had a three stage pipeline multiplier
Dialogue: 0,0:45:45.82,0:45:51.98,Chinese,,0,0,0,,所以这个例子说明我有一个三阶段管道乘数
Dialogue: 0,0:45:52.56,0:45:59.56,English,,0,0,0,,And I want to do this computation a*b, a*c and now multiply those together
Dialogue: 0,0:45:52.56,0:45:59.56,Chinese,,0,0,0,,我想做这个计算a * b，a * c然后将它们相乘
Dialogue: 0,0:46:00.56,0:46:06.16,English,,0,0,0,,So the thing to observe is that a*b and a*c don't depend on each other in any way
Dialogue: 0,0:46:00.56,0:46:06.16,Chinese,,0,0,0,,所以要注意的是a * b和a * c不以任何方式相互依赖
Dialogue: 0,0:46:07.06,0:46:12.10,English,,0,0,0,,So I can do them both and I don't have hardware to do them simultaneously
Dialogue: 0,0:46:07.06,0:46:12.10,Chinese,,0,0,0,,所以我可以做到这两点，我没有硬件同时做它们
Dialogue: 0,0:46:12.10,0:46:15.52,English,,0,0,0,,But I have them enough to do one right after the other
Dialogue: 0,0:46:12.10,0:46:15.52,Chinese,,0,0,0,,但我已经足够他们一个接一个地做一个
Dialogue: 0,0:46:16.20,0:46:23.70,English,,0,0,0,,So I can feed the first computation into the first stage a*b on step time step one
Dialogue: 0,0:46:16.20,0:46:23.70,Chinese,,0,0,0,,所以我可以在步骤时间第一步将第一个计算输入第一个阶段a * b
Dialogue: 0,0:46:24.24,0:46:27.06,English,,0,0,0,,And then time step two it will move on to stage two
Dialogue: 0,0:46:24.24,0:46:27.06,Chinese,,0,0,0,,然后是第二步，它将继续进入第二阶段
Dialogue: 0,0:46:27.06,0:46:32.18,English,,0,0,0,,And times step three it will move on to stage three
Dialogue: 0,0:46:27.06,0:46:32.18,Chinese,,0,0,0,,第三步，它将进入第三阶段
Dialogue: 0,0:46:32.82,0:46:37.28,English,,0,0,0,,But now I can start a*c in the time step two
Dialogue: 0,0:46:32.82,0:46:37.28,Chinese,,0,0,0,,但现在我可以在第二步开始一个* c
Dialogue: 0,0:46:38.10,0:46:40.68,English,,0,0,0,,Because this stage became available
Dialogue: 0,0:46:38.10,0:46:40.68,Chinese,,0,0,0,,因为这个阶段变得可用
Dialogue: 0,0:46:40.98,0:46:45.10,English,,0,0,0,,Once a*b moved from stage 1 to stage 2
Dialogue: 0,0:46:40.98,0:46:45.10,Chinese,,0,0,0,,一旦a * b从第1阶段移至第2阶段
Dialogue: 0,0:46:45.46,0:46:51.32,English,,0,0,0,,And so I can follow right behind just one clock cycle behind this other operation
Dialogue: 0,0:46:45.46,0:46:51.32,Chinese,,0,0,0,,所以我可以在这个其他操作后面的一个时钟周期后面跟进
Dialogue: 0,0:46:52.86,0:46:58.00,English,,0,0,0,,Now p1*p2 obviously depends on both of these products
Dialogue: 0,0:46:52.86,0:46:58.00,Chinese,,0,0,0,,现在p1 * p2显然取决于这两种产品
Dialogue: 0,0:46:58.78,0:47:03.22,English,,0,0,0,,So it can't start until a*c is completed
Dialogue: 0,0:46:58.78,0:47:03.22,Chinese,,0,0,0,,因此，在* c完成之前无法启动
Dialogue: 0,0:47:03.68,0:47:07.32,English,,0,0,0,,And then it will run through the pipeline without anything else
Dialogue: 0,0:47:03.68,0:47:07.32,Chinese,,0,0,0,,然后它将通过管道运行而没有任何其他东西
Dialogue: 0,0:47:07.86,0:47:15.44,English,,0,0,0,,So overall then we've done what would have normally seemed to be nine steps worth of arithmetic
Dialogue: 0,0:47:07.86,0:47:15.44,Chinese,,0,0,0,,总的来说，我们已经完成了通常看起来比较算术的9个步骤
Dialogue: 0,0:47:16.44,0:47:20.66,English,,0,0,0,,In a total of seven steps here because of pipelining
Dialogue: 0,0:47:16.44,0:47:20.66,Chinese,,0,0,0,,由于流水线操作，这里总共有七个步骤
Dialogue: 0,0:47:20.78,0:47:27.54,English,,0,0,0,,Question
Dialogue: 0,0:47:20.78,0:47:27.54,Chinese,,0,0,0,,题
Dialogue: 0,0:47:27.56,0:47:31.84,English,,0,0,0,,What's...if you had like in this a a picture here
Dialogue: 0,0:47:27.56,0:47:31.84,Chinese,,0,0,0,,什么...如果你喜欢这里的照片
Dialogue: 0,0:47:32.58,0:47:36.50,English,,0,0,0,,If there were different multipliers in these different places yes you could do
Dialogue: 0,0:47:32.58,0:47:36.50,Chinese,,0,0,0,,如果在这些不同的地方有不同的乘数，你可以做到
Dialogue: 0,0:47:37.50,0:47:39.86,English,,0,0,0,,Those two completely independent of each other
Dialogue: 0,0:47:37.50,0:47:39.86,Chinese,,0,0,0,,那两个完全相互独立
Dialogue: 0,0:47:39.92,0:47:48.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:47:39.92,0:47:48.78,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:47:48.80,0:47:53.50,English,,0,0,0,,Yes this is all in a single core of a single processor ,multi-core is yet another
Dialogue: 0,0:47:48.80,0:47:53.50,Chinese,,0,0,0,,是的，这一切都在单个处理器的单核中，多核是另一个
Dialogue: 0,0:47:53.90,0:47:57.12,English,,0,0,0,,This is a lower level parallelism than you get through multi-core
Dialogue: 0,0:47:53.90,0:47:57.12,Chinese,,0,0,0,,这是一个比通过多核更低级别的并行性
Dialogue: 0,0:47:57.82,0:48:04.52,English,,0,0,0,,And it's present except in the sort of lowest n lowest powered embedded processors some version of this exists
Dialogue: 0,0:47:57.82,0:48:04.52,Chinese,,0,0,0,,它存在，除了在最低n最低功率的嵌入式处理器中，存在一些版本
Dialogue: 0,0:48:05.30,0:48:09.30,English,,0,0,0,,And most of the time your hardware is not being fully utilized it's one thing you're going to learn from this
Dialogue: 0,0:48:05.30,0:48:09.30,Chinese,,0,0,0,,而且大多数时候你的硬件没有得到充分利用，这是你要从中学到的一件事
Dialogue: 0,0:48:12.50,0:48:16.64,English,,0,0,0,,So that's the idea of pipelining it,it's a sort of like parallelism
Dialogue: 0,0:48:12.50,0:48:16.64,Chinese,,0,0,0,,这就是流水线操作的想法，它有点像并行性
Dialogue: 0,0:48:16.64,0:48:20.96,English,,0,0,0,,But it's not that you have multiple copies of resources it's that you have
Dialogue: 0,0:48:16.64,0:48:20.96,Chinese,,0,0,0,,但并不是说你拥有多份资源副本
Dialogue: 0,0:48:21.30,0:48:29.62,English,,0,0,0,,This ability to stream operations through a single hardware resource  in close succession to each other
Dialogue: 0,0:48:21.30,0:48:29.62,Chinese,,0,0,0,,这种通过单个硬件资源相互连续流动操作的能力
Dialogue: 0,0:48:33.28,0:48:39.34,English,,0,0,0,,And so as well which is a little bit more recent than the shark machines
Dialogue: 0,0:48:33.28,0:48:39.34,Chinese,,0,0,0,,而且这比鲨鱼机器更近一点
Dialogue: 0,0:48:39.34,0:48:41.98,English,,0,0,0,,But not that much more
Dialogue: 0,0:48:39.34,0:48:41.98,Chinese,,0,0,0,,但不是那么多
Dialogue: 0,0:48:42.38,0:48:47.12,English,,0,0,0,,One of the...most recent versions of the intel x86 series
Dialogue: 0,0:48:42.38,0:48:47.12,Chinese,,0,0,0,,英特尔x86系列的最新版本之一
Dialogue: 0,0:48:48.60,0:48:55.50,English,,0,0,0,,And the functional units include there's a lot of functional units that can do different things
Dialogue: 0,0:48:48.60,0:48:55.50,Chinese,,0,0,0,,功能单元包括许多可以做不同事情的功能单元
Dialogue: 0,0:48:55.52,0:49:02.10,English,,0,0,0,,But when you add it all up there's a possibility of it doing  two loads in one store
Dialogue: 0,0:48:55.52,0:49:02.10,Chinese,,0,0,0,,但是当你把它全部添加起来时，它有可能在一个商店中进行两次加载
Dialogue: 0,0:49:02.54,0:49:07.74,English,,0,0,0,,For integer operations two floating-point multiplies one addition and one division
Dialogue: 0,0:49:02.54,0:49:07.74,Chinese,,0,0,0,,对于整数运算，两个浮点乘以一个加法和一个除法
Dialogue: 0,0:49:08.26,0:49:13.72,English,,0,0,0,,They can't all happen at the same time because there's some are share functional units
Dialogue: 0,0:49:08.26,0:49:13.72,Chinese,,0,0,0,,它们不可能同时发生，因为有些是共享功能单元
Dialogue: 0,0:49:13.86,0:49:17.88,English,,0,0,0,,But the point is there's really a lot of equipment there that can do stuff
Dialogue: 0,0:49:13.86,0:49:17.88,Chinese,,0,0,0,,但关键是那里有很多可以做东西的设备
Dialogue: 0,0:49:20.30,0:49:23.82,English,,0,0,0,,And also you can measure how....
Dialogue: 0,0:49:20.30,0:49:23.82,Chinese,,0,0,0,,而你也可以测量如何....
Dialogue: 0,0:49:23.88,0:49:30.34,English,,0,0,0,,And instruction now has two characteristics and operation is how long does it take from beginning to end
Dialogue: 0,0:49:23.88,0:49:30.34,Chinese,,0,0,0,,现在指令有两个特点，操作是从头到尾需要多长时间
Dialogue: 0,0:49:30.78,0:49:36.84,English,,0,0,0,,But also how closely spaced can two in stations be because of this pipelining
Dialogue: 0,0:49:30.78,0:49:36.84,Chinese,,0,0,0,,但是，由于这种流水线操作，两个站点之间的距离有多紧密
Dialogue: 0,0:49:37.34,0:49:42.48,English,,0,0,0,,So you see that most to them take some number of clock cycles to perform
Dialogue: 0,0:49:37.34,0:49:42.48,Chinese,,0,0,0,,所以你看到他们最需要花费一些时钟周期才能完成
Dialogue: 0,0:49:42.94,0:49:46.46,English,,0,0,0,,But they're also pipelines so that you can do a series of them
Dialogue: 0,0:49:42.94,0:49:46.46,Chinese,,0,0,0,,但它们也是管道，所以你可以做一系列的
Dialogue: 0,0:49:47.12,0:49:48.44,English,,0,0,0,,Just one cycle apart
Dialogue: 0,0:49:47.12,0:49:48.44,Chinese,,0,0,0,,只需一个周期
Dialogue: 0,0:49:48.92,0:49:55.74,English,,0,0,0,,The only different ones that are does you'll notice the division is both very slow and it's not pipelined
Dialogue: 0,0:49:48.92,0:49:55.74,Chinese,,0,0,0,,唯一不同的是，你会注意到划分既非常慢，也没有流水线
Dialogue: 0,0:49:55.74,0:50:01.28,English,,0,0,0,,And division is a very expensive operation on most machines relatively speaking
Dialogue: 0,0:49:55.74,0:50:01.28,Chinese,,0,0,0,,相对而言，在大多数机器上，除法是一项非常昂贵的操作
Dialogue: 0,0:50:05.18,0:50:17.90,English,,0,0,0,,So what I claim then is these characteristics then Provide a limit on how fast our program can run our original program 
Dialogue: 0,0:50:05.18,0:50:17.90,Chinese,,0,0,0,,那么我所声称的就是这些特征然后限制我们的程序运行原始程序的速度
Dialogue: 0,0:50:18.72,0:50:24.02,English,,0,0,0,,in that...I have a series of multiplications for example of integers here
Dialogue: 0,0:50:18.72,0:50:24.02,Chinese,,0,0,0,,在那...我有一系列的乘法例如这里的整数
Dialogue: 0,0:50:25.20,0:50:27.18,English,,0,0,0,,And this shows the code for it
Dialogue: 0,0:50:25.20,0:50:27.18,Chinese,,0,0,0,,这显示了它的代码
Dialogue: 0,0:50:27.70,0:50:33.52,English,,0,0,0,,And the result of I need the result of one multiplication before I can begin the next
Dialogue: 0,0:50:27.70,0:50:33.52,Chinese,,0,0,0,,在我开始下一个之前，我需要一次乘法的结果
Dialogue: 0,0:50:33.74,0:50:37.28,English,,0,0,0,,So there's a three clock cycle bound here
Dialogue: 0,0:50:33.74,0:50:37.28,Chinese,,0,0,0,,所以这里绑定了三个时钟周期
Dialogue: 0,0:50:37.72,0:50:41.02,English,,0,0,0,,And you'll see that in fact my measurements all correspond to
Dialogue: 0,0:50:37.72,0:50:41.02,Chinese,,0,0,0,,而且你会看到，实际上我的测量结果都符合
Dialogue: 0,0:50:41.02,0:50:46.78,English,,0,0,0,,What I'm calling the latency bound of these machines which is just based on
Dialogue: 0,0:50:41.02,0:50:46.78,Chinese,,0,0,0,,我称之为基于这些机器的延迟限制
Dialogue: 0,0:50:46.94,0:50:51.08,English,,0,0,0,,How much time it takes from a beginning of an operation to the end
Dialogue: 0,0:50:46.94,0:50:51.08,Chinese,,0,0,0,,从操作开始到结束需要多长时间
Dialogue: 0,0:50:52.42,0:50:57.32,English,,0,0,0,,And the reason is we considered diagram the computation being done by this program
Dialogue: 0,0:50:52.42,0:50:57.32,Chinese,,0,0,0,,原因是我们考虑了该程序正在进行的计算
Dialogue: 0,0:50:57.88,0:51:00.86,English,,0,0,0,,That it's doing a series of multiplications
Dialogue: 0,0:50:57.88,0:51:00.86,Chinese,,0,0,0,,它正在进行一系列的乘法运算
Dialogue: 0,0:51:01.46,0:51:06.30,English,,0,0,0,,And I require the result of one multiplication before I can start the next
Dialogue: 0,0:51:01.46,0:51:06.30,Chinese,,0,0,0,,在我开始下一个之前，我需要一次乘法的结果
Dialogue: 0,0:51:07.00,0:51:09.04,English,,0,0,0,,In general if you look at this loop code
Dialogue: 0,0:51:07.00,0:51:09.04,Chinese,,0,0,0,,一般来说，如果你看一下这个循环代码
Dialogue: 0,0:51:09.86,0:51:12.18,English,,0,0,0,,It has to compute ECX
Dialogue: 0,0:51:09.86,0:51:12.18,Chinese,,0,0,0,,它必须计算ECX
Dialogue: 0,0:51:12.38,0:51:16.88,English,,0,0,0,,The updated value of it before it can now start the next one
Dialogue: 0,0:51:12.38,0:51:16.88,Chinese,,0,0,0,,它之前的更新值现在可以开始下一个
Dialogue: 0,0:51:18.12,0:51:23.48,English,,0,0,0,,And so that's why even though this I have a pipelined multiplier
Dialogue: 0,0:51:18.12,0:51:23.48,Chinese,,0,0,0,,所以这就是为什么即使我有一个流水线乘法器
Dialogue: 0,0:51:24.34,0:51:30.26,English,,0,0,0,,My program itself limits me to of the sequential execution of all the multiplies
Dialogue: 0,0:51:24.34,0:51:30.26,Chinese,,0,0,0,,我的程序本身限制了我对所有乘法的顺序执行
Dialogue: 0,0:51:35.58,0:51:40.54,English,,0,0,0,,So let's see if we can't get beyond that bound that latency bound
Dialogue: 0,0:51:35.58,0:51:40.54,Chinese,,0,0,0,,所以让我们看看我们是否能超越那个延迟界限
Dialogue: 0,0:51:41.12,0:51:46.42,English,,0,0,0,,Well there's a fairly common technique that you might have heard of before that's called loop unrolling
Dialogue: 0,0:51:41.12,0:51:46.42,Chinese,,0,0,0,,那么在你称之为循环展开之前，你可能已经听说过一种相当常见的技术
Dialogue: 0,0:51:47.02,0:51:50.14,English,,0,0,0,,And the idea of loop unrolling is just that you
Dialogue: 0,0:51:47.02,0:51:50.14,Chinese,,0,0,0,,循环展开的想法就是你
Dialogue: 0,0:51:53.90,0:51:59.46,English,,0,0,0,,Rather than executing one value within a loop you execute a multiple ones
Dialogue: 0,0:51:53.90,0:51:59.46,Chinese,,0,0,0,,而不是在循环中执行一个值，而是执行多个值
Dialogue: 0,0:51:59.92,0:52:02.48,English,,0,0,0,,And so this code shows unrolling by two
Dialogue: 0,0:51:59.92,0:52:02.48,Chinese,,0,0,0,,因此，此代码显示两个展开
Dialogue: 0,0:52:02.86,0:52:09.54,English,,0,0,0,,And what it says is I'm going to step through this array two elements at a time
Dialogue: 0,0:52:02.86,0:52:09.54,Chinese,,0,0,0,,它说的是我将逐步通过这个数组两个元素
Dialogue: 0,0:52:09.86,0:52:15.96,English,,0,0,0,,And within each of the inner group I'm going to combine the values  from d[i] and d[i+1]
Dialogue: 0,0:52:09.86,0:52:15.96,Chinese,,0,0,0,,在每个内部组中，我将组合来自d [i]和d [i + 1]的值
Dialogue: 0,0:52:16.42,0:52:19.08,English,,0,0,0,,And I have to put in some extra code to finish off
Dialogue: 0,0:52:16.42,0:52:19.08,Chinese,,0,0,0,,我必须加入一些额外的代码才能完成
Dialogue: 0,0:52:19.50,0:52:22.40,English,,0,0,0,,What happens if the original rate was a von wenk
Dialogue: 0,0:52:19.50,0:52:22.40,Chinese,,0,0,0,,如果原始费率是von wenk会发生什么
Dialogue: 0,0:52:22.68,0:52:24.19,English,,0,0,0,,But you get the idea and
Dialogue: 0,0:52:22.68,0:52:24.19,Chinese,,0,0,0,,但是你明白了
Dialogue: 0,0:52:24.64,0:52:27.50,English,,0,0,0,,This idea I showed this code of of two
Dialogue: 0,0:52:24.64,0:52:27.50,Chinese,,0,0,0,,这个想法我展示了这两个代码
Dialogue: 0,0:52:27.50,0:52:31.68,English,,0,0,0,,But you could imagine this applying for different values of loop unrolling
Dialogue: 0,0:52:27.50,0:52:31.68,Chinese,,0,0,0,,但你可以想象这适用于不同的循环展开值
Dialogue: 0,0:52:32.84,0:52:34.14,English,,0,0,0,,So will this help us any well
Dialogue: 0,0:52:32.84,0:52:34.14,Chinese,,0,0,0,,这对我们有什么帮助
Dialogue: 0,0:52:35.68,0:52:41.12,English,,0,0,0,,When I run it I get that the integer addition got a little faster
Dialogue: 0,0:52:35.68,0:52:41.12,Chinese,,0,0,0,,当我运行它时，我得到整数加法得快一点
Dialogue: 0,0:52:41.46,0:52:43.26,English,,0,0,0,,But the other ones didn't improve at all
Dialogue: 0,0:52:41.46,0:52:43.26,Chinese,,0,0,0,,但其他的根本没有改善
Dialogue: 0,0:52:44.58,0:52:46.70,English,,0,0,0,,So this one is going faster
Dialogue: 0,0:52:44.58,0:52:46.70,Chinese,,0,0,0,,所以这个更快
Dialogue: 0,0:52:46.70,0:52:55.66,English,,0,0,0,,Because basically the old code is the overhead of the loop indexing and incrementing was enough to be slowing me down
Dialogue: 0,0:52:46.70,0:52:55.66,Chinese,,0,0,0,,因为基本上旧的代码是循环索引的开销，并且递增足以让我放慢速度
Dialogue: 0,0:52:55.96,0:52:58.42,English,,0,0,0,,Because it's already close to a clock cycle
Dialogue: 0,0:52:55.96,0:52:58.42,Chinese,,0,0,0,,因为它已经接近一个时钟周期
Dialogue: 0,0:52:58.44,0:53:05.80,English,,0,0,0,,So I just managed to knock that down to be at the latency bound of this particular instruction
Dialogue: 0,0:52:58.44,0:53:05.80,Chinese,,0,0,0,,所以我设法将其击倒在这个特定指令的延迟范围内
Dialogue: 0,0:53:06.58,0:53:11.44,English,,0,0,0,,But it didn't...have the other ones because I still have this sequential dependency
Dialogue: 0,0:53:06.58,0:53:11.44,Chinese,,0,0,0,,但它没有...拥有其他的因为我仍然有这种顺序依赖
Dialogue: 0,0:53:11.88,0:53:15.70,English,,0,0,0,,In order to get my new value of x I have to first
Dialogue: 0,0:53:11.88,0:53:15.70,Chinese,,0,0,0,,为了获得x的新值，我必须先行
Dialogue: 0,0:53:16.44,0:53:21.42,English,,0,0,0,,Do one computation and then do the other before I can begin another one
Dialogue: 0,0:53:16.44,0:53:21.42,Chinese,,0,0,0,,做一个计算，然后在我开始另一个之前再做另一个
Dialogue: 0,0:53:23.98,0:53:30.94,English,,0,0,0,,But this shows me the way I could make a very very small change and change performance fairly dramatically
Dialogue: 0,0:53:23.98,0:53:30.94,Chinese,,0,0,0,,但这向我展示了我可以做出非常小的改变并且相当显着地改变性能的方式
Dialogue: 0,0:53:31.52,0:53:36.38,English,,0,0,0,,What if I take these parentheses and shift them to the right
Dialogue: 0,0:53:31.52,0:53:36.38,Chinese,,0,0,0,,如果我把这些括号移到右边怎么办？
Dialogue: 0,0:53:41.40,0:53:43.16,English,,0,0,0,,What would that make any difference
Dialogue: 0,0:53:41.40,0:53:43.16,Chinese,,0,0,0,,什么会有所不同
Dialogue: 0,0:53:44.94,0:53:49.22,English,,0,0,0,,And lo and behold yes you find that
Dialogue: 0,0:53:44.94,0:53:49.22,Chinese,,0,0,0,,瞧，是的，你找到了
Dialogue: 0,0:53:49.80,0:54:01.46,English,,0,0,0,,And I'll call that transformation unrolling by two computing a one element at a time
Dialogue: 0,0:53:49.80,0:54:01.46,Chinese,,0,0,0,,我将这个转换称为两个一次计算一个元素的展开
Dialogue: 0,0:54:01.46,0:54:02.70,English,,0,0,0,,I'll talk about that in a minute
Dialogue: 0,0:54:01.46,0:54:02.70,Chinese,,0,0,0,,我会在一分钟内谈到这一点
Dialogue: 0,0:54:03.38,0:54:08.16,English,,0,0,0,,But I'll use this lowercase a to say I've done an associate transformation
Dialogue: 0,0:54:03.38,0:54:08.16,Chinese,,0,0,0,,但是我会用这个小写字母来表示我做了一个副转换
Dialogue: 0,0:54:08.76,0:54:13.18,English,,0,0,0,,And you see all of a sudden my time's dropped in half  for these three cases
Dialogue: 0,0:54:08.76,0:54:13.18,Chinese,,0,0,0,,而且你突然看到这三个案件我的时间减少了一半
Dialogue: 0,0:54:16.97,0:54:18.02,English,,0,0,0,,So something's going on
Dialogue: 0,0:54:16.97,0:54:18.02,Chinese,,0,0,0,,所以事情正在发生
Dialogue: 0,0:54:20.14,0:54:24.60,English,,0,0,0,,Um and so let's see why that isn't and now I'll introduce
Dialogue: 0,0:54:20.14,0:54:24.60,Chinese,,0,0,0,,嗯，让我们看看为什么不是，现在我将介绍
Dialogue: 0,0:54:27.64,0:54:30.44,English,,0,0,0,,It and so if I take my picture from before
Dialogue: 0,0:54:27.64,0:54:30.44,Chinese,,0,0,0,,如果我从以前拍摄我的照片，那么它
Dialogue: 0,0:54:31.50,0:54:34.88,English,,0,0,0,,And think about what those computations employ you'll see that
Dialogue: 0,0:54:31.50,0:54:34.88,Chinese,,0,0,0,,并考虑一下这些计算所使用的内容
Dialogue: 0,0:54:35.46,0:54:38.88,English,,0,0,0,,Right now I've changed the structure of the computation
Dialogue: 0,0:54:35.46,0:54:38.88,Chinese,,0,0,0,,现在我改变了计算的结构
Dialogue: 0,0:54:38.88,0:54:46.04,English,,0,0,0,,So that I'm pairwise combining each element of pair of elements of the array
Dialogue: 0,0:54:38.88,0:54:46.04,Chinese,,0,0,0,,这样我就成对地组合了数组中元素对的每个元素
Dialogue: 0,0:54:46.50,0:54:51.02,English,,0,0,0,,And then accumulating those into the overall computation
Dialogue: 0,0:54:46.50,0:54:51.02,Chinese,,0,0,0,,然后将它们累积到整体计算中
Dialogue: 0,0:54:51.02,0:54:55.40,English,,0,0,0,,So I've actually that shifting of the parentheses fundamentally changed
Dialogue: 0,0:54:51.02,0:54:55.40,Chinese,,0,0,0,,所以我实际上括号的转移从根本上改变了
Dialogue: 0,0:54:55.82,0:54:57.40,English,,0,0,0,,How I'm doing my computation
Dialogue: 0,0:54:55.82,0:54:57.40,Chinese,,0,0,0,,我是如何进行计算的
Dialogue: 0,0:54:59.12,0:55:02.90,English,,0,0,0,,And you can see now that this critical path which is what determines
Dialogue: 0,0:54:59.12,0:55:02.90,Chinese,,0,0,0,,你现在可以看到这个决定性的关键路径
Dialogue: 0,0:55:03.30,0:55:05.96,English,,0,0,0,,In this case the the performance limitation
Dialogue: 0,0:55:03.30,0:55:05.96,Chinese,,0,0,0,,在这种情况下的性能限制
Dialogue: 0,0:55:06.20,0:55:08.66,English,,0,0,0,,Just got shorter by a factor of two
Dialogue: 0,0:55:06.20,0:55:08.66,Chinese,,0,0,0,,刚缩短了两倍
Dialogue: 0,0:55:08.94,0:55:11.62,English,,0,0,0,,And that's why I'm now running twice as fast
Dialogue: 0,0:55:08.94,0:55:11.62,Chinese,,0,0,0,,这就是我现在跑得快两倍的原因
Dialogue: 0,0:55:11.82,0:55:16.50,English,,0,0,0,,For the operations not for energy or addition
Dialogue: 0,0:55:11.82,0:55:16.50,Chinese,,0,0,0,,对于不用于能量或添加的操作
Dialogue: 0,0:55:17.02,0:55:23.64,English,,0,0,0,,But for the other three operations I've cut by a factor or two ,just by that shift 
Dialogue: 0,0:55:17.02,0:55:23.64,Chinese,,0,0,0,,但是对于其他三个操作，我已经削减了一两倍，仅仅是那个转变
Dialogue: 0,0:55:24.32,0:55:26.48,English,,0,0,0,,Now there's some good news and bad news here
Dialogue: 0,0:55:24.32,0:55:26.48,Chinese,,0,0,0,,现在这里有一些好消息和坏消息
Dialogue: 0,0:55:27.20,0:55:29.88,English,,0,0,0,,The good news is if this is integer arithmetic
Dialogue: 0,0:55:27.20,0:55:29.88,Chinese,,0,0,0,,好消息是，如果这是整数运算
Dialogue: 0,0:55:29.88,0:55:39.56,English,,0,0,0,,We know already you know that two's complement arithmetic is associative and commutative
Dialogue: 0,0:55:29.88,0:55:39.56,Chinese,,0,0,0,,我们知道你已经知道二进制补码算法是关联的和可交换的
Dialogue: 0,0:55:39.96,0:55:44.14,English,,0,0,0,,So it really doesn't matter for both multiplication and addition
Dialogue: 0,0:55:39.96,0:55:44.14,Chinese,,0,0,0,,因此，乘法和加法都无关紧要
Dialogue: 0,0:55:44.32,0:55:47.24,English,,0,0,0,,So it really doesn't matter what order I combine these elements in
Dialogue: 0,0:55:44.32,0:55:47.24,Chinese,,0,0,0,,所以我将这些元素组合在一起的顺序并不重要
Dialogue: 0,0:55:47.24,0:55:49.84,English,,0,0,0,,I'm going to get the exact same answer no matter what
Dialogue: 0,0:55:47.24,0:55:49.84,Chinese,,0,0,0,,无论怎样，我都会得到完全相同的答案
Dialogue: 0,0:55:50.70,0:55:53.30,English,,0,0,0,,But you also solve for floating-point that's not the case
Dialogue: 0,0:55:50.70,0:55:53.30,Chinese,,0,0,0,,但是你也解决了浮点问题
Dialogue: 0,0:55:53.92,0:55:58.18,English,,0,0,0,,So with floating-point that shifting these parentheses
Dialogue: 0,0:55:53.92,0:55:58.18,Chinese,,0,0,0,,所以用浮点来移动这些括号
Dialogue: 0,0:55:58.74,0:56:02.58,English,,0,0,0,,Because of rounding possibilities and even potentially overflow
Dialogue: 0,0:55:58.74,0:56:02.58,Chinese,,0,0,0,,由于四舍五入的可能性甚至可能溢出
Dialogue: 0,0:56:03.12,0:56:07.02,English,,0,0,0,,You might get different values results from these computations
Dialogue: 0,0:56:03.12,0:56:07.02,Chinese,,0,0,0,,你可能会从这些计算中获得不同的值结果
Dialogue: 0,0:56:07.58,0:56:13.46,English,,0,0,0,,But then again if you think about you know is that really going to happen chances are no
Dialogue: 0,0:56:07.58,0:56:13.46,Chinese,,0,0,0,,但话又如果你想到你知道真的会发生，那么机会就没有了
Dialogue: 0,0:56:14.02,0:56:17.16,English,,0,0,0,,That it's not really going to affect the outcome of your program
Dialogue: 0,0:56:14.02,0:56:17.16,Chinese,,0,0,0,,这并不会影响你的计划的结果
Dialogue: 0,0:56:17.46,0:56:21.64,English,,0,0,0,,But it's enough of a change that most C compilers or most compilers period
Dialogue: 0,0:56:17.46,0:56:21.64,Chinese,,0,0,0,,但这足以让大多数C编译器或大多数编译器时期发生变化
Dialogue: 0,0:56:21.92,0:56:24.96,English,,0,0,0,,Will not make any change that changes associativity
Dialogue: 0,0:56:21.92,0:56:24.96,Chinese,,0,0,0,,不会做任何改变关联性的改变
Dialogue: 0,0:56:24.96,0:56:28.22,English,,0,0,0,,Because they're very conservative when it comes to floating-point
Dialogue: 0,0:56:24.96,0:56:28.22,Chinese,,0,0,0,,因为它们在浮点时非常保守
Dialogue: 0,0:56:29.98,0:56:34.62,English,,0,0,0,,So that's something you as an application programmer has to have to know well enough is
Dialogue: 0,0:56:29.98,0:56:34.62,Chinese,,0,0,0,,这就是你作为应用程序员必须要充分了解的东西
Dialogue: 0,0:56:34.62,0:56:38.20,English,,0,0,0,,This a valid can I do this transformation without messing things up
Dialogue: 0,0:56:34.62,0:56:38.20,Chinese,,0,0,0,,这是一个有效的我可以做这个转换而不会搞砸了
Dialogue: 0,0:56:41.16,0:56:45.90,English,,0,0,0,,And now without I'll say is now there's a new set of bounds
Dialogue: 0,0:56:41.16,0:56:45.90,Chinese,,0,0,0,,现在没有我会说现在有一套新的界限
Dialogue: 0,0:56:45.90,0:56:52.46,English,,0,0,0,,So a bound is what would appear to be sort of the best you can do based on some constraint in the program
Dialogue: 0,0:56:45.90,0:56:52.46,Chinese,,0,0,0,,因此，基于程序中的某些约束，绑定是看起来最好的
Dialogue: 0,0:56:52.88,0:56:59.58,English,,0,0,0,,And before it was saying well the latency the total time through a given for a given operation was abound
Dialogue: 0,0:56:52.88,0:56:59.58,Chinese,,0,0,0,,在它说出延迟之前，给定操作的给定总时间比比皆是
Dialogue: 0,0:57:00.50,0:57:05.56,English,,0,0,0,,And now I say well there's an even more fundamental bound which I'll call the throughput bound
Dialogue: 0,0:57:00.50,0:57:05.56,Chinese,,0,0,0,,现在我说得好，还有一个更基本的界限，我称之为吞吐量限制
Dialogue: 0,0:57:05.56,0:57:09.66,English,,0,0,0,,Which is just based on I only have so much hardware out there
Dialogue: 0,0:57:05.56,0:57:09.66,Chinese,,0,0,0,,这只是基于我只有那么多的硬件
Dialogue: 0,0:57:09.92,0:57:12.54,English,,0,0,0,,And I can only a pump it so fast
Dialogue: 0,0:57:09.92,0:57:12.54,Chinese,,0,0,0,,我只能这么快就把它抽出来
Dialogue: 0,0:57:13.32,0:57:19.26,English,,0,0,0,,So for example these two that the throughput bound is one
Dialogue: 0,0:57:13.32,0:57:19.26,Chinese,,0,0,0,,例如，这两个吞吐量绑定是一个
Dialogue: 0,0:57:19.82,0:57:28.78,English,,0,0,0,,Because I only have that actually becomes limited by the requirement
Dialogue: 0,0:57:19.82,0:57:28.78,Chinese,,0,0,0,,因为我只有那个实际上受限于要求
Dialogue: 0,0:57:28.78,0:57:32.34,English,,0,0,0,,That I'm having to read from memory
Dialogue: 0,0:57:28.78,0:57:32.34,Chinese,,0,0,0,,我必须从记忆中读出来
Dialogue: 0,0:57:32.74,0:57:35.10,English,,0,0,0,,And I have two different load units
Dialogue: 0,0:57:32.74,0:57:35.10,Chinese,,0,0,0,,我有两个不同的负载单位
Dialogue: 0,0:57:39.02,0:57:45.28,English,,0,0,0,,No! I'm sorry I only have one multiplier for integers in one for  addition
Dialogue: 0,0:57:39.02,0:57:45.28,Chinese,,0,0,0,,没有！对不起，我只有一个整数乘数，一个用于加法
Dialogue: 0,0:57:46.00,0:57:49.84,English,,0,0,0,,The throughput bound for these two actually is just a half
Dialogue: 0,0:57:46.00,0:57:49.84,Chinese,,0,0,0,,这两者的吞吐量实际上只有一半
Dialogue: 0,0:57:50.38,0:57:55.68,English,,0,0,0,,Because it turns out there's some odd part of the hardware design that has two 14-point multipliers
Dialogue: 0,0:57:50.38,0:57:55.68,Chinese,,0,0,0,,因为事实证明硬件设计中有一些奇怪的部分有两个14点乘法器
Dialogue: 0,0:57:56.20,0:57:57.96,English,,0,0,0,,But only one floating point adder
Dialogue: 0,0:57:56.20,0:57:57.96,Chinese,,0,0,0,,但只有一个浮点加法器
Dialogue: 0,0:57:58.18,0:58:03.08,English,,0,0,0,,And we'll see that we can actually make this multiplication code run faster than addition code
Dialogue: 0,0:57:58.18,0:58:03.08,Chinese,,0,0,0,,我们将看到我们实际上可以使这个乘法代码比加法代码运行得更快
Dialogue: 0,0:58:03.64,0:58:08.28,English,,0,0,0,,And over here again my limit will be that I only have to load units ,now I have to be...
Dialogue: 0,0:58:03.64,0:58:08.28,Chinese,,0,0,0,,而在这里我的限制将是我只需要加载单位，现在我必须...
Dialogue: 0,0:58:09.30,0:58:14.74,English,,0,0,0,,And I have to read for every element I'm computing,I have to be reading one element from memory
Dialogue: 0,0:58:09.30,0:58:14.74,Chinese,,0,0,0,,我必须阅读我正在计算的每个元素，我必须从内存中读取一个元素
Dialogue: 0,0:58:14.74,0:58:16.14,English,,0,0,0,,So I can't get below the
Dialogue: 0,0:58:14.74,0:58:16.14,Chinese,,0,0,0,,所以我不能低于
Dialogue: 0,0:58:20.18,0:58:23.26,English,,0,0,0,,That okay so but we saw this transformation now is let us
Dialogue: 0,0:58:20.18,0:58:23.26,Chinese,,0,0,0,,那没关系，但我们现在看到这种转变让我们
Dialogue: 0,0:58:23.70,0:58:28.60,English,,0,0,0,,Break out of this latency limitation and get something closer to throughput
Dialogue: 0,0:58:23.70,0:58:28.60,Chinese,,0,0,0,,突破这种延迟限制并获得更接近吞吐量的东西
Dialogue: 0,0:58:29.38,0:58:35.76,English,,0,0,0,,And here's another technique that can be used to again sort of get more parallelism going
Dialogue: 0,0:58:29.38,0:58:35.76,Chinese,,0,0,0,,这是另一种可以用来再次获得更多并行性的技术
Dialogue: 0,0:58:36.04,0:58:38.30,English,,0,0,0,,And I call this multiple accumulators
Dialogue: 0,0:58:36.04,0:58:38.30,Chinese,,0,0,0,,我称之为多个累加器
Dialogue: 0,0:58:38.82,0:58:41.70,English,,0,0,0,,The idea is let's a imagine that
Dialogue: 0,0:58:38.82,0:58:41.70,Chinese,,0,0,0,,这个想法让我们想象一下
Dialogue: 0,0:58:41.70,0:58:45.74,English,,0,0,0,,We have the odd-numbered elements and the even-numbered elements in the array
Dialogue: 0,0:58:41.70,0:58:45.74,Chinese,,0,0,0,,我们在数组中有奇数元素和偶数元素
Dialogue: 0,0:58:46.36,0:58:52.88,English,,0,0,0,,And we can we can compute separate sums or products of those two sets of elements
Dialogue: 0,0:58:46.36,0:58:52.88,Chinese,,0,0,0,,我们可以计算这两组元素的单独总和或产品
Dialogue: 0,0:58:53.34,0:58:56.28,English,,0,0,0,,And then the very end combine them together
Dialogue: 0,0:58:53.34,0:58:56.28,Chinese,,0,0,0,,然后最后将它们组合在一起
Dialogue: 0,0:58:56.60,0:59:00.53,English,,0,0,0,,So this is another form of and associativity transformation
Dialogue: 0,0:58:56.60,0:59:00.53,Chinese,,0,0,0,,所以这是另一种形式的关联变换
Dialogue: 0,0:59:00.53,0:59:04.54,English,,0,0,0,,You were changing the order in which we combine things together
Dialogue: 0,0:59:00.53,0:59:04.54,Chinese,,0,0,0,,你正在改变我们将事物组合在一起的顺序
Dialogue: 0,0:59:05.08,0:59:08.14,English,,0,0,0,,It's just that we're doing it in the suit of odd-even manner
Dialogue: 0,0:59:05.08,0:59:08.14,Chinese,,0,0,0,,只是我们以奇偶方式做这件事
Dialogue: 0,0:59:08.14,0:59:15.78,English,,0,0,0,,Or in general every I do it by some by some parameter i
Dialogue: 0,0:59:08.14,0:59:15.78,Chinese,,0,0,0,,或者一般来说，我通过一些参数来做一些参数i
Dialogue: 0,0:59:17.92,0:59:21.58,English,,0,0,0,,It has the same issues that if it's integer arithmetic it's fine
Dialogue: 0,0:59:17.92,0:59:21.58,Chinese,,0,0,0,,它有同样的问题，如果它是整数运算，那很好
Dialogue: 0,0:59:21.58,0:59:26.54,English,,0,0,0,,If it's floating-point there's a risk of of changing the behavior of the program
Dialogue: 0,0:59:21.58,0:59:26.54,Chinese,,0,0,0,,如果它是浮点数，则存在改变程序行为的风险
Dialogue: 0,0:59:27.78,0:59:32.40,English,,0,0,0,,But you'll see that again we get a cutting in half here and
Dialogue: 0,0:59:27.78,0:59:32.40,Chinese,,0,0,0,,但是你会再次看到我们在这里减少了一半
Dialogue: 0,0:59:32.48,0:59:35.80,English,,0,0,0,,A little bit below one for integer addition
Dialogue: 0,0:59:32.48,0:59:35.80,Chinese,,0,0,0,,稍微低于一个整数加法
Dialogue: 0,0:59:39.04,0:59:41.98,English,,0,0,0,,And again we can think of it by looking at these pictures
Dialogue: 0,0:59:39.04,0:59:41.98,Chinese,,0,0,0,,我们再次通过查看这些图片来思考它
Dialogue: 0,0:59:41.98,0:59:44.16,English,,0,0,0,,Of what are the what gets computed
Dialogue: 0,0:59:41.98,0:59:44.16,Chinese,,0,0,0,,计算的是什么？
Dialogue: 0,0:59:44.16,0:59:47.92,English,,0,0,0,,And you see what we're doing is we're computing here all the even numbers
Dialogue: 0,0:59:44.16,0:59:47.92,Chinese,,0,0,0,,而你看到我们正在做的是我们在这里计算所有偶数
Dialogue: 0,0:59:48.36,0:59:51.58,English,,0,0,0,,Even numbered elements being combined and here all the odd ones
Dialogue: 0,0:59:48.36,0:59:51.58,Chinese,,0,0,0,,偶数编号的元素组合在一起，这里所有奇数元素
Dialogue: 0,0:59:51.88,0:59:54.12,English,,0,0,0,,And the very end we're combining those together
Dialogue: 0,0:59:51.88,0:59:54.12,Chinese,,0,0,0,,最后，我们将这些结合在一起
Dialogue: 0,0:59:56.82,1:00:04.00,English,,0,0,0,,And so we can generalize this if we can unroll by a factor of K of L
Dialogue: 0,0:59:56.82,1:00:04.00,Chinese,,0,0,0,,因此，如果我们能够以L为K的因子展开，我们可以推广这一点
Dialogue: 0,1:00:04.24,1:00:07.32,English,,0,0,0,,And we can accumulate K results in parallel
Dialogue: 0,1:00:04.24,1:00:07.32,Chinese,,0,0,0,,我们可以并行累积K结果
Dialogue: 0,1:00:07.90,1:00:11.82,English,,0,0,0,,And we can use various values of l and K for it
Dialogue: 0,1:00:07.90,1:00:11.82,Chinese,,0,0,0,,我们可以使用l和K的各种值
Dialogue: 0,1:00:11.82,1:00:14.68,English,,0,0,0,,In general has to be a multiple of K
Dialogue: 0,1:00:11.82,1:00:14.68,Chinese,,0,0,0,,一般来说必须是K的倍数
Dialogue: 0,1:00:16.36,1:00:21.78,English,,0,0,0,,And so you run it out and you can get for floating-point
Dialogue: 0,1:00:16.36,1:00:21.78,Chinese,,0,0,0,,所以你运行它，你可以获得浮点数
Dialogue: 0,1:00:23.28,1:00:27.70,English,,0,0,0,,Why you can actually get it down almost to this throughput bounds of 0.5
Dialogue: 0,1:00:23.28,1:00:27.70,Chinese,,0,0,0,,为什么你几乎可以将它降低到0.5的吞吐量范围
Dialogue: 0,1:00:36.62,1:00:42.02,English,,0,0,0,,This is incorrect,this is integer addition I should say in tradition
Dialogue: 0,1:00:36.62,1:00:42.02,Chinese,,0,0,0,,这是不正确的，这是传统中应该说的整数加法
Dialogue: 0,1:00:42.70,1:00:45.92,English,,0,0,0,,You can again get it down to around 0.5
Dialogue: 0,1:00:42.70,1:00:45.92,Chinese,,0,0,0,,你可以再次降低到0.5左右
Dialogue: 0,1:00:46.64,1:00:53.48,English,,0,0,0,,And in general by sort of picking the best parameters
Dialogue: 0,1:00:46.64,1:00:53.48,Chinese,,0,0,0,,一般来说，通过选择最佳参数
Dialogue: 0,1:00:53.48,1:00:57.88,English,,0,0,0,,I can get very close to the throughput bound of this processor
Dialogue: 0,1:00:53.48,1:00:57.88,Chinese,,0,0,0,,我可以非常接近这个处理器的吞吐量限制
Dialogue: 0,1:00:58.36,1:01:04.14,English,,0,0,0,,So I've been able to take something remember it originally was  20 clock cycles than 10
Dialogue: 0,1:00:58.36,1:01:04.14,Chinese,,0,0,0,,所以我已经能够记住它最初是20个时钟周期而不是10个
Dialogue: 0,1:01:04.38,1:01:08.44,English,,0,0,0,,And now I'm getting it down to one or fewer clock cycles per element
Dialogue: 0,1:01:04.38,1:01:08.44,Chinese,,0,0,0,,现在我将每个元素的时钟周期缩短到一个或更少
Dialogue: 0,1:01:10.58,1:01:17.56,English,,0,0,0,,So now just as the final step is okay is that as good as it go actually know
Dialogue: 0,1:01:10.58,1:01:17.56,Chinese,,0,0,0,,所以现在正好最后一步是好的，就像它实际上知道的一样好
Dialogue: 0,1:01:18.96,1:01:25.34,English,,0,0,0,,You remember when I talked about floating-point I mentioned that there's the special set of registers
Dialogue: 0,1:01:18.96,1:01:25.34,Chinese,,0,0,0,,你记得当我谈到浮点时我提到过有一组特殊的寄存器
Dialogue: 0,1:01:25.70,1:01:31.96,English,,0,0,0,,That are on x86 that we're called %xmm registers on the shark machines
Dialogue: 0,1:01:25.70,1:01:31.96,Chinese,,0,0,0,,那是在x86上我们在鲨鱼机器上被称为％xmm寄存器
Dialogue: 0,1:01:32.26,1:01:36.68,English,,0,0,0,,And now this has well this newer generation have something called %ymm registers
Dialogue: 0,1:01:32.26,1:01:36.68,Chinese,,0,0,0,,而现在这个新一代有一个叫做％ymm寄存器的东西
Dialogue: 0,1:01:37.08,1:01:40.04,English,,0,0,0,,Which have the feature being twice as big as %xmm registers
Dialogue: 0,1:01:37.08,1:01:40.04,Chinese,,0,0,0,,其功能是％xmm寄存器的两倍
Dialogue: 0,1:01:40.90,1:01:51.10,English,,0,0,0,,So in particular these registers are 32 bytes long
Dialogue: 0,1:01:40.90,1:01:51.10,Chinese,,0,0,0,,所以特别是这些寄存器长32个字节
Dialogue: 0,1:01:51.76,1:01:57.38,English,,0,0,0,,And there's a new version coming out within a year or something they call AVX512
Dialogue: 0,1:01:51.76,1:01:57.38,Chinese,,0,0,0,,并且有一个新版本在一年内推出或他们称之为AVX512
Dialogue: 0,1:01:57.86,1:02:03.92,English,,0,0,0,,Where the register is 512 bits so that's 256 bytes long
Dialogue: 0,1:01:57.86,1:02:03.92,Chinese,,0,0,0,,寄存器为512位，因此长度为256字节
Dialogue: 0,1:02:04.42,1:02:10.60,English,,0,0,0,,No it's of to 512,excuse me...it's 64 bytes right
Dialogue: 0,1:02:04.42,1:02:10.60,Chinese,,0,0,0,,不，它是512，对不起......它是64字节
Dialogue: 0,1:02:11.04,1:02:13.36,English,,0,0,0,,64 bytes so it'll be twice as big as these
Dialogue: 0,1:02:11.04,1:02:13.36,Chinese,,0,0,0,,64字节所以它将是这些的两倍
Dialogue: 0,1:02:14.08,1:02:21.78,English,,0,0,0,,And as I mentioned before you can think of these as a way of operating on 32 individual characters
Dialogue: 0,1:02:14.08,1:02:21.78,Chinese,,0,0,0,,正如我之前提到的，你可以将它们视为一种操作32个单独角色的方式
Dialogue: 0,1:02:22.30,1:02:24.52,English,,0,0,0,,Or I can treat them as floating point
Dialogue: 0,1:02:22.30,1:02:24.52,Chinese,,0,0,0,,或者我可以将它们视为浮点
Dialogue: 0,1:02:25.20,1:02:28.86,English,,0,0,0,,And we saw before that you nowadays the
Dialogue: 0,1:02:25.20,1:02:28.86,Chinese,,0,0,0,,我们之前看到过你现在的情况
Dialogue: 0,1:02:29.26,1:02:35.52,English,,0,0,0,,The regular floating point makes use of the low order for bytes of these read register
Dialogue: 0,1:02:29.26,1:02:35.52,Chinese,,0,0,0,,常规浮点利用这些读寄存器的字节的低位
Dialogue: 0,1:02:36.64,1:02:40.16,English,,0,0,0,,But there's also instructions called vector addition
Dialogue: 0,1:02:36.64,1:02:40.16,Chinese,,0,0,0,,但是还有一些称为矢量加法的指令
Dialogue: 0,1:02:41.22,1:02:50.76,English,,0,0,0,,Where one instruction has the effect of doing eight floating-point additions at once and float data
Dialogue: 0,1:02:41.22,1:02:50.76,Chinese,,0,0,0,,其中一条指令具有一次执行八次浮点加法和浮点数的效果
Dialogue: 0,1:02:51.02,1:02:55.34,English,,0,0,0,,And on double precision this counterpart does four of them at once of these
Dialogue: 0,1:02:51.02,1:02:55.34,Chinese,,0,0,0,,在双倍精度上，这个对应物同时执行其中四个
Dialogue: 0,1:02:56.78,1:03:02.98,English,,0,0,0,,And the that hardware is there it's just sitting there waiting to use and it seldom gets fired up
Dialogue: 0,1:02:56.78,1:03:02.98,Chinese,,0,0,0,,而那个硬件就在那里它只是坐在那里等待使用它很少被激怒
Dialogue: 0,1:03:03.60,1:03:05.58,English,,0,0,0,,To really make use of it
Dialogue: 0,1:03:03.60,1:03:05.58,Chinese,,0,0,0,,要真正利用它
Dialogue: 0,1:03:06.00,1:03:09.68,English,,0,0,0,,But so that floating point multiplier that can do
Dialogue: 0,1:03:06.00,1:03:09.68,Chinese,,0,0,0,,但是这样可以做浮点乘数
Dialogue: 0,1:03:10.12,1:03:15.04,English,,0,0,0,,A floating point multiplication in three clock cycles and is fully pipeline
Dialogue: 0,1:03:10.12,1:03:15.04,Chinese,,0,0,0,,三个时钟周期内的浮点乘法，完全是流水线
Dialogue: 0,1:03:16.19,1:03:24.32,English,,0,0,0,,You can actually do eight fighting point multiplications in parallel and pipelined in three clock cycles
Dialogue: 0,1:03:16.19,1:03:24.32,Chinese,,0,0,0,,实际上，你可以在三个时钟周期内并行进行八次战斗点乘法并进行流水线操作
Dialogue: 0,1:03:27.38,1:03:33.04,English,,0,0,0,,And as I mentioned the shark machines has an earlier version where the numbers are half of these
Dialogue: 0,1:03:27.38,1:03:33.04,Chinese,,0,0,0,,正如我所提到的，鲨鱼机器有一个早期版本，其中数字是其中的一半
Dialogue: 0,1:03:33.04,1:03:37.49,English,,0,0,0,,So it can do 4 single precision or two double precision at once
Dialogue: 0,1:03:33.04,1:03:37.49,Chinese,,0,0,0,,因此它可以同时执行4个单精度或两个双精度
Dialogue: 0,1:03:38.76,1:03:44.16,English,,0,0,0,,And if I write code that uses that what I call vector code
Dialogue: 0,1:03:38.76,1:03:44.16,Chinese,,0,0,0,,如果我编写使用我称之为矢量代码的代码
Dialogue: 0,1:03:44.70,1:03:51.16,English,,0,0,0,,Then you can see I can drop by a factor of about four across the board here
Dialogue: 0,1:03:44.70,1:03:51.16,Chinese,,0,0,0,,然后你可以看到我可以在这里全面下降四倍
Dialogue: 0,1:03:51.86,1:03:54.82,English,,0,0,0,,And make it run much faster
Dialogue: 0,1:03:51.86,1:03:54.82,Chinese,,0,0,0,,并让它运行得更快
Dialogue: 0,1:03:54.82,1:03:58.92,English,,0,0,0,,So this 0.06 is really 0.0625 right
Dialogue: 0,1:03:54.82,1:03:58.92,Chinese,,0,0,0,,所以这个0.06真的是0.0625
Dialogue: 0,1:03:58.92,1:04:05.48,English,,0,0,0,,It's doing 16 operations per clock cycle on that
Dialogue: 0,1:03:58.92,1:04:05.48,Chinese,,0,0,0,,它每个时钟周期执行16次操作
Dialogue: 0,1:04:10.06,1:04:14.46,English,,0,0,0,,And can't quite hit the vector throughput bound
Dialogue: 0,1:04:10.06,1:04:14.46,Chinese,,0,0,0,,并且不能完全达到矢量吞吐量的限制
Dialogue: 0,1:04:14.46,1:04:17.68,English,,0,0,0,,But in general making this thing run much faster
Dialogue: 0,1:04:14.46,1:04:17.68,Chinese,,0,0,0,,但总的来说，这件事情要快得多
Dialogue: 0,1:04:18.10,1:04:20.54,English,,0,0,0,,And so the people really worry about
Dialogue: 0,1:04:18.10,1:04:20.54,Chinese,,0,0,0,,所以人们真的很担心
Dialogue: 0,1:04:20.54,1:04:27.16,English,,0,0,0,,And you can imagine these instructions were introduced for things like video processing image processing of sound
Dialogue: 0,1:04:20.54,1:04:27.16,Chinese,,0,0,0,,你可以想象这些指令是为视频处理声音的图像处理而引入的
Dialogue: 0,1:04:27.46,1:04:31.98,English,,0,0,0,,Sort of signal processing where a performance really matters
Dialogue: 0,1:04:27.46,1:04:31.98,Chinese,,0,0,0,,性能真正重要的信号处理类型
Dialogue: 0,1:04:32.00,1:04:38.02,English,,0,0,0,,How fast you can display an image how fast you can rotate something
Dialogue: 0,1:04:32.00,1:04:38.02,Chinese,,0,0,0,,显示图像的速度有多快可以旋转某些东西
Dialogue: 0,1:04:38.02,1:04:41.06,English,,0,0,0,,You know how fast you can perform graphics makes a big difference
Dialogue: 0,1:04:38.02,1:04:41.06,Chinese,,0,0,0,,你知道你可以多快地执行图形有很大的不同
Dialogue: 0,1:04:41.74,1:04:48.60,English,,0,0,0,,In video games are one of the big drivers but even for sort of other operations you might do an image
Dialogue: 0,1:04:41.74,1:04:48.60,Chinese,,0,0,0,,在视频游戏中是一个很大的驱动因素，但即使是其他类型的操作，你也可以拍摄一张照片
Dialogue: 0,1:04:48.90,1:04:51.40,English,,0,0,0,,And so these instructions were really designed to do it
Dialogue: 0,1:04:48.90,1:04:51.40,Chinese,,0,0,0,,所以这些指令真的是为了做到这一点
Dialogue: 0,1:04:51.40,1:04:54.10,English,,0,0,0,,And people write code for those kind of applications
Dialogue: 0,1:04:51.40,1:04:54.10,Chinese,,0,0,0,,人们为这些应用程序编写代码
Dialogue: 0,1:04:54.52,1:04:59.98,English,,0,0,0,,Get pretty good at writing code in a way that they can do this vector I what's called vectorizing
Dialogue: 0,1:04:54.52,1:04:59.98,Chinese,,0,0,0,,非常擅长编写代码，以便他们可以执行此向量我称之为向量化
Dialogue: 0,1:05:00.58,1:05:05.82,English,,0,0,0,,And unfortunately so the intel compiler will actually automatically do some of this for you
Dialogue: 0,1:05:00.58,1:05:05.82,Chinese,,0,0,0,,不幸的是，所以intel编译器实际上会自动为你做一些
Dialogue: 0,1:05:06.10,1:05:09.11,English,,0,0,0,,A GCC they attempted to implement it and
Dialogue: 0,1:05:06.10,1:05:09.11,Chinese,,0,0,0,,GCC他们试图实施它
Dialogue: 0,1:05:09.11,1:05:11.96,English,,0,0,0,,It didn't work very well so I think they discontinued it
Dialogue: 0,1:05:09.11,1:05:11.96,Chinese,,0,0,0,,它没有很好地工作，所以我认为他们停止了它
Dialogue: 0,1:05:12.58,1:05:15.64,English,,0,0,0,,It turns out there's a web aside
Dialogue: 0,1:05:12.58,1:05:15.64,Chinese,,0,0,0,,事实证明，这是一个网络
Dialogue: 0,1:05:16.90,1:05:21.44,English,,0,0,0,,So this is on the web from the books web page that describes
Dialogue: 0,1:05:16.90,1:05:21.44,Chinese,,0,0,0,,所以这是在网页上描述的书籍网页
Dialogue: 0,1:05:21.44,1:05:23.52,English,,0,0,0,,How to do this programming if you're interested
Dialogue: 0,1:05:21.44,1:05:23.52,Chinese,,0,0,0,,如果你有兴趣，怎么做这个编程
Dialogue: 0,1:05:23.90,1:05:28.82,English,,0,0,0,,There's extensions to GCC that are very funky really weird stuff
Dialogue: 0,1:05:23.90,1:05:28.82,Chinese,,0,0,0,,GCC的扩展非常时髦，非常奇怪
Dialogue: 0,1:05:29.36,1:05:32.20,English,,0,0,0,,But you can write code
Dialogue: 0,1:05:29.36,1:05:32.20,Chinese,,0,0,0,,但是你可以编写代码
Dialogue: 0,1:05:32.72,1:05:37.12,English,,0,0,0,,That then will get compiled down to make use of these kind of instructions
Dialogue: 0,1:05:32.72,1:05:37.12,Chinese,,0,0,0,,然后将编译下来以利用这些指令
Dialogue: 0,1:05:37.18,1:05:40.22,English,,0,0,0,,And that's how I did it and how I got these performance results
Dialogue: 0,1:05:37.18,1:05:40.22,Chinese,,0,0,0,,这就是我如何做到这一点以及我如何获得这些性能结果
Dialogue: 0,1:05:43.48,1:05:46.76,English,,0,0,0,,Okay so that shows you if you really want to it
Dialogue: 0,1:05:43.48,1:05:46.76,Chinese,,0,0,0,,好的，这样就可以告诉你是否真的想要它
Dialogue: 0,1:05:47.00,1:05:50.38,English,,0,0,0,,But that's very machine specific that will only work on
Dialogue: 0,1:05:47.00,1:05:50.38,Chinese,,0,0,0,,但这是特定于机器的，只会起作用
Dialogue: 0,1:05:52.02,1:05:58.46,English,,0,0,0,,Well you have to you can actually tune it so it's easy to compile it  to go between different machines
Dialogue: 0,1:05:52.02,1:05:58.46,Chinese,,0,0,0,,那么你必须你可以实际调整它，这样很容易编译它在不同的机器之间
Dialogue: 0,1:05:58.46,1:06:05.34,English,,0,0,0,,But it's still a fairly specific and very specific to GCC in fact
Dialogue: 0,1:05:58.46,1:06:05.34,Chinese,,0,0,0,,但它实际上仍然是一个相当具体和非常具体的GCC
Dialogue: 0,1:06:05.92,1:06:09.48,English,,0,0,0,,So that sort of shows you though if you really want to push it what you can do
Dialogue: 0,1:06:05.92,1:06:09.48,Chinese,,0,0,0,,所以，如果你真的想要推动它你可以做什么，那么就会显示出来
Dialogue: 0,1:06:10.48,1:06:13.16,English,,0,0,0,,Now let's uh get back to one of the thing
Dialogue: 0,1:06:10.48,1:06:13.16,Chinese,,0,0,0,,现在让我回到其中一件事
Dialogue: 0,1:06:13.56,1:06:20.04,English,,0,0,0,,I told you about how you can if you think of your program as a very long linear sequence of instructions
Dialogue: 0,1:06:13.56,1:06:20.04,Chinese,,0,0,0,,如果你认为你的程序是一个非常长的线性指令序列，我告诉过你如何做到这一点
Dialogue: 0,1:06:20.72,1:06:26.96,English,,0,0,0,,Then the thing is trying to grab as many of those and pull them apart as fast as it can
Dialogue: 0,1:06:20.72,1:06:26.96,Chinese,,0,0,0,,然后事情是试图抓住尽可能多的那些并尽可能快地拉开它们
Dialogue: 0,1:06:27.52,1:06:30.40,English,,0,0,0,,But of course you know your program is actually typically a loop
Dialogue: 0,1:06:27.52,1:06:30.40,Chinese,,0,0,0,,但是你当然知道你的程序实际上通常是一个循环
Dialogue: 0,1:06:30.78,1:06:32.69,English,,0,0,0,,And there aren't many instructions in that loop
Dialogue: 0,1:06:30.78,1:06:32.69,Chinese,,0,0,0,,并且该循环中的指令不多
Dialogue: 0,1:06:33.08,1:06:35.84,English,,0,0,0,,So how is it turning that into a linear sequence
Dialogue: 0,1:06:33.08,1:06:35.84,Chinese,,0,0,0,,那怎么把它变成一个线性序列呢
Dialogue: 0,1:06:36.72,1:06:41.52,English,,0,0,0,,Well that relies on an idea of how do you handle branches
Dialogue: 0,1:06:36.72,1:06:41.52,Chinese,,0,0,0,,那依赖于你如何处理分支的想法
Dialogue: 0,1:06:42.30,1:06:48.38,English,,0,0,0,,So typically the program you know fetching ahead grabbing instructions
Dialogue: 0,1:06:42.30,1:06:48.38,Chinese,,0,0,0,,所以通常你知道的程序会抓取指令
Dialogue: 0,1:06:48.38,1:06:53.92,English,,0,0,0,,And it will come to a branch instruction a conditional jump of some sort
Dialogue: 0,1:06:48.38,1:06:53.92,Chinese,,0,0,0,,并且它会在分支指令中出现某种条件跳转
Dialogue: 0,1:06:54.58,1:06:59.86,English,,0,0,0,,And there is a dilemma because in general this branch could either
Dialogue: 0,1:06:54.58,1:06:59.86,Chinese,,0,0,0,,还有一个两难的境地，因为一般来说这个分支也可以
Dialogue: 0,1:07:01.10,1:07:07.32,English,,0,0,0,,I'm sorry either be taken meaning it will go to the branch target
Dialogue: 0,1:07:01.10,1:07:07.32,Chinese,,0,0,0,,对不起，这意味着它会转到分支目标
Dialogue: 0,1:07:07.80,1:07:13.70,English,,0,0,0,,Or it could do what's called fall through meaning it it the test fails and so it just continues execution
Dialogue: 0,1:07:07.80,1:07:13.70,Chinese,,0,0,0,,或者它可以做所谓的堕落意味着测试失败，所以它只是继续执行
Dialogue: 0,1:07:14.14,1:07:19.32,English,,0,0,0,,And there's no way a priority to know what will happen these can often be data dependent
Dialogue: 0,1:07:14.14,1:07:19.32,Chinese,,0,0,0,,并且没有办法优先知道会发生什么，这些往往可能与数据有关
Dialogue: 0,1:07:22.66,1:07:27.14,English,,0,0,0,,Well and so the way this is handled on a modern processor is by doing
Dialogue: 0,1:07:22.66,1:07:27.14,Chinese,,0,0,0,,那么在现代处理器上处理它的方式就是这样做
Dialogue: 0,1:07:27.14,1:07:30.64,English,,0,0,0,,What's known as branch prediction which is essentially just guess
Dialogue: 0,1:07:27.14,1:07:30.64,Chinese,,0,0,0,,所谓的分支预测基本上只是猜测
Dialogue: 0,1:07:32.10,1:07:34.64,English,,0,0,0,,Which ways this branch going to go is going to be taken or
Dialogue: 0,1:07:32.10,1:07:34.64,Chinese,,0,0,0,,这个分支将采取哪种方式或将采取
Dialogue: 0,1:07:35.10,1:07:39.14,English,,0,0,0,,Not and you predict and then you start executing along the predicted direction
Dialogue: 0,1:07:35.10,1:07:39.14,Chinese,,0,0,0,,不是，你预测，然后你开始沿着预测的方向执行
Dialogue: 0,1:07:39.56,1:07:41.98,English,,0,0,0,,But do it in a way that if you make a mistake that
Dialogue: 0,1:07:39.56,1:07:41.98,Chinese,,0,0,0,,但是，如果你犯了错误，那就去做吧
Dialogue: 0,1:07:42.52,1:07:45.94,English,,0,0,0,,You haven't caused your reparable harm to the program
Dialogue: 0,1:07:42.52,1:07:45.94,Chinese,,0,0,0,,你没有对该计划造成可修复的损害
Dialogue: 0,1:07:46.44,1:07:48.40,English,,0,0,0,,And we'll see what that means
Dialogue: 0,1:07:46.44,1:07:48.40,Chinese,,0,0,0,,我们会看到这意味着什么
Dialogue: 0,1:07:48.86,1:07:52.12,English,,0,0,0,,So what really happens then is up here there's a lot of logic
Dialogue: 0,1:07:48.86,1:07:52.12,Chinese,,0,0,0,,那么真正发生的事情就是在这里有很多逻辑
Dialogue: 0,1:07:52.12,1:07:55.60,English,,0,0,0,,That's trying to suck out instructions
Dialogue: 0,1:07:52.12,1:07:55.60,Chinese,,0,0,0,,那是试图吮吸指令
Dialogue: 0,1:07:56.12,1:08:02.54,English,,0,0,0,,And then there's a branch unit that's being basically coming along later and saying
Dialogue: 0,1:07:56.12,1:08:02.54,Chinese,,0,0,0,,然后有一个分支单位，基本上后来出现并说
Dialogue: 0,1:08:02.94,1:08:07.00,English,,0,0,0,,Yeah you're okay you predicted that correctly so you can keep going
Dialogue: 0,1:08:02.94,1:08:07.00,Chinese,,0,0,0,,是的，你没事，你预测的正确，所以你可以坚持下去
Dialogue: 0,1:08:07.20,1:08:10.70,English,,0,0,0,,Or it will throw up a flag and say oh wait a minute stop
Dialogue: 0,1:08:07.20,1:08:10.70,Chinese,,0,0,0,,或者它会抛出一面旗帜并说哦等一下停
Dialogue: 0,1:08:11.44,1:08:16.24,English,,0,0,0,,You miss predicted this branch way back 100 clock cycles ago
Dialogue: 0,1:08:11.44,1:08:16.24,Chinese,,0,0,0,,你错过了预测这个分支方式回到100个时钟周期之前
Dialogue: 0,1:08:16.32,1:08:17.64,English,,0,0,0,,It's not that long ago but
Dialogue: 0,1:08:16.32,1:08:17.64,Chinese,,0,0,0,,这不是很久以前的事了
Dialogue: 0,1:08:18.30,1:08:21.80,English,,0,0,0,,Some number of clock cycles ago you've got to fix it
Dialogue: 0,1:08:18.30,1:08:21.80,Chinese,,0,0,0,,在一些时钟周期之前你必须解决它
Dialogue: 0,1:08:22.44,1:08:28.10,English,,0,0,0,,And so the hand-wave jumps then becomes more a case of
Dialogue: 0,1:08:22.44,1:08:28.10,Chinese,,0,0,0,,因此，手波跳跃变得更加如此
Dialogue: 0,1:08:28.36,1:08:34.58,English,,0,0,0,,Of guessing up here and then either confirming or  denying that guess down below
Dialogue: 0,1:08:28.36,1:08:34.58,Chinese,,0,0,0,,在这里猜测，然后确认或否认下面的猜测
Dialogue: 0,1:08:40.58,1:08:45.60,English,,0,0,0,,So in general then if you it will predict it one way and begin executing
Dialogue: 0,1:08:40.58,1:08:45.60,Chinese,,0,0,0,,所以总的来说，如果你它会以一种方式预测并开始执行
Dialogue: 0,1:08:46.26,1:08:50.28,English,,0,0,0,,So a mansion for example in a loop like I've shown you
Dialogue: 0,1:08:46.26,1:08:50.28,Chinese,,0,0,0,,所以，就像我向你展示的一个循环中的豪宅
Dialogue: 0,1:08:50.56,1:08:54.80,English,,0,0,0,,That you predict that the branch will be taken that you'll go back to the start of the loop again
Dialogue: 0,1:08:50.56,1:08:54.80,Chinese,,0,0,0,,你预测将采取分支，你将再次回到循环的开始
Dialogue: 0,1:08:54.80,1:08:57.04,English,,0,0,0,,That's actually a pretty good guess
Dialogue: 0,1:08:54.80,1:08:57.04,Chinese,,0,0,0,,这实际上是一个很好的猜测
Dialogue: 0,1:08:57.38,1:09:00.36,English,,0,0,0,,It's a good guess extol you hit the end of the loop
Dialogue: 0,1:08:57.38,1:09:00.36,Chinese,,0,0,0,,这是一个很好的猜测颂歌你到了循环的结尾
Dialogue: 0,1:09:00.88,1:09:02.64,English,,0,0,0,,But let's just guess that way
Dialogue: 0,1:09:00.88,1:09:02.64,Chinese,,0,0,0,,但是我们就这么猜
Dialogue: 0,1:09:03.18,1:09:08.56,English,,0,0,0,,And so the program will just keep guessing that the branch will be taken
Dialogue: 0,1:09:03.18,1:09:08.56,Chinese,,0,0,0,,因此程序将继续猜测将采取分支
Dialogue: 0,1:09:09.02,1:09:16.28,English,,0,0,0,,And by that means by all those guesses basically create this long linear sequence of instructions
Dialogue: 0,1:09:09.02,1:09:16.28,Chinese,,0,0,0,,通过这种方式，所有这些猜测基本上创建了这个长线性的指令序列
Dialogue: 0,1:09:16.66,1:09:19.68,English,,0,0,0,,That can be pulled in and executed
Dialogue: 0,1:09:16.66,1:09:19.68,Chinese,,0,0,0,,可以拉入并执行
Dialogue: 0,1:09:21.88,1:09:27.60,English,,0,0,0,,And in general some of them will be fetched and some of them you'll actually have done
Dialogue: 0,1:09:21.88,1:09:27.60,Chinese,,0,0,0,,一般来说，其中一些将被取出，其中一些你实际上已经完成了
Dialogue: 0,1:09:28.20,1:09:31.06,English,,0,0,0,,The operations that are called for in the instruction
Dialogue: 0,1:09:28.20,1:09:31.06,Chinese,,0,0,0,,指令中要求的操作
Dialogue: 0,1:09:33.56,1:09:40.50,English,,0,0,0,,And then what happens is if the flag goes up they say no this was invalid
Dialogue: 0,1:09:33.56,1:09:40.50,Chinese,,0,0,0,,然后会发生的事情是，如果旗帜上升，他们会说这不是无效的
Dialogue: 0,1:09:41.22,1:09:45.66,English,,0,0,0,,Then what will happen is it will go back and cancel
Dialogue: 0,1:09:41.22,1:09:45.66,Chinese,,0,0,0,,然后会发生什么，它将返回并取消
Dialogue: 0,1:09:46.12,1:09:50.38,English,,0,0,0,,All the instructions that have been fetched and executed
Dialogue: 0,1:09:46.12,1:09:50.38,Chinese,,0,0,0,,已获取并执行的所有指令
Dialogue: 0,1:09:50.78,1:09:56.96,English,,0,0,0,,And the way it does that is you'll notice not all these instructions only modify registers
Dialogue: 0,1:09:50.78,1:09:56.96,Chinese,,0,0,0,,它的方式就是你会注意到并非所有这些指令都只修改寄存器
Dialogue: 0,1:09:57.66,1:10:00.66,English,,0,0,0,,And it has multiple copies of all the registers
Dialogue: 0,1:09:57.66,1:10:00.66,Chinese,,0,0,0,,它有所有寄存器的多个副本
Dialogue: 0,1:10:01.10,1:10:03.14,English,,0,0,0,,Going back these are the registers
Dialogue: 0,1:10:01.10,1:10:03.14,Chinese,,0,0,0,,返回这些是寄存器
Dialogue: 0,1:10:03.14,1:10:08.84,English,,0,0,0,,These are the values that I'm sure of these are sort of speculative values  appending updates to them
Dialogue: 0,1:10:03.14,1:10:08.84,Chinese,,0,0,0,,这些值是我确定的这些值是一些附加更新的推测值
Dialogue: 0,1:10:09.26,1:10:14.56,English,,0,0,0,,And so when it comes time to cancel it just cancels out all those pending updates
Dialogue: 0,1:10:09.26,1:10:14.56,Chinese,,0,0,0,,因此，当需要取消它时，只需取消所有待处理的更新
Dialogue: 0,1:10:14.78,1:10:17.00,English,,0,0,0,,And goes back to values that it's certain of
Dialogue: 0,1:10:14.78,1:10:17.00,Chinese,,0,0,0,,并回到它确定的价值观
Dialogue: 0,1:10:17.12,1:10:20.40,English,,0,0,0,,Question
Dialogue: 0,1:10:17.12,1:10:20.40,Chinese,,0,0,0,,题
Dialogue: 0,1:10:20.40,1:10:27.66,English,,0,0,0,,The there's a big block they call the register renaming unit which is sort of
Dialogue: 0,1:10:20.40,1:10:27.66,Chinese,,0,0,0,,他们称之为寄存器重命名单元的是一个大块
Dialogue: 0,1:10:27.94,1:10:31.80,English,,0,0,0,,Multiple copies of of all the registers as they get accumulated
Dialogue: 0,1:10:27.94,1:10:31.80,Chinese,,0,0,0,,累积所有寄存器的多个副本
Dialogue: 0,1:10:31.80,1:10:42.00,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:31.80,1:10:42.00,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:10:42.00,1:10:45.94,English,,0,0,0,,It has many more will typically have several hundred reg of these
Dialogue: 0,1:10:42.00,1:10:45.94,Chinese,,0,0,0,,它有更多通常会有几百个这些
Dialogue: 0,1:10:46.26,1:10:50.72,English,,0,0,0,,Sort of virtual registers to keep pending copies to the actual registers
Dialogue: 0,1:10:46.26,1:10:50.72,Chinese,,0,0,0,,一系列虚拟寄存器，用于将待定副本保留到实际寄存器中
Dialogue: 0,1:10:50.72,1:10:52.56,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:50.72,1:10:52.56,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:10:52.56,1:10:55.26,English,,0,0,0,,It does, it stores 
Dialogue: 0,1:10:52.56,1:10:55.26,Chinese,,0,0,0,,它存在，它存储
Dialogue: 0,1:10:55.68,1:10:59.50,English,,0,0,0,,You know here's the old value Here's the first update here's the second update here's the third
Dialogue: 0,1:10:55.68,1:10:59.50,Chinese,,0,0,0,,你知道这里的旧值这里是第一次更新，这里的第二次更新是第三次更新
Dialogue: 0,1:11:01.60,1:11:09.02,English,,0,0,0,,And it keeps track of all that you can imagine why this is not something you learn in a one semester course right that
Dialogue: 0,1:11:01.60,1:11:09.02,Chinese,,0,0,0,,它记录了你可以想象的一切，为什么这不是你在一学期课程中学到的东西
Dialogue: 0,1:11:09.46,1:11:15.58,English,,0,0,0,,To keep track of all those different things flying by and make sure that it works is a pretty tricky business
Dialogue: 0,1:11:09.46,1:11:15.58,Chinese,,0,0,0,,跟踪飞过的所有不同的东西，并确保它的工作是一个相当棘手的业务
Dialogue: 0,1:11:16.06,1:11:18.48,English,,0,0,0,,But the conceptually it's a pretty simple idea
Dialogue: 0,1:11:16.06,1:11:18.48,Chinese,,0,0,0,,但从概念上讲，这是一个非常简单的想法
Dialogue: 0,1:11:18.80,1:11:24.02,English,,0,0,0,,That it just races off does a lot of things based purely on speculation
Dialogue: 0,1:11:18.80,1:11:24.02,Chinese,,0,0,0,,它只是在竞争中完成很多事情纯粹基于猜测
Dialogue: 0,1:11:24.42,1:11:27.48,English,,0,0,0,,And then only if it makes a mistake it goes oh
Dialogue: 0,1:11:24.42,1:11:27.48,Chinese,,0,0,0,,然后只有在出错的情况下才会成功哦
Dialogue: 0,1:11:27.76,1:11:29.14,English,,0,0,0,,And it sort of rolls back
Dialogue: 0,1:11:27.76,1:11:29.14,Chinese,,0,0,0,,它有点回滚
Dialogue: 0,1:11:29.94,1:11:32.62,English,,0,0,0,,To as if it had only executed up to a certain point
Dialogue: 0,1:11:29.94,1:11:32.62,Chinese,,0,0,0,,好像它只执行了某一点
Dialogue: 0,1:11:33.04,1:11:34.60,English,,0,0,0,,And then it moves forward
Dialogue: 0,1:11:33.04,1:11:34.60,Chinese,,0,0,0,,然后它继续前进
Dialogue: 0,1:11:35.76,1:11:38.68,English,,0,0,0,,And starts in going the correct way
Dialogue: 0,1:11:35.76,1:11:38.68,Chinese,,0,0,0,,并以正确的方式开始
Dialogue: 0,1:11:39.58,1:11:46.14,English,,0,0,0,,So end up,and so it can get away with this,it's very interesting tricky stuff
Dialogue: 0,1:11:39.58,1:11:46.14,Chinese,,0,0,0,,所以最终，所以它可以逃脱这个，这是非常有趣的棘手的东西
Dialogue: 0,1:11:46.48,1:11:48.80,English,,0,0,0,,But you remember we talked early in the course
Dialogue: 0,1:11:46.48,1:11:48.80,Chinese,,0,0,0,,但是你记得我们在课程的早期谈过
Dialogue: 0,1:11:49.54,1:11:56.42,English,,0,0,0,,About the difference between using conditional moves and conditional jumps to implement conditional operations
Dialogue: 0,1:11:49.54,1:11:56.42,Chinese,,0,0,0,,关于使用条件移动和条件跳转来实现条件操作之间的区别
Dialogue: 0,1:11:57.08,1:12:03.72,English,,0,0,0,,And conditional moves can take place totally within the structure of this pipeline
Dialogue: 0,1:11:57.08,1:12:03.72,Chinese,,0,0,0,,条件移动可以完全在此管道的结构内进行
Dialogue: 0,1:12:04.36,1:12:07.92,English,,0,0,0,,But a conditional jump if it's an unpredictable branch
Dialogue: 0,1:12:04.36,1:12:07.92,Chinese,,0,0,0,,但如果它是一个不可预测的分支，则是条件跳转
Dialogue: 0,1:12:08.32,1:12:13.14,English,,0,0,0,,The problem is it might go off executing and make do a lot of wasted work
Dialogue: 0,1:12:08.32,1:12:13.14,Chinese,,0,0,0,,问题是它可能会执行并浪费大量工作
Dialogue: 0,1:12:13.14,1:12:16.52,English,,0,0,0,,But even worse than when it gets back and has to restart
Dialogue: 0,1:12:13.14,1:12:16.52,Chinese,,0,0,0,,但更糟糕的是，当它回来并不得不重新启动时
Dialogue: 0,1:12:16.98,1:12:21.02,English,,0,0,0,,It takes a while to sort of fill up all the the buffers in the system
Dialogue: 0,1:12:16.98,1:12:21.02,Chinese,,0,0,0,,需要一段时间来填充系统中的所有缓冲区
Dialogue: 0,1:12:21.02,1:12:23.28,English,,0,0,0,,And get the whole thing running at full steam ahead
Dialogue: 0,1:12:21.02,1:12:23.28,Chinese,,0,0,0,,让整个事情全速前进
Dialogue: 0,1:12:27.55,1:12:32.44,English,,0,0,0,,So that kind of finishes up then the the way I describe it is
Dialogue: 0,1:12:27.55,1:12:32.44,Chinese,,0,0,0,,所以那种完成了我描述它的方式
Dialogue: 0,1:12:32.72,1:12:38.08,English,,0,0,0,,First of all don't do anything stupid even and stupid is probably it was too strong a word
Dialogue: 0,1:12:32.72,1:12:38.08,Chinese,,0,0,0,,首先，不要做任何愚蠢甚至愚蠢的事情，这可能是一个字太强了
Dialogue: 0,1:12:38.08,1:12:44.94,English,,0,0,0,,Don't do...sort of keep in mind there's certain things that you should as a programmer be doing all the time
Dialogue: 0,1:12:38.08,1:12:44.94,Chinese,,0,0,0,,不要......请记住，作为一名程序员，你应该做的某些事情一直在做
Dialogue: 0,1:12:45.48,1:12:47.20,English,,0,0,0,,And they're not obvious
Dialogue: 0,1:12:45.48,1:12:47.20,Chinese,,0,0,0,,而且他们并不明显
Dialogue: 0,1:12:47.72,1:12:52.54,English,,0,0,0,,And then begin thinking about tuning and getting some instruction level parallelism
Dialogue: 0,1:12:47.72,1:12:52.54,Chinese,,0,0,0,,然后开始考虑调整并获得一些指令级并行性
Dialogue: 0,1:12:53.22,1:12:55.32,English,,0,0,0,,And I describe it as for the machine but 
Dialogue: 0,1:12:53.22,1:12:55.32,Chinese,,0,0,0,,我把它描述为机器但是
Dialogue: 0,1:12:55.48,1:12:59.98,English,,0,0,0,,As I said pretty much all processors nowadays,it's a class of machines 
Dialogue: 0,1:12:55.48,1:12:59.98,Chinese,,0,0,0,,正如我现在所说的几乎所有处理器一样，它是一类机器
Dialogue: 0,1:12:59.98,1:13:01.98,English,,0,0,0,,So these general techniques will work
Dialogue: 0,1:12:59.98,1:13:01.98,Chinese,,0,0,0,,所以这些通用技术将起作用
Dialogue: 0,1:13:02.46,1:13:05.58,English,,0,0,0,,That those ideas of changing the associativity
Dialogue: 0,1:13:02.46,1:13:05.58,Chinese,,0,0,0,,那些改变关联性的想法
Dialogue: 0,1:13:05.78,1:13:10.86,English,,0,0,0,,They'll work whether it's a you know the ARM processor built into my cell phone
Dialogue: 0,1:13:05.78,1:13:10.86,Chinese,,0,0,0,,无论你是否知道手机中内置的ARM处理器，它们都能正常工作
Dialogue: 0,1:13:10.86,1:13:15.90,English,,0,0,0,,Or the x86 processor built into your laptop or one of the shark machines
Dialogue: 0,1:13:10.86,1:13:15.90,Chinese,,0,0,0,,或者是笔记本电脑或其中一台鲨鱼机内置的x86处理器
Dialogue: 0,1:13:15.90,1:13:19.94,English,,0,0,0,,They all have the same general of implementation structures
Dialogue: 0,1:13:15.90,1:13:19.94,Chinese,,0,0,0,,它们都具有相同的实现结构
Dialogue: 0,1:13:19.94,1:13:23.42,English,,0,0,0,,So these techniques will work across across all of them
Dialogue: 0,1:13:19.94,1:13:23.42,Chinese,,0,0,0,,因此，这些技术将适用于所有这些技术
Dialogue: 0,1:13:24.34,1:13:28.57,English,,0,0,0,,Okay that'll do us for today
Dialogue: 0,1:13:24.34,1:13:28.57,Chinese,,0,0,0,,好的，今天我们就到这
