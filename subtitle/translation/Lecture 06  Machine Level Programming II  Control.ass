[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 06  Machine Level Programming II  Control.mp4
Video File: ../../../../Desktop/csapp/Lecture 06  Machine Level Programming II  Control.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.125000
Scroll Position: 1664
Active Line: 1665
Video Position: 131694

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,40,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.72,0:00:08.00,English,,0,0,0,,Okay let's continue on coverage of machine level programming
Dialogue: 0,0:00:01.72,0:00:08.00,Chinese,,0,0,0,,好的，让我们继续机器级编程的内容
Dialogue: 0,0:00:08.82,0:00:11.46,English,,0,0,0,,The second, I think t's a six part series
Dialogue: 0,0:00:08.82,0:00:11.46,Chinese,,0,0,0,,第二，我认为这系列有六部分
Dialogue: 0,0:00:12.14,0:00:16.76,English,,0,0,0,,As I mentioned yesterday machine level programming is sort of the core of this course
Dialogue: 0,0:00:12.14,0:00:16.76,Chinese,,0,0,0,,正如我昨天提到的，机器级编程是本课程的核心
Dialogue: 0,0:00:16.92,0:00:23.04,English,,0,0,0,,That it gives you a set of tools and understanding that take you well beyond
Dialogue: 0,0:00:16.92,0:00:23.04,Chinese,,0,0,0,,它为你提供了一套工具并让你对程序理解远远超过
Dialogue: 0,0:00:23.04,0:00:29.70,English,,0,0,0,,What you're sort of average run-of-the-mill of programmer or software developer would know about
Dialogue: 0,0:00:23.04,0:00:29.70,Chinese,,0,0,0,,那些普通的程序员或软件开发人员
Dialogue: 0,0:00:30.08,0:00:34.52,English,,0,0,0,,And it's very powerful in terms of your better understanding of the system
Dialogue: 0,0:00:30.08,0:00:34.52,Chinese,,0,0,0,,它对你更好地理解系统非常有用
Dialogue: 0,0:00:34.80,0:00:41.80,English,,0,0,0,,What goes wrong? Why programs crash? What the meaning of those are?
Dialogue: 0,0:00:34.80,0:00:41.80,Chinese,,0,0,0,,出了什么问题？为什么程序崩溃？那些问题意味着什么？
Dialogue: 0,0:00:41.82,0:00:43.82,English,,0,0,0,,So it's a fairly core part of the material
Dialogue: 0,0:00:41.82,0:00:43.82,Chinese,,0,0,0,,所以这是课程十分核心的一部分
Dialogue: 0,0:00:44.48,0:00:46.96,English,,0,0,0,,As you know the data lab is due tonight
Dialogue: 0,0:00:44.48,0:00:46.96,Chinese,,0,0,0,,如你所知，data lab（csapp的第一个实验）今晚就要交了
Dialogue: 0,0:00:47.74,0:00:53.26,English,,0,0,0,,And the next lab out is called the "bomb lab" and I believe that's coming out tonight as well
Dialogue: 0,0:00:47.74,0:00:53.26,Chinese,,0,0,0,,下一个实验叫做 bomb lab，今晚也会布置下去
Dialogue: 0,0:00:53.90,0:01:00.00,English,,0,0,0,,So the bomb lab will rely on your ability to understand machine level code
Dialogue: 0,0:00:53.90,0:01:00.00,Chinese,,0,0,0,,Bomb lab 将考验你理解机器级代码的能力
Dialogue: 0,0:01:00.70,0:01:06.46,English,,0,0,0,,So the these two lectures will actually be enough to give you started on some of the earlier parts of that lab
Dialogue: 0,0:01:00.70,0:01:06.46,Chinese,,0,0,0,,因此实际上这两节课（basic 和 control）足以能够让你进行该实验的前面内容
Dialogue: 0,0:01:07.02,0:01:10.16,English,,0,0,0,,You'll learn a lot more at recitation on Monday
Dialogue: 0,0:01:07.02,0:01:10.16,Chinese,,0,0,0,,周一的复习课你学到了更多内容
Dialogue: 0,0:01:10.16,0:01:14.20,English,,0,0,0,,Either in person or if you're viewing the recorded version of that
Dialogue: 0,0:01:10.16,0:01:14.20,Chinese,,0,0,0,,无论你是亲自上课或者还是在观看录制版本
Dialogue: 0,0:01:14.64,0:01:17.54,English,,0,0,0,,That will help you move along on bomb lab
Dialogue: 0,0:01:14.64,0:01:17.54,Chinese,,0,0,0,,都将有助于你进行 bomb lab
Dialogue: 0,0:01:18.00,0:01:23.14,English,,0,0,0,,Like all the labs in this course,at least the first two, we give you a fair amount of time for them
Dialogue: 0,0:01:18.00,0:01:23.14,Chinese,,0,0,0,,像本课程中的所有实验一样，至少前两个实验，我们给你们充足的时间去完成
Dialogue: 0,0:01:23.72,0:01:29.62,English,,0,0,0,,But don't be fooled into thinking that means you can just slack off or work on other courses
Dialogue: 0,0:01:23.72,0:01:29.62,Chinese,,0,0,0,,但不要误以为你可以放松一下或钻研其他课程
Dialogue: 0,0:01:30.20,0:01:33.96,English,,0,0,0,,And then the last few moments jump in and finish this lab
Dialogue: 0,0:01:30.20,0:01:33.96,Chinese,,0,0,0,,然后在截止前的短时间内仓促完成
Dialogue: 0,0:01:34.10,0:01:40.10,English,,0,0,0,,The bomb lab once you get the hang of what you're doing,it's pretty you can just kind of crank along
Dialogue: 0,0:01:34.10,0:01:40.10,Chinese,,0,0,0,,一旦你掌握了 bomb lab 的诀窍，你就可以慢慢完成这个实验
Dialogue: 0,0:01:40.58,0:01:46.96,English,,0,0,0,,But there's a certain learning curve that will take you to even get started on it effectively
Dialogue: 0,0:01:40.58,0:01:46.96,Chinese,,0,0,0,,但是有一定的学习曲线会让你有效率地进行这个实验
Dialogue: 0,0:01:47.08,0:01:48.28,English,,0,0,0,,So don't put it off
Dialogue: 0,0:01:47.08,0:01:48.28,Chinese,,0,0,0,,所以别拖延
Dialogue: 0,0:01:56.66,0:02:12.30,English,,0,0,0,,Um or with this
Dialogue: 0,0:01:56.66,0:02:12.30,Chinese,,0,0,0,,嗯
Dialogue: 0,0:02:12.30,0:02:16.40,English,,0,0,0,,So last time we introduced the very basic principles of machine level programming
Dialogue: 0,0:02:12.30,0:02:16.40,Chinese,,0,0,0,,上节课我们介绍了机器级编程的基本原理
Dialogue: 0,0:02:16.40,0:02:21.84,English,,0,0,0,,The idea of there being special state that you have access to the registers
Dialogue: 0,0:02:16.40,0:02:21.84,Chinese,,0,0,0,,主要思想是通过访问寄存器得到一些状态
Dialogue: 0,0:02:21.84,0:02:27.22,English,,0,0,0,,Which people came out to class nest a register is part of memory?No
Dialogue: 0,0:02:21.84,0:02:27.22,Chinese,,0,0,0,,谁出来回答一下，寄存器是内存的一部分吗？不是的
Dialogue: 0,0:02:27.44,0:02:29.38,English,,0,0,0,,Are they part of the cache？No
Dialogue: 0,0:02:27.44,0:02:29.38,Chinese,,0,0,0,,它们是缓存的一部分吗？不是的
Dialogue: 0,0:02:29.90,0:02:34.30,English,,0,0,0,,They special,they're different,they don't exist to a C level program
Dialogue: 0,0:02:29.90,0:02:34.30,Chinese,,0,0,0,,它们很特殊，C 语言中没有（操作）寄存器（的关键字）
Dialogue: 0,0:02:34.30,0:02:37.06,English,,0,0,0,,When you're programming in C, you don't have any visibility into them
Dialogue: 0,0:02:34.30,0:02:37.06,Chinese,,0,0,0,,当你使用 C 语言进行编程时，你「看」不到它们（不能访问它们）
Dialogue: 0,0:02:37.66,0:02:44.26,English,,0,0,0,,And in general, today we're going to do then is go beyond the sort of very basics and start talking about the control
Dialogue: 0,0:02:37.66,0:02:44.26,Chinese,,0,0,0,,总的来说，我们会开始学习（代码执行顺序的）控制知识，（上节课）是非常基础的知识，这节课内容深一点
Dialogue: 0,0:02:44.26,0:02:50.06,English,,0,0,0,,How you control the flow of execution of instructions at the machine level
Dialogue: 0,0:02:44.26,0:02:50.06,Chinese,,0,0,0,,也就是如何控制机器级别指令的执行顺序
Dialogue: 0,0:02:50.48,0:02:58.18,English,,0,0,0,,And how you use those techniques to implement basic constructs conditional statements,loops and switch statements
Dialogue: 0,0:02:50.48,0:02:58.18,Chinese,,0,0,0,,以及如何使用这些技术来实现基本条件语句，循环和  switch 语句
Dialogue: 0,0:02:59.08,0:03:02.72,English,,0,0,0,,And then next time we'll talk about procedures which warrants a whole lecture of its own
Dialogue: 0,0:02:59.08,0:03:02.72,Chinese,,0,0,0,,紧接着下次我们将讨论保证整个课程（机器级编程）自身的过程抽象
Dialogue: 0,0:03:05.16,0:03:09.30,English,,0,0,0,,So that x86 and several machines of its generation
Dialogue: 0,0:03:05.16,0:03:09.30,Chinese,,0,0,0,,这样 x86 和它这一系列中的几代机器
Dialogue: 0,0:03:09.70,0:03:16.22,English,,0,0,0,,Have these curious little of one bit flags that are called condition codes
Dialogue: 0,0:03:09.70,0:03:16.22,Chinese,,0,0,0,,有这些奇怪的标志位，称为条件码
Dialogue: 0,0:03:16.54,0:03:19.26,English,,0,0,0,,And they're the basis of how conditional operations work
Dialogue: 0,0:03:16.54,0:03:19.26,Chinese,,0,0,0,,它们是条件指令运作的基础
Dialogue: 0,0:03:20.86,0:03:26.30,English,,0,0,0,,So to a machine level programmer then we talked last time that
Dialogue: 0,0:03:20.86,0:03:26.30,Chinese,,0,0,0,,那么对于从事机器级编程的程序员来说，我们上次谈到了这一点
Dialogue: 0,0:03:26.30,0:03:34.04,English,,0,0,0,,You have visibility of the set of registers and the memory
Dialogue: 0,0:03:26.30,0:03:34.04,Chinese,,0,0,0,,你可以看到一组寄存器和内存
Dialogue: 0,0:03:34.44,0:03:37.94,English,,0,0,0,,But you also have more things and this is only a partial list
Dialogue: 0,0:03:34.44,0:03:37.94,Chinese,,0,0,0,,但是你也有更多资料，这只是一个部分清单
Dialogue: 0,0:03:38.02,0:03:41.30,English,,0,0,0,,Actually there's more and more stuff that you can add to this picture
Dialogue: 0,0:03:38.02,0:03:41.30,Chinese,,0,0,0,,事实上，你可以在这张图片上添加更多信息
Dialogue: 0,0:03:41.96,0:03:46.60,English,,0,0,0,,But we talked about in the 64-bit x86-64
Dialogue: 0,0:03:41.96,0:03:46.60,Chinese,,0,0,0,,但是我们在 64 位 x86-64 中讨论过
Dialogue: 0,0:03:46.60,0:03:56.38,English,,0,0,0,,Now 16 registers,8 of which have names that are historic based on old x86 stuff
Dialogue: 0,0:03:46.60,0:03:56.38,Chinese,,0,0,0,,现在它有 16 个寄存器，其中 8 个沿用旧 x86 架构中的名称
Dialogue: 0,0:03:56.90,0:04:02.38,English,,0,0,0,,And 8 of which were introduced and so they simply named those %r8 through %r15
Dialogue: 0,0:03:56.90,0:04:02.38,Chinese,,0,0,0,,还有新引入的 8 个，他们很简单地将它们从 %8 命名到 ％r15
Dialogue: 0,0:04:03.62,0:04:09.42,English,,0,0,0,,And other registers for the most part the only one that's really special is %rsp
Dialogue: 0,0:04:03.62,0:04:09.42,Chinese,,0,0,0,,对于大部分寄存器，唯一真正特别的是 ％rsp
Dialogue: 0,0:04:09.48,0:04:11.54,English,,0,0,0,,It's the stack pointer tells you where
Dialogue: 0,0:04:09.48,0:04:11.54,Chinese,,0,0,0,,%rsp 寄存器存的是栈指针，它能告诉你程序执行到哪儿了
Dialogue: 0,0:04:11.76,0:04:15.76,English,,0,0,0,,And we'll learn a lot more about stacks starting next time
Dialogue: 0,0:04:11.76,0:04:15.76,Chinese,,0,0,0,,下节课我们会学习更多关于栈的知识
Dialogue: 0,0:04:16.20,0:04:21.98,English,,0,0,0,,But it's sort of where the most the the state is that manages the execution of procedures
Dialogue: 0,0:04:16.20,0:04:21.98,Chinese,,0,0,0,,栈中有非常多的状态信息，这些状态信息控制着过程的执行
Dialogue: 0,0:04:23.08,0:04:26.74,English,,0,0,0,,And so you can't just use that or set it in arbitrary ways
Dialogue: 0,0:04:23.08,0:04:26.74,Chinese,,0,0,0,,所以你不能随意地使用它或设置它
Dialogue: 0,0:04:26.74,0:04:32.78,English,,0,0,0,,But the other ones you more or less come with qualifications to that statement
Dialogue: 0,0:04:26.74,0:04:32.78,Chinese,,0,0,0,,但是其他的寄存器你可以去使用或设置
Dialogue: 0,0:04:33.28,0:04:37.66,English,,0,0,0,,There's another register that they call the %rip which has nothing to do with death
Dialogue: 0,0:04:33.28,0:04:37.66,Chinese,,0,0,0,,还有另一个寄存器，他们称之为 ％rip，与死亡无关
Dialogue: 0,0:04:40.54,0:04:43.42,English,,0,0,0,,It means that...the %rip means instruction pointer
Dialogue: 0,0:04:40.54,0:04:43.42,Chinese,,0,0,0,,％rip 的含义是指令指针（instruction pointer）
Dialogue: 0,0:04:43.90,0:04:47.74,English,,0,0,0,,In IA32 is called a %eip and now it's called %rip
Dialogue: 0,0:04:43.90,0:04:47.74,Chinese,,0,0,0,,就像 %rax 的前身是 %eax
Dialogue: 0,0:04:47.74,0:04:50.84,English,,0,0,0,,Just like the registry used to be %eax and now it's %rax
Dialogue: 0,0:04:47.74,0:04:50.84,Chinese,,0,0,0,,就像以前的寄存器是 ％eax，现在它是 ％rax
Dialogue: 0,0:04:52.06,0:04:56.52,English,,0,0,0,,So all it contains is the address of the currently executing instruction
Dialogue: 0,0:04:52.06,0:04:56.52,Chinese,,0,0,0,,它包含的是当前正在执行指令的地址
Dialogue: 0,0:04:57.12,0:04:58.60,English,,0,0,0,,And you can...
Dialogue: 0,0:04:57.12,0:04:58.60,Chinese,,0,0,0,,你可以......
Dialogue: 0,0:04:59.04,0:05:02.92,English,,0,0,0,,It's not a register that you access in a normal way
Dialogue: 0,0:04:59.04,0:05:02.92,Chinese,,0,0,0,,它不是你能以正常方式访问的寄存器
Dialogue: 0,0:05:02.92,0:05:07.16,English,,0,0,0,,But you actually there are tricks that you can find out what the value of that is
Dialogue: 0,0:05:02.92,0:05:07.16,Chinese,,0,0,0,,但实际上有一些技巧可以让你获得它的值
Dialogue: 0,0:05:07.66,0:05:13.44,English,,0,0,0,,So that just tells you where in the program,what part of the program is currently being executed
Dialogue: 0,0:05:07.66,0:05:13.44,Chinese,,0,0,0,,所以它只是告诉你程序(执行到)哪，当前正在执行的程序的哪个部分
Dialogue: 0,0:05:13.90,0:05:16.36,English,,0,0,0,,And then there's these things that are called condition codes
Dialogue: 0,0:05:13.90,0:05:16.36,Chinese,,0,0,0,,然后是这些被称为条件代码的东西
Dialogue: 0,0:05:16.36,0:05:19.32,English,,0,0,0,,And we're only showing four there's actually more like eight of them
Dialogue: 0,0:05:16.36,0:05:19.32,Chinese,,0,0,0,,我们只展示了八个中的四个
Dialogue: 0,0:05:19.90,0:05:22.90,English,,0,0,0,,But not a relevant to our general discussion
Dialogue: 0,0:05:19.90,0:05:22.90,Chinese,,0,0,0,,其他的与我们现在的讨论无关
Dialogue: 0,0:05:23.40,0:05:28.42,English,,0,0,0,,That are all one bit flags and they get set not directly
Dialogue: 0,0:05:23.40,0:05:28.42,Chinese,,0,0,0,,这些都是一位标志，它们不是直接设置的
Dialogue: 0,0:05:28.42,0:05:31.64,English,,0,0,0,,But as a side effect of other operations that take place
Dialogue: 0,0:05:28.42,0:05:31.64,Chinese,,0,0,0,,而是根据其他指令操作后的结果设置的
Dialogue: 0,0:05:32.32,0:05:37.32,English,,0,0,0,,And they're the basis for which conditional operation gets decided
Dialogue: 0,0:05:32.32,0:05:37.32,Chinese,,0,0,0,,它们是决定条件操作的基础
Dialogue: 0,0:05:37.48,0:05:39.70,English,,0,0,0,,So let's go through what those mean
Dialogue: 0,0:05:37.48,0:05:39.70,Chinese,,0,0,0,,那么让我们来看看它们的含义
Dialogue: 0,0:05:40.82,0:05:45.22,English,,0,0,0,,And they're given names, but these names are actually useful to memorize what they mean
Dialogue: 0,0:05:40.82,0:05:45.22,Chinese,,0,0,0,,它们被赋予了名称，但这些名称实际上有助于记住它们的含义
Dialogue: 0,0:05:45.82,0:05:48.26,English,,0,0,0,,So CF means the carry flag
Dialogue: 0,0:05:45.82,0:05:48.26,Chinese,,0,0,0,,因此 CF 表示进位标志
Dialogue: 0,0:05:48.90,0:05:53.20,English,,0,0,0,,And that's if you think of adding two numbers,think of them as two unsigned numbers
Dialogue: 0,0:05:48.90,0:05:53.20,Chinese,,0,0,0,,如果你将两数相加并且是两个无符号数
Dialogue: 0,0:05:53.68,0:06:00.30,English,,0,0,0,,And you do the binary arithmetic and sometimes an extra one pops out of the left hand side, right?
Dialogue: 0,0:05:53.68,0:06:00.30,Chinese,,0,0,0,,然后你进行二进制算术运算，有时候最左边会多出来一位，对吧？
Dialogue: 0,0:06:00.30,0:06:05.64,English,,0,0,0,,That's the carry bit,you the numbers you added sort of were too big
Dialogue: 0,0:06:00.30,0:06:05.64,Chinese,,0,0,0,,那就是进位，原因是两个相加的数太大了
Dialogue: 0,0:06:06.00,0:06:12.80,English,,0,0,0,,To be contained in the 32 or 64-bit or even 16 or 8-bit result
Dialogue: 0,0:06:06.00,0:06:12.80,Chinese,,0,0,0,,以至于不能被包含在 32 位或 64 位甚至 16 位或 8 位结果中
Dialogue: 0,0:06:13.64,0:06:16.64,English,,0,0,0,,And so an extra bit was generated that's called the carry bit
Dialogue: 0,0:06:13.64,0:06:16.64,Chinese,,0,0,0,,因此（计算过程）产生了一个额外的位，称为进位
Dialogue: 0,0:06:18.00,0:06:25.30,English,,0,0,0,,The zero flag(ZF) is what it sounds like it's set if the the value you just computed is zero
Dialogue: 0,0:06:18.00,0:06:25.30,Chinese,,0,0,0,,如果你刚刚计算的值为零，则零标志位（ZF）就会被置位
Dialogue: 0,0:06:25.80,0:06:28.66,English,,0,0,0,,These are set typically by arithmetic instructions by the way
Dialogue: 0,0:06:25.80,0:06:28.66,Chinese,,0,0,0,,这些通常由算术指令通过某种方式设置
Dialogue: 0,0:06:29.28,0:06:36.98,English,,0,0,0,,The sign flag(SF) is said if the value just computed as a one in the most significant bit meaning it's a negative value
Dialogue: 0,0:06:29.28,0:06:36.98,Chinese,,0,0,0,,运算结果最高有效位为 1 （说明结果是负值），符号标志（SF）会被置 1
Dialogue: 0,0:06:37.60,0:06:44.04,English,,0,0,0,,And the overflow flag(OF) is a two's complement version of overflow
Dialogue: 0,0:06:37.60,0:06:44.04,Chinese,,0,0,0,,溢出标志（OF）是表示有符号数运算溢出的位\N（译注：CF表示无符号数运算溢出位）
Dialogue: 0,0:06:44.64,0:06:51.88,English,,0,0,0,,So in particular if you remember from data lab, how do you know if addition of two values is overflowed
Dialogue: 0,0:06:44.64,0:06:51.88,Chinese,,0,0,0,,如果你还记得 data lab，你是如何确定两个数相加是否溢出的呢？
Dialogue: 0,0:06:52.00,0:06:57.30,English,,0,0,0,,If the signs of the operands are the same,but the sign of the result is different than that
Dialogue: 0,0:06:52.00,0:06:57.30,Chinese,,0,0,0,,如果操作数的符号相同，但结果的符号却和操作数符号不同
Dialogue: 0,0:06:57.80,0:07:03.66,English,,0,0,0,,So either you added two positive numbers and got a negative result.That was a positive overflow
Dialogue: 0,0:06:57.80,0:07:03.66,Chinese,,0,0,0,,要么你是两个正数相加而得到了一个负数结果。这是正溢出
Dialogue: 0,0:07:03.66,0:07:08.53,English,,0,0,0,,Or you added two negative numbers and got a negative result.That's negative overflow
Dialogue: 0,0:07:03.66,0:07:08.53,Chinese,,0,0,0,,要么你是两个负数相加而得到了正数结果。这是负溢出\N（译注：英文字幕说得到负数结果是老师口误）
Dialogue: 0,0:07:08.90,0:07:13.35,English,,0,0,0,,You can't overflow if the two arguments are of opposite signs.right?
Dialogue: 0,0:07:08.90,0:07:13.35,Chinese,,0,0,0,,如果两个参数（即操作数）的符号相反，你就不会溢出。
Dialogue: 0,0:07:14.24,0:07:21.48,English,,0,0,0,,So those four flags get,set as a sort of normal activity by many of the instructions
Dialogue: 0,0:07:14.24,0:07:21.48,Chinese,,0,0,0,,这四个标志被置位是许多指令的一种常规行为
Dialogue: 0,0:07:22.08,0:07:25.14,English,,0,0,0,,Not by our friend the lea instruction
Dialogue: 0,0:07:22.08,0:07:25.14,Chinese,,0,0,0,,但是 lea 指令不会设置这四个标志位
Dialogue: 0,0:07:25.14,0:07:31.18,English,,0,0,0,,Which I mentioned is kind of a quirky instruction that GCC really likes a lot and you'll see it in a lot of places
Dialogue: 0,0:07:25.14,0:07:31.18,Chinese,,0,0,0,,我提到的是一种 GCC 非常喜欢的奇怪指令，你会在很多地方看到它
Dialogue: 0,0:07:34.20,0:07:39.96,English,,0,0,0,,But in general and most of the time those flags get completely ignored,because who cares right
Dialogue: 0,0:07:34.20,0:07:39.96,Chinese,,0,0,0,,但总的来说，这些标志大部分时间都被完全忽略了，因为一般没人在乎
Dialogue: 0,0:07:40.82,0:07:45.08,English,,0,0,0,,But they do show up at various points when you're doing conditional operations
Dialogue: 0,0:07:40.82,0:07:45.08,Chinese,,0,0,0,,但当你进行条件操作时，它们就会出现在不同的情况下
Dialogue: 0,0:07:47.78,0:07:53.54,English,,0,0,0,,So there's some special instructions whose only effect is to set condition codes
Dialogue: 0,0:07:47.78,0:07:53.54,Chinese,,0,0,0,,有一些特殊指令，它们唯一的作用就是设置条件码
Dialogue: 0,0:07:53.54,0:07:57.72,English,,0,0,0,,And the one that you'll see is especially it's called compare CMP
Dialogue: 0,0:07:53.54,0:07:57.72,Chinese,,0,0,0,,你们在 ppt 上看到的那个 cmp（compare）就是其中一个
Dialogue: 0,0:07:58.34,0:08:07.34,English,,0,0,0,,And by the way the queue at the end of these is all just a reflection of their operating on 64-bit words,quadword as I said
Dialogue: 0,0:07:58.34,0:08:07.34,Chinese,,0,0,0,,顺便说一句，以 q 结尾的指令表示对 64 位数据进行操作，也就是我说的 quadword（四字）
Dialogue: 0,0:08:07.88,0:08:16.40,English,,0,0,0,,So the comparison is sort of like a subtraction instruction except that you don't do anything with the result
Dialogue: 0,0:08:07.88,0:08:16.40,Chinese,,0,0,0,,cmp 指令和减法指令几乎一样，但是 cmp 指令不会对得到的结果做任何操作
Dialogue: 0,0:08:17.20,0:08:21.56,English,,0,0,0,,Normal subtraction instruction is like x minus equals y
Dialogue: 0,0:08:17.20,0:08:21.56,Chinese,,0,0,0,,正常的减法指令（sub）类似于 x-=y
Dialogue: 0,0:08:22.52,0:08:26.76,English,,0,0,0,,It will read two numbers but then it will store the result wherever x is stored
Dialogue: 0,0:08:22.52,0:08:26.76,Chinese,,0,0,0,,它将读取两个数字，随后将运算结果赋给 x
Dialogue: 0,0:08:28.08,0:08:33.40,English,,0,0,0,,But compare just takes these two values does the subtraction and doesn't do anything with the result
Dialogue: 0,0:08:28.08,0:08:33.40,Chinese,,0,0,0,,但是 cmp 只是将这两个值做减法，不会对结果做任何操作
Dialogue: 0,0:08:33.40,0:08:36.88,English,,0,0,0,,But it will set it's these four condition flags
Dialogue: 0,0:08:33.40,0:08:36.88,Chinese,,0,0,0,,但它会设置这四个条件标志
Dialogue: 0,0:08:38.66,0:08:45.96,English,,0,0,0,,And just a few things to keep in mind that are often will be sources of confuse
Dialogue: 0,0:08:38.66,0:08:45.96,Chinese,,0,0,0,,还有要牢记一些事情，否则会经常让你感到困惑
Dialogue: 0,0:08:46.56,0:08:54.36,English,,0,0,0,,Remember that the arguments in the way we write them in machine code is the opposite of what you'd expect
Dialogue: 0,0:08:46.56,0:08:54.36,Chinese,,0,0,0,,请记住，我们在机器代码中编写参数的方式与你期望的相反
Dialogue: 0,0:08:55.06,0:08:57.38,English,,0,0,0,,By the way,somebody asked me last time
Dialogue: 0,0:08:55.06,0:08:57.38,Chinese,,0,0,0,,顺便说一句，上次有人问过我
Dialogue: 0,0:08:57.38,0:09:02.84,English,,0,0,0,,There's another. there's sort of two dialects of assembly code used on x86 machines
Dialogue: 0,0:08:57.38,0:09:02.84,Chinese,,0,0,0,,还有另一种，x86 机器上有两种汇编语言
Dialogue: 0,0:09:03.46,0:09:07.64,English,,0,0,0,,There's the one that's used by intel and Microsoft and we don't use it
Dialogue: 0,0:09:03.46,0:09:07.64,Chinese,,0,0,0,,有一种是英特尔和微软使用的，我们不使用它
Dialogue: 0,0:09:08.04,0:09:14.24,English,,0,0,0,,And then there's the one used that sort of used by Linux systems and that's the one we use
Dialogue: 0,0:09:08.04,0:09:14.24,Chinese,,0,0,0,,另一种是 Linux 系统使用的，就是我们现在上课使用的
Dialogue: 0,0:09:14.66,0:09:19.66,English,,0,0,0,,And they're different,and one of the quirks of them is they write their arguments in different orders
Dialogue: 0,0:09:14.66,0:09:19.66,Chinese,,0,0,0,,这两种语言是不同的，他们之间很奇怪的一个差异是他们参数的顺序不同
Dialogue: 0,0:09:19.86,0:09:22.58,English,,0,0,0,,So it will drive you crazy reading trying to read
Dialogue: 0,0:09:19.86,0:09:22.58,Chinese,,0,0,0,,这会让你在阅读代码时感到发疯
Dialogue: 0,0:09:22.96,0:09:24.32,English,,0,0,0,,If you're familiar with one
Dialogue: 0,0:09:22.96,0:09:24.32,Chinese,,0,0,0,,如果你熟悉其中一种
Dialogue: 0,0:09:24.54,0:09:28.58,English,,0,0,0,,It's like if you've ever tried to drive a car on the wrong side of the road
Dialogue: 0,0:09:24.54,0:09:28.58,Chinese,,0,0,0,,就像你曾试图在路的错误一侧驾驶汽车一样
Dialogue: 0,0:09:29.30,0:09:31.60,English,,0,0,0,,You often will crash or do bad things
Dialogue: 0,0:09:29.30,0:09:31.60,Chinese,,0,0,0,,你经常会崩溃或做错一些事
Dialogue: 0,0:09:33.76,0:09:36.74,English,,0,0,0,,Um so that's just an aside that
Dialogue: 0,0:09:33.76,0:09:36.74,Chinese,,0,0,0,,这些话有点离题了
Dialogue: 0,0:09:37.02,0:09:42.98,English,,0,0,0,,What I find by the way when I'm looking at code and I see a compare instruction
Dialogue: 0,0:09:37.02,0:09:42.98,Chinese,,0,0,0,,但当我看到一条 cmp 指令时
Dialogue: 0,0:09:42.98,0:09:51.10,English,,0,0,0,,I actually write as a comment of compare of the two but I flipped the order
Dialogue: 0,0:09:42.98,0:09:51.10,Chinese,,0,0,0,,我会在注释中注明这是一个比较指令，并且把参数顺序倒过来
Dialogue: 0,0:09:51.14,0:09:55.32,English,,0,0,0,,So that I'm sure that I sort of keep in my mind what the comparison was of
Dialogue: 0,0:09:51.14,0:09:55.32,Chinese,,0,0,0,,因此，我确信我会在脑海中记住比较的内容
Dialogue: 0,0:09:56.38,0:10:00.34,English,,0,0,0,,And so these flags get set according to the rules of subtraction
Dialogue: 0,0:09:56.38,0:10:00.34,Chinese,,0,0,0,,所以这些标志根据减法规则被置位
Dialogue: 0,0:10:00.44,0:10:04.64,English,,0,0,0,,And so it turns out that the carry flag and the overflow flag
Dialogue: 0,0:10:00.44,0:10:04.64,Chinese,,0,0,0,,最后得到进位标志和溢出标志
Dialogue: 0,0:10:04.64,0:10:07.30,English,,0,0,0,,You have to sort of flip your sense of what happened
Dialogue: 0,0:10:04.64,0:10:07.30,Chinese,,0,0,0,,你必须翻转你对发生事情的感觉
Dialogue: 0,0:10:07.30,0:10:11.62,English,,0,0,0,,Because it's a subtraction rather than addition but it's the same general idea
Dialogue: 0,0:10:07.30,0:10:11.62,Chinese,,0,0,0,,因为它是一个减法而不是加法，但原理却是一样的
Dialogue: 0,0:10:14.84,0:10:18.92,English,,0,0,0,,So that sort of shows you one particular one
Dialogue: 0,0:10:14.84,0:10:18.92,Chinese,,0,0,0,,这是一个特例
Dialogue: 0,0:10:19.26,0:10:25.82,English,,0,0,0,,In another instruction that you'll see whose only purpose in the world is to to set condition flags
Dialogue: 0,0:10:19.26,0:10:25.82,Chinese,,0,0,0,,test 指令唯一的目的是设置条件标志
Dialogue: 0,0:10:26.04,0:10:31.26,English,,0,0,0,,Condition codes is the test instruction and this is typically used the compare as
Dialogue: 0,0:10:26.04,0:10:31.26,Chinese,,0,0,0,,条件码在 test 指令中通常用于比较
Dialogue: 0,0:10:31.42,0:10:34.80,English,,0,0,0,,You'd think it's when you have two values and you want to compare them to each other
Dialogue: 0,0:10:31.42,0:10:34.80,Chinese,,0,0,0,,当你有两个值并希望它们相互比较的时候，你会使用cmp指令
Dialogue: 0,0:10:35.30,0:10:39.44,English,,0,0,0,,And the test is if you really just have one value and you want to see what it's like is
Dialogue: 0,0:10:35.30,0:10:39.44,Chinese,,0,0,0,,当你只有一个值，你想看看它是什么样的时，test 指令就派上用场了
Dialogue: 0,0:10:39.64,0:10:43.96,English,,0,0,0,,It's zero is negative, those are the main things you care about
Dialogue: 0,0:10:39.64,0:10:43.96,Chinese,,0,0,0,,你主要想知道它到底是零还是负数，又或者是正数？
Dialogue: 0,0:10:44.10,0:10:45.84,English,,0,0,0,,In fact that's the only thing you can determine
Dialogue: 0,0:10:44.10,0:10:45.84,Chinese,,0,0,0,,事实上，这是你（使用test指令）唯一能确定的事情
Dialogue: 0,0:10:46.40,0:10:53.56,English,,0,0,0,,But just because I guess they had up they had sort of a possibility of having two arguments to this
Dialogue: 0,0:10:46.40,0:10:53.56,Chinese,,0,0,0,,但仅仅因为我猜他们已经有了，他们有可能对此有两个参数（操作数）
Dialogue: 0,0:10:53.94,0:10:56.04,English,,0,0,0,,So they decided well let's go ahead and do it
Dialogue: 0,0:10:53.94,0:10:56.04,Chinese,,0,0,0,,所以他们决定让我们继续前进吧
Dialogue: 0,0:10:56.48,0:11:02.58,English,,0,0,0,,How do you have two arguments to a test instruction what's and the two results and then test that value
Dialogue: 0,0:10:56.48,0:11:02.58,Chinese,,0,0,0,,test 的两个参数如何设置呢
Dialogue: 0,0:11:03.16,0:11:04.96,English,,0,0,0,,So what you'll typically see is a test
Dialogue: 0,0:11:03.16,0:11:04.96,Chinese,,0,0,0,,你一般会看到 test 是这样使用的
Dialogue: 0,0:11:06.60,0:11:13.40,English,,0,0,0,,Where both arguments are the same so testq %rax, %rax
Dialogue: 0,0:11:06.60,0:11:13.40,Chinese,,0,0,0,,两个参数都相同，所以是 testq ％rax, ％rax
Dialogue: 0,0:11:14.24,0:11:20.34,English,,0,0,0,,Where so that you're just any register to itself and one property the end operation is
Dialogue: 0,0:11:14.24,0:11:20.34,Chinese,,0,0,0,,两个参数是相同的寄存器
Dialogue: 0,0:11:21.12,0:11:27.10,English,,0,0,0,,It's what they test item potent adding ending two things the same things together gives you that same thing
Dialogue: 0,0:11:21.12,0:11:27.10,Chinese,,0,0,0,,这就是test功能强大的地方，可以把两个参数用一个相同的参数，来替代得到（测试）一个参数的效果
Dialogue: 0,0:11:31.62,0:11:33.46,English,,0,0,0,,So we can see these
Dialogue: 0,0:11:31.62,0:11:33.46,Chinese,,0,0,0,,所以我们可以看到这些
Dialogue: 0,0:11:33.46,0:11:35.46,English,,0,0,0,,And now
Dialogue: 0,0:11:33.46,0:11:35.46,Chinese,,0,0,0,,现在
Dialogue: 0,0:11:35.86,0:11:38.26,English,,0,0,0,,So I told you that's how the condition codes get set
Dialogue: 0,0:11:35.86,0:11:38.26,Chinese,,0,0,0,,我来告诉你如何设置条件码
Dialogue: 0,0:11:38.26,0:11:41.14,English,,0,0,0,,Now how do you actually read them, how do you make use of them
Dialogue: 0,0:11:38.26,0:11:41.14,Chinese,,0,0,0,,现在的问题是你怎么读取它们以及读取后如何使用它们
Dialogue: 0,0:11:41.62,0:11:45.32,English,,0,0,0,,Well there's two in principle you can actually extract
Dialogue: 0,0:11:41.62,0:11:45.32,Chinese,,0,0,0,,那么原则上你可以
Dialogue: 0,0:11:45.36,0:11:51.00,English,,0,0,0,,And get the condition code values directly out of this special status register
Dialogue: 0,0:11:45.36,0:11:51.00,Chinese,,0,0,0,,直接从这个特殊的状态寄存器中提取获得获条件码的值
Dialogue: 0,0:11:51.00,0:11:53.16,English,,0,0,0,,But that's very unusual to do that
Dialogue: 0,0:11:51.00,0:11:53.16,Chinese,,0,0,0,,但一般不这样做
Dialogue: 0,0:11:53.68,0:12:02.72,English,,0,0,0,,What's more common is you either try to read it in and set a 1 bit flag based on the result in a read some other register
Dialogue: 0,0:11:53.68,0:12:02.72,Chinese,,0,0,0,,常见的做法是你要么尝试读取它，要根据读取其他寄存器的结果设置 1 位标志
Dialogue: 0,0:12:03.06,0:12:05.48,English,,0,0,0,,Or you try do a conditional branch
Dialogue: 0,0:12:03.06,0:12:05.48,Chinese,,0,0,0,,或者你尝试做一个条件分支
Dialogue: 0,0:12:06.64,0:12:09.56,English,,0,0,0,,So the first example where you try to read it
Dialogue: 0,0:12:06.64,0:12:09.56,Chinese,,0,0,0,,所以你尝试阅读第一个例子时
Dialogue: 0,0:12:10.08,0:12:13.92,English,,0,0,0,,In a way that you can make use of it is done with the set instruction
Dialogue: 0,0:12:10.08,0:12:13.92,Chinese,,0,0,0,,在某种程度上，你可以使用 set 指令完成它
Dialogue: 0,0:12:14.84,0:12:18.70,English,,0,0,0,,And you'll see there's a whole range of set instructions
Dialogue: 0,0:12:14.84,0:12:18.70,Chinese,,0,0,0,,而且你会看到有一系列的 set 指令
Dialogue: 0,0:12:19.32,0:12:25.98,English,,0,0,0,,But their only difference is really just what the condition they're setting based on
Dialogue: 0,0:12:19.32,0:12:25.98,Chinese,,0,0,0,,但这 set 指令唯一的区别就在于它们所基于的条件
Dialogue: 0,0:12:27.28,0:12:36.06,English,,0,0,0,,So the what a set instruction does, it sets a single byte of a single register to either 1 or 0
Dialogue: 0,0:12:27.28,0:12:36.06,Chinese,,0,0,0,,因此 set 指令的作用是将单个寄存器的单个字节设置为 1 或 0
Dialogue: 0,0:12:36.90,0:12:43.90,English,,0,0,0,,And the basis for whether it's sets it to 1 or 0 is a based on
Dialogue: 0,0:12:36.90,0:12:43.90,Chinese,,0,0,0,,而判断它将其设置为 1 还是 0 是基于
Dialogue: 0,0:12:43.90,0:12:47.02,English,,0,0,0,,What the condition codes are as essence what's the
Dialogue: 0,0:12:43.90,0:12:47.02,Chinese,,0,0,0,,条件码的值
Dialogue: 0,0:12:47.62,0:12:51.10,English,,0,0,0,,What happened your most recent instruction before hand
Dialogue: 0,0:12:47.62,0:12:51.10,Chinese,,0,0,0,,最近的指令做了什么事
Dialogue: 0,0:12:51.10,0:12:58.44,English,,0,0,0,,was it a arithmetic instruction or a set instruction or a test instruction or a compare instruction
Dialogue: 0,0:12:51.10,0:12:58.44,Chinese,,0,0,0,,它是算术指令？set 指令？ test指令？亦或是 cmp 指令？
Dialogue: 0,0:12:59.12,0:13:05.52,English,,0,0,0,,And as you can see there's they're all based on some logical combination of these condition codes
Dialogue: 0,0:12:59.12,0:13:05.52,Chinese,,0,0,0,,正如你 ppt 上所看到的，set 指令都基于这些条件码的逻辑组合而进行设置的
Dialogue: 0,0:13:06.04,0:13:10.04,English,,0,0,0,,That correspond to what the names imply
Dialogue: 0,0:13:06.04,0:13:10.04,Chinese,,0,0,0,,这些逻辑组合和 set 指令的名字相一致
Dialogue: 0,0:13:10.44,0:13:17.06,English,,0,0,0,,So for example the sets instruction is true,if the sign flag is true
Dialogue: 0,0:13:10.44,0:13:17.06,Chinese,,0,0,0,,例如符号标志为真，则 sets 指令为真
Dialogue: 0,0:13:17.36,0:13:19.96,English,,0,0,0,,Meaning that the most recent result was negative
Dialogue: 0,0:13:17.36,0:13:19.96,Chinese,,0,0,0,,意味着最近的运算结果是负数
Dialogue: 0,0:13:20.78,0:13:27.46,English,,0,0,0,,And there's other ones less than less than or equal to two's complement comparisons
Dialogue: 0,0:13:20.78,0:13:27.46,Chinese,,0,0,0,,还有其他的，比如用于补码有符号数比较的小于（setl），小于等于（setle）
Dialogue: 0,0:13:27.90,0:13:33.64,English,,0,0,0,,And they have to take into consideration did the most recent result cause an overflow or not
Dialogue: 0,0:13:27.90,0:13:33.64,Chinese,,0,0,0,,并且它们必须考虑到最近的结果是否导致了溢出
Dialogue: 0,0:13:33.64,0:13:36.96,English,,0,0,0,,Because that will affect the result of the comparison
Dialogue: 0,0:13:33.64,0:13:36.96,Chinese,,0,0,0,,因为那会影响比较的结果
Dialogue: 0,0:13:38.58,0:13:43.38,English,,0,0,0,,So that's part of the reason we tortured you with understanding two's complement arithmetic
Dialogue: 0,0:13:38.58,0:13:43.38,Chinese,,0,0,0,,这就是我们让你们理解二进制补码算法的部分原因
Dialogue: 0,0:13:43.38,0:13:47.70,English,,0,0,0,,And how you compare results and making you understand the bit-level behavior
Dialogue: 0,0:13:43.38,0:13:47.70,Chinese,,0,0,0,,以及如何比较结果并让你了解位级行为
Dialogue: 0,0:13:48.08,0:13:50.48,English,,0,0,0,,So that you can understand what these instructions do
Dialogue: 0,0:13:48.08,0:13:50.48,Chinese,,0,0,0,,这样你就可以理解这些指令的作用
Dialogue: 0,0:13:52.40,0:13:55.06,English,,0,0,0,,So we're cruel but we have a reason for our cruelty
Dialogue: 0,0:13:52.40,0:13:55.06,Chinese,,0,0,0,,所以我们很严格，但我们有严格的理由
Dialogue: 0,0:13:57.50,0:14:02.69,English,,0,0,0,,So, you say 1 byte, how do you deal with 1 byte, well here's another thing we didn't tell you yet
Dialogue: 0,0:13:57.50,0:14:02.69,Chinese,,0,0,0,,所以你说到 1 字节，如何处理 1 字节，这是另一件我们还没告诉你的事情
Dialogue: 0,0:14:03.24,0:14:05.76,English,,0,0,0,,And we're going to keep telling you more stuff over and over again
Dialogue: 0,0:14:03.24,0:14:05.76,Chinese,,0,0,0,,我们会一遍又一遍地告诉你更多的东西
Dialogue: 0,0:14:06.14,0:14:09.30,English,,0,0,0,,It turns out for every one of these 16 registers
Dialogue: 0,0:14:06.14,0:14:09.30,Chinese,,0,0,0,,这 16 个寄存器中的每一个
Dialogue: 0,0:14:09.76,0:14:15.12,English,,0,0,0,,You can directly set the lowest order byte of it to either 0 or 1
Dialogue: 0,0:14:09.76,0:14:15.12,Chinese,,0,0,0,,你都可以直接将其最低位字节设置为 0 或 1
Dialogue: 0,0:14:15.66,0:14:20.92,English,,0,0,0,,And it won't affect it, it turns out it doesn't affect any of the other 7 bytes of that register
Dialogue: 0,0:14:15.66,0:14:20.92,Chinese,,0,0,0,,而这一行为不会影响到该寄存器的其他 7 个字节
Dialogue: 0,0:14:22.02,0:14:24.14,English,,0,0,0,,So and they all have quirky names
Dialogue: 0,0:14:22.02,0:14:24.14,Chinese,,0,0,0,,所以他们都有古怪的名字
Dialogue: 0,0:14:25.18,0:14:28.88,English,,0,0,0,,The l means low in there
Dialogue: 0,0:14:25.18,0:14:28.88,Chinese,,0,0,0,,l 意味着低位
Dialogue: 0,0:14:32.14,0:14:38.12,English,,0,0,0,,So here's an example of using putting all this together to do something that's vaguely useful
Dialogue: 0,0:14:32.14,0:14:38.12,Chinese,,0,0,0,,这是一个例子，它用到了我们这节课学到的很有用的知识
Dialogue: 0,0:14:40.24,0:14:47.90,English,,0,0,0,,Suppose I want to function gt, that will take two numbers and compare them and set the result
Dialogue: 0,0:14:40.24,0:14:47.90,Chinese,,0,0,0,,假设我想运行 gt，它会接收两个数字并比较它们最后设置结果
Dialogue: 0,0:14:48.20,0:14:54.00,English,,0,0,0,,Return result value of 1 if x > y  and 0 otherwise
Dialogue: 0,0:14:48.20,0:14:54.00,Chinese,,0,0,0,,如果 x > y 则返回结果值 1，否则返回 0
Dialogue: 0,0:14:56.04,0:14:59.76,English,,0,0,0,,And so here's the assembly code with some tabbing problems
Dialogue: 0,0:14:56.04,0:14:59.76,Chinese,,0,0,0,,所以这里的汇编代码有一些制表符（对齐）问题
Dialogue: 0,0:15:03.26,0:15:13.38,English,,0,0,0,,Success nothing bugs me hold on
Dialogue: 0,0:15:03.26,0:15:13.38,Chinese,,0,0,0,,我没有遇到任何错误
Dialogue: 0,0:15:13.40,0:15:31.70,English,,0,0,0,,I might know try and do this. well no
Dialogue: 0,0:15:13.40,0:15:31.70,Chinese,,0,0,0,,我试着解决一下。好吧~没有解决
Dialogue: 0,0:15:31.72,0:15:33.18,English,,0,0,0,,I will fix this later
Dialogue: 0,0:15:31.72,0:15:33.18,Chinese,,0,0,0,,我稍后会解决这个问题
Dialogue: 0,0:15:33.20,0:15:35.94,English,,0,0,0,,Anyways it's not the end of the world
Dialogue: 0,0:15:33.20,0:15:35.94,Chinese,,0,0,0,,无论如何，它不是世界末日
Dialogue: 0,0:15:41.52,0:15:49.00,English,,0,0,0,,Normally an assembly code one thing you've noticed is that the instructions are indented by a tab space
Dialogue: 0,0:15:41.52,0:15:49.00,Chinese,,0,0,0,,通常，汇编代码指令是由 Tab 键缩进的
Dialogue: 0,0:15:49.04,0:15:52.32,English,,0,0,0,,And the only thing,that's way over in the left margin labels
Dialogue: 0,0:15:49.04,0:15:52.32,Chinese,,0,0,0,,唯一（要注意）的事，就是在左边距标签上
Dialogue: 0,0:15:52.32,0:15:59.92,English,,0,0,0,,So this is just sort of this what the the assembler is actually quite tolerant of formatting things
Dialogue: 0,0:15:52.32,0:15:59.92,Chinese,,0,0,0,,所以这就是汇编程序实际上非常容忍格式化的东西
Dialogue: 0,0:15:59.92,0:16:01.40,English,,0,0,0,,But this isn't the way it normally book
Dialogue: 0,0:15:59.92,0:16:01.40,Chinese,,0,0,0,,但这不是通常记录的方式
Dialogue: 0,0:16:02.48,0:16:07.36,English,,0,0,0,,So anyways the point is there's a comparing the one rule that
Dialogue: 0,0:16:02.48,0:16:07.36,Chinese,,0,0,0,,所以无论如何，关键在于比较的规则
Dialogue: 0,0:16:07.36,0:16:10.20,English,,0,0,0,,You need to understand about procedures is that
Dialogue: 0,0:16:07.36,0:16:10.20,Chinese,,0,0,0,,你需要了解的过程是这个
Dialogue: 0,0:16:10.30,0:16:16.20,English,,0,0,0,,The first argument is passed in register %rdi and the second register %rsi
Dialogue: 0,0:16:10.30,0:16:16.20,Chinese,,0,0,0,,第一个参数在寄存器在 ％rdi 中，第二个在寄存器 ％rsi 中
Dialogue: 0,0:16:16.68,0:16:23.10,English,,0,0,0,,And that if I'm going to return a result from a function I do that by storing it and register %rax before I return
Dialogue: 0,0:16:16.68,0:16:23.10,Chinese,,0,0,0,,如果我要从函数中返回结果，我会在返回之前将结果存在 %rax 寄存器中
Dialogue: 0,0:16:24.62,0:16:28.36,English,,0,0,0,,So the first instruction compares these two
Dialogue: 0,0:16:24.62,0:16:28.36,Chinese,,0,0,0,,所以第一条指令比较了这两个（值）
Dialogue: 0,0:16:28.82,0:16:31.06,English,,0,0,0,,And you notice how I flip the order that
Dialogue: 0,0:16:28.82,0:16:31.06,Chinese,,0,0,0,,注意我是如何翻转顺序的
Dialogue: 0,0:16:31.36,0:16:35.66,English,,0,0,0,,It sets %rsi which is y, and %rdi which is x
Dialogue: 0,0:16:31.36,0:16:35.66,Chinese,,0,0,0,,它设置 ％rsi 为 y，％rdi 为 x
Dialogue: 0,0:16:36.48,0:16:39.14,English,,0,0,0,,But when I annotate it I say x to y
Dialogue: 0,0:16:36.48,0:16:39.14,Chinese,,0,0,0,,但是当我注释它时，我会说 x 到 y
Dialogue: 0,0:16:39.14,0:16:42.16,English,,0,0,0,,So that I mentally am thinking in the order
Dialogue: 0,0:16:39.14,0:16:42.16,Chinese,,0,0,0,,所以我思考时是以正常的顺序
Dialogue: 0,0:16:42.16,0:16:45.30,English,,0,0,0,,That the actual comparison is made rather than the way they're listed
Dialogue: 0,0:16:42.16,0:16:45.30,Chinese,,0,0,0,,进行比较而不是以汇编代码中的参数顺序
Dialogue: 0,0:16:45.98,0:16:50.04,English,,0,0,0,,So I always do that when I'm looking at code to help me flip those two around
Dialogue: 0,0:16:45.98,0:16:50.04,Chinese,,0,0,0,,因此当我阅读代码时我一直会这么做，这可以帮助我以正常的顺序进行思考
Dialogue: 0,0:16:52.46,0:16:58.18,English,,0,0,0,,And then here's our instruction.So that compare instruction set these four condition code register
Dialogue: 0,0:16:52.46,0:16:58.18,Chinese,,0,0,0,,然后这是我们的指令。所以 cmp 指令设置这四个条件码寄存器
Dialogue: 0,0:16:58.78,0:17:06.58,English,,0,0,0,,And now the setg sets... Now set this single byte register,the lowest byte of %rax to 1
Dialogue: 0,0:16:58.78,0:17:06.58,Chinese,,0,0,0,,现在 setg 设置这个单字节寄存器（%al），即 ％rax 的最低字节为 1
Dialogue: 0,0:17:06.62,0:17:11.00,English,,0,0,0,,If the result was the comparison was greater
Dialogue: 0,0:17:06.62,0:17:11.00,Chinese,,0,0,0,,如果比较的结果是大于（x>y）的话
Dialogue: 0,0:17:12.24,0:17:16.24,English,,0,0,0,,So according to this rule
Dialogue: 0,0:17:12.24,0:17:16.24,Chinese,,0,0,0,,所以根据这条规则
Dialogue: 0,0:17:19.12,0:17:28.52,English,,0,0,0,,And the factor that was to set just as 1 byte of this 8 bytes register to either 0 or 1
Dialogue: 0,0:17:19.12,0:17:28.52,Chinese,,0,0,0,,并会将该 8 字节寄存器的最低 1 字节设置为 0 或 1
Dialogue: 0,0:17:29.06,0:17:34.86,English,,0,0,0,,Now my problem is that these remaining 7 bytes have whatever happened to be there before
Dialogue: 0,0:17:29.06,0:17:34.86,Chinese,,0,0,0,,现在我的问题是剩余的 7 个字节如何处理
Dialogue: 0,0:17:35.34,0:17:36.88,English,,0,0,0,,And I want it to be all zeros
Dialogue: 0,0:17:35.34,0:17:36.88,Chinese,,0,0,0,,而且我希望它全部为零
Dialogue: 0,0:17:37.78,0:17:41.30,English,,0,0,0,,So the the way it does it is a bit weird
Dialogue: 0,0:17:37.78,0:17:41.30,Chinese,,0,0,0,,所以它的实现方式有点奇怪
Dialogue: 0,0:17:43.54,0:17:48.26,English,,0,0,0,,There's an instruction called move with zero extension byte to long
Dialogue: 0,0:17:43.54,0:17:48.26,Chinese,,0,0,0,,有一个具有从单字节到四字节的零扩展（功能）的 mov 指令
Dialogue: 0,0:17:50.84,0:17:53.02,English,,0,0,0,,Now you get to know these better if with time
Dialogue: 0,0:17:50.84,0:17:53.02,Chinese,,0,0,0,,现在，如果有时间的话，你会更好地了解这些
Dialogue: 0,0:17:54.10,0:17:54.82,English,,0,0,0,,Let me um...
Dialogue: 0,0:17:54.10,0:17:54.82,Chinese,,0,0,0,,让我来......
Dialogue: 0,0:17:57.62,0:18:01.16,English,,0,0,0,,That means is you can actually copy a byte from any place
Dialogue: 0,0:17:57.62,0:18:01.16,Chinese,,0,0,0,,这意味着你实际上可以从任何地方复制一个字节
Dialogue: 0,0:18:01.92,0:18:05.72,English,,0,0,0,,Like the low order or byte of some other register into a new register
Dialogue: 0,0:18:01.92,0:18:05.72,Chinese,,0,0,0,,像其他一些寄存器的低位或字节进入新的寄存器一样
Dialogue: 0,0:18:06.50,0:18:11.48,English,,0,0,0,,And you'll put zeros to the left of it,that's what they mean by zero extension
Dialogue: 0,0:18:06.50,0:18:11.48,Chinese,,0,0,0,,并且你会在它的左边放置零，这就是零扩展的含义
Dialogue: 0,0:18:12.54,0:18:17.82,English,,0,0,0,,That seems logical but one thing you'll notice is the destination here is %eax
Dialogue: 0,0:18:12.54,0:18:17.82,Chinese,,0,0,0,,这似乎合乎逻辑，但你会注意到的一件事是这里的目标寄存器是 ％eax
Dialogue: 0,0:18:18.68,0:18:21.38,English,,0,0,0,,Which you'll recall although it doesn't show here
Dialogue: 0,0:18:18.68,0:18:21.38,Chinese,,0,0,0,,你肯定记得它虽然 PPT 上没有显示
Dialogue: 0,0:18:21.38,0:18:25.76,English,,0,0,0,,That's the lower 32 bits of register %rax
Dialogue: 0,0:18:21.38,0:18:25.76,Chinese,,0,0,0,,它是寄存器 ％rax 的低 32 位
Dialogue: 0,0:18:27.50,0:18:32.62,English,,0,0,0,,And then you'd say well that only got me halfway there right
Dialogue: 0,0:18:27.50,0:18:32.62,Chinese,,0,0,0,,然后你会说好，只有在那里的一半
Dialogue: 0,0:18:32.62,0:18:35.98,English,,0,0,0,,How do I make sure the upper 32 bits are set to 0
Dialogue: 0,0:18:32.62,0:18:35.98,Chinese,,0,0,0,,如何确保高 32 位被设置为 0
Dialogue: 0,0:18:36.58,0:18:44.90,English,,0,0,0,,Well one of the weird quirks of x86-64 is for any computation
Dialogue: 0,0:18:36.58,0:18:44.90,Chinese,,0,0,0,,好吧是这个样子的，x86-64 的有个奇怪的地方，那就是任何计算
Dialogue: 0,0:18:45.40,0:18:48.96,English,,0,0,0,,Where the result is a 32-bit result
Dialogue: 0,0:18:45.40,0:18:48.96,Chinese,,0,0,0,,结果是 32 位的结果
Dialogue: 0,0:18:49.76,0:18:53.72,English,,0,0,0,,It will add zeros to the remaining 32 bits of the register
Dialogue: 0,0:18:49.76,0:18:53.72,Chinese,,0,0,0,,它会把寄存器的其余 32 位设置为 0
Dialogue: 0,0:18:55.04,0:18:59.28,English,,0,0,0,,And it's different for example the byte level operations only affect the bytes
Dialogue: 0,0:18:55.04,0:18:59.28,Chinese,,0,0,0,,并且它是不同的，例如字节级操作仅影响要设置的那个字节位置（而不会设置其他位）
Dialogue: 0,0:18:59.52,0:19:07.20,English,,0,0,0,,The two byte or operations like what you'd have if the data type were short
Dialogue: 0,0:18:59.52,0:19:07.20,Chinese,,0,0,0,,如果数据（操作数）类型是 short，那么两个字节或操作就像你所想的一样
Dialogue: 0,0:19:07.66,0:19:09.08,English,,0,0,0,,Only affect those two bytes
Dialogue: 0,0:19:07.66,0:19:09.08,Chinese,,0,0,0,,只会影响要操作的那两个字节
Dialogue: 0,0:19:09.72,0:19:13.22,English,,0,0,0,,But the four byte instructions set the upper bytes to 0
Dialogue: 0,0:19:09.72,0:19:13.22,Chinese,,0,0,0,,但是四字节指令会将剩余的高位字节设置为 0
Dialogue: 0,0:19:13.78,0:19:18.28,English,,0,0,0,,And that was some somebody at AMD and I don't know who it is
Dialogue: 0,0:19:13.78,0:19:18.28,Chinese,,0,0,0,,这是 AMD 的某些人设定的规则，具体我不知道是谁
Dialogue: 0,0:19:18.88,0:19:23.40,English,,0,0,0,,Decided this was a good idea and it might be a good idea but it's really confusing
Dialogue: 0,0:19:18.88,0:19:23.40,Chinese,,0,0,0,,认为这是一个好主意（并最终决定采用），这可能是一个好主意，但它确实很让人费解
Dialogue: 0,0:19:24.84,0:19:29.16,English,,0,0,0,,But that's something you'll have to just sort of remember in the back your mind
Dialogue: 0,0:19:24.84,0:19:29.16,Chinese,,0,0,0,,但是你必须想起这个规则
Dialogue: 0,0:19:29.16,0:19:30.70,English,,0,0,0,,When you see things like this
Dialogue: 0,0:19:29.16,0:19:30.70,Chinese,,0,0,0,,当你看到这样的代码时
Dialogue: 0,0:19:31.80,0:19:37.72,English,,0,0,0,,So the effect of this instruction is to take this one bit result,which is the lower bit of register %rax
Dialogue: 0,0:19:31.80,0:19:37.72,Chinese,,0,0,0,,因此该指令的作用是取一位结果，即寄存器 ％rax 的低位
Dialogue: 0,0:19:38.90,0:19:42.06,English,,0,0,0,,Copy it to the same place as it already is
Dialogue: 0,0:19:38.90,0:19:42.06,Chinese,,0,0,0,,将其复制到原来的位置
Dialogue: 0,0:19:42.86,0:19:46.60,English,,0,0,0,,But then set the remaining 7 bytes to 0,which is what we want
Dialogue: 0,0:19:42.86,0:19:46.60,Chinese,,0,0,0,,然后将剩余的 7 个字节设置为 0，这就是我们想要的
Dialogue: 0,0:19:48.00,0:19:49.88,English,,0,0,0,,So you'll see this pattern quite often
Dialogue: 0,0:19:48.00,0:19:49.88,Chinese,,0,0,0,,所以你会经常看到这种模式
Dialogue: 0,0:19:54.62,0:19:55.72,English,,0,0,0,,Question? got it
Dialogue: 0,0:19:54.62,0:19:55.72,Chinese,,0,0,0,,有问题吗？没有
Dialogue: 0,0:19:56.62,0:20:00.60,English,,0,0,0,,Okay so now that's sort of sometimes I want to do this
Dialogue: 0,0:19:56.62,0:20:00.60,Chinese,,0,0,0,,好，现在有时我想这样做
Dialogue: 0,0:20:01.26,0:20:05.36,English,,0,0,0,,I just want to get a one bit flag as a result of the comparison
Dialogue: 0,0:20:01.26,0:20:05.36,Chinese,,0,0,0,,我只想获得一位标志来作为比较的结果
Dialogue: 0,0:20:06.12,0:20:11.90,English,,0,0,0,,But more generally I want to do something with that information and not just set one bit
Dialogue: 0,0:20:06.12,0:20:11.90,Chinese,,0,0,0,,但更一般地说，我想用这些信息做一些事情而不只是设置某一位
Dialogue: 0,0:20:13.08,0:20:18.82,English,,0,0,0,,So the simplest version is what about a conditional  and if and possibly in else
Dialogue: 0,0:20:13.08,0:20:18.82,Chinese,,0,0,0,,条件语句最简单的情况可能是 if 和可能有的 else
Dialogue: 0,0:20:20.54,0:20:24.96,English,,0,0,0,,Well that's done by this actually two ways to do it
Dialogue: 0,0:20:20.54,0:20:24.96,Chinese,,0,0,0,,实际上有两种实现方式
Dialogue: 0,0:20:24.99,0:20:28.84,English,,0,0,0,,So we'll go through the sort of general purpose traditional way
Dialogue: 0,0:20:24.99,0:20:28.84,Chinese,,0,0,0,,我们先学习那种通用的传统方式
Dialogue: 0,0:20:29.22,0:20:34.16,English,,0,0,0,,And then we'll show the more specialized newer way and we'll compare those
Dialogue: 0,0:20:29.22,0:20:34.16,Chinese,,0,0,0,,然后我们将展示更特别的新方式，并对其进行比较
Dialogue: 0,0:20:34.30,0:20:38.30,English,,0,0,0,,So the traditional way is to use what's known as a jump instruction
Dialogue: 0,0:20:34.30,0:20:38.30,Chinese,,0,0,0,,传统的方法是使用我们熟知的跳转指令
Dialogue: 0,0:20:38.78,0:20:43.26,English,,0,0,0,,And the jump instruction normally instructions execute in a particular order
Dialogue: 0,0:20:38.78,0:20:43.26,Chinese,,0,0,0,,并且跳转指令通常以特定顺序执行
Dialogue: 0,0:20:43.74,0:20:47.62,English,,0,0,0,,Just like when you're writing a program and you write a series of statements
Dialogue: 0,0:20:43.74,0:20:47.62,Chinese,,0,0,0,,就像你正在编写一个程序并编写了一系列语句
Dialogue: 0,0:20:48.18,0:20:50.02,English,,0,0,0,,They execute one after the next
Dialogue: 0,0:20:48.18,0:20:50.02,Chinese,,0,0,0,,他们一行接一行地执行一样
Dialogue: 0,0:20:51.00,0:20:55.12,English,,0,0,0,,A jump instruction is a way you can go from wherever you are to someplace else
Dialogue: 0,0:20:51.00,0:20:55.12,Chinese,,0,0,0,,跳转指令可以让你从任何地方到其他地方
Dialogue: 0,0:20:55.66,0:21:02.48,English,,0,0,0,,And either skip over some instructions or jump back to some other a previous position or wherever
Dialogue: 0,0:20:55.66,0:21:02.48,Chinese,,0,0,0,,它既可以跳过某些指令，也可以跳回到之前的某些位置或任何位置
Dialogue: 0,0:21:03.44,0:21:08.56,English,,0,0,0,,And there's two kinds of jumps ones that are unconditional whether several kinds
Dialogue: 0,0:21:03.44,0:21:08.56,Chinese,,0,0,0,,并且有两种跳转方式，其中一种是无条件跳转
Dialogue: 0,0:21:08.70,0:21:12.56,English,,0,0,0,,But an unconditional jump means when I say jump you jump
Dialogue: 0,0:21:08.70,0:21:12.56,Chinese,,0,0,0,,无条件跳跃意味着当我想跳转时就可以跳转
Dialogue: 0,0:21:13.58,0:21:17.26,English,,0,0,0,,But there's others conditional jumps that will actually only do that jumping
Dialogue: 0,0:21:13.58,0:21:17.26,Chinese,,0,0,0,,但是另一种有条件跳转只有
Dialogue: 0,0:21:17.26,0:21:20.08,English,,0,0,0,,If the condition codes are set appropriately
Dialogue: 0,0:21:17.26,0:21:20.08,Chinese,,0,0,0,,当条件码满足时才会跳转
Dialogue: 0,0:21:20.58,0:21:24.06,English,,0,0,0,,And you'll see that the names of these jump instructions are the same as
Dialogue: 0,0:21:20.58,0:21:24.06,Chinese,,0,0,0,,你会看到这些跳转指令的命名与
Dialogue: 0,0:21:24.06,0:21:26.24,English,,0,0,0,,the set instructions with the same conditions
Dialogue: 0,0:21:24.06,0:21:26.24,Chinese,,0,0,0,,（另一些）设置指令有相同的条件码
Dialogue: 0,0:21:26.92,0:21:33.34,English,,0,0,0,,So there's a variety of different reasons that the program may be given to either jump or not jump
Dialogue: 0,0:21:26.92,0:21:33.34,Chinese,,0,0,0,,因此，有许多不同的原因可以让程序跳转或不跳转
Dialogue: 0,0:21:38.48,0:21:43.00,English,,0,0,0,,So I'm going to use this one example to show you several different versions of it
Dialogue: 0,0:21:38.48,0:21:43.00,Chinese,,0,0,0,,我会使用这个例子向你展示它的几个不同版本
Dialogue: 0,0:21:43.76,0:21:49.30,English,,0,0,0,,And like everything you'll see here these particular programs aren't that useful
Dialogue: 0,0:21:43.76,0:21:49.30,Chinese,,0,0,0,,这里展示的例子没有什么实际意义
Dialogue: 0,0:21:49.30,0:21:51.54,English,,0,0,0,,But they illustrate ideas
Dialogue: 0,0:21:49.30,0:21:51.54,Chinese,,0,0,0,,但他们说明了想法
Dialogue: 0,0:21:52.24,0:22:00.84,English,,0,0,0,,So imagine I wanted to compute the the difference of two values and then take their absolute value
Dialogue: 0,0:21:52.24,0:22:00.84,Chinese,,0,0,0,,所以想象一下，我想计算两个值的差值然后取其绝对值
Dialogue: 0,0:22:01.78,0:22:04.40,English,,0,0,0,,So there's various ways you can imagine doing it
Dialogue: 0,0:22:01.78,0:22:04.40,Chinese,,0,0,0,,你可以想出有各种各样的方法去做
Dialogue: 0,0:22:04.40,0:22:09.48,English,,0,0,0,,By the way I'm going to do it is decide to either subtract y from x or x from y
Dialogue: 0,0:22:04.40,0:22:09.48,Chinese,,0,0,0,,顺便说一句，我要做的就是决定从 x 中减去 y 或从 y 减去 x
Dialogue: 0,0:22:09.48,0:22:12.38,English,,0,0,0,,Depending on the relative values of those two
Dialogue: 0,0:22:09.48,0:22:12.38,Chinese,,0,0,0,,取决于这两者的相对值
Dialogue: 0,0:22:12.96,0:22:16.20,English,,0,0,0,,And of course the astute observer will notice that
Dialogue: 0,0:22:12.96,0:22:16.20,Chinese,,0,0,0,,当然，细心的观察者会注意到这一点
Dialogue: 0,0:22:17.20,0:22:20.68,English,,0,0,0,,This has problems if you have a team in somewhere
Dialogue: 0,0:22:17.20,0:22:20.68,Chinese,,0,0,0,,这会有一些问题
Dialogue: 0,0:22:22.10,0:22:26.22,English,,0,0,0,,If the result because there's no absolute value but we're not going to worry about that
Dialogue: 0,0:22:22.10,0:22:26.22,Chinese,,0,0,0,,如果结果没有绝对值，但我们不会担心这一点
Dialogue: 0,0:22:27.70,0:22:29.86,English,,0,0,0,,Um...so...
Dialogue: 0,0:22:27.70,0:22:29.86,Chinese,,0,0,0,,嗯...所以...
Dialogue: 0,0:22:30.16,0:22:34.56,English,,0,0,0,,In other words I just want to say if x is greater than y, then I want to subtract y from x
Dialogue: 0,0:22:30.16,0:22:34.56,Chinese,,0,0,0,,换句话说，我只想说如果 x 大于 y，那么我想从 x 中减去 y
Dialogue: 0,0:22:35.34,0:22:38.60,English,,0,0,0,,And if x is less than or equal to y, I want to subtract x from y
Dialogue: 0,0:22:35.34,0:22:38.60,Chinese,,0,0,0,,如果 x 小于或等于 y，我想从 y 中减去 x
Dialogue: 0,0:22:39.74,0:22:44.86,English,,0,0,0,,And here's the code for it where the blue and the red or color coding the different parts of it
Dialogue: 0,0:22:39.74,0:22:44.86,Chinese,,0,0,0,,这里是代码，蓝色和红色或其他颜色的代码表示它的不同部分
Dialogue: 0,0:22:45.76,0:22:51.38,English,,0,0,0,,So here you see the compare instruction and again I've written them out
Dialogue: 0,0:22:45.76,0:22:51.38,Chinese,,0,0,0,,在这里你看到了比较指令，我再次把它们写出来了
Dialogue: 0,0:22:53.44,0:22:58.04,English,,0,0,0,,In the reverse order to help me keep track of what the comparison is
Dialogue: 0,0:22:53.44,0:22:58.04,Chinese,,0,0,0,,以相反的顺序写下来有助于我跟踪比较的什么
Dialogue: 0,0:22:58.52,0:23:03.60,English,,0,0,0,,And it says I'm going to compare x and y and if x is less than or equal to y
Dialogue: 0,0:22:58.52,0:23:03.60,Chinese,,0,0,0,,代码含义是我要比较 x 和 y 以及 x 是否小于或等于 y
Dialogue: 0,0:23:03.74,0:23:08.68,English,,0,0,0,,I want to jump to a location specified by this label L4
Dialogue: 0,0:23:03.74,0:23:08.68,Chinese,,0,0,0,,我想跳转到标签 l4 指定的位置
Dialogue: 0,0:23:09.40,0:23:13.68,English,,0,0,0,,And so in general in assembly code if you give a name and then a colon
Dialogue: 0,0:23:09.40,0:23:13.68,Chinese,,0,0,0,,因此通常在汇编代码中，如果你给出一个名称紧跟着是冒号
Dialogue: 0,0:23:13.98,0:23:17.24,English,,0,0,0,,What's to the left of that is called a label
Dialogue: 0,0:23:13.98,0:23:17.24,Chinese,,0,0,0,,那么左边的内容叫做标签
Dialogue: 0,0:23:17.62,0:23:23.50,English,,0,0,0,,And it's just a tag that it's only visible in the assembly code, it's not actually in the object code
Dialogue: 0,0:23:17.62,0:23:23.50,Chinese,,0,0,0,,它只是一个标签，它只在汇编代码中可见，\N它实际上并不在目标代码中
Dialogue: 0,0:23:24.10,0:23:32.16,English,,0,0,0,,That will later I'll be used to compute an address for determining that will encode
Dialogue: 0,0:23:24.10,0:23:32.16,Chinese,,0,0,0,,稍后我会计算目的地址，这地址将用于编码
Dialogue: 0,0:23:32.16,0:23:34.62,English,,0,0,0,,Where this jump will actually land
Dialogue: 0,0:23:32.16,0:23:34.62,Chinese,,0,0,0,,实际上跳转到的位置
Dialogue: 0,0:23:35.44,0:23:36.86,English,,0,0,0,,When you're looking at assembly code
Dialogue: 0,0:23:35.44,0:23:36.86,Chinese,,0,0,0,,当你在看汇编代码时
Dialogue: 0,0:23:36.86,0:23:43.90,English,,0,0,0,,One of the features it provides is a little bit easier way to understand it then to look at addresses
Dialogue: 0,0:23:36.86,0:23:43.90,Chinese,,0,0,0,,它提供的功能之一是更容易理解它然后找到地址
Dialogue: 0,0:23:44.32,0:23:49.00,English,,0,0,0,,And so it just tells you to be looking at that the jump would occur to this position
Dialogue: 0,0:23:44.32,0:23:49.00,Chinese,,0,0,0,,所以它只是告诉你这个位置会发生跳转
Dialogue: 0,0:23:50.58,0:23:52.78,English,,0,0,0,,And what you'll see here is
Dialogue: 0,0:23:50.58,0:23:52.78,Chinese,,0,0,0,,你会在这里看到的是什么
Dialogue: 0,0:23:53.76,0:23:57.02,English,,0,0,0,,The in these two branches the blue code versus the red
Dialogue: 0,0:23:53.76,0:23:57.02,Chinese,,0,0,0,,在这两个分支中蓝色代码与红色代码相对应
Dialogue: 0,0:23:57.02,0:24:01.74,English,,0,0,0,,What you're doing is in one case subtracting y from x
Dialogue: 0,0:23:57.02,0:24:01.74,Chinese,,0,0,0,,在一种情况下你正在做的是从 x 中减去 y
Dialogue: 0,0:24:03.14,0:24:08.16,English,,0,0,0,,Here you move x into our %ax and you subtract y from it
Dialogue: 0,0:24:03.14,0:24:08.16,Chinese,,0,0,0,,在这里你将 x 移动到我们的 %ax 中，然后从中减去 y
Dialogue: 0,0:24:08.74,0:24:12.36,English,,0,0,0,,And here you do the opposite you're subtracting x from y
Dialogue: 0,0:24:08.74,0:24:12.36,Chinese,,0,0,0,,在这里（红色代码）你做的相反，你从 y 减去 x
Dialogue: 0,0:24:13.74,0:24:17.60,English,,0,0,0,,And in this case
Dialogue: 0,0:24:13.74,0:24:17.60,Chinese,,0,0,0,,在这种情况下
Dialogue: 0,0:24:17.78,0:24:23.12,English,,0,0,0,,So in the first case,you'll make the jump if x is less than or equal to y
Dialogue: 0,0:24:17.78,0:24:23.12,Chinese,,0,0,0,,所以在第一种情况下，如果 x 小于或等于 y，你将进行跳转
Dialogue: 0,0:24:23.74,0:24:27.52,English,,0,0,0,,You'll compact y from x and you'll do a return
Dialogue: 0,0:24:23.74,0:24:27.52,Chinese,,0,0,0,,你将从 x 减去 y 并且你将返回
Dialogue: 0,0:24:27.72,0:24:33.50,English,,0,0,0,,And you remember that I don't have to do anything special to return a value back from a function
Dialogue: 0,0:24:27.72,0:24:33.50,Chinese,,0,0,0,,而且你记得我没有做任何特殊的事情来从函数返回一个值
Dialogue: 0,0:24:33.50,0:24:36.36,English,,0,0,0,,All I have to do the stick register %rax
Dialogue: 0,0:24:33.50,0:24:36.36,Chinese,,0,0,0,,我要做的只是放入寄存器 ％rax
Dialogue: 0,0:24:36.78,0:24:39.96,English,,0,0,0,,And calling function will know that's where to find the return value
Dialogue: 0,0:24:36.78,0:24:39.96,Chinese,,0,0,0,,并且调用函数将知道在哪里找到返回值
Dialogue: 0,0:24:41.04,0:24:42.66,English,,0,0,0,,So here does a ret
Dialogue: 0,0:24:41.04,0:24:42.66,Chinese,,0,0,0,,所以这里有一个 ret 指令
Dialogue: 0,0:24:42.98,0:24:47.50,English,,0,0,0,,And here it does the subtraction and it simply does a return directly from that part of it
Dialogue: 0,0:24:42.98,0:24:47.50,Chinese,,0,0,0,,在这里它进行减法，然后简单地从中直接返回
Dialogue: 0,0:24:50.84,0:24:53.62,English,,0,0,0,,So it's a pretty straightforward piece of code
Dialogue: 0,0:24:50.84,0:24:53.62,Chinese,,0,0,0,,所以这是一段相当简单的代码
Dialogue: 0,0:24:53.62,0:25:00.82,English,,0,0,0,,But you can see it's using this jumping to create two different parts of code that get executed
Dialogue: 0,0:24:53.62,0:25:00.82,Chinese,,0,0,0,,但是你可以看到它正在使用这种跳转创建两个不同的代码部分来执行
Dialogue: 0,0:25:01.10,0:25:02.86,English,,0,0,0,,Under different conditions
Dialogue: 0,0:25:01.10,0:25:02.86,Chinese,,0,0,0,,在不同的条件下
Dialogue: 0,0:25:03.08,0:25:14.06,English,,0,0,0,,Question? what's that? I'm sorry I didn't hear you
Dialogue: 0,0:25:03.08,0:25:14.06,Chinese,,0,0,0,,什么问题？什么？对不起，我没有听到你的声音
Dialogue: 0,0:25:14.16,0:25:18.79,English,,0,0,0,,Oh well there's a couple things one is you want the result to end up in %rax
Dialogue: 0,0:25:14.16,0:25:18.79,Chinese,,0,0,0,,你要记住两件事，一件是你想要的结果最终在 ％rax 寄存器中
Dialogue: 0,0:25:19.62,0:25:25.98,English,,0,0,0,,Right and remember the subtract instructions...all the two argument instructions
Dialogue: 0,0:25:19.62,0:25:25.98,Chinese,,0,0,0,,另一件是正确记住减法指令的两个参数
Dialogue: 0,0:25:27.14,0:25:35.18,English,,0,0,0,,There that you take two values and then you the one this,second argument the destination argument
Dialogue: 0,0:25:27.14,0:25:35.18,Chinese,,0,0,0,,你有两个值，一个是第一个源参数（减数），另一个是目标参数（被减数）
Dialogue: 0,0:25:35.66,0:25:38.00,English,,0,0,0,,You overwrite what was there with the new result
Dialogue: 0,0:25:35.66,0:25:38.00,Chinese,,0,0,0,,你会用新的结果覆盖第二个参数
Dialogue: 0,0:25:38.88,0:25:41.36,English,,0,0,0,,So this is a pretty typical pattern you'll see
Dialogue: 0,0:25:38.88,0:25:41.36,Chinese,,0,0,0,,这是一个非常典型的模式，你会看到
Dialogue: 0,0:25:41.86,0:25:48.46,English,,0,0,0,,You move some value into a register and then you into %rax is very common
Dialogue: 0,0:25:41.86,0:25:48.46,Chinese,,0,0,0,,你将一些值移动到一个寄存器中，然后你（把结果）移动到 ％rax，这很常见
Dialogue: 0,0:25:48.74,0:25:55.52,English,,0,0,0,,And then you do some arithmetic operation with that register as a destination to kind of update it
Dialogue: 0,0:25:48.74,0:25:55.52,Chinese,,0,0,0,,然后，你使用该寄存器进行一些算术运算并用结果更新它
Dialogue: 0,0:25:57.10,0:26:00.88,English,,0,0,0,,If it's like if you're writing in C if all the time you had to write sort of
Dialogue: 0,0:25:57.10,0:26:00.88,Chinese,,0,0,0,,就好像你在使用 C 语言，但是所有的时间你必须以这种方式写代码
Dialogue: 0,0:26:01.30,0:26:03.08,English,,0,0,0,,X plus equals something...
Dialogue: 0,0:26:01.30,0:26:03.08,Chinese,,0,0,0,,X += ......
Dialogue: 0,0:26:03.08,0:26:08.68,English,,0,0,0,,X minus equals and that all your arithmetic had to be expressed in those terms
Dialogue: 0,0:26:03.08,0:26:08.68,Chinese,,0,0,0,,X -= ....... 并且所有算术都必须用这些术语表示
Dialogue: 0,0:26:13.30,0:26:15.66,English,,0,0,0,,Okay so...
Dialogue: 0,0:26:13.30,0:26:15.66,Chinese,,0,0,0,,可以，然后呢...
Dialogue: 0,0:26:16.10,0:26:21.39,English,,0,0,0,,It's fun to look at assembly code for about five minutes and then you get sick of it
Dialogue: 0,0:26:16.10,0:26:21.39,Chinese,,0,0,0,,看汇编代码的前五分钟你可能觉得有趣，但是过一会你就会厌烦
Dialogue: 0,0:26:22.04,0:26:25.76,English,,0,0,0,,So one thing to sort of present these same ideas
Dialogue: 0,0:26:22.04,0:26:25.76,Chinese,,0,0,0,,所以想要更高级的（语言）表示相同的意思
Dialogue: 0,0:26:25.76,0:26:31.42,English,,0,0,0,,But give it in a little bit more abstract form is to write it in C
Dialogue: 0,0:26:25.76,0:26:31.42,Chinese,,0,0,0,,用 C 语言编写可以更抽象一些
Dialogue: 0,0:26:31.76,0:26:34.78,English,,0,0,0,,But in a form of C that looks a lot like assembly code
Dialogue: 0,0:26:31.76,0:26:34.78,Chinese,,0,0,0,,但是在 C 形式中看起来很像汇编代码
Dialogue: 0,0:26:35.48,0:26:38.18,English,,0,0,0,,And in particular one of the features of C
Dialogue: 0,0:26:35.48,0:26:38.18,Chinese,,0,0,0,,这是 C 的一个特性
Dialogue: 0,0:26:38.18,0:26:44.18,English,,0,0,0,,That is not generally advertised is there's a statement called goto
Dialogue: 0,0:26:38.18,0:26:44.18,Chinese,,0,0,0,,有一个名为 goto 的表达式，一般不被建议使用
Dialogue: 0,0:26:45.36,0:26:47.44,English,,0,0,0,,And you can put labels in your code
Dialogue: 0,0:26:45.36,0:26:47.44,Chinese,,0,0,0,,你可以（使用goto）在代码中添加标签
Dialogue: 0,0:26:52.26,0:26:55.16,English,,0,0,0,,And you can tell the program
Dialogue: 0,0:26:52.26,0:26:55.16,Chinese,,0,0,0,,你可以告诉程序
Dialogue: 0,0:26:55.16,0:26:59.02,English,,0,0,0,,That if something happens then you want to jump to that part of the program
Dialogue: 0,0:26:55.16,0:26:59.02,Chinese,,0,0,0,,如果发生了某些事情，你想跳转到程序的哪一部分
Dialogue: 0,0:26:59.88,0:27:02.10,English,,0,0,0,,So it looks a lot like that assembly code right
Dialogue: 0,0:26:59.88,0:27:02.10,Chinese,,0,0,0,,所以它看起来很像汇编代码对吧
Dialogue: 0,0:27:02.26,0:27:07.02,English,,0,0,0,,That you saw jump jle instead of what this says
Dialogue: 0,0:27:02.26,0:27:07.02,Chinese,,0,0,0,,之前你看到的是跳转（指令）jle 而不是这样的（ppt 上右边的 goto 那行）
Dialogue: 0,0:27:07.50,0:27:10.64,English,,0,0,0,,It's like I'm doing a test
Dialogue: 0,0:27:07.50,0:27:10.64,Chinese,,0,0,0,,这就像我在做一个测试
Dialogue: 0,0:27:10.92,0:27:16.42,English,,0,0,0,,And then if the test is which in this case I call it end test because it's the opposite of the test
Dialogue: 0,0:27:10.92,0:27:16.42,Chinese,,0,0,0,,然后，如果测试是在这种情况下我称之为结束测试，因为它与
Dialogue: 0,0:27:17.00,0:27:18.42,English,,0,0,0,,that's in the original program
Dialogue: 0,0:27:17.00,0:27:18.42,Chinese,,0,0,0,,原始程序中的测试相反
Dialogue: 0,0:27:19.34,0:27:24.84,English,,0,0,0,,And if that end test condition holds I want to jump to another part of the program I'm calling else
Dialogue: 0,0:27:19.34,0:27:24.84,Chinese,,0,0,0,,如果那个结束测试条件成立，我想跳到称之为 else 的程序的另一部分
Dialogue: 0,0:27:25.98,0:27:32.14,English,,0,0,0,,And you notice I uppercase that because it's not the actual else of a if-then-else
Dialogue: 0,0:27:25.98,0:27:32.14,Chinese,,0,0,0,,而且你注意到我是大写的，因为它不是 if-then-else 中实际的 else
Dialogue: 0,0:27:33.28,0:27:35.92,English,,0,0,0,,And same way if this one is well...
Dialogue: 0,0:27:33.28,0:27:35.92,Chinese,,0,0,0,,同样的，如果这个很好......
Dialogue: 0,0:27:38.12,0:27:42.24,English,,0,0,0,,Actually to be most accurate I should have simply said return result from this point
Dialogue: 0,0:27:38.12,0:27:42.24,Chinese,,0,0,0,,实际上，为了最准确，我应该简单地说从这一点返回结果
Dialogue: 0,0:27:43.80,0:27:45.64,English,,0,0,0,,This codes a little bit out a day
Dialogue: 0,0:27:43.80,0:27:45.64,Chinese,,0,0,0,,这个代码有点过时了
Dialogue: 0,0:27:46.92,0:27:48.62,English,,0,0,0,,So I should have said return result
Dialogue: 0,0:27:46.92,0:27:48.62,Chinese,,0,0,0,,所以我应该说返回结果
Dialogue: 0,0:27:49.06,0:27:53.78,English,,0,0,0,,But another version would be to have done a goto down to here and return the result from there
Dialogue: 0,0:27:49.06,0:27:53.78,Chinese,,0,0,0,,但另一个版本是在这里完成到这（译注：应该是指到goto done）并从那里返回结果
Dialogue: 0,0:27:54.40,0:27:56.82,English,,0,0,0,,And you'll see different compilers generate in different forms
Dialogue: 0,0:27:54.40,0:27:56.82,Chinese,,0,0,0,,你会看到不同的编译器生成不同的形式
Dialogue: 0,0:27:58.66,0:28:02.30,English,,0,0,0,,So I'm going to typically use this way of presenting code
Dialogue: 0,0:27:58.66,0:28:02.30,Chinese,,0,0,0,,所以我一般会使用这种方式展示代码
Dialogue: 0,0:28:02.58,0:28:08.14,English,,0,0,0,,Just so that you can look at and understand what these control structures look like
Dialogue: 0,0:28:02.58,0:28:08.14,Chinese,,0,0,0,,这样你就可以查看并理解程序的控制结构
Dialogue: 0,0:28:08.50,0:28:13.96,English,,0,0,0,,Without having to sort of scrutinize the low-level assembly code instructions
Dialogue: 0,0:28:08.50,0:28:13.96,Chinese,,0,0,0,,无需仔细阅读底层汇编代码
Dialogue: 0,0:28:17.14,0:28:18.48,English,,0,0,0,,So we consider take this...
Dialogue: 0,0:28:17.14,0:28:18.48,Chinese,,0,0,0,,我们来看看这个
Dialogue: 0,0:28:18.60,0:28:19.15,English,,0,0,0,,Questions
Dialogue: 0,0:28:18.60,0:28:19.15,Chinese,,0,0,0,,什么问题？
Dialogue: 0,0:28:19.34,0:28:26.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:28:19.34,0:28:26.74,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:28:26.74,0:28:30.60,English,,0,0,0,,Yeah I think there's a homework or a practice problem of exactly that sort
Dialogue: 0,0:28:26.74,0:28:30.60,Chinese,,0,0,0,,是的，我认为这是一个完整的家庭作业或练习题
Dialogue: 0,0:28:30.84,0:28:33.46,English,,0,0,0,,So in general you could do it neither way and
Dialogue: 0,0:28:30.84,0:28:33.46,Chinese,,0,0,0,,所以一般来说你无论如何也无法做到
Dialogue: 0,0:28:33.60,0:28:38.16,English,,0,0,0,,Why the compiler picks one versus the other is, I think it's a completely arbitrary decision
Dialogue: 0,0:28:33.60,0:28:38.16,Chinese,,0,0,0,,为什么编译器选择一个而不是另一个，我认为这是一个完全武断的决定
Dialogue: 0,0:28:39.04,0:28:41.66,English,,0,0,0,,But consistently I found GCC does it this way
Dialogue: 0,0:28:39.04,0:28:41.66,Chinese,,0,0,0,,但我发现 GCC 就是一直这样做的
Dialogue: 0,0:28:45.62,0:28:52.40,English,,0,0,0,,Okay so let's sort of talking sort of imagine you're writing a compiler
Dialogue: 0,0:28:45.62,0:28:52.40,Chinese,,0,0,0,,好吧，让我们假设你正在编写一个编译器
Dialogue: 0,0:28:52.40,0:28:55.90,English,,0,0,0,,How would you take this special case I just showed
Dialogue: 0,0:28:52.40,0:28:55.90,Chinese,,0,0,0,,你会如何处理我刚刚展示的例子
Dialogue: 0,0:28:56.12,0:29:02.14,English,,0,0,0,,And generalize it into a rule for compiling if-then-else expressions
Dialogue: 0,0:28:56.12,0:29:02.14,Chinese,,0,0,0,,并将其概括为一条用来编译 if-then-else 表达式的规则
Dialogue: 0,0:29:02.70,0:29:07.64,English,,0,0,0,,And I'm going to use the version of in see, the question mark version
Dialogue: 0,0:29:02.70,0:29:07.64,Chinese,,0,0,0,,我将使用现在将要看的版本，刚才问题中提到的那个版本（gcc 那个版本）
Dialogue: 0,0:29:07.64,0:29:14.30,English,,0,0,0,,Where you kind of encapsulate that whole conditional is a single expression rather than the statement
Dialogue: 0,0:29:07.64,0:29:14.30,Chinese,,0,0,0,,在哪种情况下，封装整个条件是单个表达式而不是语句
Dialogue: 0,0:29:14.30,0:29:18.22,English,,0,0,0,,But you can understand that these rules would be the same in either case
Dialogue: 0,0:29:14.30,0:29:18.22,Chinese,,0,0,0,,但是你可以理解成这些规则在任何一种情况下都是相同的
Dialogue: 0,0:29:18.98,0:29:23.00,English,,0,0,0,,So imagine in general you had a C code
Dialogue: 0,0:29:18.98,0:29:23.00,Chinese,,0,0,0,,所以想象一下你有一个 C 代码
Dialogue: 0,0:29:23.00,0:29:29.14,English,,0,0,0,,Where there's a test controlling whether to return the result of one expression or another
Dialogue: 0,0:29:23.00,0:29:29.14,Chinese,,0,0,0,,该 C 代码有一个 test，用来控制返回哪一个结果
Dialogue: 0,0:29:30.32,0:29:35.96,English,,0,0,0,,And this is what my absdiff code would look like if I wrote it in that form
Dialogue: 0,0:29:30.32,0:29:35.96,Chinese,,0,0,0,,这就是我的 absdiff 代码，如果我以这种形式编写的话
Dialogue: 0,0:29:37.76,0:29:39.78,English,,0,0,0,,And so in general what we can say is
Dialogue: 0,0:29:37.76,0:29:39.78,Chinese,,0,0,0,,总的来说
Dialogue: 0,0:29:41.18,0:29:46.54,English,,0,0,0,,What we'll do is we'll compete well take the test and invert it
Dialogue: 0,0:29:41.18,0:29:46.54,Chinese,,0,0,0,,我们要做的就是计算测试结果并将其反转
Dialogue: 0,0:29:47.42,0:29:52.64,English,,0,0,0,,And say if that test is not true then we will ...
Dialogue: 0,0:29:47.42,0:29:52.64,Chinese,,0,0,0,,也就是如果 test 结果为假，我们如何做
Dialogue: 0,0:29:56.14,0:30:01.92,English,,0,0,0,,So if ntest is true,then we will jump to some part of the code
Dialogue: 0,0:29:56.14,0:30:01.92,Chinese,,0,0,0,,因此，如果 ntest 为 true，那么我们将跳转到某些
Dialogue: 0,0:30:01.92,0:30:05.20,English,,0,0,0,,Where we've compiled the code for the else expression(Else_Expr)
Dialogue: 0,0:30:01.92,0:30:05.20,Chinese,,0,0,0,,我们已经编译好的 else 表达式的代码（Else_Expr）
Dialogue: 0,0:30:06.02,0:30:11.64,English,,0,0,0,,And if it that test fails here, so that the original test condition holds
Dialogue: 0,0:30:06.02,0:30:11.64,Chinese,,0,0,0,,如果测试失败，那么原始测试条件成立
Dialogue: 0,0:30:12.38,0:30:18.78,English,,0,0,0,,Then we'll stick in whatever code it takes to to compute the then expression(Then_Expr)
Dialogue: 0,0:30:12.38,0:30:18.78,Chinese,,0,0,0,,然后我们将坚持使用无论原来是怎样的代码来计算 then 表达式（Then_Expr）
Dialogue: 0,0:30:19.34,0:30:24.12,English,,0,0,0,,And then we'll merge back together in the case you saw where it's just a single little function
Dialogue: 0,0:30:19.34,0:30:24.12,Chinese,,0,0,0,,然后，在你看到它只是一个小函数的情况下，我们将合并在一起
Dialogue: 0,0:30:24.46,0:30:27.24,English,,0,0,0,,We can just call a ret here and get out of the thing
Dialogue: 0,0:30:24.46,0:30:27.24,Chinese,,0,0,0,,我们可以在这里调用 ret，然后退出
Dialogue: 0,0:30:27.66,0:30:32.18,English,,0,0,0,,But if this is one line of code then there's a whole bunch of lines after that
Dialogue: 0,0:30:27.66,0:30:32.18,Chinese,,0,0,0,,但如果这是一行代码，那么之后会有一大堆行
Dialogue: 0,0:30:32.66,0:30:36.04,English,,0,0,0,,Typically you want to merge back together again and continue from there
Dialogue: 0,0:30:32.66,0:30:36.04,Chinese,,0,0,0,,通常，你希望再次合并在一起并从那里继续
Dialogue: 0,0:30:36.38,0:30:42.08,English,,0,0,0,,And so that's what this show is all I'll finish by going to whatever comes afterwards
Dialogue: 0,0:30:36.38,0:30:42.08,Chinese,,0,0,0,,所以这就是这个说明的全部内容，我将通过随后的任何事情来完成（这个说明）
Dialogue: 0,0:30:43.46,0:30:48.78,English,,0,0,0,,So this is a way I like to you know,although we're not writing compilers in this course
Dialogue: 0,0:30:43.46,0:30:48.78,Chinese,,0,0,0,,所以这是我喜欢的一种方式，虽然我们不是在编写本课程的编译器
Dialogue: 0,0:30:48.78,0:30:52.48,English,,0,0,0,,I think it helps to to think in terms of general rules
Dialogue: 0,0:30:48.78,0:30:52.48,Chinese,,0,0,0,,我认为这有助于从一般规则来考虑
Dialogue: 0,0:30:52.98,0:30:57.00,English,,0,0,0,,Of how a compiler would translate C code into assembly code
Dialogue: 0,0:30:52.98,0:30:57.00,Chinese,,0,0,0,,编译器如何将 C 代码转换为汇编代码
Dialogue: 0,0:30:57.50,0:31:02.46,English,,0,0,0,,So that when you see that assembly code you'll recognize these patterns and know what they mean
Dialogue: 0,0:30:57.50,0:31:02.46,Chinese,,0,0,0,,因此，当你看到汇编代码时，你将识别这些模式并知道它们的含义
Dialogue: 0,0:31:02.58,0:31:08.86,English,,0,0,0,,Question?
Dialogue: 0,0:31:02.58,0:31:08.86,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:31:09.88,0:31:15.24,English,,0,0,0,,So just as we saw yes in general what like here
Dialogue: 0,0:31:09.88,0:31:15.24,Chinese,,0,0,0,,就像我们在一般情况下在这看到的一样，
Dialogue: 0,0:31:15.60,0:31:19.42,English,,0,0,0,,It would fall through to the done, good question
Dialogue: 0,0:31:15.60,0:31:19.42,Chinese,,0,0,0,,它最终会执行到 done，好问题
Dialogue: 0,0:31:23.44,0:31:27.96,English,,0,0,0,,Okay so that's one version of a conditional and that's the most general way
Dialogue: 0,0:31:23.44,0:31:27.96,Chinese,,0,0,0,,好的，所以这是条件的一个版本，这是最通用的方式
Dialogue: 0,0:31:27.96,0:31:30.08,English,,0,0,0,,And the way it used to always be done
Dialogue: 0,0:31:27.96,0:31:30.08,Chinese,,0,0,0,,过去一直使用这种方式
Dialogue: 0,0:31:30.92,0:31:35.24,English,,0,0,0,,But there's another approach that you'll see fairly common in code
Dialogue: 0,0:31:30.92,0:31:35.24,Chinese,,0,0,0,,但是你会在代码中看到另一种相当常见的方法
Dialogue: 0,0:31:35.38,0:31:38.90,English,,0,0,0,,It's sort of an optimization called conditional move
Dialogue: 0,0:31:35.38,0:31:38.90,Chinese,,0,0,0,,这是一种称为条件移动的优化
Dialogue: 0,0:31:40.06,0:31:45.50,English,,0,0,0,,And it's bit non-intuitive from a software developer's perspective why you'd ever want to do this
Dialogue: 0,0:31:40.06,0:31:45.50,Chinese,,0,0,0,,从软件开发人员的角度来看，不明白为什么想要这样做，因为这有点不直观
Dialogue: 0,0:31:46.04,0:31:51.40,English,,0,0,0,,The basic idea is I'm going to compute both them then and the else the values they'd produce
Dialogue: 0,0:31:46.04,0:31:51.40,Chinese,,0,0,0,,基本思想是我把 then 代码和 else 都执行得到两个结果
Dialogue: 0,0:31:52.12,0:31:54.62,English,,0,0,0,,And only after that I choose which one I use
Dialogue: 0,0:31:52.12,0:31:54.62,Chinese,,0,0,0,,然后我才会选择使用哪一个结果
Dialogue: 0,0:31:55.62,0:31:59.94,English,,0,0,0,,So it seems wasteful but it actually turns out to be more efficient
Dialogue: 0,0:31:55.62,0:31:59.94,Chinese,,0,0,0,,看起来似乎浪费时间但事实证明它更有效率
Dialogue: 0,0:32:00.50,0:32:03.06,English,,0,0,0,,If there are fairly simple computations
Dialogue: 0,0:32:00.50,0:32:03.06,Chinese,,0,0,0,,如果有十分简单的计算
Dialogue: 0,0:32:03.60,0:32:08.80,English,,0,0,0,,And the reason of that is and we'll see a little bit more when we talk about performance optimization
Dialogue: 0,0:32:03.60,0:32:08.80,Chinese,,0,0,0,,当我们学到性能优化时我们会明白原因
Dialogue: 0,0:32:09.44,0:32:15.32,English,,0,0,0,,A modern processor is a little like an oil tanker sailing in the sea
Dialogue: 0,0:32:09.44,0:32:15.32,Chinese,,0,0,0,,现代处理器有点像在海上航行的油轮
Dialogue: 0,0:32:15.62,0:32:19.26,English,,0,0,0,,Meaning that it plows along in a certain direction
Dialogue: 0,0:32:15.62,0:32:19.26,Chinese,,0,0,0,,这意味着它沿着某个方向航行
Dialogue: 0,0:32:19.62,0:32:23.40,English,,0,0,0,,And it really is hard to get it to stop or to turn
Dialogue: 0,0:32:19.62,0:32:23.40,Chinese,,0,0,0,,它真的很难让它停下来或转向
Dialogue: 0,0:32:24.64,0:32:27.64,English,,0,0,0,,So that's you say what are you talking about but
Dialogue: 0,0:32:24.64,0:32:27.64,Chinese,,0,0,0,,你可能正在想我在说啥
Dialogue: 0,0:32:28.46,0:32:34.70,English,,0,0,0,,Think of an instruction sequences you know the ocean of code  that you're cruising through
Dialogue: 0,0:32:28.46,0:32:34.70,Chinese,,0,0,0,,假设你知道的指令序列正在代码海洋中巡航
Dialogue: 0,0:32:35.14,0:32:39.20,English,,0,0,0,,And these things can just fly through a straight sequence of code
Dialogue: 0,0:32:35.14,0:32:39.20,Chinese,,0,0,0,,这些指令可以很顺畅的执行
Dialogue: 0,0:32:39.70,0:32:43.16,English,,0,0,0,,Because they are they do what they call pipelining
Dialogue: 0,0:32:39.70,0:32:43.16,Chinese,,0,0,0,,因为他们使用了所谓的流水线技术
Dialogue: 0,0:32:43.16,0:32:47.48,English,,0,0,0,,Meaning they start bringing in parts of one instruction before they're done with the next
Dialogue: 0,0:32:43.16,0:32:47.48,Chinese,,0,0,0,,这意味着他们在完成一个指令之前就开始执行下一个指令的一部分
Dialogue: 0,0:32:47.72,0:32:51.72,English,,0,0,0,,And actually go up to depths of 20 or more instructions deep of
Dialogue: 0,0:32:47.72,0:32:51.72,Chinese,,0,0,0,,实际上流水线能达到 20 条以上指令的深度
Dialogue: 0,0:32:52.46,0:32:57.32,English,,0,0,0,,How far had they're working sort of fetching forward and future instructions
Dialogue: 0,0:32:52.46,0:32:57.32,Chinese,,0,0,0,,能达到的深度主要取决于提前获取的指令的条数
Dialogue: 0,0:32:57.70,0:32:59.94,English,,0,0,0,,While finishing up the ones that still remain
Dialogue: 0,0:32:57.70,0:32:59.94,Chinese,,0,0,0,,当完成一些指令时仍然有另一些指令留在流水线上
Dialogue: 0,0:33:00.32,0:33:03.36,English,,0,0,0,,So that's my ocean line or my tanker analogy
Dialogue: 0,0:33:00.32,0:33:03.36,Chinese,,0,0,0,,这就是我的海洋线或我的油轮类比
Dialogue: 0,0:33:04.32,0:33:08.14,English,,0,0,0,,But all of a sudden you come and then what happens when they hit a branch
Dialogue: 0,0:33:04.32,0:33:08.14,Chinese,,0,0,0,,但突然他们到达一个分支会发生什么？
Dialogue: 0,0:33:09.24,0:33:12.00,English,,0,0,0,,They'll try to guess, it's called branch prediction
Dialogue: 0,0:33:09.24,0:33:12.00,Chinese,,0,0,0,,他们会试着猜测分支结果，这被称为分支预测技术
Dialogue: 0,0:33:12.46,0:33:15.68,English,,0,0,0,,And guess where is this kind of branch going to go
Dialogue: 0,0:33:12.46,0:33:15.68,Chinese,,0,0,0,,猜测会运行哪个分支
Dialogue: 0,0:33:15.74,0:33:19.88,English,,0,0,0,,Where it you know well the conditional branch will be taken or is it going to fall through
Dialogue: 0,0:33:15.74,0:33:19.88,Chinese,,0,0,0,,在你熟悉的情况下，条件分支将被采用或将会落空
Dialogue: 0,0:33:20.48,0:33:24.94,English,,0,0,0,,And they're pretty good at that, they're good at it 98% of the time
Dialogue: 0,0:33:20.48,0:33:24.94,Chinese,,0,0,0,,并且他们非常擅长预测，98％ 的时候他们都能猜对
Dialogue: 0,0:33:25.80,0:33:32.68,English,,0,0,0,,So they can even anticipate suta curves in the road  my analogy is breaking down
Dialogue: 0,0:33:25.80,0:33:32.68,Chinese,,0,0,0,,所以他们甚至可以在路上预测 suta 曲线，我的比喻正在打破
Dialogue: 0,0:33:34.22,0:33:39.84,English,,0,0,0,,And start going in that direction and as long as they get it right it's very efficient
Dialogue: 0,0:33:34.22,0:33:39.84,Chinese,,0,0,0,,并开始朝着这个方向前进，只要猜测正确，就会非常有效率
Dialogue: 0,0:33:40.46,0:33:48.52,English,,0,0,0,,But if they get it wrong it's as if you have to stop the thing back it up turn the other way start again
Dialogue: 0,0:33:40.46,0:33:48.52,Chinese,,0,0,0,,但是，如果分支猜错了，你必须阻止它并转向另一个方向重新开始
Dialogue: 0,0:33:48.80,0:33:54.52,English,,0,0,0,,And that can take 40 instructions 40 clock cycles say to do in bad situations
Dialogue: 0,0:33:48.80,0:33:54.52,Chinese,,0,0,0,,在较差情况下，这可能需要 40 个指令 40 个时钟周期
Dialogue: 0,0:33:54.64,0:33:59.26,English,,0,0,0,,So and this is pretty common if you think of like an absolute value
Dialogue: 0,0:33:54.64,0:33:59.26,Chinese,,0,0,0,,所以，如果你认为这是一个绝对值，这是很常见的
Dialogue: 0,0:33:59.78,0:34:04.90,English,,0,0,0,,Can you predict whether a value is going to be positive or negative? It not usually
Dialogue: 0,0:33:59.78,0:34:04.90,Chinese,,0,0,0,,你能预测一个值是正的还是负的？一般不能预测
Dialogue: 0,0:34:05.50,0:34:09.36,English,,0,0,0,,So about half the time whatever you guess you're going to guess wrong
Dialogue: 0,0:34:05.50,0:34:09.36,Chinese,,0,0,0,,大约一半的时间，不管你猜什么，你猜的都是错了
Dialogue: 0,0:34:10.06,0:34:13.30,English,,0,0,0,,So these conditional move instructions it turns out
Dialogue: 0,0:34:10.06,0:34:13.30,Chinese,,0,0,0,,事实证明这些条件移动指令
Dialogue: 0,0:34:13.80,0:34:17.64,English,,0,0,0,,It's much easier to just plow through compute both
Dialogue: 0,0:34:13.80,0:34:17.64,Chinese,,0,0,0,,通过先执行两个分支来提高效率要容易得多
Dialogue: 0,0:34:17.64,0:34:23.04,English,,0,0,0,,And then at the last minute all you have to do is move a value into a register or not
Dialogue: 0,0:34:17.64,0:34:23.04,Chinese,,0,0,0,,在最后一分钟，你要做的就是是否将值移入寄存器
Dialogue: 0,0:34:23.04,0:34:27.24,English,,0,0,0,,And that doesn't require stopping the whole processor and making this turn
Dialogue: 0,0:34:23.04,0:34:27.24,Chinese,,0,0,0,,这并不需要暂停整个处理器的执行然后重新选择分支执行
Dialogue: 0,0:34:28.22,0:34:30.60,English,,0,0,0,,So that's my long explanation for
Dialogue: 0,0:34:28.22,0:34:30.60,Chinese,,0,0,0,,我用了很长时间来解释
Dialogue: 0,0:34:31.26,0:34:37.14,English,,0,0,0,,And if you don't want to understand that I'll just say well just trust me, it's a good idea sometimes
Dialogue: 0,0:34:31.26,0:34:37.14,Chinese,,0,0,0,,如果你不想明白，我也可以理解，但是你要相信我，这是个提高效率的好方法
Dialogue: 0,0:34:40.60,0:34:47.72,English,,0,0,0,,So the the general pattern then if I use the same idea is I want to compute both results
Dialogue: 0,0:34:40.60,0:34:47.72,Chinese,,0,0,0,,如果我采用同样的思想，那么通常的处理方法是计算出两个结果
Dialogue: 0,0:34:47.72,0:34:52.92,English,,0,0,0,,And I'll call the result and this is an eval this is eval the eval value
Dialogue: 0,0:34:47.72,0:34:52.92,Chinese,,0,0,0,,我将调用结果，这是一个 eval，这是 eval 的值
Dialogue: 0,0:34:53.66,0:34:55.18,English,,0,0,0,,I'll compute both of them
Dialogue: 0,0:34:53.66,0:34:55.18,Chinese,,0,0,0,,我会计算它们
Dialogue: 0,0:34:55.66,0:35:01.38,English,,0,0,0,,I'll do my test and then this red thing imagine that's all done with a single instruction
Dialogue: 0,0:34:55.66,0:35:01.38,Chinese,,0,0,0,,我会做这个测试然后用一条指令完成红色部分的代码
Dialogue: 0,0:35:01.38,0:35:05.82,English,,0,0,0,,That says I'll copy the value of eval to result
Dialogue: 0,0:35:01.38,0:35:05.82,Chinese,,0,0,0,,这就是说我会将 eval 的值复制到结果中
Dialogue: 0,0:35:06.40,0:35:10.60,English,,0,0,0,,But only if my condition holds so that's why it's called a conditional move
Dialogue: 0,0:35:06.40,0:35:10.60,Chinese,,0,0,0,,但只有当我的条件成立时才会这样做，所以这就是为什么它被称为有条件的举动
Dialogue: 0,0:35:12.82,0:35:14.86,English,,0,0,0,,Then we'll see this is the code
Dialogue: 0,0:35:12.82,0:35:14.86,Chinese,,0,0,0,,这是汇编代码
Dialogue: 0,0:35:15.02,0:35:19.16,English,,0,0,0,,By the way you saw my original version, starting to have to jump back
Dialogue: 0,0:35:15.02,0:35:19.16,Chinese,,0,0,0,,顺便说一句，你看到我原来的版本，开始不得不跳回来（译注：回到前面的ppt）
Dialogue: 0,0:35:19.84,0:35:26.92,English,,0,0,0,,I had to explicitly tell the GCC don't put use conditional moves
Dialogue: 0,0:35:19.84,0:35:26.92,Chinese,,0,0,0,,我不得不明确告诉 GCC 不要使用条件移动
Dialogue: 0,0:35:27.36,0:35:29.93,English,,0,0,0,,Because it really wants to a very badly
Dialogue: 0,0:35:27.36,0:35:29.93,Chinese,,0,0,0,,因为它真的非常想使用条件移动
Dialogue: 0,0:35:30.28,0:35:34.26,English,,0,0,0,,And so you have to force it not to and I did that here
Dialogue: 0,0:35:30.28,0:35:34.26,Chinese,,0,0,0,,所以你必须强迫它不要使用条件移动，我在这里这么做
Dialogue: 0,0:35:37.66,0:35:41.72,English,,0,0,0,,So here's the actual code then and again you'll see the the color coding
Dialogue: 0,0:35:37.66,0:35:41.72,Chinese,,0,0,0,,所以这是实际的代码，你会看到颜色不同的代码
Dialogue: 0,0:35:42.40,0:35:45.44,English,,0,0,0,,That it's doing both subtractions
Dialogue: 0,0:35:42.40,0:35:45.44,Chinese,,0,0,0,,它做了两次减法
Dialogue: 0,0:35:45.44,0:35:47.88,English,,0,0,0,,It's actually doing the move and subtract
Dialogue: 0,0:35:45.44,0:35:47.88,Chinese,,0,0,0,,它实际上正在进行移动和减法操作
Dialogue: 0,0:35:48.54,0:35:54.16,English,,0,0,0,,Move and subtract so it's doing both the branches you saw before the then and the else branch
Dialogue: 0,0:35:48.54,0:35:54.16,Chinese,,0,0,0,,它执行了之前你所看到的 then 和 else 两个分支
Dialogue: 0,0:35:55.26,0:36:00.18,English,,0,0,0,,It's doing a comparison and then here is the conditional mov instruction
Dialogue: 0,0:35:55.26,0:36:00.18,Chinese,,0,0,0,,它正在进行比较，然后是条件 mov 指令
Dialogue: 0,0:36:00.86,0:36:08.88,English,,0,0,0,,cmov in this case the L here is not a word size,it's the less than or equal to a direction
Dialogue: 0,0:36:00.86,0:36:08.88,Chinese,,0,0,0,,在这种情况下，这里的 l 不是表示字大小，而是小于或等价于一个方向
Dialogue: 0,0:36:09.38,0:36:15.18,English,,0,0,0,,So in the case the that I need the red value basically
Dialogue: 0,0:36:09.38,0:36:15.18,Chinese,,0,0,0,,所以在我需要红色值的情况下
Dialogue: 0,0:36:15.78,0:36:19.18,English,,0,0,0,,You saw the the red value is stored in register %rdx
Dialogue: 0,0:36:15.78,0:36:19.18,Chinese,,0,0,0,,你看到红色值存储在寄存器 ％rdx 中
Dialogue: 0,0:36:20.26,0:36:22.98,English,,0,0,0,,In that case I will copy it into the result register
Dialogue: 0,0:36:20.26,0:36:22.98,Chinese,,0,0,0,,在那种情况下，我会将其复制到结果寄存器中
Dialogue: 0,0:36:24.56,0:36:31.22,English,,0,0,0,,So again it's like this idea of just go ahead and do everything and then pick at the last end
Dialogue: 0,0:36:24.56,0:36:31.22,Chinese,,0,0,0,,所以再次就像这样的想法，继续做所有事情，然后在最后选择
Dialogue: 0,0:36:31.60,0:36:39.40,English,,0,0,0,,And the point is that this one instruction it looks just as far as for this processor execution
Dialogue: 0,0:36:31.60,0:36:39.40,Chinese,,0,0,0,,重点是这一条指令看起来就像这个处理器执行一样
Dialogue: 0,0:36:39.40,0:36:42.98,English,,0,0,0,,That's sort of like a a mov instruction that it's fairly straightforward to do
Dialogue: 0,0:36:39.40,0:36:42.98,Chinese,,0,0,0,,这有点像一个 mov 指令，它做起来相当简单
Dialogue: 0,0:36:47.90,0:36:51.94,English,,0,0,0,,Okay so why doesn't it do that all the time well there's a couple reasons
Dialogue: 0,0:36:47.90,0:36:51.94,Chinese,,0,0,0,,好吧，为什么不能一直使用 conditional move，有几个原因
Dialogue: 0,0:36:52.36,0:36:57.68,English,,0,0,0,,One is that might be a really really bad idea to do both computations
Dialogue: 0,0:36:52.36,0:36:57.68,Chinese,,0,0,0,,一个是进行两种计算可能是一个非常糟糕的主意
Dialogue: 0,0:36:57.68,0:37:01.50,English,,0,0,0,,If you have to like crack a password in one and
Dialogue: 0,0:36:57.68,0:37:01.50,Chinese,,0,0,0,,如果你不得不在一个（分支）中破解密码
Dialogue: 0,0:37:01.98,0:37:06.26,English,,0,0,0,,You know find the nth prime number and another you probably don't want to do both of those
Dialogue: 0,0:37:01.98,0:37:06.26,Chinese,,0,0,0,,你要找到第n个素数和另一个素数，你可能不想把这两个素数都算法出来（找素数耗费时间）
Dialogue: 0,0:37:06.98,0:37:11.18,English,,0,0,0,,So in general in that case
Dialogue: 0,0:37:06.98,0:37:11.18,Chinese,,0,0,0,,所以一般来说就是这种情况
Dialogue: 0,0:37:11.72,0:37:14.86,English,,0,0,0,,And so the and you'll notice GCC will only do this
Dialogue: 0,0:37:11.72,0:37:14.86,Chinese,,0,0,0,,所以你会注意到 GCC 只会这样做
Dialogue: 0,0:37:15.24,0:37:19.96,English,,0,0,0,,If both branches are fairly straightforward computations that they're trying to do
Dialogue: 0,0:37:15.24,0:37:19.96,Chinese,,0,0,0,,如果两个分支都是简单直接的计算，他们会试图使用 conditional move 进行优化
Dialogue: 0,0:37:20.90,0:37:23.32,English,,0,0,0,,And there's some times when you just plain can't do it
Dialogue: 0,0:37:20.90,0:37:23.32,Chinese,,0,0,0,,而有些时候，你只是单纯地无法做到这一点
Dialogue: 0,0:37:23.92,0:37:27.34,English,,0,0,0,,So for example if you're using a conditional to guard
Dialogue: 0,0:37:23.92,0:37:27.34,Chinese,,0,0,0,,因此，例如你使用条件来保证
Dialogue: 0,0:37:27.88,0:37:33.58,English,,0,0,0,,Whether a pointer can be dereferenced or not because it's a null pointer potentially a null pointer
Dialogue: 0,0:37:27.88,0:37:33.58,Chinese,,0,0,0,,是否可以取消引用指针，因为它是一个空指针，可能是一个空指针
Dialogue: 0,0:37:34.00,0:37:37.56,English,,0,0,0,,Then you really don't want to try that null pointer dereference
Dialogue: 0,0:37:34.00,0:37:37.56,Chinese,,0,0,0,,那你真的不会想对空指针解引用
Dialogue: 0,0:37:39.96,0:37:44.22,English,,0,0,0,,Just for a way to save some time
Dialogue: 0,0:37:39.96,0:37:44.22,Chinese,,0,0,0,,仅仅为了节省一些时间
Dialogue: 0,0:37:44.94,0:37:48.12,English,,0,0,0,,And similarly if you could have a side-effect
Dialogue: 0,0:37:44.94,0:37:48.12,Chinese,,0,0,0,,相似的，如果你的代码可能产生期望之外的效果（副作用）
Dialogue: 0,0:37:48.20,0:37:54.50,English,,0,0,0,,If the result of executing either branch could be to change some other part of the program state
Dialogue: 0,0:37:48.20,0:37:54.50,Chinese,,0,0,0,,如果执行任一分支的结果可能会改变程序其他部分的状态
Dialogue: 0,0:37:55.10,0:37:56.85,English,,0,0,0,,Then you don't really want to do that either
Dialogue: 0,0:37:55.10,0:37:56.85,Chinese,,0,0,0,,那你也不想那样做
Dialogue: 0,0:37:57.42,0:38:03.58,English,,0,0,0,,And so the conditional mov only gets used then in this somewhat special case
Dialogue: 0,0:37:57.42,0:38:03.58,Chinese,,0,0,0,,因此，条件 mov 只能在某些特殊情况下使用
Dialogue: 0,0:38:03.58,0:38:08.74,English,,0,0,0,,That you have two computations relatively easy to do safe to do no side-effects
Dialogue: 0,0:38:03.58,0:38:08.74,Chinese,,0,0,0,,比如你的两个计算相对容易安全，没有副作用
Dialogue: 0,0:38:09.74,0:38:13.26,English,,0,0,0,,But that happens just often enough that this is actually a worthwhile thing
Dialogue: 0,0:38:09.74,0:38:13.26,Chinese,,0,0,0,,这种情况经常会碰到，这实际上是一件有意义的事情
Dialogue: 0,0:38:16.70,0:38:19.48,English,,0,0,0,,Okay so that gets us conditionals
Dialogue: 0,0:38:16.70,0:38:19.48,Chinese,,0,0,0,,好的，条件的内容就讲到这里了
Dialogue: 0,0:38:20.04,0:38:26.34,English,,0,0,0,,And now let's look at loops that's a sort of next step up in control structures
Dialogue: 0,0:38:20.04,0:38:26.34,Chinese,,0,0,0,,现在让我们来看看循环，它也属于控制结构的一环
Dialogue: 0,0:38:28.14,0:38:30.90,English,,0,0,0,,And C actually has three different kinds of loops
Dialogue: 0,0:38:28.14,0:38:30.90,Chinese,,0,0,0,,实际上 C 语言有三种不同的循环
Dialogue: 0,0:38:31.52,0:38:36.52,English,,0,0,0,,It has a a while-loop which you're familiar with and a for-loop which you're familiar with
Dialogue: 0,0:38:31.52,0:38:36.52,Chinese,,0,0,0,,有你熟悉的 while 循环和 for 循环
Dialogue: 0,0:38:36.84,0:38:41.72,English,,0,0,0,,And it has a third one which in my whole life of writing and I've written a lot of C code in my life
Dialogue: 0,0:38:36.84,0:38:41.72,Chinese,,0,0,0,,还有第三种循环，迄今为止，我写过很多 C 语言代码
Dialogue: 0,0:38:42.42,0:38:44.70,English,,0,0,0,,I've used this like about 6 times
Dialogue: 0,0:38:42.42,0:38:44.70,Chinese,,0,0,0,,我用了大约 6 次第三种循环（do-while）
Dialogue: 0,0:38:45.64,0:38:49.28,English,,0,0,0,,So but it turns out it's the simplest one to implement so we'll go ahead and do it
Dialogue: 0,0:38:45.64,0:38:49.28,Chinese,,0,0,0,,但事实证明它是最简单的实现方式，所以我们将深入学习它
Dialogue: 0,0:38:49.86,0:38:52.34,English,,0,0,0,,So that the it's called the do-while loop
Dialogue: 0,0:38:49.86,0:38:52.34,Chinese,,0,0,0,,它被称为 do-while 循环
Dialogue: 0,0:38:53.00,0:38:59.26,English,,0,0,0,,And so the keyword is do,and then there's some stuff you do,that's the body of the do
Dialogue: 0,0:38:53.00,0:38:59.26,Chinese,,0,0,0,,关键字是 do，然后你会做一些事情，这些事构成了 do 的主体
Dialogue: 0,0:38:59.90,0:39:05.41,English,,0,0,0,,And then there's a test at the end that tells you whether to keep repeating this loop
Dialogue: 0,0:38:59.90,0:39:05.41,Chinese,,0,0,0,,然后在最后进行测试，告诉你是否继续重复此循环
Dialogue: 0,0:39:05.88,0:39:10.08,English,,0,0,0,,So it sort of flips a normal while loop you have the conditional test at the front
Dialogue: 0,0:39:05.88,0:39:10.08,Chinese,,0,0,0,,与正常的 while 循环相比，do-while 有一点倒过来的感觉，while 是先进行条件判断
Dialogue: 0,0:39:10.46,0:39:11.94,English,,0,0,0,,And here you have it at the end
Dialogue: 0,0:39:10.46,0:39:11.94,Chinese,,0,0,0,,但 do-while 是在最后进行条件判断
Dialogue: 0,0:39:15.84,0:39:20.52,English,,0,0,0,,So it turns out if we think in terms of goto that's a pretty straightforward thing to replace this
Dialogue: 0,0:39:15.84,0:39:20.52,Chinese,,0,0,0,,因此，如果用 goto 替换它是一件相当简单的事情
Dialogue: 0,0:39:22.14,0:39:28.54,English,,0,0,0,,With a code that will do a test and if the test holds it will jump back
Dialogue: 0,0:39:22.14,0:39:28.54,Chinese,,0,0,0,,使用代码进行测试，如果测试成功，它将跳回
Dialogue: 0,0:39:29.00,0:39:33.26,English,,0,0,0,,And say ok a reacts acute that part of the program I was just in
Dialogue: 0,0:39:29.00,0:39:33.26,Chinese,,0,0,0,,并且说好的是，我刚刚参与的程序部分反应非常强烈
Dialogue: 0,0:39:34.08,0:39:43.24,English,,0,0,0,,So it sets up a loop where you can think of it's literally a loop of control flow going round and round
Dialogue: 0,0:39:34.08,0:39:43.24,Chinese,,0,0,0,,它设置了一个循环，你可以想到它实际上是一个循环的控制流程
Dialogue: 0,0:39:46.44,0:39:51.48,English,,0,0,0,,And by the way this is actually a same useful function it's called popcount sometimes
Dialogue: 0,0:39:46.44,0:39:51.48,Chinese,,0,0,0,,顺便说一下，这实际上是一个有用的函数，它有时被称为 popcount
Dialogue: 0,0:39:51.96,0:39:59.16,English,,0,0,0,,How many ones are there in a in a word of data in this case 64-bit word
Dialogue: 0,0:39:51.96,0:39:59.16,Chinese,,0,0,0,,在这种情况下，是用来统计 64 位字中 1 的个数
Dialogue: 0,0:39:59.56,0:40:02.38,English,,0,0,0,,There's been some generations of data lab
Dialogue: 0,0:39:59.56,0:40:02.38,Chinese,,0,0,0,,data lab 已经有好几个版本了
Dialogue: 0,0:40:02.38,0:40:06.96,English,,0,0,0,,Where you were required to write this function using all your favorite operations
Dialogue: 0,0:40:02.38,0:40:06.96,Chinese,,0,0,0,,每个版本都需要你用你喜欢的操作去实现这个函数
Dialogue: 0,0:40:09.68,0:40:14.80,English,,0,0,0,,And with a fairly small limit on operations but we're not doing that today
Dialogue: 0,0:40:09.68,0:40:14.80,Chinese,,0,0,0,,并且对操作符的限制很小，但我们今天不会去实现这个函数
Dialogue: 0,0:40:19.12,0:40:23.78,English,,0,0,0,,So here my point is you see that there's a fairly straightforward
Dialogue: 0,0:40:19.12,0:40:23.78,Chinese,,0,0,0,,所以我的观点是，这有一个相当简单的方式
Dialogue: 0,0:40:24.40,0:40:30.08,English,,0,0,0,,Way of taking this particular loop and turning it into just a combination of conditional
Dialogue: 0,0:40:24.40,0:40:30.08,Chinese,,0,0,0,,使用 do-while 循环并将其转化为各种条件的组合
Dialogue: 0,0:40:30.46,0:40:33.91,English,,0,0,0,,That where you do is you jump back to where you were before
Dialogue: 0,0:40:30.46,0:40:33.91,Chinese,,0,0,0,,你开始执行 do 的部分就是你之前需要跳转回来的位置
Dialogue: 0,0:40:34.60,0:40:36.28,English,,0,0,0,,And here's the actual code for it
Dialogue: 0,0:40:34.60,0:40:36.28,Chinese,,0,0,0,,这是它的实际代码
Dialogue: 0,0:40:37.84,0:40:44.62,English,,0,0,0,,I won't go through all of it,but you can believe from these annotations that it very closely follows the code here
Dialogue: 0,0:40:37.84,0:40:44.62,Chinese,,0,0,0,,我不会详细介绍它，但你可以从这些注释中看到它与上面的代码很相似
Dialogue: 0,0:40:45.18,0:40:54.48,English,,0,0,0,,And the main thing to see is, this jump if not equal (jne) to label l2 and that takes you back to here
Dialogue: 0,0:40:45.18,0:40:54.48,Chinese,,0,0,0,,最重要的是，jne 的标签为 L2，如果为真，那么会跳回到 L2
Dialogue: 0,0:40:57.16,0:41:03.18,English,,0,0,0,,And so the general form of it then is you take a do
Dialogue: 0,0:40:57.16,0:41:03.18,Chinese,,0,0,0,,因此，它的一般形式是你实现 do 的部分
Dialogue: 0,0:41:03.18,0:41:06.34,English,,0,0,0,,And then this part of it's called the body of the loop and this is the test
Dialogue: 0,0:41:03.18,0:41:06.34,Chinese,,0,0,0,,然后它的这部分称为循环体，这是测试
Dialogue: 0,0:41:06.96,0:41:11.88,English,,0,0,0,,And so now you set up some code where you can execute the body perform the test
Dialogue: 0,0:41:06.96,0:41:11.88,Chinese,,0,0,0,,所以现在你设置一些代码来执行循环体测试
Dialogue: 0,0:41:12.30,0:41:14.40,English,,0,0,0,,And if the test holds you go back to the loop
Dialogue: 0,0:41:12.30,0:41:14.40,Chinese,,0,0,0,,如果测试成功，你就会回到循环中
Dialogue: 0,0:41:17.30,0:41:20.58,English,,0,0,0,,So a while loop is really just why I could do loop
Dialogue: 0,0:41:17.30,0:41:20.58,Chinese,,0,0,0,,所以 do-while 循环的本质还是 while 循环
Dialogue: 0,0:41:21.58,0:41:24.78,English,,0,0,0,,A do-while loop except that you move the test to the beginning
Dialogue: 0,0:41:21.58,0:41:24.78,Chinese,,0,0,0,,将测试移到开头就变成了 while 循环
Dialogue: 0,0:41:24.80,0:41:30.60,English,,0,0,0,,And the only difference therefore is with a do loop you don't do the test it
Dialogue: 0,0:41:24.80,0:41:30.60,Chinese,,0,0,0,,因此，两者唯一的区别是 do-while 循环在第一次时不进行测试
Dialogue: 0,0:41:30.70,0:41:36.06,English,,0,0,0,,The first time through you're guaranteed to do it the first time no matter what
Dialogue: 0,0:41:30.70,0:41:36.06,Chinese,,0,0,0,,无论如何，总会运行一次循环体
Dialogue: 0,0:41:36.86,0:41:44.02,English,,0,0,0,,While a while loop will explicitly test even at the very beginning and skip over the loop if the condition doesn't hold
Dialogue: 0,0:41:36.86,0:41:44.02,Chinese,,0,0,0,,而 while 循环在最开始时就会进行测试，如果条件不成立则跳过循环
Dialogue: 0,0:41:45.50,0:41:50.72,English,,0,0,0,,So there's two ways to generate a code well there's more than two ways to generate code for a while loop
Dialogue: 0,0:41:45.50,0:41:50.72,Chinese,,0,0,0,,因此有两种方法可以为 while 循环生成代码
Dialogue: 0,0:41:51.14,0:41:54.20,English,,0,0,0,,But you'll find GCC actually uses two different ways
Dialogue: 0,0:41:51.14,0:41:54.20,Chinese,,0,0,0,,但是你会发现 GCC 实际上使用了两种不同的方式
Dialogue: 0,0:41:54.80,0:42:01.12,English,,0,0,0,,A one is what we'll find when we use this optimization setting I talked about last time
Dialogue: 0,0:41:54.80,0:42:01.12,Chinese,,0,0,0,,当我们使用上次谈到的优化设置时，我们会发现一个
Dialogue: 0,0:42:01.12,0:42:04.16,English,,0,0,0,,Called -O which stands for optimized
Dialogue: 0,0:42:01.12,0:42:04.16,Chinese,,0,0,0,,被称为 -O，O 是 optimized 优化的意思
Dialogue: 0,0:42:04.72,0:42:09.10,English,,0,0,0,,g which means debug of course as you've already know
Dialogue: 0,0:42:04.72,0:42:09.10,Chinese,,0,0,0,,g 意味着调试，当然你已经知道了
Dialogue: 0,0:42:10.44,0:42:14.26,English,,0,0,0,,There's some history to what the -g flags means
Dialogue: 0,0:42:10.44,0:42:14.26,Chinese,,0,0,0,,-g 标志的含义有一些历史
Dialogue: 0,0:42:15.24,0:42:21.18,English,,0,0,0,,So and as I mentioned last time this turns out to be the perfect level of optimization for this course
Dialogue: 0,0:42:15.24,0:42:21.18,Chinese,,0,0,0,,正如我上次提到的，-Og 是本课程的最好优化级别
Dialogue: 0,0:42:21.80,0:42:27.36,English,,0,0,0,,Where you want to be able to look at machine code and understand it and how it relates to the C code
Dialogue: 0,0:42:21.80,0:42:27.36,Chinese,,0,0,0,,你希望能够查看机器代码并理解它以及它与 C 代码的关系
Dialogue: 0,0:42:27.36,0:42:30.42,English,,0,0,0,,Because it does some sort of simple optimizations
Dialogue: 0,0:42:27.36,0:42:30.42,Chinese,,0,0,0,,因为它做了某种简单的优化
Dialogue: 0,0:42:30.44,0:42:33.76,English,,0,0,0,,But it doesn't try to rewrite your whole program to make it run better
Dialogue: 0,0:42:30.44,0:42:33.76,Chinese,,0,0,0,,但它不会尝试重写整个程序以使其运行得更好
Dialogue: 0,0:42:35.20,0:42:39.44,English,,0,0,0,,Whereas even with -O1 one which is the next level in the optimization
Dialogue: 0,0:42:35.20,0:42:39.44,Chinese,,0,0,0,,如果使用 -O1，它是优化中的下一个级别
Dialogue: 0,0:42:39.78,0:42:42.88,English,,0,0,0,,You'll find sometimes it will do some pretty quirky stuff
Dialogue: 0,0:42:39.78,0:42:42.88,Chinese,,0,0,0,,你也会发现有时它会做一些非常奇怪的事情
Dialogue: 0,0:42:44.82,0:42:49.94,English,,0,0,0,,But when you actually as a program developer as a software developer out there
Dialogue: 0,0:42:44.82,0:42:49.94,Chinese,,0,0,0,,但是当你真正作为一个软件开发人员时
Dialogue: 0,0:42:50.58,0:42:54.36,English,,0,0,0,,Or you talk to companies and you ask what optimization level do you use
Dialogue: 0,0:42:50.58,0:42:54.36,Chinese,,0,0,0,,或者你与公司交谈，并询问他们使用的优化级别
Dialogue: 0,0:42:54.78,0:42:59.20,English,,0,0,0,,Those probably say -O2 that's sort of the common one
Dialogue: 0,0:42:54.78,0:42:59.20,Chinese,,0,0,0,,他们可能会说 -O2，这是常见的那个
Dialogue: 0,0:43:00.56,0:43:03.20,English,,0,0,0,,So usually there's higher levels optimization
Dialogue: 0,0:43:00.56,0:43:03.20,Chinese,,0,0,0,,所以通常有更高级别的优化
Dialogue: 0,0:43:03.48,0:43:07.30,English,,0,0,0,,And we're purposely backing off from that to make this code easier to understand
Dialogue: 0,0:43:03.48,0:43:07.30,Chinese,,0,0,0,,我们故意降低优化等级，来让这些代码更容易理解
Dialogue: 0,0:43:08.30,0:43:13.50,English,,0,0,0,,So anyways with the this default optimization we're using for this course
Dialogue: 0,0:43:08.30,0:43:13.50,Chinese,,0,0,0,,在本课程中，无论怎样，我们都是用 -Og 作为默认优化选项
Dialogue: 0,0:43:13.98,0:43:18.10,English,,0,0,0,,It does a transformation I call the jump to middle translation
Dialogue: 0,0:43:13.98,0:43:18.10,Chinese,,0,0,0,,它做了一个转换，我称之为「jump-to-middle」
Dialogue: 0,0:43:18.48,0:43:22.40,English,,0,0,0,,These are by the way my own names you won't find them in any other document
Dialogue: 0,0:43:18.48,0:43:22.40,Chinese,,0,0,0,,这是我自己使用的术语，其他地方没有这个名词
Dialogue: 0,0:43:24.32,0:43:33.68,English,,0,0,0,,But what the idea of it is imagine again I have a while loop of this form where there's a test in the body to execute
Dialogue: 0,0:43:24.32,0:43:33.68,Chinese,,0,0,0,,但是它的想法是再次想象我有一个这种形式的 while 循环，其中有一个测试在循环体中执行
Dialogue: 0,0:43:34.26,0:43:40.38,English,,0,0,0,,Well what out the problem I have to do compared to before is some I've to execute the test before I start
Dialogue: 0,0:43:34.26,0:43:40.38,Chinese,,0,0,0,,但是与之前的 do-while 循环相比，我需要在进行
Dialogue: 0,0:43:41.13,0:43:42.68,English,,0,0,0,,The first iteration of the loop
Dialogue: 0,0:43:41.13,0:43:42.68,Chinese,,0,0,0,,循环的第一次迭代前就进行测试
Dialogue: 0,0:43:43.08,0:43:49.32,English,,0,0,0,,So the way I'll do it here,I'll just jump to the middle of the what was the old loop code
Dialogue: 0,0:43:43.08,0:43:49.32,Chinese,,0,0,0,,所以这里我采用的方式是，我只是跳到 do-while 循环代码的中间
Dialogue: 0,0:43:49.86,0:43:52.00,English,,0,0,0,,To the test portion of that loop
Dialogue: 0,0:43:49.86,0:43:52.00,Chinese,,0,0,0,,即跳转到 do-while 循环的测试部分
Dialogue: 0,0:43:52.70,0:43:57.74,English,,0,0,0,,And then let that test determine whether I actually enter the the loop itself
Dialogue: 0,0:43:52.70,0:43:57.74,Chinese,,0,0,0,,然后测试我是否可以执行循环体
Dialogue: 0,0:43:59.72,0:44:09.34,English,,0,0,0,,And so this is an example of...a go to a code version of my popcount function
Dialogue: 0,0:43:59.72,0:44:09.34,Chinese,,0,0,0,,所以这是一个例子......popcount 函数 while 版的代码
Dialogue: 0,0:44:09.78,0:44:13.10,English,,0,0,0,,So I've written the popcount function using a while loop this time
Dialogue: 0,0:44:09.78,0:44:13.10,Chinese,,0,0,0,,所以我这次使用 while 循环编写了 popcount 函数
Dialogue: 0,0:44:14.90,0:44:19.88,English,,0,0,0,,It turns out whether you use do-while or while loop, you'll get the same result in this particular function
Dialogue: 0,0:44:14.90,0:44:19.88,Chinese,,0,0,0,,事实证明，无论你使用 do-while 还是 while 循环，你都会在这个函数中得到相同的结果
Dialogue: 0,0:44:21.18,0:44:29.84,English,,0,0,0,,And you'll see the way it looks is,it jumps to the test portion of the code
Dialogue: 0,0:44:21.18,0:44:29.84,Chinese,,0,0,0,,它会跳转到代码的测试部分
Dialogue: 0,0:44:30.38,0:44:35.67,English,,0,0,0,,And then if that holds it then actually starts in the first execution of the loop
Dialogue: 0,0:44:30.38,0:44:35.67,Chinese,,0,0,0,,然后如果测试通过就能够执行第一次循环
Dialogue: 0,0:44:36.14,0:44:38.78,English,,0,0,0,,And then from there on it looks the same as the do-while loop
Dialogue: 0,0:44:36.14,0:44:38.78,Chinese,,0,0,0,,然后从这时起看起来就和 do-while 循环一样了
Dialogue: 0,0:44:38.78,0:44:45.02,English,,0,0,0,,It just does the what was in the loop does the test jumps back to the beginning
Dialogue: 0,0:44:38.78,0:44:45.02,Chinese,,0,0,0,,它执行循环体然后进行测试，循环往复
Dialogue: 0,0:44:49.26,0:44:53.72,English,,0,0,0,,Oh and then there's a second method which is in some ways more traditional
Dialogue: 0,0:44:49.26,0:44:53.72,Chinese,,0,0,0,,第二种方法在某些方面更传统
Dialogue: 0,0:44:54.42,0:45:00.28,English,,0,0,0,,And you'll find that if you use optimization one(-o1) which is a fairly useful thing to do in practice
Dialogue: 0,0:44:54.42,0:45:00.28,Chinese,,0,0,0,,你会发现，如果你使用 -O1 优化级别，这在实际编程中是一件非常有用的事情
Dialogue: 0,0:45:00.48,0:45:06.90,English,,0,0,0,,So just to show you that,instead of deciding which one I was going to show you I decided to show you both
Dialogue: 0,0:45:00.48,0:45:06.90,Chinese,,0,0,0,,我不打算选择一种进行讲解，我会对两种方式都进行讲解
Dialogue: 0,0:45:09.30,0:45:15.64,English,,0,0,0,,And the idea of that is to do a essentially to take a while loop and turn it into a do-while loop
Dialogue: 0,0:45:09.30,0:45:15.64,Chinese,,0,0,0,,第二种方法的主要思想是将 while 循环转换为 do-while 循环
Dialogue: 0,0:45:16.32,0:45:19.18,English,,0,0,0,,But introducing a conditional beforehand
Dialogue: 0,0:45:16.32,0:45:19.18,Chinese,,0,0,0,,但会先进行条件测试
Dialogue: 0,0:45:19.74,0:45:23.18,English,,0,0,0,,That would essentially guard your entrance to the loop
Dialogue: 0,0:45:19.74,0:45:23.18,Chinese,,0,0,0,,这样可以防止你直接进入循环
Dialogue: 0,0:45:24.10,0:45:25.96,English,,0,0,0,,So you do an initial test
Dialogue: 0,0:45:24.10,0:45:25.96,Chinese,,0,0,0,,所以需要做初步测试
Dialogue: 0,0:45:26.14,0:45:30.24,English,,0,0,0,,And if that's false then you skip over the loop all together
Dialogue: 0,0:45:26.14,0:45:30.24,Chinese,,0,0,0,,如果测试为假，那么将跳过所有循环
Dialogue: 0,0:45:30.48,0:45:32.78,English,,0,0,0,,Otherwise it's performed like a do-while loop
Dialogue: 0,0:45:30.48,0:45:32.78,Chinese,,0,0,0,,否则它就像 do-while 循环一样执行
Dialogue: 0,0:45:35.72,0:45:38.74,English,,0,0,0,,And so that has a fairly straightforward translation into code
Dialogue: 0,0:45:35.72,0:45:38.74,Chinese,,0,0,0,,因此，可以十分直接的将它翻译成代码
Dialogue: 0,0:45:39.48,0:45:44.54,English,,0,0,0,,And that again it looks a little different from before that it has an initial test
Dialogue: 0,0:45:39.48,0:45:44.54,Chinese,,0,0,0,,而且它与之前的有些不同，它有初步测试
Dialogue: 0,0:45:45.28,0:45:47.78,English,,0,0,0,,But then it looks so I could do while loop
Dialogue: 0,0:45:45.28,0:45:47.78,Chinese,,0,0,0,,但是后续代码就是 do-while 循环
Dialogue: 0,0:45:51.76,0:45:54.22,English,,0,0,0,,So I won't show you the assembly versions of those
Dialogue: 0,0:45:51.76,0:45:54.22,Chinese,,0,0,0,,所以我不会展示汇编代码
Dialogue: 0,0:45:54.30,0:46:05.62,English,,0,0,0,,But if you look at it actually the code is all in directories that are linked to your the the class directory,the class webpage
Dialogue: 0,0:45:54.30,0:46:05.62,Chinese,,0,0,0,,但是如果你看一下它实际上代码都在链接到你的课程目录，课程网页的目录中
Dialogue: 0,0:46:05.68,0:46:07.30,English,,0,0,0,,So you can actually look at the code
Dialogue: 0,0:46:05.68,0:46:07.30,Chinese,,0,0,0,,所以你可以看看代码
Dialogue: 0,0:46:07.66,0:46:10.96,English,,0,0,0,,And you'll see that it follows exactly the way I'm describing it
Dialogue: 0,0:46:07.66,0:46:10.96,Chinese,,0,0,0,,你会发现它完全符合我描述它的方式
Dialogue: 0,0:46:13.12,0:46:16.30,English,,0,0,0,,And then a third kind of loop is the for loop
Dialogue: 0,0:46:13.12,0:46:16.30,Chinese,,0,0,0,,然后第三种循环是 for 循环
Dialogue: 0,0:46:16.82,0:46:24.58,English,,0,0,0,,Which in C is actually a very powerful very general type of thing and so it's very commonly used
Dialogue: 0,0:46:16.82,0:46:24.58,Chinese,,0,0,0,,for 循环在 C 语言中作用非常大，非常有用
Dialogue: 0,0:46:25.12,0:46:30.26,English,,0,0,0,,But you can see that the for loop has four components to it
Dialogue: 0,0:46:25.12,0:46:30.26,Chinese,,0,0,0,,for 循环有四个部分
Dialogue: 0,0:46:30.36,0:46:38.36,English,,0,0,0,,(It) has an initialization,has a test,has a rule for doing an update in case as a way to continue the loop
Dialogue: 0,0:46:30.36,0:46:38.36,Chinese,,0,0,0,,（它）有一个初始化，有一个测试，有一个规则进行更新来继续循环
Dialogue: 0,0:46:38.70,0:46:40.30,English,,0,0,0,,And then it has the body of the loop
Dialogue: 0,0:46:38.70,0:46:40.30,Chinese,,0,0,0,,它有循环的主体
Dialogue: 0,0:46:40.90,0:46:43.62,English,,0,0,0,,And so here's a version of my pop count function
Dialogue: 0,0:46:40.90,0:46:43.62,Chinese,,0,0,0,,这是我的 popcount 函数的 for 循环版本
Dialogue: 0,0:46:45.18,0:46:52.10,English,,0,0,0,,Where I'm just going through all the bits in the word extracting them out
Dialogue: 0,0:46:45.18,0:46:52.10,Chinese,,0,0,0,,我只是遍历字的每一位并提取它们
Dialogue: 0,0:46:52.50,0:46:56.13,English,,0,0,0,,And adding them accumulating them to be the result
Dialogue: 0,0:46:52.50,0:46:56.13,Chinese,,0,0,0,,并累加它们作为结果
Dialogue: 0,0:46:57.08,0:47:00.10,English,,0,0,0,,So ripping apart this four
Dialogue: 0,0:46:57.08,0:47:00.10,Chinese,,0,0,0,,所以从四个部分看待这个代码
Dialogue: 0,0:47:00.50,0:47:07.56,English,,0,0,0,,You see that these four blocks of the loop correspond to the initialization is to set equal to zero
Dialogue: 0,0:47:00.50,0:47:07.56,Chinese,,0,0,0,,你会看到 for 循环四个部分对应的代码 init 部分是设置为 0
Dialogue: 0,0:47:08.46,0:47:11.16,English,,0,0,0,,The test is to compare i to the word size
Dialogue: 0,0:47:08.46,0:47:11.16,Chinese,,0,0,0,,test 是将 i 与单词大小进行比较
Dialogue: 0,0:47:12.54,0:47:16.46,English,,0,0,0,,Which I've set here to be eight times
Dialogue: 0,0:47:12.54,0:47:16.46,Chinese,,0,0,0,,我在这里将 wsize 设置为 int 字节数乘以 8
Dialogue: 0,0:47:16.56,0:47:22.08,English,,0,0,0,,So however many bytes there are in an int multiply that by 8 to get the word size
Dialogue: 0,0:47:16.56,0:47:22.08,Chinese,,0,0,0,,因此，无论 int 是多少字节，乘以 8 都能得到字大小
Dialogue: 0,0:47:23.30,0:47:25.20,English,,0,0,0,,And then the update is i++
Dialogue: 0,0:47:23.30,0:47:25.20,Chinese,,0,0,0,,然后更新部分是 i++
Dialogue: 0,0:47:25.70,0:47:28.66,English,,0,0,0,,And then the body is this stuff that's within the brackets here
Dialogue: 0,0:47:25.70,0:47:28.66,Chinese,,0,0,0,,然后循环体就是括号里这些代码
Dialogue: 0,0:47:30.78,0:47:34.24,English,,0,0,0,,So I can think of that in general one
Dialogue: 0,0:47:30.78,0:47:34.24,Chinese,,0,0,0,,所以我想用通用的方式表示 for 循环
Dialogue: 0,0:47:34.84,0:47:41.82,English,,0,0,0,,One general way to think about a for loop in C is by this rule
Dialogue: 0,0:47:34.84,0:47:41.82,Chinese,,0,0,0,,在 C 语言中思考 for 循环的一种通用方法是通过这个规则
Dialogue: 0,0:47:43.34,0:47:45.28,English,,0,0,0,,That will turn a for loop into a while loop
Dialogue: 0,0:47:43.34,0:47:45.28,Chinese,,0,0,0,,这将把 for 循环变成 while 循环
Dialogue: 0,0:47:47.22,0:47:52.28,English,,0,0,0,,And so what it says is I first do the initialization
Dialogue: 0,0:47:47.22,0:47:52.28,Chinese,,0,0,0,,首先进行初始化
Dialogue: 0,0:47:52.90,0:47:57.72,English,,0,0,0,,And then I do a loop where I guard it with this test
Dialogue: 0,0:47:52.90,0:47:57.72,Chinese,,0,0,0,,然后我做了一个循环，会先进行测试才能判定是否进入 for 循环
Dialogue: 0,0:47:59.30,0:48:02.76,English,,0,0,0,,And then what I keep doing is executing the body
Dialogue: 0,0:47:59.30,0:48:02.76,Chinese,,0,0,0,,然后我会执行循环体
Dialogue: 0,0:48:03.50,0:48:07.70,English,,0,0,0,,And then performing whatever update there is and then continuing with the test
Dialogue: 0,0:48:03.50,0:48:07.70,Chinese,,0,0,0,,再执行更新，接着继续测试
Dialogue: 0,0:48:08.66,0:48:14.90,English,,0,0,0,,So that's sort of the semantics the the definition of the behavior of a for loop in C
Dialogue: 0,0:48:08.66,0:48:14.90,Chinese,,0,0,0,,所以这就是 C 语言中 for 循环行为的定义
Dialogue: 0,0:48:17.66,0:48:21.86,English,,0,0,0,,So I can take my different pieces of my for loop
Dialogue: 0,0:48:17.66,0:48:21.86,Chinese,,0,0,0,,我可以将 for 循环的不同部分摘出来
Dialogue: 0,0:48:22.66,0:48:29.46,English,,0,0,0,,And say well okay I'll take that rule and use it to pack them in  to form a while loop
Dialogue: 0,0:48:22.66,0:48:29.46,Chinese,,0,0,0,,采用上述规则将其变成一个 while 循环
Dialogue: 0,0:48:30.10,0:48:33.58,English,,0,0,0,,And of course you know that you can sort of go between those two
Dialogue: 0,0:48:30.10,0:48:33.58,Chinese,,0,0,0,,当然，你可以任意选择一种
Dialogue: 0,0:48:33.90,0:48:39.92,English,,0,0,0,,It's somewhat a matter of taste whether a given loop should be written using a for loop or a while loop
Dialogue: 0,0:48:33.90,0:48:39.92,Chinese,,0,0,0,,无论是使用 for 循环还是使用 while 循环，这都是个人选择问题
Dialogue: 0,0:48:46.00,0:48:54.20,English,,0,0,0,,So one reason why it's actually useful to do this  -o1 one optimization I talked to you about is
Dialogue: 0,0:48:46.00,0:48:54.20,Chinese,,0,0,0,,因此，实际上有用的一个原因是 -O1 我与你们谈过的一个优化选项
Dialogue: 0,0:48:54.52,0:48:58.90,English,,0,0,0,,It's fairly common for the initial tests to be trivially true
Dialogue: 0,0:48:54.52,0:48:58.90,Chinese,,0,0,0,,对于初始测试而言，这是相当普遍的
Dialogue: 0,0:48:59.74,0:49:02.52,English,,0,0,0,,So for example in here if i=0
Dialogue: 0,0:48:59.74,0:49:02.52,Chinese,,0,0,0,,例如在这里，如果 i=0
Dialogue: 0,0:49:02.96,0:49:07.52,English,,0,0,0,,And I'm comparing it to the word size which would typically be 32
Dialogue: 0,0:49:02.96,0:49:07.52,Chinese,,0,0,0,,我通常将它与 32 位的字进行比较
Dialogue: 0,0:49:08.86,0:49:11.54,English,,0,0,0,,Well that test is true that's a certain thing
Dialogue: 0,0:49:08.86,0:49:11.54,Chinese,,0,0,0,,测试为真，这是肯定的
Dialogue: 0,0:49:11.92,0:49:15.14,English,,0,0,0,,And so what you'll see is that the compiler can figure that out
Dialogue: 0,0:49:11.92,0:49:15.14,Chinese,,0,0,0,,所以你会看到编译器可以解决这个问题
Dialogue: 0,0:49:15.86,0:49:22.12,English,,0,0,0,,And just throw away this guarding code would have to be there otherwise
Dialogue: 0,0:49:15.86,0:49:22.12,Chinese,,0,0,0,,然后摒弃保护代码
Dialogue: 0,0:49:22.84,0:49:23.78,English,,0,0,0,,So...
Dialogue: 0,0:49:22.84,0:49:23.78,Chinese,,0,0,0,,嗯......
Dialogue: 0,0:49:24.62,0:49:32.24,English,,0,0,0,,So that I believe the main reason why this is the transformation that gets used with the -O1 optimization level is 
Dialogue: 0,0:49:24.62,0:49:32.24,Chinese,,0,0,0,,所以我相信这是使用 -O1 级别优化的主要原因
Dialogue: 0,0:49:32.36,0:49:35.54,English,,0,0,0,,Often times it doesn't need this initial test
Dialogue: 0,0:49:32.36,0:49:35.54,Chinese,,0,0,0,,通常它不需要这个初始测试
Dialogue: 0,0:49:40.64,0:49:48.94,English,,0,0,0,,Ok so now I'm going to finish up with what's in to me at least the loop stuff is sort of what you'd expect
Dialogue: 0,0:49:40.64,0:49:48.94,Chinese,,0,0,0,,好的，现在我要结束我所了解的循环，至少是你想要的那部分
Dialogue: 0,0:49:50.80,0:49:54.34,English,,0,0,0,,If you were to have to you know turn
Dialogue: 0,0:49:50.80,0:49:54.34,Chinese,,0,0,0,,假如你要把一段 C 代码翻译成汇编码
Dialogue: 0,0:49:54.98,0:50:01.10,English,,0,0,0,,A C code into something very low level where all you could do is jumps and test
Dialogue: 0,0:49:54.98,0:50:01.10,Chinese,,0,0,0,,而在这样低层的环境下，你能用的只有跳转和测试指令
Dialogue: 0,0:50:01.74,0:50:03.64,English,,0,0,0,,Well maybe that's obvious but maybe not
Dialogue: 0,0:50:01.74,0:50:03.64,Chinese,,0,0,0,,那么，这种转换还是比较简单直白的
Dialogue: 0,0:50:04.26,0:50:07.32,English,,0,0,0,,The switch statement on the other hand is a totally different beast
Dialogue: 0,0:50:04.26,0:50:07.32,Chinese,,0,0,0,,然而 switch 语句则完全不同
Dialogue: 0,0:50:07.98,0:50:14.76,English,,0,0,0,,And I want to show you that because there's no counterpart in normal C code of how you'd even think about it
Dialogue: 0,0:50:07.98,0:50:14.76,Chinese,,0,0,0,,而且我想告诉你，因为正常的 C 代码中没有对应的操作时\N你如何考虑这个问题（译注：应该是指 bomb lab的内容）
Dialogue: 0,0:50:16.24,0:50:21.10,English,,0,0,0,,And it's fairly a little bit harder to do cipher
Dialogue: 0,0:50:16.24,0:50:21.10,Chinese,,0,0,0,,密码管理起来相当困难
Dialogue: 0,0:50:21.58,0:50:23.42,English,,0,0,0,,And you're going to have to do it in the bomb lab
Dialogue: 0,0:50:21.58,0:50:23.42,Chinese,,0,0,0,,你需要在 bomb lab 中做这件事
Dialogue: 0,0:50:25.22,0:50:28.90,English,,0,0,0,,So here's an example of a switch statement that is of
Dialogue: 0,0:50:25.22,0:50:28.90,Chinese,,0,0,0,,所以这是一个 switch 语句的例子
Dialogue: 0,0:50:29.64,0:50:33.98,English,,0,0,0,,Nothing about this is useful except to demonstrate some principles of
Dialogue: 0,0:50:29.64,0:50:33.98,Chinese,,0,0,0,,主要展示 switch 的用法
Dialogue: 0,0:50:34.00,0:50:37.48,English,,0,0,0,,How to turn a switch statement into a assembly code
Dialogue: 0,0:50:34.00,0:50:37.48,Chinese,,0,0,0,,如何将 switch 语句转换为汇编代码
Dialogue: 0,0:50:38.32,0:50:45.88,English,,0,0,0,,So the point of it is as you know in C you switch on a particular value some type of integer value
Dialogue: 0,0:50:38.32,0:50:45.88,Chinese,,0,0,0,,C 语言中你可以用不同类型的整数值来进行 switch 跳转
Dialogue: 0,0:50:46.64,0:50:49.12,English,,0,0,0,,And then it will match different cases
Dialogue: 0,0:50:46.64,0:50:49.12,Chinese,,0,0,0,,然后它将匹配不同的情况
Dialogue: 0,0:50:49.66,0:50:53.74,English,,0,0,0,,Where each of these cases has to be some constant numeric value
Dialogue: 0,0:50:49.66,0:50:53.74,Chinese,,0,0,0,,每一种情况都必须有某个常量数值
Dialogue: 0,0:50:54.58,0:50:57.44,English,,0,0,0,,Constant integer value
Dialogue: 0,0:50:54.58,0:50:57.44,Chinese,,0,0,0,,常量整数值
Dialogue: 0,0:50:58.94,0:51:01.74,English,,0,0,0,,And one of the weirdest features of C is
Dialogue: 0,0:50:58.94,0:51:01.74,Chinese,,0,0,0,,而 C 语言最奇怪的特征之一是
Dialogue: 0,0:51:02.28,0:51:06.38,English,,0,0,0,,If you don't at the end of the case if you don't explicitly say break
Dialogue: 0,0:51:02.28,0:51:06.38,Chinese,,0,0,0,,如果你没有在 case 的末尾加上 break 语句
Dialogue: 0,0:51:07.30,0:51:09.52,English,,0,0,0,,It'll do what's known as falling through
Dialogue: 0,0:51:07.30,0:51:09.52,Chinese,,0,0,0,,它就会一直继续运行下去
Dialogue: 0,0:51:10.12,0:51:15.30,English,,0,0,0,,So in this example here it will y/z
Dialogue: 0,0:51:10.12,0:51:15.30,Chinese,,0,0,0,,在这个例子中，执行完 y/z
Dialogue: 0,0:51:16.02,0:51:21.47,English,,0,0,0,,And then it will just glide right into this statement that adds z to w
Dialogue: 0,0:51:16.02,0:51:21.47,Chinese,,0,0,0,,它会继续运行 w+=z
Dialogue: 0,0:51:22.10,0:51:28.70,English,,0,0,0,,This is by the way like one of the worst design decisions in the history of programming languages
Dialogue: 0,0:51:22.10,0:51:28.70,Chinese,,0,0,0,,这是编程语言历史上最糟糕的设计之一
Dialogue: 0,0:51:28.70,0:51:31.42,English,,0,0,0,,And it's been the cause of more and more
Dialogue: 0,0:51:28.70,0:51:31.42,Chinese,,0,0,0,,这导致了越来越多的 bug
Dialogue: 0,0:51:31.98,0:51:37.58,English,,0,0,0,,You know heartbreak and bugs that nobody could understand than any other single part of the language
Dialogue: 0,0:51:31.98,0:51:37.58,Chinese,,0,0,0,,你知道 C 语言的除了这部分，没有任何其他单一部分，能让人有无法理解的心碎和错误
Dialogue: 0,0:51:38.50,0:51:43.88,English,,0,0,0,,And for some bizarre reason they've kept it alive even into java and all these other languages
Dialogue: 0,0:51:38.50,0:51:43.88,Chinese,,0,0,0,,而且由于一些奇怪的原因，他们甚至将这种设计保留在 java 和所有其他语言中
Dialogue: 0,0:51:44.80,0:51:49.12,English,,0,0,0,,That fixed a lot of the worst parts you know the most dangerous parts of C
Dialogue: 0,0:51:44.80,0:51:49.12,Chinese,,0,0,0,,这保留了你知道的 C 语言中最危险部分中许多最糟糕的部分
Dialogue: 0,0:51:49.12,0:51:50.78,English,,0,0,0,,But somehow they kept this future
Dialogue: 0,0:51:49.12,0:51:50.78,Chinese,,0,0,0,,但不知为何，他们保留了这个特性
Dialogue: 0,0:51:51.52,0:51:56.62,English,,0,0,0,,And so just as a advice as a programmer if you ever ever use this
Dialogue: 0,0:51:51.52,0:51:56.62,Chinese,,0,0,0,,如果你们曾经使用过 switch，我给你们一个建议
Dialogue: 0,0:51:57.32,0:52:01.08,English,,0,0,0,,Where you purposely want it to go from one case to another
Dialogue: 0,0:51:57.32,0:52:01.08,Chinese,,0,0,0,,在你确实需要从一个 case 跳转到另一个 case 的地方
Dialogue: 0,0:52:01.50,0:52:04.28,English,,0,0,0,,You should have to put a comment in there to say
Dialogue: 0,0:52:01.50,0:52:04.28,Chinese,,0,0,0,,请务必添加上注释
Dialogue: 0,0:52:05.04,0:52:07.50,English,,0,0,0,,Trust me I really did want it to fall through
Dialogue: 0,0:52:05.04,0:52:07.50,Chinese,,0,0,0,,相信我，我真的想要它继续往下运行
Dialogue: 0,0:52:07.50,0:52:10.98,English,,0,0,0,,I know you almost never want to do this but I do here
Dialogue: 0,0:52:07.50,0:52:10.98,Chinese,,0,0,0,,我知道你不想这样做，但我在这里这样做了
Dialogue: 0,0:52:12.50,0:52:15.12,English,,0,0,0,,So that's a fairly common convention
Dialogue: 0,0:52:12.50,0:52:15.12,Chinese,,0,0,0,,这是一个常见的习惯
Dialogue: 0,0:52:15.40,0:52:20.68,English,,0,0,0,,I don't know how many times I've had bugs that were because I forgot to put breaks
Dialogue: 0,0:52:15.40,0:52:20.68,Chinese,,0,0,0,,我数不清我因为没有写 break 语句而产生 bug 的次数了
Dialogue: 0,0:52:22.20,0:52:25.22,English,,0,0,0,,Anyways enough of my editorializing
Dialogue: 0,0:52:22.20,0:52:25.22,Chinese,,0,0,0,,我已经对 switch 语句阐述了足够多的观点
Dialogue: 0,0:52:26.48,0:52:29.48,English,,0,0,0,,The other feature you see and in C is
Dialogue: 0,0:52:26.48,0:52:29.48,Chinese,,0,0,0,,C 中另一个特点是
Dialogue: 0,0:52:29.94,0:52:33.26,English,,0,0,0,,You can sort of a bunch up multiple cases
Dialogue: 0,0:52:29.94,0:52:33.26,Chinese,,0,0,0,,你可以把多个 case 放在一起
Dialogue: 0,0:52:33.58,0:52:36.84,English,,0,0,0,,If you think of it that's just a special case of the fall through
Dialogue: 0,0:52:33.58,0:52:36.84,Chinese,,0,0,0,,如果你认为这只是一个特殊情况，需要继续往下执行
Dialogue: 0,0:52:37.18,0:52:40.89,English,,0,0,0,,Write the case five has nothing to do but to fall through to six
Dialogue: 0,0:52:37.18,0:52:40.89,Chinese,,0,0,0,,case 5 不会做任何事，会向下执行到 case 6
Dialogue: 0,0:52:41.12,0:52:44.32,English,,0,0,0,,But so that's the same general way and there's nothing
Dialogue: 0,0:52:41.12,0:52:44.32,Chinese,,0,0,0,,会经常有这种情况，所以没什么需要注意的
Dialogue: 0,0:52:44.42,0:52:48.08,English,,0,0,0,,That's not bad and it doesn't require a comment
Dialogue: 0,0:52:44.42,0:52:48.08,Chinese,,0,0,0,,所以不需要注释
Dialogue: 0,0:52:49.54,0:52:53.48,English,,0,0,0,,And the other one is that there's a default, so if none of these cases match either
Dialogue: 0,0:52:49.54,0:52:53.48,Chinese,,0,0,0,,另一个是 default，如果这些情况都不匹配
Dialogue: 0,0:52:54.12,0:52:58.34,English,,0,0,0,,Because x was 0 or smaller or x was a really big number
Dialogue: 0,0:52:54.12,0:52:58.34,Chinese,,0,0,0,,因为 x 是 0 或更小的数，或者 x 是一个非常大的数字
Dialogue: 0,0:52:58.86,0:53:00.64,English,,0,0,0,,Or in this case if x were 4
Dialogue: 0,0:52:58.86,0:53:00.64,Chinese,,0,0,0,,或者在这种情况下，如果 x 是 4
Dialogue: 0,0:53:02.12,0:53:03.62,English,,0,0,0,,There's no matching case
Dialogue: 0,0:53:02.12,0:53:03.62,Chinese,,0,0,0,,没有匹配的 case
Dialogue: 0,0:53:04.30,0:53:08.38,English,,0,0,0,,And of course you also know that these cases don't have to be in any particular order either
Dialogue: 0,0:53:04.30,0:53:08.38,Chinese,,0,0,0,,当然，你也知道这些 case 也不必按任何特定顺序排列
Dialogue: 0,0:53:09.72,0:53:17.80,English,,0,0,0,,So that's all the sort of features of a case statement, a switch statements.Sorry
Dialogue: 0,0:53:09.72,0:53:17.80,Chinese,,0,0,0,,这是 switch 语句所有的特性
Dialogue: 0,0:53:18.54,0:53:26.20,English,,0,0,0,,So normally if you write this in sort of if you were told thou shalt not use switch statements anymore
Dialogue: 0,0:53:18.54,0:53:26.20,Chinese,,0,0,0,,所以通常情况下，如果你被告知你不应该再使用 switch 语句了
Dialogue: 0,0:53:26.84,0:53:32.50,English,,0,0,0,,What you'd probably do is write this big long chain of if else,if else,if else right
Dialogue: 0,0:53:26.84,0:53:32.50,Chinese,,0,0,0,,你可能要做的就是写一个 if-else 大长链
Dialogue: 0,0:53:33.82,0:53:37.65,English,,0,0,0,,Uh and you'd expect that to be the machine code but it's not
Dialogue: 0,0:53:33.82,0:53:37.65,Chinese,,0,0,0,,你可能认为 if-else 结构是 switch 语句的机器码样式，但实际上不是
Dialogue: 0,0:53:37.84,0:53:41.78,English,,0,0,0,,And so let me show you what the machine code does
Dialogue: 0,0:53:37.84,0:53:41.78,Chinese,,0,0,0,,所以让我告诉你 swicth 的机器码做了什么
Dialogue: 0,0:53:42.30,0:53:43.84,English,,0,0,0,,It's kind of a long story
Dialogue: 0,0:53:42.30,0:53:43.84,Chinese,,0,0,0,,这是一个很长的故事
Dialogue: 0,0:53:44.62,0:53:50.08,English,,0,0,0,,So think of the general form of it as being some blocks of code
Dialogue: 0,0:53:44.62,0:53:50.08,Chinese,,0,0,0,,将它的一般形式看作一些代码块
Dialogue: 0,0:53:51.78,0:53:56.44,English,,0,0,0,,The entry points of which are labeled by these case values
Dialogue: 0,0:53:51.78,0:53:56.44,Chinese,,0,0,0,,其入口点由这些 case 值标记
Dialogue: 0,0:53:57.06,0:54:01.22,English,,0,0,0,,And then the box you know string together in various different ways and do various things
Dialogue: 0,0:53:57.06,0:54:01.22,Chinese,,0,0,0,,然后这些代码块以各种不同的方式串起来并做各种各样的事情
Dialogue: 0,0:54:02.02,0:54:06.80,English,,0,0,0,,What I'm going to do is compile a code for all of those blocks
Dialogue: 0,0:54:02.02,0:54:06.80,Chinese,,0,0,0,,我要做的是将所有这些代码块编译成一串总代码
Dialogue: 0,0:54:07.60,0:54:14.52,English,,0,0,0,,And store them away in some part of memory load up memory to contain these code blocks
Dialogue: 0,0:54:07.60,0:54:14.52,Chinese,,0,0,0,,并将它们存储在内存的某些位置，加载内存能得到这些代码块
Dialogue: 0,0:54:14.90,0:54:16.56,English,,0,0,0,,And then I'm going to build a table
Dialogue: 0,0:54:14.90,0:54:16.56,Chinese,,0,0,0,,然后我将建一张表
Dialogue: 0,0:54:17.24,0:54:24.60,English,,0,0,0,,And each entry of this table describes the starting location of one of these code blocks
Dialogue: 0,0:54:17.24,0:54:24.60,Chinese,,0,0,0,,该表的每一项都描述了一个代码块的起始位置
Dialogue: 0,0:54:25.58,0:54:29.86,English,,0,0,0,,And I'll put them in order of my case labels if I have
Dialogue: 0,0:54:25.58,0:54:29.86,Chinese,,0,0,0,,如果我一个范围的话，我会把它们按照我的 case 标签的顺序排列
Dialogue: 0,0:54:30.74,0:54:37.52,English,,0,0,0,,You know I want to span a scope from well let's assume zero but typically that's not the case
Dialogue: 0,0:54:30.74,0:54:37.52,Chinese,,0,0,0,,我们来假设一下
Dialogue: 0,0:54:37.96,0:54:40.94,English,,0,0,0,,Zero up to n-1
Dialogue: 0,0:54:37.96,0:54:40.94,Chinese,,0,0,0,,0 到 n-1
Dialogue: 0,0:54:41.44,0:54:47.14,English,,0,0,0,,I'll have this table will have that many entries of addresses to tell me
Dialogue: 0,0:54:41.44,0:54:47.14,Chinese,,0,0,0,,这个表有很多地址项
Dialogue: 0,0:54:48.76,0:54:52.00,English,,0,0,0,,Where these code blocks are located
Dialogue: 0,0:54:48.76,0:54:52.00,Chinese,,0,0,0,,这些地址项是代码块的位置
Dialogue: 0,0:54:53.58,0:54:56.62,English,,0,0,0,,And then I'm going to use this really cool instruction
Dialogue: 0,0:54:53.58,0:54:56.62,Chinese,,0,0,0,,然后我将使用这个非常酷的指令
Dialogue: 0,0:54:57.40,0:55:04.36,English,,0,0,0,,Which is a sort of like it's as if you...it's like array indexing
Dialogue: 0,0:54:57.40,0:55:04.36,Chinese,,0,0,0,,这有点像你......它就像一个数组索引
Dialogue: 0,0:55:04.54,0:55:13.46,English,,0,0,0,,So if you think of array indexing it means you can grab a value out of the middle of some you know array
Dialogue: 0,0:55:04.54,0:55:13.46,Chinese,,0,0,0,,因此，如果你想到数组索引，则意味着你可以从某些已知数组的中间获取值
Dialogue: 0,0:55:13.52,0:55:18.48,English,,0,0,0,,Some set of values without having to step through them one by one
Dialogue: 0,0:55:13.52,0:55:18.48,Chinese,,0,0,0,,不必遍历寻找
Dialogue: 0,0:55:19.30,0:55:27.30,English,,0,0,0,,And it's the same idea here that I will take my value and use that to figure out directly
Dialogue: 0,0:55:19.30,0:55:27.30,Chinese,,0,0,0,,switch 的机器码也用了同样的思想，我会用我的例子来让你们弄明白原理
Dialogue: 0,0:55:27.92,0:55:31.16,English,,0,0,0,,Where I should jump to a block of code
Dialogue: 0,0:55:27.92,0:55:31.16,Chinese,,0,0,0,,我应该跳到一个代码块
Dialogue: 0,0:55:31.62,0:55:34.58,English,,0,0,0,,Without having to step through a bunch of other conditions
Dialogue: 0,0:55:31.62,0:55:34.58,Chinese,,0,0,0,,无需通过一堆其他条件（跳到某个代码块）
Dialogue: 0,0:55:36.06,0:55:40.08,English,,0,0,0,,So and you can see the efficiency again from that it's the difference between
Dialogue: 0,0:55:36.06,0:55:40.08,Chinese,,0,0,0,,再看一下两种思想之间效率的差别
Dialogue: 0,0:55:40.78,0:55:44.90,English,,0,0,0,,Sort of in one step knowing exactly where you want to be versus
Dialogue: 0,0:55:40.78,0:55:44.90,Chinese,,0,0,0,,一步到位，准确地知道你想要跳转到的地方
Dialogue: 0,0:55:46.28,0:55:51.68,English,,0,0,0,,Stepping through you know on average n over two conditions to get to where I want to go
Dialogue: 0,0:55:46.28,0:55:51.68,Chinese,,0,0,0,,逐步的通过条件遍历找到要执行的代码块，时间复杂度为 O(n)
Dialogue: 0,0:55:54.48,0:55:57.06,English,,0,0,0,,So let's look at this at the assembly code level
Dialogue: 0,0:55:54.48,0:55:57.06,Chinese,,0,0,0,,让我们在汇编代码层面来看一下
Dialogue: 0,0:56:00.22,0:56:05.02,English,,0,0,0,,And it's a little bit of a long thing because we have to build some machinery around this
Dialogue: 0,0:56:00.22,0:56:05.02,Chinese,,0,0,0,,这需要点时间，因为我们必须围绕这个建立一些机制
Dialogue: 0,0:56:06.96,0:56:10.56,English,,0,0,0,,So here's my example I've got three arguments
Dialogue: 0,0:56:06.96,0:56:10.56,Chinese,,0,0,0,,这是我的例子，我有三个参数
Dialogue: 0,0:56:11.00,0:56:19.70,English,,0,0,0,,So just remember I told you are %rdi and %rsi for the first two arguments,the third argument is in %rdx
Dialogue: 0,0:56:11.00,0:56:19.70,Chinese,,0,0,0,,前讲过，要牢记，前两个参数分别存在 ％rdi 和 ％rsi，第三个参数存在 ％rdx
Dialogue: 0,0:56:21.48,0:56:25.70,English,,0,0,0,,And here's the beginning of the switch code
Dialogue: 0,0:56:21.48,0:56:25.70,Chinese,,0,0,0,,这是 switch 机器码的开始
Dialogue: 0,0:56:26.80,0:56:31.00,English,,0,0,0,,It's just making a copy of argument z here for some reason
Dialogue: 0,0:56:26.80,0:56:31.00,Chinese,,0,0,0,,由于某些原因，它只是在这里复制参数 z
Dialogue: 0,0:56:31.56,0:56:38.74,English,,0,0,0,,And then it's looking at comparing x to 6 and why is 6 an important number
Dialogue: 0,0:56:31.56,0:56:38.74,Chinese,,0,0,0,,然后比较 x 和 6，为什么是 6，6 是一个重要的数字
Dialogue: 0,0:56:40.62,0:56:47.70,English,,0,0,0,,Because you see 6 was the largest value of any of my cases
Dialogue: 0,0:56:40.62,0:56:47.70,Chinese,,0,0,0,,因为我的这些 case 里 6 是最大的数字
Dialogue: 0,0:56:48.16,0:56:53.18,English,,0,0,0,,And now it's using a jump instruction to go to .L8
Dialogue: 0,0:56:48.16,0:56:53.18,Chinese,,0,0,0,,现在它正在使用跳转指令转到 .L8
Dialogue: 0,0:56:53.18,0:56:57.48,English,,0,0,0,,What we'll find is that tells you what the default behavior should be
Dialogue: 0,0:56:53.18,0:56:57.48,Chinese,,0,0,0,,我们发现它会跳转到默认行为
Dialogue: 0,0:56:58.42,0:57:02.82,English,,0,0,0,,So it's sort of flushing away the default cases
Dialogue: 0,0:56:58.42,0:57:02.82,Chinese,,0,0,0,,所以它有点代替了默认行为
Dialogue: 0,0:57:02.82,0:57:06.82,English,,0,0,0,,The cases that are either x is too small or x is too large
Dialogue: 0,0:57:02.82,0:57:06.82,Chinese,,0,0,0,,x 的情况太小或 x 太大
Dialogue: 0,0:57:07.34,0:57:13.64,English,,0,0,0,,And I should mention there's a clever trick there if you look at 'ja' means jump above
Dialogue: 0,0:57:07.34,0:57:13.64,Chinese,,0,0,0,,我应该提一下，这儿有一个聪明的伎俩，「ja」意思是 jump above
Dialogue: 0,0:57:13.98,0:57:17.16,English,,0,0,0,,That's the unsigned comparison
Dialogue: 0,0:57:13.98,0:57:17.16,Chinese,,0,0,0,,这是无符号比较
Dialogue: 0,0:57:17.64,0:57:24.48,English,,0,0,0,,And what it's making use of is our result that you remember that if a number is negative
Dialogue: 0,0:57:17.64,0:57:24.48,Chinese,,0,0,0,,它正在使用我们的结果，你应该记得如果一个数字是负数
Dialogue: 0,0:57:25.08,0:57:29.64,English,,0,0,0,,If you think of it as an unsigned value it becomes very large positive value
Dialogue: 0,0:57:25.08,0:57:29.64,Chinese,,0,0,0,,如果你将其视为无符号值，则会变为非常大的正值
Dialogue: 0,0:57:30.42,0:57:38.14,English,,0,0,0,,So by doing the "ja" instead of a "jg" right. Jump greater than I'm doing jump above
Dialogue: 0,0:57:30.42,0:57:38.14,Chinese,,0,0,0,,所以通过使用「ja」而不是「jg」
Dialogue: 0,0:57:38.98,0:57:51.80,English,,0,0,0,,It's saying I want to jump to the default if either x is greater than 6
Dialogue: 0,0:57:38.98,0:57:51.80,Chinese,,0,0,0,,如果 x 大于 6，我想跳转到默认行为
Dialogue: 0,0:57:52.50,0:57:56.70,English,,0,0,0,,But also it will cause it to jump if x is less than 0
Dialogue: 0,0:57:52.50,0:57:56.70,Chinese,,0,0,0,,但如果 x 小于 0，也会导致跳转到默认行为
Dialogue: 0,0:57:57.84,0:57:58.30,English,,0,0,0,,Got it
Dialogue: 0,0:57:57.84,0:57:58.30,Chinese,,0,0,0,,明白了吗？
Dialogue: 0,0:57:58.88,0:58:04.00,English,,0,0,0,,So it's a clever trick of unsigned versus signed numbers it's taking advantage of
Dialogue: 0,0:57:58.88,0:58:04.00,Chinese,,0,0,0,,所以这是一个聪明的技巧，使用无符号数比较指令
Dialogue: 0,0:58:05.02,0:58:12.64,English,,0,0,0,,And then the final part is,this is the real heart of the work,this is my very special  goto instruction
Dialogue: 0,0:58:05.02,0:58:12.64,Chinese,,0,0,0,,然后是最后一部分，这是 switch 原理的真正核心，非常特殊的 goto 指令
Dialogue: 0,0:58:14.14,0:58:22.10,English,,0,0,0,,That lets me index into a table and extract out of that an address  and then jump to that address
Dialogue: 0,0:58:14.14,0:58:22.10,Chinese,,0,0,0,,这让我可以对表进行索引并从中提取出一个地址，然后跳转到该地址
Dialogue: 0,0:58:22.72,0:58:30.22,English,,0,0,0,,So that's what lets me go directly up to some block of code
Dialogue: 0,0:58:22.72,0:58:30.22,Chinese,,0,0,0,,这就是能够直接进入某些代码块的原理
Dialogue: 0,0:58:30.64,0:58:36.74,English,,0,0,0,,Based on whether my values will we'll see will be in the range between 0 and 6
Dialogue: 0,0:58:30.64,0:58:36.74,Chinese,,0,0,0,,根据值是否在 0 到 6 之间
Dialogue: 0,0:58:38.04,0:58:40.32,English,,0,0,0,,So there'll be seven entries in that table
Dialogue: 0,0:58:38.04,0:58:40.32,Chinese,,0,0,0,,因此该表中将有七项
Dialogue: 0,0:58:44.90,0:58:48.00,English,,0,0,0,,One thing just to keep track up for later
Dialogue: 0,0:58:44.90,0:58:48.00,Chinese,,0,0,0,,有一点只是为了以后跟踪
Dialogue: 0,0:58:48.62,0:58:53.12,English,,0,0,0,,You'll see that for some reason the GCC said you know
Dialogue: 0,0:58:48.62,0:58:53.12,Chinese,,0,0,0,,你会看到这个是由于某些原因，GCC，你懂的
Dialogue: 0,0:58:53.86,0:58:59.40,English,,0,0,0,,If I look at all the code I actually don't use w as initialized very much
Dialogue: 0,0:58:53.86,0:58:59.40,Chinese,,0,0,0,,如果我查看所有代码，我实际上不会使用 w 作为初始化
Dialogue: 0,0:58:59.58,0:59:02.46,English,,0,0,0,,So I won't bother doing it until somewhere within the code blocks
Dialogue: 0,0:58:59.58,0:59:02.46,Chinese,,0,0,0,,所以我不会在代码块中的某个地方做这件事
Dialogue: 0,0:59:03.18,0:59:05.68,English,,0,0,0,,So just we'll have to keep track of that here
Dialogue: 0,0:59:03.18,0:59:05.68,Chinese,,0,0,0,,所以我们必须在这里跟踪它
Dialogue: 0,0:59:06.56,0:59:10.90,English,,0,0,0,,Okay so this is the magic instruction
Dialogue: 0,0:59:06.56,0:59:10.90,Chinese,,0,0,0,,好的，这是魔术指令
Dialogue: 0,0:59:12.24,0:59:16.20,English,,0,0,0,,And now if we look...this is all assembly code
Dialogue: 0,0:59:12.24,0:59:16.20,Chinese,,0,0,0,,现在，如果我们看...这是所有汇编代码
Dialogue: 0,0:59:17.16,0:59:19.32,English,,0,0,0,,You'll see this is the actual jump table
Dialogue: 0,0:59:17.16,0:59:19.32,Chinese,,0,0,0,,你会看到这是实际的跳转表
Dialogue: 0,0:59:20.04,0:59:23.68,English,,0,0,0,,And it's constructed it's specified in assembly code
Dialogue: 0,0:59:20.04,0:59:23.68,Chinese,,0,0,0,,它的构造是由汇编代码指定的
Dialogue: 0,0:59:23.70,0:59:27.42,English,,0,0,0,,And it's the job of the assembler to actually fill in the contents of this table
Dialogue: 0,0:59:23.70,0:59:27.42,Chinese,,0,0,0,,填写此表的实际内容是汇编程序的工作
Dialogue: 0,0:59:28.88,0:59:31.16,English,,0,0,0,,Excuse me
Dialogue: 0,0:59:28.88,0:59:31.16,Chinese,,0,0,0,,不好意思
Dialogue: 0,0:59:32.00,0:59:36.16,English,,0,0,0,,But what the assembly code is telling the assembler is
Dialogue: 0,0:59:32.00,0:59:36.16,Chinese,,0,0,0,,汇编代码告诉汇编程序这是什么
Dialogue: 0,0:59:36.68,0:59:41.98,English,,0,0,0,,I need a quad is just a declaration to say I need an 8 byte value here
Dialogue: 0,0:59:36.68,0:59:41.98,Chinese,,0,0,0,,quad 只是一个声明，表示这儿需要一个 8 字节的值
Dialogue: 0,0:59:42.46,0:59:45.54,English,,0,0,0,,And that value should match whatever address
Dialogue: 0,0:59:42.46,0:59:45.54,Chinese,,0,0,0,,并且该值应该匹配任何地址
Dialogue: 0,0:59:46.02,0:59:49.42,English,,0,0,0,,You decide you later determine is the address of
Dialogue: 0,0:59:46.02,0:59:49.42,Chinese,,0,0,0,,你决定以后确定的是地址
Dialogue: 0,0:59:49.58,0:59:54.04,English,,0,0,0,,Where I'm going to stick and label 8  and all these other ones
Dialogue: 0,0:59:49.58,0:59:54.04,Chinese,,0,0,0,,我要坚持并标记 8 和所有其他标签
Dialogue: 0,0:59:54.44,0:59:58.54,English,,0,0,0,,And these are in the order as I mentioned from x equals 0 through 6
Dialogue: 0,0:59:54.44,0:59:58.54,Chinese,,0,0,0,,这些是我提到的从 x 等于 0 到 6 的顺序
Dialogue: 0,0:59:59.56,1:00:03.64,English,,0,0,0,,And we can already see a few cases that are interesting here
Dialogue: 0,0:59:59.56,1:00:03.64,Chinese,,0,0,0,,我们已经可以看到一些有趣的例子
Dialogue: 0,1:00:04.36,1:00:07.16,English,,0,0,0,,Let me see if I've got a picture on this
Dialogue: 0,1:00:04.36,1:00:07.16,Chinese,,0,0,0,,让我看看我是否有这方面的照片
Dialogue: 0,1:00:12.60,1:00:13.70,English,,0,0,0,,Yeah
Dialogue: 0,1:00:12.60,1:00:13.70,Chinese,,0,0,0,,有的
Dialogue: 0,1:00:16.66,1:00:22.54,English,,0,0,0,,So we can actually already see some of the logic of this switch statement
Dialogue: 0,1:00:16.66,1:00:22.54,Chinese,,0,0,0,,实际上我们已经可以看到 switch 语句的一些逻辑
Dialogue: 0,1:00:22.96,1:00:25.68,English,,0,0,0,,Built into the ordering of entries in this table
Dialogue: 0,1:00:22.96,1:00:25.68,Chinese,,0,0,0,,内置于此表中各项的顺序
Dialogue: 0,1:00:26.90,1:00:29.20,English,,0,0,0,,So in particular there is no case zero here
Dialogue: 0,1:00:26.90,1:00:29.20,Chinese,,0,0,0,,特别地这里没有 case 0
Dialogue: 0,1:00:30.04,1:00:31.70,English,,0,0,0,,So case zero should be the default
Dialogue: 0,1:00:30.04,1:00:31.70,Chinese,,0,0,0,,所以 case 0 应该是默认代码块
Dialogue: 0,1:00:32.56,1:00:34.30,English,,0,0,0,,There is no case for here
Dialogue: 0,1:00:32.56,1:00:34.30,Chinese,,0,0,0,,这儿缺少 case 4
Dialogue: 0,1:00:34.92,1:00:36.72,English,,0,0,0,,So case four should be the default
Dialogue: 0,1:00:34.92,1:00:36.72,Chinese,,0,0,0,,因此 case 4 应该是默认代码块
Dialogue: 0,1:00:37.22,1:00:42.04,English,,0,0,0,,And it turns out and we already saw before the 'ja' instruction going to .L8
Dialogue: 0,1:00:37.22,1:00:42.04,Chinese,,0,0,0,,之前我们看到了 ja  .L8 指令
Dialogue: 0,1:00:42.20,1:00:47.06,English,,0,0,0,,So .L8 is actually where the code block is going to be for the default case
Dialogue: 0,1:00:42.20,1:00:47.06,Chinese,,0,0,0,,因此 .L8 实际上是默认代码块的位置
Dialogue: 0,1:00:47.64,1:00:53.90,English,,0,0,0,,So you see basically you can think of this as sometimes kept having holes in your switch statement
Dialogue: 0,1:00:47.64,1:00:53.90,Chinese,,0,0,0,,所以你基本上可以想到，有时候你的 switch 语句中有缺漏的 case
Dialogue: 0,1:00:54.28,1:01:00.12,English,,0,0,0,,And we're going to just fill in those holes by saying those should go to the default case
Dialogue: 0,1:00:54.28,1:01:00.12,Chinese,,0,0,0,,我们会将这些缺漏的情况归到默认代码块
Dialogue: 0,1:01:03.40,1:01:09.24,English,,0,0,0,,And here you'll notice that they're not put in any particularly logical order
Dialogue: 0,1:01:03.40,1:01:09.24,Chinese,,0,0,0,,在这里你会注意到它们没有按照任何特别合乎逻辑的顺序排列
Dialogue: 0,1:01:09.82,1:01:19.94,English,,0,0,0,,A one thing you'll see again is .L7 is repeated twice here
Dialogue: 0,1:01:09.82,1:01:19.94,Chinese,,0,0,0,,.L7 在这里重复两次
Dialogue: 0,1:01:20.80,1:01:24.06,English,,0,0,0,,Because it covers both cases five and six
Dialogue: 0,1:01:20.80,1:01:24.06,Chinese,,0,0,0,,因为它代表了 case 5 和 case 6
Dialogue: 0,1:01:24.44,1:01:27.92,English,,0,0,0,,So again you'll see this sort of doubling up is handled automatically
Dialogue: 0,1:01:24.44,1:01:27.92,Chinese,,0,0,0,,通过两次 .L7 就能自动处理这种多个 case 对应同一种行为的情况
Dialogue: 0,1:01:28.56,1:01:33.76,English,,0,0,0,,By the jump table will give you the same address for multiple different cases
Dialogue: 0,1:01:28.56,1:01:33.76,Chinese,,0,0,0,,通过跳转表将为多个不同的情况提供相同的地址
Dialogue: 0,1:01:38.32,1:01:41.74,English,,0,0,0,,Okay and now the rest of it is to look at the various code box
Dialogue: 0,1:01:38.32,1:01:41.74,Chinese,,0,0,0,,好的，现在剩下的就是查看各种代码块
Dialogue: 0,1:01:41.74,1:01:48.43,English,,0,0,0,,And this by the way I'm showing you, I'm took a file you know extracted little bits of it
Dialogue: 0,1:01:41.74,1:01:48.43,Chinese,,0,0,0,,我会把每个小部分挨个展示
Dialogue: 0,1:01:48.48,1:01:52.00,English,,0,0,0,,But normally you're looking at this whole listing in one big order
Dialogue: 0,1:01:48.48,1:01:52.00,Chinese,,0,0,0,,但你一般会直接阅读整块代码
Dialogue: 0,1:01:53.06,1:01:57.62,English,,0,0,0,,So now we can look at the individual code blocks and see what's going on
Dialogue: 0,1:01:53.06,1:01:57.62,Chinese,,0,0,0,,现在我们看看各个代码块做了什么事情
Dialogue: 0,1:01:57.62,1:02:01.94,English,,0,0,0,,And you'll see for example case one told me to multiply two numbers
Dialogue: 0,1:01:57.62,1:02:01.94,Chinese,,0,0,0,,比如 case1 是两个数相乘
Dialogue: 0,1:02:02.54,1:02:03.94,English,,0,0,0,,And you'll see that the break
Dialogue: 0,1:02:02.54,1:02:03.94,Chinese,,0,0,0,,然后 break
Dialogue: 0,1:02:04.50,1:02:08.02,English,,0,0,0,,In general it's just going to be turned into returned instructions here
Dialogue: 0,1:02:04.50,1:02:08.02,Chinese,,0,0,0,,一般情况下，break 只会转换为返回指令（ret）
Dialogue: 0,1:02:08.02,1:02:13.70,English,,0,0,0,,Because my function...let's go sorry to jump in code
Dialogue: 0,1:02:08.02,1:02:13.70,Chinese,,0,0,0,,因为我的函数......让我们转到代码
Dialogue: 0,1:02:13.76,1:02:17.86,English,,0,0,0,,You see this function did a switch statement and then whatever
Dialogue: 0,1:02:13.76,1:02:17.86,Chinese,,0,0,0,,这个函数中有一个 switch 语句
Dialogue: 0,1:02:19.86,1:02:24.74,English,,0,0,0,,Whatever it gets computed within the switch statement gets returned as a result of this
Dialogue: 0,1:02:19.86,1:02:24.74,Chinese,,0,0,0,,无论在 switch 中如何计算，最终都会返回结果
Dialogue: 0,1:02:25.50,1:02:32.24,English,,0,0,0,,So the compiler doesn't actually come to a single point and say okay everyone returned at this point
Dialogue: 0,1:02:25.50,1:02:32.24,Chinese,,0,0,0,,实际上，编译器并不是达到某一点并且说好每种情况都在该点返回
Dialogue: 0,1:02:32.24,1:02:36.60,English,,0,0,0,,It just sticks returns directly in wherever these breaks occur
Dialogue: 0,1:02:32.24,1:02:36.60,Chinese,,0,0,0,,它只会直接在 break 处返回
Dialogue: 0,1:02:42.48,1:02:44.82,English,,0,0,0,,And so here it does a multiply and a return
Dialogue: 0,1:02:42.48,1:02:44.82,Chinese,,0,0,0,,所以这儿做了乘法并返回
Dialogue: 0,1:02:46.94,1:02:53.80,English,,0,0,0,,Here is actually a curious by the way I'm always somewhat surprised by what the compiler does
Dialogue: 0,1:02:46.94,1:02:53.80,Chinese,,0,0,0,,实际上这是一种奇怪的方式，我总是对编译器的具体做法感到有些惊讶
Dialogue: 0,1:02:55.26,1:02:57.54,English,,0,0,0,,It is never exactly what you'd expect
Dialogue: 0,1:02:55.26,1:02:57.54,Chinese,,0,0,0,,它永远不会是你期望的那种方式
Dialogue: 0,1:02:58.64,1:03:09.52,English,,0,0,0,,So in particular, it patched together this fall through case by two blocks of code
Dialogue: 0,1:02:58.64,1:03:09.52,Chinese,,0,0,0,,比如这，它把两个连续执行的两个代码块合在了一起
Dialogue: 0,1:03:11.32,1:03:14.10,English,,0,0,0,,And it had to do these separately
Dialogue: 0,1:03:11.32,1:03:14.10,Chinese,,0,0,0,,它必须分开做这些
Dialogue: 0,1:03:14.12,1:03:22.84,English,,0,0,0,,Because remember w was not set before I entered the this these code blocks it deferred setting that
Dialogue: 0,1:03:14.12,1:03:22.84,Chinese,,0,0,0,,因为在我进入这些代码块之前 w 没有被赋值为 1，也就是说，w 被推迟赋值了
Dialogue: 0,1:03:23.30,1:03:26.42,English,,0,0,0,,And here I hit case three and all of a sudden I actually need
Dialogue: 0,1:03:23.30,1:03:26.42,Chinese,,0,0,0,,当直接进入 case 3 时，突然间我真的需要
Dialogue: 0,1:03:26.80,1:03:29.16,English,,0,0,0,,Whatever w was which was one
Dialogue: 0,1:03:26.80,1:03:29.16,Chinese,,0,0,0,,w 的值为 1
Dialogue: 0,1:03:29.68,1:03:36.24,English,,0,0,0,,And so I guess the compiler said well gosh I guess I better set w to one here before we continue
Dialogue: 0,1:03:29.68,1:03:36.24,Chinese,,0,0,0,,所以编译器会提前将 w 设置为 1
Dialogue: 0,1:03:36.96,1:03:39.48,English,,0,0,0,,So as the result it sort of creates two code blocks
Dialogue: 0,1:03:36.96,1:03:39.48,Chinese,,0,0,0,,结果它创建了两个代码块
Dialogue: 0,1:03:39.50,1:03:43.18,English,,0,0,0,,But it jumps from the second one the
Dialogue: 0,1:03:39.50,1:03:43.18,Chinese,,0,0,0,,但是 case 2 会直接跳到第二个代码块
Dialogue: 0,1:03:43.42,1:03:47.06,English,,0,0,0,,This block into partway through this other block
Dialogue: 0,1:03:43.42,1:03:47.06,Chinese,,0,0,0,,w=1 这块代码位于两块代码之间
Dialogue: 0,1:03:51.20,1:03:56.30,English,,0,0,0,,Here's some actual,yeah so here's the actual code
Dialogue: 0,1:03:51.20,1:03:56.30,Chinese,,0,0,0,,这是实际的汇编代码
Dialogue: 0,1:03:57.28,1:04:01.96,English,,0,0,0,,This is the block that does the division it's very quirky how you have to write division
Dialogue: 0,1:03:57.28,1:04:01.96,Chinese,,0,0,0,,这是划分好的代码块，这种划分方式很奇怪
Dialogue: 0,1:04:02.50,1:04:04.84,English,,0,0,0,,It's covered in the book I won't go through it here
Dialogue: 0,1:04:02.50,1:04:04.84,Chinese,,0,0,0,,这是书中内容，我不会继续深入讲解它了
Dialogue: 0,1:04:05.44,1:04:08.98,English,,0,0,0,,And then this jump .L6 is what I say go to merge
Dialogue: 0,1:04:05.44,1:04:08.98,Chinese,,0,0,0,,然后这个跳转 .L6 就是我说的合并
Dialogue: 0,1:04:09.50,1:04:12.30,English,,0,0,0,,And the merge is where you're bringing these two cases together
Dialogue: 0,1:04:09.50,1:04:12.30,Chinese,,0,0,0,,合并是你将这两个 case 放在一起的地方
Dialogue: 0,1:04:12.86,1:04:15.00,English,,0,0,0,,Here is where it's setting l to one
Dialogue: 0,1:04:12.86,1:04:15.00,Chinese,,0,0,0,,这是 w 设为 1 的地方
Dialogue: 0,1:04:17.22,1:04:22.88,English,,0,0,0,,Again it's making use of this feature and that the upper 32 bits get set to zeros
Dialogue: 0,1:04:17.22,1:04:22.88,Chinese,,0,0,0,,再次强调一下，movl 会将高 32 位设置为零
Dialogue: 0,1:04:22.96,1:04:26.72,English,,0,0,0,,So I can use a movl instruction here
Dialogue: 0,1:04:22.96,1:04:26.72,Chinese,,0,0,0,,所以我可以在这里使用 movl 指令
Dialogue: 0,1:04:26.72,1:04:27.56,English,,0,0,0,,Yes question
Dialogue: 0,1:04:26.72,1:04:27.56,Chinese,,0,0,0,,是的问题
Dialogue: 0,1:04:27.72,1:04:33.94,English,,0,0,0,,[student speaking]
Dialogue: 0,1:04:27.72,1:04:33.94,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:33.98,1:04:39.24,English,,0,0,0,,Did not have the code for what...no the jump table is sort of embedded
Dialogue: 0,1:04:33.98,1:04:39.24,Chinese,,0,0,0,,没有代码...没有跳转表是嵌入的
Dialogue: 0,1:04:39.94,1:04:41.34,English,,0,0,0,,Let me just show you real quick
Dialogue: 0,1:04:39.94,1:04:41.34,Chinese,,0,0,0,,让我快速向你展示
Dialogue: 0,1:04:44.08,1:04:45.14,English,,0,0,0,,No probably bad idea
Dialogue: 0,1:04:44.08,1:04:45.14,Chinese,,0,0,0,,并不好展示
Dialogue: 0,1:04:48.10,1:04:52.30,English,,0,0,0,,The jump if you look at the the .s file the assembly code file
Dialogue: 0,1:04:48.10,1:04:52.30,Chinese,,0,0,0,,如果你查看「.s」的汇编代码文件
Dialogue: 0,1:04:52.98,1:04:56.84,English,,0,0,0,,Oh all this stuff I'm showing you i've extracted out of that
Dialogue: 0,1:04:52.98,1:04:56.84,Chinese,,0,0,0,,我展示的这些全部都有，只不过我没有全部展示，只是进行部分展示
Dialogue: 0,1:04:57.48,1:05:02.04,English,,0,0,0,,But it's all in there and so that the compiler generated these tables
Dialogue: 0,1:04:57.48,1:05:02.04,Chinese,,0,0,0,,但表是存在的，编译器生成了这些表
Dialogue: 0,1:05:02.48,1:05:05.12,English,,0,0,0,,At least the sort of framework for these tables
Dialogue: 0,1:05:02.48,1:05:05.12,Chinese,,0,0,0,,至少这些表的框架是由编译器生成的
Dialogue: 0,1:05:05.58,1:05:08.14,English,,0,0,0,,The details of which get filled in by the assembler
Dialogue: 0,1:05:05.58,1:05:08.14,Chinese,,0,0,0,,表的详细信息由汇编程序填写
Dialogue: 0,1:05:08.82,1:05:11.06,English,,0,0,0,,So it is generated by the compiler
Dialogue: 0,1:05:08.82,1:05:11.06,Chinese,,0,0,0,,所以它是由编译器生成的
Dialogue: 0,1:05:16.66,1:05:23.34,English,,0,0,0,,Okay so that just shows you this one example of handling a particular way to handle the fall through case
Dialogue: 0,1:05:16.66,1:05:23.34,Chinese,,0,0,0,,好的，这仅仅是用特别方法处理 fall through case 的一个例子
Dialogue: 0,1:05:24.44,1:05:31.16,English,,0,0,0,,And then the remaining ones, again you'll see here I got, if I get to this case
Dialogue: 0,1:05:24.44,1:05:31.16,Chinese,,0,0,0,,然后剩下的那些，还会遇到我们刚刚看到的那些
Dialogue: 0,1:05:31.30,1:05:34.04,English,,0,0,0,,I need the fact that w is initialized to 1
Dialogue: 0,1:05:31.30,1:05:34.04,Chinese,,0,0,0,,我需要 w 被初始化为 1
Dialogue: 0,1:05:34.68,1:05:35.88,English,,0,0,0,,So we'll do so here
Dialogue: 0,1:05:34.68,1:05:35.88,Chinese,,0,0,0,,所以我们在这里进行 w 的初始化
Dialogue: 0,1:05:37.20,1:05:41.06,English,,0,0,0,,In the default case it just assigns to 2w and so that's all it does
Dialogue: 0,1:05:37.20,1:05:41.06,Chinese,,0,0,0,,在默认情况下， w 被赋值为 2
Dialogue: 0,1:05:41.94,1:05:44.66,English,,0,0,0,,So anyways I've actually shown you all the code box
Dialogue: 0,1:05:41.94,1:05:44.66,Chinese,,0,0,0,,我已经向你们展示了所有的代码块
Dialogue: 0,1:05:44.88,1:05:50.62,English,,0,0,0,,But I've shown you one by one, but they're just all kind of strung in the file and in no particular order
Dialogue: 0,1:05:44.88,1:05:50.62,Chinese,,0,0,0,,只不过我是逐一向你们展示，将它们串起来就形成了文件，并没有特别的顺序
Dialogue: 0,1:05:51.14,1:05:52.93,English,,0,0,0,,It doesn't matter what order they are
Dialogue: 0,1:05:51.14,1:05:52.93,Chinese,,0,0,0,,它们的顺序无关紧要
Dialogue: 0,1:05:53.38,1:05:54.04,English,,0,0,0,,Yes
Dialogue: 0,1:05:53.38,1:05:54.04,Chinese,,0,0,0,,是
Dialogue: 0,1:05:55.34,1:06:02.24,English,,0,0,0,,[student speaking]
Dialogue: 0,1:05:55.34,1:06:02.24,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:06:02.24,1:06:06.00,English,,0,0,0,,Yes so that was the reason for that jump above(ja) at the beginning
Dialogue: 0,1:06:02.24,1:06:06.00,Chinese,,0,0,0,,是的，这就是在开始时 jump above（ja）的原因
Dialogue: 0,1:06:10.10,1:06:17.76,English,,0,0,0,,So this jump above(ja) .L8 was a way that if x was either less than zero or greater than 6
Dialogue: 0,1:06:10.10,1:06:17.76,Chinese,,0,0,0,,ja .L8 是一种方法，如果 x 小于 0 或大于 6，就会跳转到 .L8
Dialogue: 0,1:06:18.74,1:06:23.40,English,,0,0,0,,It would go to the default case and it will only do this indexing trick
Dialogue: 0,1:06:18.74,1:06:23.40,Chinese,,0,0,0,,.L8 是默认情况，如果 x 介于 0 和 6 之间
Dialogue: 0,1:06:24.48,1:06:31.36,English,,0,0,0,,If x is between 0 and 6
Dialogue: 0,1:06:24.48,1:06:31.36,Chinese,,0,0,0,,就会进行索引
Dialogue: 0,1:06:32.72,1:06:35.36,English,,0,0,0,,And that's typically the way this works that you'll see that
Dialogue: 0,1:06:32.72,1:06:35.36,Chinese,,0,0,0,,这通常是你看到的方式
Dialogue: 0,1:06:36.28,1:06:42.36,English,,0,0,0,,Whatever range of values you give it has to figure out the smallest and the largest one set up
Dialogue: 0,1:06:36.28,1:06:42.36,Chinese,,0,0,0,,无论你给的值是多少，都必须找出最小值和最大值
Dialogue: 0,1:06:42.54,1:06:48.90,English,,0,0,0,,So it goes to the default case if it's out of that range and then set up a table for the values within that range
Dialogue: 0,1:06:42.54,1:06:48.90,Chinese,,0,0,0,,如果它超出该范围，则进入默认情况（default），然后为该范围内的值设置表
Dialogue: 0,1:06:49.34,1:06:50.06,English,,0,0,0,,Question
Dialogue: 0,1:06:49.34,1:06:50.06,Chinese,,0,0,0,,问吧
Dialogue: 0,1:06:50.24,1:06:58.52,English,,0,0,0,,[student speaking]
Dialogue: 0,1:06:50.24,1:06:58.52,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,1:06:58.52,1:07:02.20,English,,0,0,0,,So the question I'm rose I should be repeating questions
Dialogue: 0,1:06:58.52,1:07:02.20,Chinese,,0,0,0,,我重复下问题
Dialogue: 0,1:07:02.62,1:07:08.38,English,,0,0,0,,The question is of what if it's a negative number for your case which is perfectly legal
Dialogue: 0,1:07:02.62,1:07:08.38,Chinese,,0,0,0,,问题是如果 case 的值为负，这种情况经常出现
Dialogue: 0,1:07:08.78,1:07:12.12,English,,0,0,0,,It will typically add a bias to it effectively
Dialogue: 0,1:07:08.78,1:07:12.12,Chinese,,0,0,0,,它通常会进行偏置处理
Dialogue: 0,1:07:12.14,1:07:16.32,English,,0,0,0,,So that whatever your lowest value was become zero
Dialogue: 0,1:07:12.14,1:07:16.32,Chinese,,0,0,0,,所以无论你的最小值是多少，都会通过增加偏置值的方式变成 0
Dialogue: 0,1:07:17.02,1:07:20.76,English,,0,0,0,,Or it'll do something like that to avoid having to do negative indexing
Dialogue: 0,1:07:17.02,1:07:20.76,Chinese,,0,0,0,,或者它会做类似的事情，以避免出现负数索引
Dialogue: 0,1:07:21.74,1:07:25.02,English,,0,0,0,,Another question I see,yes
Dialogue: 0,1:07:21.74,1:07:25.02,Chinese,,0,0,0,,提问吧
Dialogue: 0,1:07:25.62,1:07:32.20,English,,0,0,0,,....yeah so you can go from zero to a million ....
Dialogue: 0,1:07:25.62,1:07:32.20,Chinese,,0,0,0,,如果只有 case 0 和 case 1000000 两种，难道中间的所有值都要建表吗
Dialogue: 0,1:07:33.12,1:07:36.34,English,,0,0,0,,Yeah they could be you could go zero in a million and nothing in between right
Dialogue: 0,1:07:33.12,1:07:36.34,Chinese,,0,0,0,,是的，存在这种情况
Dialogue: 0,1:07:36.86,1:07:42.10,English,,0,0,0,,So you'd have two cases you really don't want a million entry table for just two cases
Dialogue: 0,1:07:36.86,1:07:42.10,Chinese,,0,0,0,,你只有两个 case，但是你不想仅仅因为两个 case 就建个有百万项的表
Dialogue: 0,1:07:42.66,1:07:44.80,English,,0,0,0,,So it will turn it into if felts code
Dialogue: 0,1:07:42.66,1:07:44.80,Chinese,,0,0,0,,所以会变成 if-else 代码
Dialogue: 0,1:07:45.28,1:07:48.24,English,,0,0,0,,But the clever thing it will do if you know binary search
Dialogue: 0,1:07:45.28,1:07:48.24,Chinese,,0,0,0,,但是会聪明一点的建立 if-else 代码，如果你了解二分搜索
Dialogue: 0,1:07:49.38,1:07:54.82,English,,0,0,0,,It relies on the fact that it knows in advance all the values and it will actually set up a tree of if felts is
Dialogue: 0,1:07:49.38,1:07:54.82,Chinese,,0,0,0,,它依赖于这样一个事实：它事先知道所有的值，它实际上会建立一个 if-else 树
Dialogue: 0,1:07:55.58,1:08:02.16,English,,0,0,0,,So really it will do it, if you want to thank algorithmically it does it with a logarithmic number of tests
Dialogue: 0,1:07:55.58,1:08:02.16,Chinese,,0,0,0,,它真的会这样做，这能够让时间复杂度变为 log2(n)
Dialogue: 0,1:08:02.88,1:08:07.16,English,,0,0,0,,Rather than a linear number of tests
Dialogue: 0,1:08:02.88,1:08:07.16,Chinese,,0,0,0,,而不是 O(n)
Dialogue: 0,1:08:07.16,1:08:09.16,English,,0,0,0,,Question
Dialogue: 0,1:08:07.16,1:08:09.16,Chinese,,0,0,0,,问吧
Dialogue: 0,1:08:09.38,1:08:16.58,English,,0,0,0,,[student speaking]
Dialogue: 0,1:08:09.38,1:08:16.58,Chinese,,0,0,0,,[学生发言]
Dialogue: 0,1:08:16.68,1:08:19.74,English,,0,0,0,,Oh yes yeah so
Dialogue: 0,1:08:16.68,1:08:19.74,Chinese,,0,0,0,,哦，是的，是的
Dialogue: 0,1:08:20.62,1:08:22.26,English,,0,0,0,,So these two answers that
Dialogue: 0,1:08:20.62,1:08:22.26,Chinese,,0,0,0,,我回答一下这两个问题
Dialogue: 0,1:08:22.26,1:08:25.46,English,,0,0,0,,One is if which I actually answered both now
Dialogue: 0,1:08:22.26,1:08:25.46,Chinese,,0,0,0,,一个是我已经回答的问题
Dialogue: 0,1:08:25.98,1:08:32.12,English,,0,0,0,,If one is what if there's some negative values or what if the lowest number is 5700 right
Dialogue: 0,1:08:25.98,1:08:32.12,Chinese,,0,0,0,,如果有一个负值，或者如果最小值是 5700，那么该怎么办？
Dialogue: 0,1:08:32.54,1:08:35.42,English,,0,0,0,,Well what it will typically do is put some bias
Dialogue: 0,1:08:32.54,1:08:35.42,Chinese,,0,0,0,,通常的做法是进行偏置
Dialogue: 0,1:08:36.22,1:08:41.14,English,,0,0,0,,And you'll add or subtract some value so that the first case is at value 0
Dialogue: 0,1:08:36.22,1:08:41.14,Chinese,,0,0,0,,通过加上或减去某个值让第一个 case 为 0
Dialogue: 0,1:08:41.86,1:08:45.36,English,,0,0,0,,So that's why it handles you know ones that are just completely out of range
Dialogue: 0,1:08:41.86,1:08:45.36,Chinese,,0,0,0,,这就是为什么它能够处理那些完全超出范围值的原因
Dialogue: 0,1:08:45.62,1:08:50.98,English,,0,0,0,,And the other is what if it's a really big spread of values and relatively sparse
Dialogue: 0,1:08:45.62,1:08:50.98,Chinese,,0,0,0,,另一个如果值的范围很大，并且相对稀疏
Dialogue: 0,1:08:51.50,1:08:55.58,English,,0,0,0,,How much you're using it and there will revert to if-else code
Dialogue: 0,1:08:51.50,1:08:55.58,Chinese,,0,0,0,,用到的值都会被转变成 if-else 代码
Dialogue: 0,1:08:55.74,1:08:59.22,English,,0,0,0,,And the compiler has its own rules about how it does these things
Dialogue: 0,1:08:55.74,1:08:59.22,Chinese,,0,0,0,,并且编译器有如何执行这些操作的规则
Dialogue: 0,1:08:59.22,1:09:02.34,English,,0,0,0,,You can sort of run experiments and try and reverse engineer
Dialogue: 0,1:08:59.22,1:09:02.34,Chinese,,0,0,0,,你可以进行实验并尝试逆向工程
Dialogue: 0,1:09:03.28,1:09:06.46,English,,0,0,0,,Those 0 these are all valid questions by the way appreciate
Dialogue: 0,1:09:03.28,1:09:06.46,Chinese,,0,0,0,,提问的问题都很好
Dialogue: 0,1:09:11.98,1:09:15.86,English,,0,0,0,,Okay so we're going to get through this
Dialogue: 0,1:09:11.98,1:09:15.86,Chinese,,0,0,0,,好的，我们要结束这部分了
Dialogue: 0,1:09:17.48,1:09:26.26,English,,0,0,0,,Oh so anyways in like I said I think in my own experience you know understanding
Dialogue: 0,1:09:17.48,1:09:26.26,Chinese,,0,0,0,,就像我说的那样，根据我的经验
Dialogue: 0,1:09:27.90,1:09:36.42,English,,0,0,0,,The conditionals you can kind of figure that out it's intuitive sort of feels like what you'd expect a program to do
Dialogue: 0,1:09:27.90,1:09:36.42,Chinese,,0,0,0,,如果你理解了条件，你就能凭感觉弄明白程序做了什么
Dialogue: 0,1:09:36.82,1:09:43.56,English,,0,0,0,,Whereas the switch statement is maybe unexpected,it's a way to do something
Dialogue: 0,1:09:36.82,1:09:43.56,Chinese,,0,0,0,,虽然 switch 可能不常用，但它是一种解决方法
Dialogue: 0,1:09:44.00,1:09:50.94,English,,0,0,0,,That is not totally obvious but if then when you think about it and appreciate it
Dialogue: 0,1:09:44.00,1:09:50.94,Chinese,,0,0,0,,但如果你思考过它并欣赏它的话
Dialogue: 0,1:09:50.94,1:09:54.68,English,,0,0,0,,Actually it gives you a good performance boost
Dialogue: 0,1:09:50.94,1:09:54.68,Chinese,,0,0,0,,实际上它可以为你带来良好的性能提升
Dialogue: 0,1:09:55.12,1:09:57.86,English,,0,0,0,,You know again algorithmically this jump table makes it
Dialogue: 0,1:09:55.12,1:09:57.86,Chinese,,0,0,0,,跳转表从算法层面带来了性能提升
Dialogue: 0,1:09:58.34,1:10:06.28,English,,0,0,0,,So it's a constant time a constant number of steps to get to where you need to in the switch statement
Dialogue: 0,1:09:58.34,1:10:06.28,Chinese,,0,0,0,,因此，在 switch 语句中获取所需位置的时间复杂度时 O(1)
Dialogue: 0,1:10:06.86,1:10:10.48,English,,0,0,0,,If you just did it linearly one after the other
Dialogue: 0,1:10:06.86,1:10:10.48,Chinese,,0,0,0,,如果你只是线性的一个接一个地查找
Dialogue: 0,1:10:10.92,1:10:16.10,English,,0,0,0,,Then that would be linear time and you'd expect on you know if everything's uniform and average
Dialogue: 0,1:10:10.92,1:10:16.10,Chinese,,0,0,0,,将会是线性时间复杂度
Dialogue: 0,1:10:16.52,1:10:19.92,English,,0,0,0,,About how you'd be about halfway through on average
Dialogue: 0,1:10:16.52,1:10:19.92,Chinese,,0,0,0,,关于二分折半的方式
Dialogue: 0,1:10:20.74,1:10:25.10,English,,0,0,0,,If you...if it's sparse you'll see it will set up a tree of conditionals
Dialogue: 0,1:10:20.74,1:10:25.10,Chinese,,0,0,0,,如果数值是稀疏的，它会设置一个条件树
Dialogue: 0,1:10:25.60,1:10:27.76,English,,0,0,0,,So it can do in logarithmic time so
Dialogue: 0,1:10:25.60,1:10:27.76,Chinese,,0,0,0,,所以它可以在对数时间内完成
Dialogue: 0,1:10:28.08,1:10:32.66,English,,0,0,0,,No matter what it will be better than just what you'd get in the obvious form of your felts
Dialogue: 0,1:10:28.08,1:10:32.66,Chinese,,0,0,0,,不管哪种情况都要优于 if-else 形式
Dialogue: 0,1:10:32.79,1:10:33.96,English,,0,0,0,,I saw a question over here
Dialogue: 0,1:10:32.79,1:10:33.96,Chinese,,0,0,0,,我看到有人提问
Dialogue: 0,1:10:34.00,1:10:37.90,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:34.00,1:10:37.90,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:10:37.90,1:10:44.58,English,,0,0,0,,Well the good news is,I don't set up the jump tree the compiler sets up the jump tree right
Dialogue: 0,1:10:37.90,1:10:44.58,Chinese,,0,0,0,,好消息是，我没有设置跳转树，而是编译器正确设置跳转树
Dialogue: 0,1:10:45.46,1:10:49.52,English,,0,0,0,,But if you're asking if I were a compiler how would I set up the jump tree right
Dialogue: 0,1:10:45.46,1:10:49.52,Chinese,,0,0,0,,但是，如果你问我如果我是编译器，我将如何正确设置跳转树
Dialogue: 0,1:10:49.52,1:10:51.02,English,,0,0,0,,Which is a good question
Dialogue: 0,1:10:49.52,1:10:51.02,Chinese,,0,0,0,,这是个好问题
Dialogue: 0,1:10:51.44,1:10:53.28,English,,0,0,0,,If you know binary search right
Dialogue: 0,1:10:51.44,1:10:53.28,Chinese,,0,0,0,,如果你知道二分查找
Dialogue: 0,1:10:53.28,1:10:57.80,English,,0,0,0,,That you've got a range of values and you pick you compare it to the middle value
Dialogue: 0,1:10:53.28,1:10:57.80,Chinese,,0,0,0,,你有一定范围的值，你选择一个并将其与中间值进行比较
Dialogue: 0,1:10:58.14,1:11:01.22,English,,0,0,0,,And it's either less or it's greater or equal
Dialogue: 0,1:10:58.14,1:11:01.22,Chinese,,0,0,0,,要么小于，要么大于或者相等
Dialogue: 0,1:11:01.86,1:11:07.40,English,,0,0,0,,And if it's less than you sort of recursively handle the one set and if it's greater at the other hip
Dialogue: 0,1:11:01.86,1:11:07.40,Chinese,,0,0,0,,如果小于则递归处理一组数，如果大于则处理另外一组
Dialogue: 0,1:11:07.72,1:11:09.90,English,,0,0,0,,That's exactly what these trees look like
Dialogue: 0,1:11:07.72,1:11:09.90,Chinese,,0,0,0,,这是跳转树的准确形式
Dialogue: 0,1:11:10.58,1:11:13.90,English,,0,0,0,,So they're balanced binary trees and they're taking advantage of the fact
Dialogue: 0,1:11:10.58,1:11:13.90,Chinese,,0,0,0,,它们是平衡二叉树，他们正在利用这个事实
Dialogue: 0,1:11:14.52,1:11:16.86,English,,0,0,0,,That in C which is not true in all languages
Dialogue: 0,1:11:14.52,1:11:16.86,Chinese,,0,0,0,,在 C 语言中是这样的，但不是所有语言都是这样的
Dialogue: 0,1:11:17.30,1:11:23.98,English,,0,0,0,,That all the this case conditions you're looking at our constants they're determined
Dialogue: 0,1:11:17.30,1:11:23.98,Chinese,,0,0,0,,所有的 case 条件值已经确定了
Dialogue: 0,1:11:24.74,1:11:28.16,English,,0,0,0,,When the compiler is doing the compilation those are constant values
Dialogue: 0,1:11:24.74,1:11:28.16,Chinese,,0,0,0,,当编译器进行编译时，这些是常量值
Dialogue: 0,1:11:28.26,1:11:33.02,English,,0,0,0,,So it can sort them figure out how many there are what range of values
Dialogue: 0,1:11:28.26,1:11:33.02,Chinese,,0,0,0,,因此，它可以对它们进行排序，以确定值的范围
Dialogue: 0,1:11:33.02,1:11:36.88,English,,0,0,0,,So there are decide which version to do the clang and generate the code
Dialogue: 0,1:11:33.02,1:11:36.88,Chinese,,0,0,0,,因此，决定使用哪个版本进行 clang 并生成代码
Dialogue: 0,1:11:38.44,1:11:39.32,English,,0,0,0,,Other questions
Dialogue: 0,1:11:38.44,1:11:39.32,Chinese,,0,0,0,,还有其他问题吗？
Dialogue: 0,1:11:41.75,1:11:45.32,English,,0,0,0,,So these are all good and it's a very good question so
Dialogue: 0,1:11:41.75,1:11:45.32,Chinese,,0,0,0,,这是一个非常好的问题
Dialogue: 0,1:11:45.56,1:11:48.18,English,,0,0,0,,And you're starting to think about
Dialogue: 0,1:11:45.56,1:11:48.18,Chinese,,0,0,0,,你开始思考了
Dialogue: 0,1:11:48.56,1:11:51.04,English,,0,0,0,,You know which is the way that computer scientists should think is
Dialogue: 0,1:11:48.56,1:11:51.04,Chinese,,0,0,0,,计算机科学家应该考虑的方式是
Dialogue: 0,1:11:51.04,1:11:53.66,English,,0,0,0,,How do you take some idea I've seen one case of
Dialogue: 0,1:11:51.04,1:11:53.66,Chinese,,0,0,0,,你怎么看待我见过的一个例子
Dialogue: 0,1:11:54.04,1:11:59.78,English,,0,0,0,,Well how do I handle condition x and condition y and you know what happens if this that's exactly
Dialogue: 0,1:11:54.04,1:11:59.78,Chinese,,0,0,0,,那么我如何处理条件 x 和条件 y，你知道如果这恰好就会发生什么
Dialogue: 0,1:12:00.46,1:12:02.14,English,,0,0,0,,What we do we sort of
Dialogue: 0,1:12:00.46,1:12:02.14,Chinese,,0,0,0,,我们做的是什么
Dialogue: 0,1:12:02.66,1:12:06.12,English,,0,0,0,,We're never happy with a simple explanation we want to understand
Dialogue: 0,1:12:02.66,1:12:06.12,Chinese,,0,0,0,,我们对我们想要了解的简单解释感到满意
Dialogue: 0,1:12:06.12,1:12:09.40,English,,0,0,0,,How we could actually implement it as a program if we ever had to do so
Dialogue: 0,1:12:06.12,1:12:09.40,Chinese,,0,0,0,,如果我们不得不这样做，我们如何才能真正实现它
Dialogue: 0,1:12:13.84,1:12:15.94,English,,0,0,0,,So and
Dialogue: 0,1:12:13.84,1:12:15.94,Chinese,,0,0,0,,所以和
Dialogue: 0,1:12:17.42,1:12:23.38,English,,0,0,0,,So just in general that the main thing you see is that there's a fairly limited bag of tricks
Dialogue: 0,1:12:17.42,1:12:23.38,Chinese,,0,0,0,,一般来说，你看到的主要内容是有一套相当有限的技巧
Dialogue: 0,1:12:23.92,1:12:28.42,English,,0,0,0,,For which the program implements constructs
Dialogue: 0,1:12:23.92,1:12:28.42,Chinese,,0,0,0,,来让程序实现了主体结构
Dialogue: 0,1:12:28.50,1:12:30.76,English,,0,0,0,,You've seen basically three
Dialogue: 0,1:12:28.50,1:12:30.76,Chinese,,0,0,0,,你基本上看到了三个
Dialogue: 0,1:12:32.04,1:12:37.66,English,,0,0,0,,One is to use conditional jumps go to different parts of the code
Dialogue: 0,1:12:32.04,1:12:37.66,Chinese,,0,0,0,,一种是使用条件跳转到代码的不同部分
Dialogue: 0,1:12:38.22,1:12:40.54,English,,0,0,0,,Another to use conditional moves
Dialogue: 0,1:12:38.22,1:12:40.54,Chinese,,0,0,0,,另一个使用条件移动
Dialogue: 0,1:12:41.50,1:12:44.72,English,,0,0,0,,And the third is to use this jump table idea
Dialogue: 0,1:12:41.50,1:12:44.72,Chinese,,0,0,0,,第三个是使用这种跳转表
Dialogue: 0,1:12:45.14,1:12:51.00,English,,0,0,0,,And those are really that put plus a little bit to do of procedures
Dialogue: 0,1:12:45.14,1:12:51.00,Chinese,,0,0,0,,这些实际上只是在 procedures 上加了一些东西
Dialogue: 0,1:12:51.36,1:12:52.48,English,,0,0,0,,You see all there is
Dialogue: 0,1:12:51.36,1:12:52.48,Chinese,,0,0,0,,你看到了所有的一切
Dialogue: 0,1:12:52.92,1:12:57.72,English,,0,0,0,,And all the other stuff you see in a program that sort of changes
Dialogue: 0,1:12:52.92,1:12:57.72,Chinese,,0,0,0,,以及程序里能改变执行流的其他东西
Dialogue: 0,1:12:58.42,1:13:04.90,English,,0,0,0,,The flow of execution or what gets executed -o built out of those basic primitives
Dialogue: 0,1:12:58.42,1:13:04.90,Chinese,,0,0,0,,主要是由这些基本原语构建
Dialogue: 0,1:13:05.94,1:13:08.36,English,,0,0,0,,And that's generally true that what we see is
Dialogue: 0,1:13:05.94,1:13:08.36,Chinese,,0,0,0,,我们所看到的情况通常都是正确的
Dialogue: 0,1:13:09.80,1:13:15.02,English,,0,0,0,,You know when you go from C code to machine code you often have to kind of piece together various
Dialogue: 0,1:13:09.80,1:13:15.02,Chinese,,0,0,0,,你知道当你从 C 代码转到机器代码时，你经常要把各种各样底层指令组合起来
Dialogue: 0,1:13:15.70,1:13:19.38,English,,0,0,0,,Low-level instructions to implement some higher-level construct
Dialogue: 0,1:13:15.70,1:13:19.38,Chinese,,0,0,0,,实现某些更高级别的指令
Dialogue: 0,1:13:22.38,1:13:25.72,English,,0,0,0,,And so we've seen these all in different form stone
Dialogue: 0,1:13:22.38,1:13:25.72,Chinese,,0,0,0,,我们今天用不同的形式来学习了这些内容
Dialogue: 0,1:13:26.84,1:13:29.46,English,,0,0,0,,And next time then we'll talk about procedures
Dialogue: 0,1:13:26.84,1:13:29.46,Chinese,,0,0,0,,下次课我们将讨论 procedures
Dialogue: 0,1:13:29.48,1:13:32.88,English,,0,0,0,,And that's as you can imagine a fairly major topic
Dialogue: 0,1:13:29.48,1:13:32.88,Chinese,,0,0,0,,这是一个相当重要的主题
Dialogue: 0,1:13:32.88,1:13:35.92,English,,0,0,0,,Because it is worth one entire procedure
Dialogue: 0,1:13:32.88,1:13:35.92,Chinese,,0,0,0,,需要整整一堂课进行学习
Dialogue: 0,1:13:36.42,1:13:39.96,English,,0,0,0,,Okay very good thank you
Dialogue: 0,1:13:36.42,1:13:39.96,Chinese,,0,0,0,,好的，非常感谢谢谢
