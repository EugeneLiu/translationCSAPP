[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 10  Program Optimization.mp4
Video File: ../../../../Desktop/csapp/Lecture 10  Program Optimization.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 1658
Active Line: 1665
Video Position: 131726

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,40,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:04.92,English,,0,0,0,,So we've now gotten through all the lectures on machine code
Dialogue: 0,0:00:00.03,0:00:04.92,Chinese,,0,0,0,,我们已经完成了机器级代码的所有课程
Dialogue: 0,0:00:04.92,0:00:07.00,English,,0,0,0,,And we're starting to talk about...
Dialogue: 0,0:00:04.92,0:00:07.00,Chinese,,0,0,0,,接下来......
Dialogue: 0,0:00:07.34,0:00:10.12,English,,0,0,0,,Okay now that you know this stuff what can you do with it
Dialogue: 0,0:00:07.34,0:00:10.12,Chinese,,0,0,0,,我们已经知道了机器级代码，以及我们能用它来做什么
Dialogue: 0,0:00:10.88,0:00:14.30,English,,0,0,0,,And this lecture is along the lines of that
Dialogue: 0,0:00:10.88,0:00:14.30,Chinese,,0,0,0,,这节课是基于机器级代码的课程
Dialogue: 0,0:00:14.30,0:00:21.06,English,,0,0,0,,This is sort of what you are now empowered to do now that you can look at an understand machine code
Dialogue: 0,0:00:14.30,0:00:21.06,Chinese,,0,0,0,,现在你可以看懂机器级代码
Dialogue: 0,0:00:21.44,0:00:29.10,English,,0,0,0,,This material is a little this actually there's a whole chapter of the book chapter five on performance optimization
Dialogue: 0,0:00:21.44,0:00:29.10,Chinese,,0,0,0,,这节课实际上覆盖了课本的第五章 优化程序性能
Dialogue: 0,0:00:29.10,0:00:30.96,English,,0,0,0,,And we're only going to do one lecture on it
Dialogue: 0,0:00:29.10,0:00:30.96,Chinese,,0,0,0,,但我们只上一节课
Dialogue: 0,0:00:31.50,0:00:32.88,English,,0,0,0,,And we don't have any labs
Dialogue: 0,0:00:31.50,0:00:32.88,Chinese,,0,0,0,,并且，也没有课后实验（现在已经有第五章的lab了）
Dialogue: 0,0:00:33.28,0:00:38.36,English,,0,0,0,,Unfortunately that really get you to push your limits on this which is too bad
Dialogue: 0,0:00:33.28,0:00:38.36,Chinese,,0,0,0,,这种课程安排确实有点可惜
Dialogue: 0,0:00:38.36,0:00:40.12,English,,0,0,0,,Because it's a very interesting topic
Dialogue: 0,0:00:38.36,0:00:40.12,Chinese,,0,0,0,,因为这是一个非常有趣的话题
Dialogue: 0,0:00:40.52,0:00:43.02,English,,0,0,0,,One I think you'd find yourself well equipped for
Dialogue: 0,0:00:40.52,0:00:43.02,Chinese,,0,0,0,,一个我认为你应该掌握的知识点
Dialogue: 0,0:00:43.56,0:00:50.26,English,,0,0,0,,There are typically a few small exam problems that are sort of based on some of the material here
Dialogue: 0,0:00:43.56,0:00:50.26,Chinese,,0,0,0,,这一章，考试中只会出一些小的题目
Dialogue: 0,0:00:50.26,0:00:51.76,English,,0,0,0,,You'll find in old exams
Dialogue: 0,0:00:50.26,0:00:51.76,Chinese,,0,0,0,,可以参考以前考试的题目
Dialogue: 0,0:00:52.72,0:00:56.02,English,,0,0,0,,But really the idea is how can I make programs run fast
Dialogue: 0,0:00:52.72,0:00:56.02,Chinese,,0,0,0,,这一章的主题是，如果让程序运行更快
Dialogue: 0,0:00:56.66,0:01:02.30,English,,0,0,0,,Given that I sort of know what algorithm I'm using
Dialogue: 0,0:00:56.66,0:01:02.30,Chinese,,0,0,0,,这里，运行的更快指的是算法已经确定了
Dialogue: 0,0:01:02.30,0:01:05.66,English,,0,0,0,,And I've perhaps gotten a program that runs
Dialogue: 0,0:01:02.30,0:01:05.66,Chinese,,0,0,0,,并且程序可以正确运行
Dialogue: 0,0:01:05.96,0:01:07.64,English,,0,0,0,,How can I make it run faster
Dialogue: 0,0:01:05.96,0:01:07.64,Chinese,,0,0,0,,如何让它运行得更快
Dialogue: 0,0:01:08.26,0:01:12.28,English,,0,0,0,,And one of the the themes of it is
Dialogue: 0,0:01:08.26,0:01:12.28,Chinese,,0,0,0,,这是我们这一章的主题
Dialogue: 0,0:01:12.66,0:01:14.62,English,,0,0,0,,You can sort of do this in layers
Dialogue: 0,0:01:12.66,0:01:14.62,Chinese,,0,0,0,,你可以在不同的层面上做这件事情
Dialogue: 0,0:01:14.68,0:01:28.36,English,,0,0,0,,You can sort of first of do the stuff to avoid a sort of things that make programs run slow across a wide variety of machines
Dialogue: 0,0:01:14.68,0:01:28.36,Chinese,,0,0,0,,比如，你可以先去掉程序中不必要的工作，这个优化不依赖与目标机器
Dialogue: 0,0:01:28.66,0:01:30.10,English,,0,0,0,,Just make your...
Dialogue: 0,0:01:28.66,0:01:30.10,Chinese,,0,0,0,,这会让你的程序运行更快...
Dialogue: 0,0:01:30.12,0:01:36.04,English,,0,0,0,,And I would describe it as making your code more compiler friendly, we'll talk about what that means
Dialogue: 0,0:01:30.12,0:01:36.04,Chinese,,0,0,0,,后面我会讲什么是编译器友好代码
Dialogue: 0,0:01:36.60,0:01:40.74,English,,0,0,0,,And you have to have some understanding and appreciation for what compilers are good at
Dialogue: 0,0:01:36.60,0:01:40.74,Chinese,,0,0,0,,要编写出编译器友好的代码，你必须明白什么代码编译器能够优化
Dialogue: 0,0:01:41.20,0:01:43.94,English,,0,0,0,,And what they're not good at to be able to do that
Dialogue: 0,0:01:41.20,0:01:43.94,Chinese,,0,0,0,,什么代码编译器无法优化
Dialogue: 0,0:01:43.94,0:01:48.82,English,,0,0,0,,And I describe these is the kind of things that you should just be in the habit of
Dialogue: 0,0:01:43.94,0:01:48.82,Chinese,,0,0,0,,并且你应该养成习惯
Dialogue: 0,0:01:49.20,0:01:53.24,English,,0,0,0,,When you write programs writing this code that I'll describe is compiler friendly
Dialogue: 0,0:01:49.20,0:01:53.24,Chinese,,0,0,0,,编写代码的时候，编写的代码都是编译器友好的代码
Dialogue: 0,0:01:53.92,0:02:03.04,English,,0,0,0,,And then the next level is okay given that I've sort of taken away the things that really shouldn't have been there in the first place
Dialogue: 0,0:01:53.92,0:02:03.04,Chinese,,0,0,0,,我们已经去掉了程序中不必要的代码，下一步是
Dialogue: 0,0:02:03.40,0:02:06.38,English,,0,0,0,,Now how can I make my programs run faster
Dialogue: 0,0:02:03.40,0:02:06.38,Chinese,,0,0,0,,我们如何让程序运行得更快
Dialogue: 0,0:02:06.38,0:02:14.12,English,,0,0,0,,In particular,how can I adapt it to the capabilities of the types of machines that this program is going to run on
Dialogue: 0,0:02:06.38,0:02:14.12,Chinese,,0,0,0,,特别是，我们如何针对特定的机器对程序进行优化
Dialogue: 0,0:02:14.44,0:02:22.26,English,,0,0,0,,And that can again go from ones that will generally make programs run fast across a wide variety of machines to ones that
Dialogue: 0,0:02:14.44,0:02:22.26,Chinese,,0,0,0,,也就是从对大多数机器的优化，转移到了对
Dialogue: 0,0:02:22.30,0:02:24.08,English,,0,0,0,,Become very specific
Dialogue: 0,0:02:22.30,0:02:24.08,Chinese,,0,0,0,,特定机器的优化
Dialogue: 0,0:02:24.46,0:02:30.08,English,,0,0,0,,Very specific is a risky thing because even in the world of  say x86 machines
Dialogue: 0,0:02:24.46,0:02:30.08,Chinese,,0,0,0,,针对特定机器优化是一个冒险的事情，因为例如 x86 的机器
Dialogue: 0,0:02:30.32,0:02:34.56,English,,0,0,0,,There's quite a variety of them that are available at any given point in time
Dialogue: 0,0:02:30.32,0:02:34.56,Chinese,,0,0,0,,在每个时间点，它们都有各种不同的型号
Dialogue: 0,0:02:35.04,0:02:37.02,English,,0,0,0,,And they evolve over time as well
Dialogue: 0,0:02:35.04,0:02:37.02,Chinese,,0,0,0,,并且不同的型号也随着时间的推移而发展
Dialogue: 0,0:02:37.02,0:02:44.44,English,,0,0,0,,So you can make a program run really fast on one particular model of one x86 processor
Dialogue: 0,0:02:37.02,0:02:44.44,Chinese,,0,0,0,,因此，可能在一个 x86 处理器的特定型号上运行速度较快
Dialogue: 0,0:02:44.82,0:02:46.48,English,,0,0,0,,But it might not that...
Dialogue: 0,0:02:44.82,0:02:46.48,Chinese,,0,0,0,,但在另一台 x86 机器上运行速度可能较慢......
Dialogue: 0,0:02:47.10,0:02:51.54,English,,0,0,0,,If you're trying too hard you'll find your effort is sort of wasted when you move it to another
Dialogue: 0,0:02:47.10,0:02:51.54,Chinese,,0,0,0,,当你把优化的程序移到另一个机器时，你会发现你的努力有点浪费
Dialogue: 0,0:02:51.94,0:02:57.38,English,,0,0,0,,On the other hand these general ideas I'm going to describe actually work across quite a range of machines
Dialogue: 0,0:02:51.94,0:02:57.38,Chinese,,0,0,0,,另一方面，我将要描述的这些一般性想法实际上适用于各种各样的机器
Dialogue: 0,0:02:58.62,0:03:01.10,English,,0,0,0,,So and I'll talk about that more as we go along
Dialogue: 0,0:02:58.62,0:03:01.10,Chinese,,0,0,0,,随着我们的进展，我会更多地谈论这个问题
Dialogue: 0,0:03:02.96,0:03:06.58,English,,0,0,0,,So it used to be in the bad old days that
Dialogue: 0,0:03:02.96,0:03:06.58,Chinese,,0,0,0,,以前
Dialogue: 0,0:03:06.62,0:03:09.88,English,,0,0,0,,If you wanted a program to run fast you had to write an assembly code
Dialogue: 0,0:03:06.62,0:03:09.88,Chinese,,0,0,0,,如果你希望程序快速运行，则你必须编写汇编代码
Dialogue: 0,0:03:10.20,0:03:13.60,English,,0,0,0,,And that's just plain not true anymore and if anyone tells you it's true
Dialogue: 0,0:03:10.20,0:03:13.60,Chinese,,0,0,0,,而这显然不再是真的，如果有人告诉你这是真的
Dialogue: 0,0:03:13.94,0:03:16.70,English,,0,0,0,,It's because they're full of it, it's just not true
Dialogue: 0,0:03:13.94,0:03:16.70,Chinese,,0,0,0,,这是因为他们对这个不了解，事实并非如此
Dialogue: 0,0:03:17.04,0:03:23.32,English,,0,0,0,,Unless except for the exceptional case where you're running on a very small resource constrained machine
Dialogue: 0,0:03:17.04,0:03:23.32,Chinese,,0,0,0,,除非程序运行在资源非常小的机器上
Dialogue: 0,0:03:23.98,0:03:27.56,English,,0,0,0,,Such as a very small underpowered embedded system
Dialogue: 0,0:03:23.98,0:03:27.56,Chinese,,0,0,0,,比如程序运行在一个非常小的计算力不足的嵌入式系统上
Dialogue: 0,0:03:29.09,0:03:32.56,English,,0,0,0,,So let's just assume that we're going to use a compiler
Dialogue: 0,0:03:29.09,0:03:32.56,Chinese,,0,0,0,,我们使用的编译器为 gcc
Dialogue: 0,0:03:33.02,0:03:36.66,English,,0,0,0,,And we'll assume for this course we're going to use gcc because it's generally available
Dialogue: 0,0:03:33.02,0:03:36.66,Chinese,,0,0,0,,我们这个课程使用 gcc 作为编译器，是因为 gcc 的获取比较方面
Dialogue: 0,0:03:37.06,0:03:44.40,English,,0,0,0,,It's not actually the best compiler out there intel makes a compiler that costs money to license and stuff
Dialogue: 0,0:03:37.06,0:03:44.40,Chinese,,0,0,0,,它实际上并不是最好的编译器，但英特尔制造的编译器需要花钱才能使用
Dialogue: 0,0:03:44.40,0:03:49.88,English,,0,0,0,,But it really can do some amazing things and other compilers exist
Dialogue: 0,0:03:44.40,0:03:49.88,Chinese,,0,0,0,,虽然有其他编译器，但事实上 gcc 可以做到较好的优化
Dialogue: 0,0:03:49.88,0:03:53.96,English,,0,0,0,,But GCC is sort of a a good enough compiler for most people
Dialogue: 0,0:03:49.88,0:03:53.96,Chinese,,0,0,0,,对于大多数人来说，gcc 是一个足够好的编译器
Dialogue: 0,0:03:56.80,0:04:02.80,English,,0,0,0,,But there's some features of some things that sort of puzzle compilers that they don't really understand
Dialogue: 0,0:03:56.80,0:04:02.80,Chinese,,0,0,0,,但是有些东西和特性编译器是不能真正理解的
Dialogue: 0,0:04:02.80,0:04:07.80,English,,0,0,0,,Compilers don't really understand for example that the numbers you're using
Dialogue: 0,0:04:02.80,0:04:07.80,Chinese,,0,0,0,,例如，编译器并不真正理解你正在使用的数字
Dialogue: 0,0:04:08.24,0:04:13.14,English,,0,0,0,,When you say it's an int might actually range over a much smaller set of values
Dialogue: 0,0:04:08.24,0:04:13.14,Chinese,,0,0,0,,当你定义一个 int，但实际上它的取值范围是比 int 范围小很多的子集
Dialogue: 0,0:04:14.18,0:04:21.18,English,,0,0,0,,And they have a very hard time understanding memory referencing patterns and the effect of procedure calls
Dialogue: 0,0:04:14.18,0:04:21.18,Chinese,,0,0,0,,编译器也很难理解内存引用模式和过程调用的影响
Dialogue: 0,0:04:26.50,0:04:29.62,English,,0,0,0,,And so in general what happens with the compiler is it
Dialogue: 0,0:04:26.50,0:04:29.62,Chinese,,0,0,0,,一般来说，编译器
Dialogue: 0,0:04:29.92,0:04:35.92,English,,0,0,0,,Has a whole sort of cookbook of optimization strategies
Dialogue: 0,0:04:29.92,0:04:35.92,Chinese,,0,0,0,,有一整套优化策略
Dialogue: 0,0:04:35.92,0:04:40.84,English,,0,0,0,,And some recipes for how to try out different strategies and apply them
Dialogue: 0,0:04:35.92,0:04:40.84,Chinese,,0,0,0,,以及如何使用这些优化方案的方法
Dialogue: 0,0:04:41.44,0:04:46.14,English,,0,0,0,,But in general if it ever feels like this code is something that
Dialogue: 0,0:04:41.44,0:04:46.14,Chinese,,0,0,0,,但总的来说，如果编译器如果对代码
Dialogue: 0,0:04:46.14,0:04:50.14,English,,0,0,0,,It doesn't feel confident about being able to make certain transformations
Dialogue: 0,0:04:46.14,0:04:50.14,Chinese,,0,0,0,,能够进行某些优化不够确定
Dialogue: 0,0:04:50.48,0:04:56.98,English,,0,0,0,,That it just won't,it will keep things sort of a more direct implementation of exactly what you described
Dialogue: 0,0:04:50.48,0:04:56.98,Chinese,,0,0,0,,编译器不会优化，会采取直接的实现方法
Dialogue: 0,0:04:57.36,0:05:00.04,English,,0,0,0,,We'll show examples of that as we go along
Dialogue: 0,0:04:57.36,0:05:00.04,Chinese,,0,0,0,,讲的过程中，我会展示这方面的例子
Dialogue: 0,0:05:00.70,0:05:06.82,English,,0,0,0,,So the thing about it optimizing compilers it always has a fallback position which is to not optimize
Dialogue: 0,0:05:00.70,0:05:06.82,Chinese,,0,0,0,,编译器的优化方案中总有一个备选方案，即不优化
Dialogue: 0,0:05:07.42,0:05:11.86,English,,0,0,0,,And sometimes that will get in trouble if you want your program to run faster
Dialogue: 0,0:05:07.42,0:05:11.86,Chinese,,0,0,0,,如果你希望程序运行得更快，你有可能遇到麻烦
Dialogue: 0,0:05:12.28,0:05:19.10,English,,0,0,0,,And the compiler just in its own conservative white decides not to do that optimization
Dialogue: 0,0:05:12.28,0:05:19.10,Chinese,,0,0,0,,因为编译器选择了不对代码进行优化
Dialogue: 0,0:05:19.30,0:05:22.18,English,,0,0,0,,And one of the tricks that you'll find is pretty useful
Dialogue: 0,0:05:19.30,0:05:22.18,Chinese,,0,0,0,,这时你可以使用一个非常有用的技巧
Dialogue: 0,0:05:22.56,0:05:25.80,English,,0,0,0,,Now that you can read assembly code is you run the compiler
Dialogue: 0,0:05:22.56,0:05:25.80,Chinese,,0,0,0,,因为你可以阅读汇编代码，所以你可以编译程序
Dialogue: 0,0:05:26.22,0:05:28.32,English,,0,0,0,,You see what optimizations it does
Dialogue: 0,0:05:26.22,0:05:28.32,Chinese,,0,0,0,,看看编译器做了哪些优化
Dialogue: 0,0:05:28.90,0:05:33.38,English,,0,0,0,,And if it doesn't make something that you expect it to be able to do you go back and figure it out
Dialogue: 0,0:05:28.90,0:05:33.38,Chinese,,0,0,0,,如果编译器没有做到你想要的优化，你就回去看代码，找到原因
Dialogue: 0,0:05:33.44,0:05:42.30,English,,0,0,0,,So it's very common by the way to rewrite your program in the same language
Dialogue: 0,0:05:33.44,0:05:42.30,Chinese,,0,0,0,,因此，用同一种语言重写程序
Dialogue: 0,0:05:42.30,0:05:49.74,English,,0,0,0,,And sort of tune it in and up to make it run faster to make it more compiler friendly
Dialogue: 0,0:05:42.30,0:05:49.74,Chinese,,0,0,0,,并对其进行调整以使其运行得更快，更加编译器友好
Dialogue: 0,0:05:49.74,0:05:51.32,English,,0,0,0,,That's there's nothing wrong with that
Dialogue: 0,0:05:49.74,0:05:51.32,Chinese,,0,0,0,,这是一种常用的优化程序的方法
Dialogue: 0,0:05:51.78,0:05:55.96,English,,0,0,0,,As long as you don't then just totally obliterate the program and make it totally illegible
Dialogue: 0,0:05:51.78,0:05:55.96,Chinese,,0,0,0,,只要你不把这个程序改的完全无法阅读
Dialogue: 0,0:05:57.66,0:06:01.50,English,,0,0,0,,So let's just describe some sort of general optimizations
Dialogue: 0,0:05:57.66,0:06:01.50,Chinese,,0,0,0,,所以我们只讲一些通用的优化方式
Dialogue: 0,0:06:01.50,0:06:06.82,English,,0,0,0,,And you've actually seen versions of this,in some of the assembly code we've already looked at
Dialogue: 0,0:06:01.50,0:06:06.82,Chinese,,0,0,0,,这里的汇编代码的一些版本我们前面已经看过了
Dialogue: 0,0:06:08.02,0:06:13.70,English,,0,0,0,,Oh and I'll use mostly sort of examples from multi-dimensional arrays
Dialogue: 0,0:06:08.02,0:06:13.70,Chinese,,0,0,0,,我们使用的大多数例子是多维数组
Dialogue: 0,0:06:13.70,0:06:17.68,English,,0,0,0,,Because those are actually fairly easy optimization type of tasks
Dialogue: 0,0:06:13.70,0:06:17.68,Chinese,,0,0,0,,因为多维数组是相当容易优化的任务
Dialogue: 0,0:06:18.40,0:06:21.16,English,,0,0,0,,But these applied to other types of program as well
Dialogue: 0,0:06:18.40,0:06:21.16,Chinese,,0,0,0,,但这些优化方法也适用于其他的程序
Dialogue: 0,0:06:21.98,0:06:29.58,English,,0,0,0,,So you saw before when we described how to do array indexing in multi-dimensional arrays
Dialogue: 0,0:06:21.98,0:06:29.58,Chinese,,0,0,0,,我们已经学习过了，怎么对一个多维数组中的元素进行索引
Dialogue: 0,0:06:30.22,0:06:36.63,English,,0,0,0,,That the old style of code was if you had a a variable sized array
Dialogue: 0,0:06:30.22,0:06:36.63,Chinese,,0,0,0,,C 原来的代码风格是，如果你有一个二维数组
Dialogue: 0,0:06:36.84,0:06:46.66,English,,0,0,0,,It was up to you the programmer to write the formula of how you convert row i column j into a position in a one-dimensional array
Dialogue: 0,0:06:36.84,0:06:46.66,Chinese,,0,0,0,,程序员可以将第 i 行第 j 列转换为一维数组中的位置
Dialogue: 0,0:06:47.58,0:06:53.46,English,,0,0,0,,So remember it's just the number of columns times the row number plus the column numbers standard one
Dialogue: 0,0:06:47.58,0:06:53.46,Chinese,,0,0,0,,这个转化的公式是，每一行的列数乘以 i 加上列号 j
Dialogue: 0,0:06:54.12,0:06:57.68,English,,0,0,0,,So that would give this would be pretty typical code
Dialogue: 0,0:06:54.12,0:06:57.68,Chinese,,0,0,0,,所以这是非常常用的代码
Dialogue: 0,0:06:57.68,0:07:00.72,English,,0,0,0,,Then it would give you a notation like this
Dialogue: 0,0:06:57.68,0:07:00.72,Chinese,,0,0,0,,所以会抽象出这样一个函数
Dialogue: 0,0:07:00.72,0:07:09.60,English,,0,0,0,,If you wanted to set one row in array 'a' to the values in a one dimensional row of 'b'
Dialogue: 0,0:07:00.72,0:07:09.60,Chinese,,0,0,0,,将二维数组 a 中的一行设置为一维数组 b 的值
Dialogue: 0,0:07:10.98,0:07:13.08,English,,0,0,0,,This is a code you'd write
Dialogue: 0,0:07:10.98,0:07:13.08,Chinese,,0,0,0,,这是你要编写的函数
Dialogue: 0,0:07:13.52,0:07:16.28,English,,0,0,0,,And the main observation is within this loop
Dialogue: 0,0:07:13.52,0:07:16.28,Chinese,,0,0,0,,我们主要观察这个循环体
Dialogue: 0,0:07:16.74,0:07:19.04,English,,0,0,0,,The only variable that's changing is j
Dialogue: 0,0:07:16.74,0:07:19.04,Chinese,,0,0,0,,唯一变化的变量是 j
Dialogue: 0,0:07:20.24,0:07:25.82,English,,0,0,0,,And so from the array perspective your this computation n*i··
Dialogue: 0,0:07:20.24,0:07:25.82,Chinese,,0,0,0,,所以从数组的角度来看，n*i 这个计算...
Dialogue: 0,0:07:25.82,0:07:28.56,English,,0,0,0,,If it gets repeated over and over again within this loop
Dialogue: 0,0:07:25.82,0:07:28.56,Chinese,,0,0,0,,如果它在这个循环中反复执行
Dialogue: 0,0:07:29.22,0:07:32.52,English,,0,0,0,,Then you're just wasting,it's a wasted effort
Dialogue: 0,0:07:29.22,0:07:32.52,Chinese,,0,0,0,,仅仅只是一种浪费
Dialogue: 0,0:07:32.92,0:07:35.16,English,,0,0,0,,So you can do what's called code motion
Dialogue: 0,0:07:32.92,0:07:35.16,Chinese,,0,0,0,,所以你可以一种叫做代码移动的优化方式
Dialogue: 0,0:07:35.42,0:07:40.54,English,,0,0,0,,Which is to precompute the value of n*i outside of the loop
Dialogue: 0,0:07:35.42,0:07:40.54,Chinese,,0,0,0,,在循环外预先计算 n*i 的值
Dialogue: 0,0:07:40.96,0:07:45.74,English,,0,0,0,,And then use it over and over again inside and compilers will generally do this
Dialogue: 0,0:07:40.96,0:07:45.74,Chinese,,0,0,0,,然后在内部一遍又一遍地使用它，编译器通常会这样做
Dialogue: 0,0:07:47.36,0:07:53.78,English,,0,0,0,,When they can detect for example that it's a array access code and it has this technique
Dialogue: 0,0:07:47.36,0:07:53.78,Chinese,,0,0,0,,当编译器可以检测到它是一个数组访问代码，并且编译器有这种技术时
Dialogue: 0,0:07:54.14,0:08:03.42,English,,0,0,0,,It will generally do optimizations like this if you set say an optimization level of 1 or higher to GCC
Dialogue: 0,0:07:54.14,0:08:03.42,Chinese,,0,0,0,,如果你将 gcc 的优化级别设置为 1 或更高，它通常会进行这样的优化
Dialogue: 0,0:08:07.14,0:08:14.42,English,,0,0,0,,And we can see this in fact this is this code that I ran it through GCC using optimization 1
Dialogue: 0,0:08:07.14,0:08:14.42,Chinese,,0,0,0,,我们实际上可以查看使用 gcc，优化级别为 1 编译后的汇编代码
Dialogue: 0,0:08:14.68,0:08:19.22,English,,0,0,0,,And you see as this read instruction shows it boosted this multiplication outside of the loop
Dialogue: 0,0:08:14.68,0:08:19.22,Chinese,,0,0,0,,并且你看到在访问数组元素之前，即循环体之外增加了这个乘法操作
Dialogue: 0,0:08:20.60,0:08:25.90,English,,0,0,0,,And it's a little as if you actually this code does even more
Dialogue: 0,0:08:20.60,0:08:25.90,Chinese,,0,0,0,,实际上这个代码还做了另外的优化
Dialogue: 0,0:08:25.90,0:08:29.50,English,,0,0,0,,It turns the code into something that looks more like a pointer code
Dialogue: 0,0:08:25.90,0:08:29.50,Chinese,,0,0,0,,它将代码转换为指针风格的代码
Dialogue: 0,0:08:29.78,0:08:38.34,English,,0,0,0,,Accessing array 'a' and stepping through that element by element of the array
Dialogue: 0,0:08:29.78,0:08:38.34,Chinese,,0,0,0,,使用指针来访问数组 a，然后每次循环，指针的值加 1
Dialogue: 0,0:08:39.62,0:08:42.46,English,,0,0,0,,Another one and we've seen this already that when
Dialogue: 0,0:08:39.62,0:08:42.46,Chinese,,0,0,0,,另外，我们可以看到
Dialogue: 0,0:08:42.94,0:08:49.30,English,,0,0,0,,GCC turns a multiplication or a division by shifting and adding an operations like that
Dialogue: 0,0:08:42.94,0:08:49.30,Chinese,,0,0,0,,gcc 通过移位和加法运算来实现
Dialogue: 0,0:08:49.67,0:08:51.97,English,,0,0,0,,Multiplication or division by constants
Dialogue: 0,0:08:49.67,0:08:51.97,Chinese,,0,0,0,,一个操作数为常数乘法和除法
Dialogue: 0,0:08:52.12,0:08:55.90,English,,0,0,0,,We've seen examples of that and a similar one would happen if
Dialogue: 0,0:08:52.12,0:08:55.90,Chinese,,0,0,0,,我们已经看到过这样的例子，类似的
Dialogue: 0,0:09:01.58,0:09:09.82,English,,0,0,0,,If we took that program I showed before and applied it to every row
Dialogue: 0,0:09:01.58,0:09:09.82,Chinese,,0,0,0,,在之前的程序中，这个方法会应用于每一次对数组的访问
Dialogue: 0,0:09:09.96,0:09:16.78,English,,0,0,0,,So we want to set for array 'a' we wanted to set every one of its rows to the value of the one dimensional array 'b'
Dialogue: 0,0:09:09.96,0:09:16.78,Chinese,,0,0,0,,现在，我们要将二维数组 a 的每一行设置为一维数组 b 的值
Dialogue: 0,0:09:19.22,0:09:24.80,English,,0,0,0,,Then again if we took that code we boosted the n*i in there
Dialogue: 0,0:09:19.22,0:09:24.80,Chinese,,0,0,0,,然后，如果我们可是使用左边的代码，我们预先计算了 n*i 的值
Dialogue: 0,0:09:25.62,0:09:31.32,English,,0,0,0,,So now the inner loop is good but you realize that this multiplication isn't necessary either
Dialogue: 0,0:09:25.62,0:09:31.32,Chinese,,0,0,0,,所以现在内循环效率不错，但你马上意识到第一个乘法也是不必要的
Dialogue: 0,0:09:31.32,0:09:36.20,English,,0,0,0,,Because what we're doing from i=0 to i=1 to i=2
Dialogue: 0,0:09:31.32,0:09:36.20,Chinese,,0,0,0,,因为从 i=0 到 i=1 到 i=2
Dialogue: 0,0:09:36.68,0:09:41.26,English,,0,0,0,,Is we're just increasing the parameter ni by we're adding n to it
Dialogue: 0,0:09:36.68,0:09:41.26,Chinese,,0,0,0,,因为我们可以通过让 ni 增加 n 来实现
Dialogue: 0,0:09:41.86,0:09:49.12,English,,0,0,0,,So we can...and that's called a reduction in strength we've taken a multiplication and turned it into addition
Dialogue: 0,0:09:41.86,0:09:49.12,Chinese,,0,0,0,,这个称为计算量的减少，我们将乘法转化为加法
Dialogue: 0,0:09:49.12,0:09:56.02,English,,0,0,0,,Because there's some predictable pattern of how this variable ni is going to be updated
Dialogue: 0,0:09:49.12,0:09:56.02,Chinese,,0,0,0,,因为有一些可预测的模式可以更新这个变量 ni
Dialogue: 0,0:09:56.34,0:10:02.30,English,,0,0,0,,Another example and again array indexing is a good example for optimizations
Dialogue: 0,0:09:56.34,0:10:02.30,Chinese,,0,0,0,,这个例子也是关于数组访问优化的
Dialogue: 0,0:10:02.64,0:10:10.60,English,,0,0,0,,Imagine we had a image that we represent as a two-dimensional array of pixel values
Dialogue: 0,0:10:02.64,0:10:10.60,Chinese,,0,0,0,,想象一下，我们有一个图片，我们表示为像素值的二维数组
Dialogue: 0,0:10:11.38,0:10:15.58,English,,0,0,0,,And we want to do something that's what a filtering operation
Dialogue: 0,0:10:11.38,0:10:15.58,Chinese,,0,0,0,,我们想要做一些过滤操作
Dialogue: 0,0:10:15.58,0:10:22.62,English,,0,0,0,,Where we want to take the sum of the four neighbors of a given pixel north,south,east and west
Dialogue: 0,0:10:15.58,0:10:22.62,Chinese,,0,0,0,,我们想要得到一个像素东南西北四个邻居的像素值
Dialogue: 0,0:10:23.14,0:10:26.56,English,,0,0,0,,And average those together or sum them together
Dialogue: 0,0:10:23.14,0:10:26.56,Chinese,,0,0,0,,求它们的平均值或它们的和
Dialogue: 0,0:10:27.68,0:10:37.20,English,,0,0,0,,And so the natural way you'd write this and see is to say I want usually i
Dialogue: 0,0:10:27.68,0:10:37.20,Chinese,,0,0,0,,实现这个功能最自然的代码
Dialogue: 0,0:10:38.04,0:10:40.94,English,,0,0,0,,Images you count from the top down and so
Dialogue: 0,0:10:38.04,0:10:40.94,Chinese,,0,0,0,,是直接求出
Dialogue: 0,0:10:41.28,0:10:50.00,English,,0,0,0,,You'd say this is the the pixel above,this is the pixel below,this is the pixel to the left,this is the pixel to the right
Dialogue: 0,0:10:41.28,0:10:50.00,Chinese,,0,0,0,,上下左右四个像素值
Dialogue: 0,0:10:50.98,0:10:56.60,English,,0,0,0,,And if you do this in and just compile it straight through
Dialogue: 0,0:10:50.98,0:10:56.60,Chinese,,0,0,0,,类似于左边的代码，然后直接编译它
Dialogue: 0,0:10:56.94,0:11:02.36,English,,0,0,0,,Unfortunately it appears as if there's three different multiplications by n
Dialogue: 0,0:10:56.94,0:11:02.36,Chinese,,0,0,0,,会发现汇编代码中有三个乘以 n 的乘法
Dialogue: 0,0:11:02.74,0:11:05.08,English,,0,0,0,,i-1, i+1 and i
Dialogue: 0,0:11:02.74,0:11:05.08,Chinese,,0,0,0,,i-1，i+1 和 i
Dialogue: 0,0:11:05.56,0:11:11.94,English,,0,0,0,,And if the compiler isn't too clever it won't realize that these are related to each other
Dialogue: 0,0:11:05.56,0:11:11.94,Chinese,,0,0,0,,如果编译器不是太聪明，它不会意识到它们彼此相关
Dialogue: 0,0:11:11.94,0:11:16.02,English,,0,0,0,,And it will issue three different multiply operations just to do this one pixel thing
Dialogue: 0,0:11:11.94,0:11:16.02,Chinese,,0,0,0,,对每一个像素，都会做 3 次乘法运算
Dialogue: 0,0:11:16.78,0:11:18.94,English,,0,0,0,,Whereas if I'm a little more clever
Dialogue: 0,0:11:16.78,0:11:18.94,Chinese,,0,0,0,,如果我更聪明一点
Dialogue: 0,0:11:19.40,0:11:22.76,English,,0,0,0,,And this is one where I manually rewrote the code
Dialogue: 0,0:11:19.40,0:11:22.76,Chinese,,0,0,0,,我会手工重写这部分代码
Dialogue: 0,0:11:22.76,0:11:24.42,English,,0,0,0,,So the compiler would pick it up
Dialogue: 0,0:11:22.76,0:11:24.42,Chinese,,0,0,0,,然后重新编译
Dialogue: 0,0:11:25.00,0:11:30.84,English,,0,0,0,,I'd say well if I ...so inj is i*n+j
Dialogue: 0,0:11:25.00,0:11:30.84,Chinese,,0,0,0,,改动之后的代码如右图所示，inj 是 i*n+j
Dialogue: 0,0:11:31.52,0:11:39.74,English,,0,0,0,,And I can get the the pixel above the pixel below by shifting that off setting that by a value of n
Dialogue: 0,0:11:31.52,0:11:39.74,Chinese,,0,0,0,,我可以通过加减 n 来得到下上像素的值
Dialogue: 0,0:11:42.06,0:11:46.42,English,,0,0,0,,And then it will issue the code this will compile with the code with just one multiply
Dialogue: 0,0:11:42.06,0:11:46.42,Chinese,,0,0,0,,然后重新编译代码，这次编译的代码只有一个乘法运算
Dialogue: 0,0:11:46.54,0:11:51.36,English,,0,0,0,,And in general by the way multiply used to be a very expensive instruction
Dialogue: 0,0:11:46.54,0:11:51.36,Chinese,,0,0,0,,一般来说，乘法操作非常昂贵
Dialogue: 0,0:11:51.80,0:11:57.20,English,,0,0,0,,Nowadays is enough hardware resources that it takes about three clock cycles,so it's not a huge deal
Dialogue: 0,0:11:51.80,0:11:57.20,Chinese,,0,0,0,,但现在有足够的硬件资源，乘法操作需要大约三个时钟周期，所以这不是一个大问题
Dialogue: 0,0:11:57.74,0:12:02.38,English,,0,0,0,,But anytime you can take three multiplies and use just one instead that's generally a good idea
Dialogue: 0,0:11:57.74,0:12:02.38,Chinese,,0,0,0,,但是，任何时候你可以使用一个乘法操作替代三个乘法操作，都是有优化的
Dialogue: 0,0:12:02.54,0:12:02.96,English,,0,0,0,,Question
Dialogue: 0,0:12:02.54,0:12:02.96,Chinese,,0,0,0,,请讲
Dialogue: 0,0:12:02.96,0:12:08.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:12:02.96,0:12:08.54,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:12:08.60,0:12:11.48,English,,0,0,0,,So the question is what if you're trying to optimize for space
Dialogue: 0,0:12:08.60,0:12:11.48,Chinese,,0,0,0,,这个问题是，如果你是针对空间进行优化，该怎么做
Dialogue: 0,0:12:11.48,0:12:13.84,English,,0,0,0,,And there are a lot of optimizations that will
Dialogue: 0,0:12:11.48,0:12:13.84,Chinese,,0,0,0,,的确，程序有很多优化方式
Dialogue: 0,0:12:14.54,0:12:19.48,English,,0,0,0,,Make your code be bigger at the expense of in order to go faster right
Dialogue: 0,0:12:14.54,0:12:19.48,Chinese,,0,0,0,,为了更快地运行，可能需要编写更多代码
Dialogue: 0,0:12:19.90,0:12:22.78,English,,0,0,0,,This one though I'd argue this is actually shorter code right
Dialogue: 0,0:12:19.90,0:12:22.78,Chinese,,0,0,0,,这里虽然左边的代码更短
Dialogue: 0,0:12:24.10,0:12:26.30,English,,0,0,0,,And just look at the number of instructions so
Dialogue: 0,0:12:24.10,0:12:26.30,Chinese,,0,0,0,,但这里关心的是汇编指令的数量
Dialogue: 0,0:12:26.64,0:12:32.02,English,,0,0,0,,And usually so code you know that used to be a bigger concern when memory was sort of
Dialogue: 0,0:12:26.64,0:12:32.02,Chinese,,0,0,0,,在过去，程序占用内存的大小可以是一个比较关注的点
Dialogue: 0,0:12:32.44,0:12:37.16,English,,0,0,0,,You know back the original IBM pc had 640 kilobytes of memory so
Dialogue: 0,0:12:32.44,0:12:37.16,Chinese,,0,0,0,,因为原来的 IBM 电脑只有 640k 字节的内存
Dialogue: 0,0:12:37.56,0:12:42.34,English,,0,0,0,,In its maximum configuration and that was a big deal to actually buy it that much
Dialogue: 0,0:12:37.56,0:12:42.34,Chinese,,0,0,0,,并且是最高的配置，而且这个电脑的价格并不便宜
Dialogue: 0,0:12:42.88,0:12:46.72,English,,0,0,0,,So you know back then that was a big deal memory but nowadays memory
Dialogue: 0,0:12:42.88,0:12:46.72,Chinese,,0,0,0,,所以，过去程序占用的内存大小的限制比较大，但现在
Dialogue: 0,0:12:47.10,0:12:52.02,English,,0,0,0,,The size of the program is usually a pretty small fraction of what you're dealing with overall
Dialogue: 0,0:12:47.10,0:12:52.02,Chinese,,0,0,0,,程序的内存大小通常只是你电脑内存的一小部分
Dialogue: 0,0:12:52.56,0:12:53.72,English,,0,0,0,,But it's a valid question
Dialogue: 0,0:12:52.56,0:12:53.72,Chinese,,0,0,0,,但这是一个有意义的问题
Dialogue: 0,0:12:57.14,0:13:02.80,English,,0,0,0,,Okay so that just shows you an example and in general compilers are pretty good at doing
Dialogue: 0,0:12:57.14,0:13:02.80,Chinese,,0,0,0,,好的，展示这个例子，一般的编译器都非常擅长
Dialogue: 0,0:13:03.26,0:13:07.92,English,,0,0,0,,Those low-level optimizations like that if you write the code in a way that's reasonable
Dialogue: 0,0:13:03.26,0:13:07.92,Chinese,,0,0,0,,这种低级优化，如果你编写代码的方式比较合理的话
Dialogue: 0,0:13:08.40,0:13:15.48,English,,0,0,0,,But there's some other ones that the compiler and even a the fanciest compiler you can buy might not be able to figure it out
Dialogue: 0,0:13:08.40,0:13:15.48,Chinese,,0,0,0,,但是还有一些其他的代码，你可以购买的最好的编译器也可能无法优化
Dialogue: 0,0:13:15.90,0:13:20.70,English,,0,0,0,,And so I like to illustrate this with...when the first term we ever taught 213
Dialogue: 0,0:13:15.90,0:13:20.70,Chinese,,0,0,0,,我喜欢用这个例子来说明这一点......213 课程的第一个学期
Dialogue: 0,0:13:21.16,0:13:27.16,English,,0,0,0,,I was looking at some lab a code that some of the students wrote
Dialogue: 0,0:13:21.16,0:13:27.16,Chinese,,0,0,0,,我在实验室里看到一些学生写的这段代码
Dialogue: 0,0:13:27.16,0:13:29.32,English,,0,0,0,,And I was horrified about this code
Dialogue: 0,0:13:27.16,0:13:29.32,Chinese,,0,0,0,,我对这段代码感到震惊
Dialogue: 0,0:13:30.08,0:13:33.68,English,,0,0,0,,And I showed it to the TA and none of them figured out what was wrong
Dialogue: 0,0:13:30.08,0:13:33.68,Chinese,,0,0,0,,我向助教展示了这段代码，但没有一个人弄清楚出了什么问题
Dialogue: 0,0:13:33.68,0:13:38.76,English,,0,0,0,,And I've shown it to many other highly-trained C programmers professionals
Dialogue: 0,0:13:33.68,0:13:38.76,Chinese,,0,0,0,,我已经向许多其他训练有素的 C 程序员专业人员展示过它
Dialogue: 0,0:13:39.04,0:13:42.16,English,,0,0,0,,They go looks ok to me
Dialogue: 0,0:13:39.04,0:13:42.16,Chinese,,0,0,0,,他们感觉没什么问题
Dialogue: 0,0:13:42.22,0:13:45.40,English,,0,0,0,,So let's figure out what's why I was horrified by this code
Dialogue: 0,0:13:42.22,0:13:45.40,Chinese,,0,0,0,,那么让我们弄清楚为什么我被这段代码吓坏了
Dialogue: 0,0:13:45.86,0:13:49.56,English,,0,0,0,,So the idea of this code is supposed to be pretty straightforward there's a string s
Dialogue: 0,0:13:45.86,0:13:49.56,Chinese,,0,0,0,,这段代码的功能非常简单的，有一个字符串 s
Dialogue: 0,0:13:50.18,0:13:56.64,English,,0,0,0,,And I want to convert that string all the characters in it to lowercase
Dialogue: 0,0:13:50.18,0:13:56.64,Chinese,,0,0,0,,我想将该字符串中的所有字符转换为小写字母
Dialogue: 0,0:13:58.34,0:14:03.24,English,,0,0,0,,So I'm just going to read through the string and for each string position
Dialogue: 0,0:13:58.34,0:14:03.24,Chinese,,0,0,0,,所以我只是遍历这个字符串，对于字符串的每个位置
Dialogue: 0,0:14:04.02,0:14:09.06,English,,0,0,0,,Test that character and if it's somewhere between upper case a and upper case z
Dialogue: 0,0:14:04.02,0:14:09.06,Chinese,,0,0,0,,测试那个位置的字符，如果它在大写字母 a 和大写字母z之间
Dialogue: 0,0:14:09.38,0:14:14.56,English,,0,0,0,,Then I'm going to shift it to being between a and z otherwise I will change it
Dialogue: 0,0:14:09.38,0:14:14.56,Chinese,,0,0,0,,然后我将它变换到 a 和 z 之间，也就是转化为对应的小写字母
Dialogue: 0,0:14:15.00,0:14:16.36,English,,0,0,0,,So pretty straightforward
Dialogue: 0,0:14:15.00,0:14:16.36,Chinese,,0,0,0,,非常简单明了
Dialogue: 0,0:14:17.30,0:14:20.52,English,,0,0,0,,But if you run this you see that
Dialogue: 0,0:14:17.30,0:14:20.52,Chinese,,0,0,0,,但如果你运行它，你会看到
Dialogue: 0,0:14:21.08,0:14:24.20,English,,0,0,0,,If you go up to half a million characters
Dialogue: 0,0:14:21.08,0:14:24.20,Chinese,,0,0,0,,如果你的字符串到了五十万个字符
Dialogue: 0,0:14:25.26,0:14:33.66,English,,0,0,0,,Which might sound like a lot but it takes 240 or so so  so four minutes to run this code
Dialogue: 0,0:14:25.26,0:14:33.66,Chinese,,0,0,0,,需要 240 秒左右，也就是 4 分钟，才能运行完此代码
Dialogue: 0,0:14:35.30,0:14:37.78,English,,0,0,0,,And you go well that's a pretty big string
Dialogue: 0,0:14:35.30,0:14:37.78,Chinese,,0,0,0,,这是一个比较大的字符串
Dialogue: 0,0:14:37.78,0:14:43.04,English,,0,0,0,,It's really not a big string you should be able to do lowercase conversion of a string
Dialogue: 0,0:14:37.78,0:14:43.04,Chinese,,0,0,0,,但它真的不是一个特别大的字符串，你应该能够在 4 秒钟之内
Dialogue: 0,0:14:43.04,0:14:44.92,English,,0,0,0,,And a lot less than four seconds
Dialogue: 0,0:14:43.04,0:14:44.92,Chinese,,0,0,0,,将这个字符串转化为小写
Dialogue: 0,0:14:45.26,0:14:48.68,English,,0,0,0,,And you also notice this growth is nonlinear it's quadratic
Dialogue: 0,0:14:45.26,0:14:48.68,Chinese,,0,0,0,,你也注意到这种增长是非线性的，它是二次的
Dialogue: 0,0:14:48.68,0:14:52.78,English,,0,0,0,,It's growing as the square of the string length,so this is not good
Dialogue: 0,0:14:48.68,0:14:52.78,Chinese,,0,0,0,,它正在以字符串长度的平方增长，所以这并不好
Dialogue: 0,0:14:53.48,0:15:03.64,English,,0,0,0,,And unfortunately it's the kind and by the way this is one of the that is very easy surprisingly easy To have programs that have some hidden performance bug
Dialogue: 0,0:14:53.48,0:15:03.64,Chinese,,0,0,0,,这是一类非常容易有隐藏的性能上的 bug 的程序
Dialogue: 0,0:15:03.90,0:15:05.40,English,,0,0,0,,That makes them run quadratic
Dialogue: 0,0:15:03.90,0:15:05.40,Chinese,,0,0,0,,bug 会使程序的增长是二次的
Dialogue: 0,0:15:05.42,0:15:11.26,English,,0,0,0,,And you run test and you test for strings of 10,000 or less
Dialogue: 0,0:15:05.42,0:15:11.26,Chinese,,0,0,0,,并且当你的测试数据是 10,000 或更少的字符串时
Dialogue: 0,0:15:11.68,0:15:16.16,English,,0,0,0,,And it doesn't look like a big deal because the run time is insignificant so
Dialogue: 0,0:15:11.68,0:15:16.16,Chinese,,0,0,0,,它看起来并不是什么大不了的事，因为运行时间是微不足道的
Dialogue: 0,0:15:16.64,0:15:19.76,English,,0,0,0,,But then all of a sudden it hits a really bad case
Dialogue: 0,0:15:16.64,0:15:19.76,Chinese,,0,0,0,,但如果这个程序遇到了字符串比较大的情况
Dialogue: 0,0:15:20.30,0:15:25.68,English,,0,0,0,,So this is... there's something wrong here
Dialogue: 0,0:15:20.30,0:15:25.68,Chinese,,0,0,0,,就会出问题
Dialogue: 0,0:15:26.30,0:15:28.72,English,,0,0,0,,So what's so bad about this program well
Dialogue: 0,0:15:26.30,0:15:28.72,Chinese,,0,0,0,,所以，为什么这个程序不好
Dialogue: 0,0:15:29.82,0:15:35.36,English,,0,0,0,,The key is when in a test like this of calling strlen
Dialogue: 0,0:15:29.82,0:15:35.36,Chinese,,0,0,0,,关键的点是在条件测试中调用 strlen 函数
Dialogue: 0,0:15:36.34,0:15:44.62,English,,0,0,0,,So the way it's determining whether it's reached the end of the string is by calling strlen to figure out how long the string is
Dialogue: 0,0:15:36.34,0:15:44.62,Chinese,,0,0,0,,但 strlen 函数是通过测试字符串是否到达末尾的方式来计算字符串的长度
Dialogue: 0,0:15:46.66,0:15:54.82,English,,0,0,0,,Now and remember if we do the conversion of a for loop into a goto form like you've seen
Dialogue: 0,0:15:46.66,0:15:54.82,Chinese,,0,0,0,,现在，我们将 for 循环转换为 goto 形式
Dialogue: 0,0:15:54.82,0:15:56.94,English,,0,0,0,,There's various ways to convert it
Dialogue: 0,0:15:54.82,0:15:56.94,Chinese,,0,0,0,,有各种方法来进行这个转化
Dialogue: 0,0:15:57.08,0:16:00.98,English,,0,0,0,,But all of them the test get built into the loop
Dialogue: 0,0:15:57.08,0:16:00.98,Chinese,,0,0,0,,但是所有这些测试都在循环中
Dialogue: 0,0:16:02.02,0:16:08.94,English,,0,0,0,,So the main feature of that is this call to strlen will happen every time you go through the loop
Dialogue: 0,0:16:02.02,0:16:08.94,Chinese,,0,0,0,,因此，每次循环时都会产生对 strlen 的调用
Dialogue: 0,0:16:11.14,0:16:13.28,English,,0,0,0,,And people overlook that fact
Dialogue: 0,0:16:11.14,0:16:13.28,Chinese,,0,0,0,,程序员常常忽略了这样一个事实
Dialogue: 0,0:16:14.18,0:16:17.66,English,,0,0,0,,When you look at the different parts of a for loop
Dialogue: 0,0:16:14.18,0:16:17.66,Chinese,,0,0,0,,for 循环有三个不同部分
Dialogue: 0,0:16:18.20,0:16:20.70,English,,0,0,0,,The initialization only gets executed once
Dialogue: 0,0:16:18.20,0:16:20.70,Chinese,,0,0,0,,初始化只执行一次
Dialogue: 0,0:16:21.36,0:16:28.98,English,,0,0,0,,But both the tests and the update get incremented get applied every time you run through the loop
Dialogue: 0,0:16:21.36,0:16:28.98,Chinese,,0,0,0,,但测试和更新每次循环都会执行
Dialogue: 0,0:16:30.14,0:16:36.44,English,,0,0,0,,So if that's getting called as many times as there are characters in the loop in the string right
Dialogue: 0,0:16:30.14,0:16:36.44,Chinese,,0,0,0,,因此，strlen 调用的次数，等于字符串中字符的数量
Dialogue: 0,0:16:37.60,0:16:39.20,English,,0,0,0,,And now how does strlen work
Dialogue: 0,0:16:37.60,0:16:39.20,Chinese,,0,0,0,,现在看 strlen 如何工作
Dialogue: 0,0:16:39.22,0:16:42.58,English,,0,0,0,,Remember and see the only way you know how long a string is
Dialogue: 0,0:16:39.22,0:16:42.58,Chinese,,0,0,0,,查看字符串长度的唯一方法
Dialogue: 0,0:16:43.06,0:16:47.26,English,,0,0,0,,Is to step through the whole thing and find the null character at the end
Dialogue: 0,0:16:43.06,0:16:47.26,Chinese,,0,0,0,,是遍历整个字符串直到找到空字符为止
Dialogue: 0,0:16:48.18,0:16:52.28,English,,0,0,0,,So strlen itself is a linear time operation in the string
Dialogue: 0,0:16:48.18,0:16:52.28,Chinese,,0,0,0,,因此 strlen 本身就是线性时间的操作
Dialogue: 0,0:16:54.02,0:16:59.84,English,,0,0,0,,And you're doing that and so you're doing n calls to a function that takes time n
Dialogue: 0,0:16:54.02,0:16:59.84,Chinese,,0,0,0,,所以，你对一个线性时间函数调用了 n 次 
Dialogue: 0,0:17:00.80,0:17:04.66,English,,0,0,0,,If the string is getting shorter as you go but not very fast so
Dialogue: 0,0:17:00.80,0:17:04.66,Chinese,,0,0,0,,执行的过程中字符串越来越短，但是执行的速度不是很快
Dialogue: 0,0:17:05.10,0:17:07.06,English,,0,0,0,,Basically that's quadratic performance
Dialogue: 0,0:17:05.10,0:17:07.06,Chinese,,0,0,0,,基本上是二次的
Dialogue: 0,0:17:09.98,0:17:12.46,English,,0,0,0,,And that explains why you get that runtime
Dialogue: 0,0:17:09.98,0:17:12.46,Chinese,,0,0,0,,这就解释了为什么我们的运行时间会比较长
Dialogue: 0,0:17:13.64,0:17:16.62,English,,0,0,0,,So in particular if I just make the following little change
Dialogue: 0,0:17:13.64,0:17:16.62,Chinese,,0,0,0,,如果我做了以下一些小改动
Dialogue: 0,0:17:17.14,0:17:20.56,English,,0,0,0,,I introduce a local variable called len
Dialogue: 0,0:17:17.14,0:17:20.56,Chinese,,0,0,0,,我引入一个名为 len 的局部变量
Dialogue: 0,0:17:21.38,0:17:24.50,English,,0,0,0,,And I pre compute strlen
Dialogue: 0,0:17:21.38,0:17:24.50,Chinese,,0,0,0,,我预先计算 strlen
Dialogue: 0,0:17:24.50,0:17:29.26,English,,0,0,0,,Because the string isn't the length of the string isn't changing I'm just changing the characters in this string
Dialogue: 0,0:17:24.50,0:17:29.26,Chinese,,0,0,0,,因为字符串的长度没有改变，我们只是改变了这个字符串中的字符
Dialogue: 0,0:17:30.10,0:17:34.46,English,,0,0,0,,Then so the the program will do the same thing
Dialogue: 0,0:17:30.10,0:17:34.46,Chinese,,0,0,0,,那么程序将做同样的事情
Dialogue: 0,0:17:34.78,0:17:38.22,English,,0,0,0,,But now the runtime is so short it doesn't even show up
Dialogue: 0,0:17:34.78,0:17:38.22,Chinese,,0,0,0,,但是现在运行时很短，甚至都看不出来时间的增长
Dialogue: 0,0:17:38.60,0:17:43.68,English,,0,0,0,,It's maybe a second to do a million characters it's just not a big deal at all
Dialogue: 0,0:17:38.60,0:17:43.68,Chinese,,0,0,0,,即使是一百万个字符，也不是什么大不了的事
Dialogue: 0,0:17:44.28,0:17:46.66,English,,0,0,0,,As it should be it's just running through
Dialogue: 0,0:17:44.28,0:17:46.66,Chinese,,0,0,0,,因为它仅仅是遍历字符串
Dialogue: 0,0:17:47.22,0:17:53.72,English,,0,0,0,,And so that's just an example one of many that I've seen in my career where
Dialogue: 0,0:17:47.22,0:17:53.72,Chinese,,0,0,0,,这只是我职业生涯中见过的许多例子之一
Dialogue: 0,0:17:54.42,0:18:00.14,English,,0,0,0,,Something that seems almost insignificant turns out to be a serious performance problem
Dialogue: 0,0:17:54.42,0:18:00.14,Chinese,,0,0,0,,看似无足轻重的事情，最后证明存在严重的性能问题
Dialogue: 0,0:18:03.58,0:18:06.34,English,,0,0,0,,So why couldn't a compiler figure this out
Dialogue: 0,0:18:03.58,0:18:06.34,Chinese,,0,0,0,,那么为什么编译器无法解决这个问题
Dialogue: 0,0:18:07.62,0:18:09.58,English,,0,0,0,,Why couldn't a smart compiler
Dialogue: 0,0:18:07.62,0:18:09.58,Chinese,,0,0,0,,为什么编译器不能更智能一点
Dialogue: 0,0:18:13.08,0:18:14.90,English,,0,0,0,,Look at the original code
Dialogue: 0,0:18:13.08,0:18:14.90,Chinese,,0,0,0,,看看原始代码
Dialogue: 0,0:18:17.14,0:18:22.68,English,,0,0,0,,And see, you know this is what the programmer wrote
Dialogue: 0,0:18:17.14,0:18:22.68,Chinese,,0,0,0,,知道这是程序员写的
Dialogue: 0,0:18:22.68,0:18:26.52,English,,0,0,0,,But I know a better way to do it I'll precompute strlen in advance
Dialogue: 0,0:18:22.68,0:18:26.52,Chinese,,0,0,0,,但编译器知道更好的方法，会提前预先计算 strlen
Dialogue: 0,0:18:27.36,0:18:32.66,English,,0,0,0,,Well there's a couple reasons one is actually if you look at the code for strlen
Dialogue: 0,0:18:27.36,0:18:32.66,Chinese,,0,0,0,,有几个原因使得编译器无法进行此类优化
Dialogue: 0,0:18:32.90,0:18:35.80,English,,0,0,0,,You see that it's actually modifying the string
Dialogue: 0,0:18:32.90,0:18:35.80,Chinese,,0,0,0,,第一，这里的代码在循环中修改了字符串
Dialogue: 0,0:18:36.34,0:18:42.06,English,,0,0,0,,And strlen at this I mean the the code here is modifying the string and we're calling strlen on it
Dialogue: 0,0:18:36.34,0:18:42.06,Chinese,,0,0,0,,这里我的意思是这里的代码是修改字符串，并且我们调用了 strlen
Dialogue: 0,0:18:42.20,0:18:48.24,English,,0,0,0,,So you'd have to be pretty careful to do the analysis the compiler would to figure out that
Dialogue: 0,0:18:42.20,0:18:48.24,Chinese,,0,0,0,,因此，编译器必须非常小心的分析，知道
Dialogue: 0,0:18:48.72,0:18:50.72,English,,0,0,0,,Even though the string is changing
Dialogue: 0,0:18:48.72,0:18:50.72,Chinese,,0,0,0,,即使字符串正在改变
Dialogue: 0,0:18:51.54,0:18:55.62,English,,0,0,0,,The result you're going to get from strlen is not going to change
Dialogue: 0,0:18:51.54,0:18:55.62,Chinese,,0,0,0,,从 strlen 获得的结果不会改变
Dialogue: 0,0:18:58.89,0:19:03.80,English,,0,0,0,,So that's a one reason
Dialogue: 0,0:18:58.89,0:19:03.80,Chinese,,0,0,0,,所以这是一个原因
Dialogue: 0,0:19:04.30,0:19:05.82,English,,0,0,0,,And the second is...
Dialogue: 0,0:19:04.30,0:19:05.82,Chinese,,0,0,0,,第二是......
Dialogue: 0,0:19:06.68,0:19:14.36,English,,0,0,0,,Well and how can the compiler be sure which version of strlen is actually going to get used
Dialogue: 0,0:19:06.68,0:19:14.36,Chinese,,0,0,0,,那么编译器如何确定哪个版本的 strlen 实际上将被使用
Dialogue: 0,0:19:14.80,0:19:18.66,English,,0,0,0,,You remember and see each of the files gets compiled separately
Dialogue: 0,0:19:14.80,0:19:18.66,Chinese,,0,0,0,,因为每个文件都是单独编译的
Dialogue: 0,0:19:19.00,0:19:23.68,English,,0,0,0,,And only afterwards does it all get brought together in the linking phase
Dialogue: 0,0:19:19.00,0:19:23.68,Chinese,,0,0,0,,编译之后，它们才会在链接阶段链接在一起
Dialogue: 0,0:19:23.68,0:19:26.70,English,,0,0,0,,And some of that even happens after the program gets started
Dialogue: 0,0:19:23.68,0:19:26.70,Chinese,,0,0,0,,其中一些甚至在程序启动后发生
Dialogue: 0,0:19:27.48,0:19:30.74,English,,0,0,0,,So even though there's a standard strlen function
Dialogue: 0,0:19:27.48,0:19:30.74,Chinese,,0,0,0,,所以尽管有一个标准的 strlen 函数
Dialogue: 0,0:19:31.36,0:19:37.26,English,,0,0,0,,It's not necessarily the case that that's the one that will actually get used in the final program
Dialogue: 0,0:19:31.36,0:19:37.26,Chinese,,0,0,0,,实际上并不一定会在最终的程序中使用它
Dialogue: 0,0:19:37.26,0:19:40.98,English,,0,0,0,,So the compiler really can't be sure of that
Dialogue: 0,0:19:37.26,0:19:40.98,Chinese,,0,0,0,,所以编译器真的不能确定调用那个 strlen 函数
Dialogue: 0,0:19:41.18,0:19:46.70,English,,0,0,0,,In particular imagine I provided a sort of customized strlen function like this
Dialogue: 0,0:19:41.18,0:19:46.70,Chinese,,0,0,0,,想想一下，我提供了一种这样的自定义 strlen 函数（如 PPT 所示）
Dialogue: 0,0:19:47.40,0:19:53.26,English,,0,0,0,,That is keeping track of the sum of the lengths of all the strings that it's been called on
Dialogue: 0,0:19:47.40,0:19:53.26,Chinese,,0,0,0,,它记录调用它的的所有字符串的长度之和
Dialogue: 0,0:19:53.72,0:19:57.12,English,,0,0,0,,Or some other side effect like that that
Dialogue: 0,0:19:53.72,0:19:57.12,Chinese,,0,0,0,,或者其他一些副作用
Dialogue: 0,0:19:57.84,0:20:02.20,English,,0,0,0,,Well that program would produce a very different result than if
Dialogue: 0,0:19:57.84,0:20:02.20,Chinese,,0,0,0,,那么程序会产生一个非常不同的结果
Dialogue: 0,0:20:02.78,0:20:05.86,English,,0,0,0,,If I whether or not I make the optimization
Dialogue: 0,0:20:02.78,0:20:05.86,Chinese,,0,0,0,,如果我进行优化的话
Dialogue: 0,0:20:05.98,0:20:12.36,English,,0,0,0,,So the compiler has to assume that strlen is just a black box that does whatever it does
Dialogue: 0,0:20:05.98,0:20:12.36,Chinese,,0,0,0,,所以编译器必须假设 strlen 只是一个黑盒子，它可能做任何事
Dialogue: 0,0:20:12.76,0:20:19.68,English,,0,0,0,,And can't make any assumptions about what side effects it might have and so forth
Dialogue: 0,0:20:12.76,0:20:19.68,Chinese,,0,0,0,,并且不能对它能否产生的副作用做出任何假设
Dialogue: 0,0:20:19.72,0:20:26.52,English,,0,0,0,,So it won't make that optimization on any machine even with the best compiler
Dialogue: 0,0:20:19.72,0:20:26.52,Chinese,,0,0,0,,所以即使使用最好的编译器，它也不会在任何机器上进行这样的优化
Dialogue: 0,0:20:27.44,0:20:35.70,English,,0,0,0,,So that's just an example that and you can tell that I've gotten kind of sensitized to this
Dialogue: 0,0:20:27.44,0:20:35.70,Chinese,,0,0,0,,所以这只是一个例子，你可以告诉我，你已经对此敏感了
Dialogue: 0,0:20:36.24,0:20:39.06,English,,0,0,0,,So that I spot these but a lot of people don't
Dialogue: 0,0:20:36.24,0:20:39.06,Chinese,,0,0,0,,所以你发现了这些，但很多人没有
Dialogue: 0,0:20:42.52,0:20:44.12,English,,0,0,0,,Um so let's look at this
Dialogue: 0,0:20:42.52,0:20:44.12,Chinese,,0,0,0,,嗯，让我们看看这个
Dialogue: 0,0:20:44.98,0:20:47.12,English,,0,0,0,,Let's see
Dialogue: 0,0:20:44.98,0:20:47.12,Chinese,,0,0,0,,嗯
Dialogue: 0,0:20:50.78,0:20:54.28,English,,0,0,0,,Oh this is another bad example a bad coding example
Dialogue: 0,0:20:50.78,0:20:54.28,Chinese,,0,0,0,,哦，这是一个糟糕的代码的另一个例子
Dialogue: 0,0:20:55.50,0:21:06.36,English,,0,0,0,,Of imagine I want to compute for a two-dimensional array a  and 'a' one-dimensional array 'b'
Dialogue: 0,0:20:55.50,0:21:06.36,Chinese,,0,0,0,,我有一个二维数组 a 和一个一维数组 b
Dialogue: 0,0:21:06.76,0:21:14.90,English,,0,0,0,,I want to make b be b[i] be the sum of all the elements in row i of  a
Dialogue: 0,0:21:06.76,0:21:14.90,Chinese,,0,0,0,,我想使 b 的 b[i] 等于 a 中 i 行中所有元素的总和
Dialogue: 0,0:21:15.94,0:21:20.46,English,,0,0,0,,So again this is a fairly obvious kind of way to write this program that you
Dialogue: 0,0:21:15.94,0:21:20.46,Chinese,,0,0,0,,这里这个程序写得相当直白
Dialogue: 0,0:21:21.60,0:21:27.64,English,,0,0,0,,Say well b[i]=0 and I'm going to just accumulate it,I'll step through the row and accumulate all the values
Dialogue: 0,0:21:21.60,0:21:27.64,Chinese,,0,0,0,,b[i] 初始化为 0，然后遍历 a 的一行，把 a[i][j] 的值累加到 b[i] 上
Dialogue: 0,0:21:28.40,0:21:34.14,English,,0,0,0,,And of course we know now we could improve this by moving i*n out and so forth
Dialogue: 0,0:21:28.40,0:21:34.14,Chinese,,0,0,0,,当然，我们现在知道我们可以通过移动 i*n 来改善这一点
Dialogue: 0,0:21:34.18,0:21:35.56,English,,0,0,0,,I'm not trying to illustrate that
Dialogue: 0,0:21:34.18,0:21:35.56,Chinese,,0,0,0,,但我想说的不是这一点
Dialogue: 0,0:21:36.64,0:21:39.52,English,,0,0,0,,But what you'll see in the program this is in the inner loop
Dialogue: 0,0:21:36.64,0:21:39.52,Chinese,,0,0,0,,主要到在程序的内循环中
Dialogue: 0,0:21:40.08,0:21:44.58,English,,0,0,0,,And we've looked briefly at some floating-point instructions
Dialogue: 0,0:21:40.08,0:21:44.58,Chinese,,0,0,0,,我们已经简要介绍了一些浮点指令
Dialogue: 0,0:21:44.82,0:21:47.18,English,,0,0,0,,And remember that the main feature of them is
Dialogue: 0,0:21:44.82,0:21:47.18,Chinese,,0,0,0,,它们的主要特征是
Dialogue: 0,0:21:47.74,0:21:51.24,English,,0,0,0,,The move instructions look like the move ones you're familiar with
Dialogue: 0,0:21:47.74,0:21:51.24,Chinese,,0,0,0,,移动指令看起来像你熟悉的移动指令
Dialogue: 0,0:21:51.50,0:21:56.08,English,,0,0,0,,Except when we put floating-point data in one of these %xmm registers
Dialogue: 0,0:21:51.50,0:21:56.08,Chinese,,0,0,0,,除了我们将浮点数据放在其中一个 ％xmm 寄存器中
Dialogue: 0,0:21:57.32,0:22:02.42,English,,0,0,0,,So the main thing you see here is it's reading from memory
Dialogue: 0,0:21:57.32,0:22:02.42,Chinese,,0,0,0,,所以你在这里看到的主要是它从内存中读取数据
Dialogue: 0,0:22:02.94,0:22:06.42,English,,0,0,0,,It's adding something to it and then it's writing back to memory
Dialogue: 0,0:22:02.94,0:22:06.42,Chinese,,0,0,0,,然后加上某个值，然后它写回内存
Dialogue: 0,0:22:06.98,0:22:10.48,English,,0,0,0,,And what that memory location corresponds to b[i]
Dialogue: 0,0:22:06.98,0:22:10.48,Chinese,,0,0,0,,那个内存位置对应 b[i]
Dialogue: 0,0:22:11.30,0:22:18.64,English,,0,0,0,,So what it means is every time through this loop it's having to do a memory read and a memory write of b
Dialogue: 0,0:22:11.30,0:22:18.64,Chinese,,0,0,0,,所以这意味着每次循环都需要从内存中读取 b[i]，然后再把 b[i] 写回内存
Dialogue: 0,0:22:19.08,0:22:21.12,English,,0,0,0,,In addition to the memory read of a
Dialogue: 0,0:22:19.08,0:22:21.12,Chinese,,0,0,0,,除了多了内存读取之外
Dialogue: 0,0:22:22.08,0:22:29.30,English,,0,0,0,,Even though presumably b[i] is the same of value that you just updated it to
Dialogue: 0,0:22:22.08,0:22:29.30,Chinese,,0,0,0,,b[i] 与上次循环
Dialogue: 0,0:22:30.46,0:22:33.56,English,,0,0,0,,Well in the previous execution of this loop right
Dialogue: 0,0:22:30.46,0:22:33.56,Chinese,,0,0,0,,更新的值相同
Dialogue: 0,0:22:33.82,0:22:37.10,English,,0,0,0,,So why do you have to,why do you read it,why do you write it out
Dialogue: 0,0:22:33.82,0:22:37.10,Chinese,,0,0,0,,那么你为什么要这样做，为什么要从内存中读取然后再写回到内存呢
Dialogue: 0,0:22:37.52,0:22:41.54,English,,0,0,0,,And then read it back in increment it and then again copy it back out
Dialogue: 0,0:22:37.52,0:22:41.54,Chinese,,0,0,0,,然后再从内存中读取，加上某个值，再写到内存中
Dialogue: 0,0:22:41.54,0:22:47.78,English,,0,0,0,,Why does it have to go keep jumping back and forth between memory and registers over and over again
Dialogue: 0,0:22:41.54,0:22:47.78,Chinese,,0,0,0,,为什么必须一遍又一遍地在内存和寄存器之间来回传送数据
Dialogue: 0,0:22:49.28,0:22:53.24,English,,0,0,0,,Well the reason is because in C you can't be sure
Dialogue: 0,0:22:49.28,0:22:53.24,Chinese,,0,0,0,,原因是因为在 C 中你无法确定是否有
Dialogue: 0,0:22:53.78,0:22:57.86,English,,0,0,0,,That there isn't what's known as aliasing and I'm demonstrating it here
Dialogue: 0,0:22:53.78,0:22:57.86,Chinese,,0,0,0,,内存别名使用
Dialogue: 0,0:22:58.24,0:23:04.54,English,,0,0,0,,Imagine if row b is just declared to be that
Dialogue: 0,0:22:58.24,0:23:04.54,Chinese,,0,0,0,,想象一下，如果行 b 为 a 中的某一行
Dialogue: 0,0:23:05.32,0:23:10.10,English,,0,0,0,,Okay so imagine and you can do in C, this is legal C code
Dialogue: 0,0:23:05.32,0:23:10.10,Chinese,,0,0,0,,好吧，想象一下，在 C 中你可以这样做，这是合法的 C 代码
Dialogue: 0,0:23:10.50,0:23:16.34,English,,0,0,0,,You can make one memory data structure overlay another data structure
Dialogue: 0,0:23:10.50,0:23:16.34,Chinese,,0,0,0,,你可以使一个内存数据结构覆盖另一个数据结构
Dialogue: 0,0:23:16.34,0:23:24.54,English,,0,0,0,,That's referred to as aliasing when too soon as separate parts of the program are referring to the same locations in memory
Dialogue: 0,0:23:16.34,0:23:24.54,Chinese,,0,0,0,,当程序的不同部分指向内存中的相同位置时，这称为别名
Dialogue: 0,0:23:25.04,0:23:27.28,English,,0,0,0,,And the C compiler has no way of knowing
Dialogue: 0,0:23:25.04,0:23:27.28,Chinese,,0,0,0,,并且 C 编译器无法知道是否存在别名
Dialogue: 0,0:23:29.14,0:23:35.44,English,,0,0,0,,Whether there's a lot of work and optimizing compilers to detect aliasing possibilities
Dialogue: 0,0:23:29.14,0:23:35.44,Chinese,,0,0,0,,编译器需要做大量的工作来检查是否有内存别名引用
Dialogue: 0,0:23:35.80,0:23:38.30,English,,0,0,0,,But in general as to assume aliasing might happen
Dialogue: 0,0:23:35.80,0:23:38.30,Chinese,,0,0,0,,但总的来说，编译器假设存在内存别名引用
Dialogue: 0,0:23:38.84,0:23:47.72,English,,0,0,0,,So imagine this aliasing happened so that array 'b' can corresponds then to this row of array 'a'
Dialogue: 0,0:23:38.84,0:23:47.72,Chinese,,0,0,0,,想象一下，数组 b 可以对应于数组 a 中的一行
Dialogue: 0,0:23:49.50,0:23:53.10,English,,0,0,0,,Well then of course its initial value is 4, 8, 16
Dialogue: 0,0:23:49.50,0:23:53.10,Chinese,,0,0,0,,所以 b 的初始值是 4，8，16
Dialogue: 0,0:23:53.10,0:23:55.20,English,,0,0,0,,But if you trace through what this code will do
Dialogue: 0,0:23:53.10,0:23:55.20,Chinese,,0,0,0,,但是如果你逐步调试这段代码
Dialogue: 0,0:23:55.58,0:24:00.76,English,,0,0,0,,It has a sort of odd behavior that is probably not useful for anything
Dialogue: 0,0:23:55.58,0:24:00.76,Chinese,,0,0,0,,你会发现它的行为比较奇怪，可能对任何事情都没用
Dialogue: 0,0:24:01.28,0:24:09.30,English,,0,0,0,,But it just demonstrates that what will happen is as this as b gets updated
Dialogue: 0,0:24:01.28,0:24:09.30,Chinese,,0,0,0,,它仅仅表明，当 b 更新的时候
Dialogue: 0,0:24:09.66,0:24:15.46,English,,0,0,0,,It's effectively changing a and it's changing then what's being read during the summation
Dialogue: 0,0:24:09.66,0:24:15.46,Chinese,,0,0,0,,它改变了 a，然后影响了求和的结果
Dialogue: 0,0:24:17.70,0:24:20.86,English,,0,0,0,,And so this is a real possibility in C
Dialogue: 0,0:24:17.70,0:24:20.86,Chinese,,0,0,0,,在 C 语言中这是可能发生的
Dialogue: 0,0:24:21.72,0:24:24.70,English,,0,0,0,,And so the compiler when it's given code like this
Dialogue: 0,0:24:21.72,0:24:24.70,Chinese,,0,0,0,,所以编译器对于这样的代码
Dialogue: 0,0:24:25.72,0:24:32.18,English,,0,0,0,,It has to assume that the these two memory locations might court overlap each other
Dialogue: 0,0:24:25.72,0:24:32.18,Chinese,,0,0,0,,它必须假设这两个存储位置可能相互重叠
Dialogue: 0,0:24:32.22,0:24:37.68,English,,0,0,0,,So that's why it's carefully writing it out and then reading it back in over and over again
Dialogue: 0,0:24:32.22,0:24:37.68,Chinese,,0,0,0,,所以，编译器会小心地把值写到内存然后一遍又一遍地读回来
Dialogue: 0,0:24:40.50,0:24:45.32,English,,0,0,0,,And so if I just rewrite this code by introducing again a local variable
Dialogue: 0,0:24:40.50,0:24:45.32,Chinese,,0,0,0,,因此，如果通过引入局部变量来重写此代码
Dialogue: 0,0:24:46.20,0:24:48.44,English,,0,0,0,,And accumulating in that local variable
Dialogue: 0,0:24:46.20,0:24:48.44,Chinese,,0,0,0,,并把求和的结果保存在该局部变量中
Dialogue: 0,0:24:49.06,0:24:52.98,English,,0,0,0,,And then only at the end do I assign that to b[i]
Dialogue: 0,0:24:49.06,0:24:52.98,Chinese,,0,0,0,,然后只在最后我赋值 b[i]
Dialogue: 0,0:24:53.64,0:24:57.18,English,,0,0,0,,Then you'll see this exact same loop all of a sudden gets a lot simpler
Dialogue: 0,0:24:53.64,0:24:57.18,Chinese,,0,0,0,,然后你会看到这个完全相同的循环突然变得更加简单
Dialogue: 0,0:24:57.24,0:25:02.82,English,,0,0,0,,It's just a read floating point, read and add to do that
Dialogue: 0,0:24:57.24,0:25:02.82,Chinese,,0,0,0,,它只是读取一个浮点数，然后加到寄存器
Dialogue: 0,0:25:03.80,0:25:12.90,English,,0,0,0,,And we'll see in fact the memory is actually one of the limiting perform performance limiters in a program
Dialogue: 0,0:25:03.80,0:25:12.90,Chinese,,0,0,0,,这里，对内存的读写限制了程序的性能
Dialogue: 0,0:25:12.90,0:25:16.71,English,,0,0,0,,So this is won't be a significantly faster
Dialogue: 0,0:25:12.90,0:25:16.71,Chinese,,0,0,0,,所以改写之后不会明显加快
Dialogue: 0,0:25:16.88,0:25:22.08,English,,0,0,0,,And again that's something that you as a programmer would hardly think is a big deal
Dialogue: 0,0:25:16.88,0:25:22.08,Chinese,,0,0,0,,再一次重申，作为一名程序员，你很难想到这是一件大事
Dialogue: 0,0:25:23.08,0:25:25.32,English,,0,0,0,,But the C compiler can't do that in general
Dialogue: 0,0:25:23.08,0:25:25.32,Chinese,,0,0,0,,但是 C 编译器通常不能进行这样的优化
Dialogue: 0,0:25:25.56,0:25:30.62,English,,0,0,0,,Because it can't determine in advance what possible aliasing there can be
Dialogue: 0,0:25:25.56,0:25:30.62,Chinese,,0,0,0,,因为它无法预先确定是否存在的内存别名使用
Dialogue: 0,0:25:35.20,0:25:41.84,English,,0,0,0,,So as is these two examples C sort of get in the habit of introducing local variables and using them
Dialogue: 0,0:25:35.20,0:25:41.84,Chinese,,0,0,0,,因此，要习惯这两个例子中引入局部变量的写法
Dialogue: 0,0:25:42.12,0:25:47.74,English,,0,0,0,,And it's your way of telling the compiler don't call the same function over and over again
Dialogue: 0,0:25:42.12,0:25:47.74,Chinese,,0,0,0,,这样可以告诉编译器不要一遍又一遍地调用相同函数
Dialogue: 0,0:25:47.74,0:25:53.38,English,,0,0,0,,Don't read and write the same memory location over and over again just hold it in a temporary one
Dialogue: 0,0:25:47.74,0:25:53.38,Chinese,,0,0,0,,不要一遍又一遍地读取和写入相同的内存位置，只需将其保存在临时位置即可
Dialogue: 0,0:25:53.58,0:25:58.26,English,,0,0,0,,And then it will automatically allocate a register and store it in that register and everything will be good
Dialogue: 0,0:25:53.58,0:25:58.26,Chinese,,0,0,0,,然后编译器会自动分配一个寄存器并将结果存储在该寄存器中，一切都会很好
Dialogue: 0,0:26:01.40,0:26:09.88,English,,0,0,0,,Okay so that's sort of the the kind of what we call optimization blockers the kind of things that
Dialogue: 0,0:26:01.40,0:26:09.88,Chinese,,0,0,0,,好的，这就是会阻止编译器优化的一些东西
Dialogue: 0,0:26:10.40,0:26:12.48,English,,0,0,0,,You as a programmer can make a difference on
Dialogue: 0,0:26:10.40,0:26:12.48,Chinese,,0,0,0,,作为程序员，你可以帮助编译器进行优化
Dialogue: 0,0:26:12.48,0:26:17.10,English,,0,0,0,,And the main blockers are memory referencing aliasing and function calls
Dialogue: 0,0:26:12.48,0:26:17.10,Chinese,,0,0,0,,影响编译器优化的，主要是内存别名使用和
Dialogue: 0,0:26:17.60,0:26:21.54,English,,0,0,0,,And sort of understanding what might happen in that function call
Dialogue: 0,0:26:17.60,0:26:21.54,Chinese,,0,0,0,,函数调用中的副作用
Dialogue: 0,0:26:22.38,0:26:24.70,English,,0,0,0,,And so now what we're going to do is transition
Dialogue: 0,0:26:22.38,0:26:24.70,Chinese,,0,0,0,,好的，现在我们要转移到另一个话题
Dialogue: 0,0:26:24.82,0:26:48.50,English,,0,0,0,,Question?[student speaking]
Dialogue: 0,0:26:24.82,0:26:48.50,Chinese,,0,0,0,,这位同学有问题吗？[学生提问]
Dialogue: 0,0:26:48.78,0:26:51.36,English,,0,0,0,,Oh no no this is alias C code
Dialogue: 0,0:26:48.78,0:26:51.36,Chinese,,0,0,0,,不，这是 C 代码（double B[3] = A+3有问题，GCC 编译无法通过）
Dialogue: 0,0:26:53.96,0:26:57.12,English,,0,0,0,,I'm sure this is known C code because it ran
Dialogue: 0,0:26:53.96,0:26:57.12,Chinese,,0,0,0,,我确定这是 C 代码，因为我运行过它
Dialogue: 0,0:26:59.86,0:27:08.50,English,,0,0,0,,This is initializing calling it an array b remember these are in stars these aren't two-dimensional arrays right
Dialogue: 0,0:26:59.86,0:27:08.50,Chinese,,0,0,0,,这个函数接受两个 double * 的参数，所以它们都不是二维数组
Dialogue: 0,0:27:11.24,0:27:14.82,English,,0,0,0,,So this is saying a is now a
Dialogue: 0,0:27:11.24,0:27:14.82,Chinese,,0,0,0,,所以这就是说 a 不是二维数组
Dialogue: 0,0:27:15.80,0:27:19.72,English,,0,0,0,,Think of it as a linear array of four elements of nine elements
Dialogue: 0,0:27:15.80,0:27:19.72,Chinese,,0,0,0,,可以把数组 b 想象成 9 个元素数组中的其中 3 个元素
Dialogue: 0,0:27:20.38,0:27:24.68,English,,0,0,0,,And a plus three is just to go in three
Dialogue: 0,0:27:20.38,0:27:24.68,Chinese,,0,0,0,,加三表明是从第三个开始
Dialogue: 0,0:27:25.02,0:27:28.80,English,,0,0,0,,So this is it is declaring b is not a pointer it's an array
Dialogue: 0,0:27:25.02,0:27:28.80,Chinese,,0,0,0,,所以这就是声明 b 不是指针它是一个数组
Dialogue: 0,0:27:29.10,0:27:35.60,English,,0,0,0,,But remember with an array you can use the name of that array as a reference to a pointer
Dialogue: 0,0:27:29.10,0:27:35.60,Chinese,,0,0,0,,但数组的名称也可以作为一个指针
Dialogue: 0,0:27:35.84,0:27:38.02,English,,0,0,0,,A readable reference not a writable reference right
Dialogue: 0,0:27:35.84,0:27:38.02,Chinese,,0,0,0,,可以通过指针读写数组
Dialogue: 0,0:27:38.34,0:27:44.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:27:38.34,0:27:44.54,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:27:44.72,0:27:48.02,English,,0,0,0,,Right for this exact code well I'll double check it
Dialogue: 0,0:27:44.72,0:27:48.02,Chinese,,0,0,0,,对，我会仔细检查仔细检查这段代码
Dialogue: 0,0:27:48.02,0:28:05.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:27:48.02,0:28:05.78,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:28:05.80,0:28:08.58,English,,0,0,0,,So the question is why the C use null terminated strings
Dialogue: 0,0:28:05.80,0:28:08.58,Chinese,,0,0,0,,所以问题是为什么 C 使用 null 来标识字符串的结尾
Dialogue: 0,0:28:09.20,0:28:14.28,English,,0,0,0,,And it does and it might be a bad decision for multiple reasons right but
Dialogue: 0,0:28:09.20,0:28:14.28,Chinese,,0,0,0,,使用这种方式可能是一个糟糕的决定，但多种原因
Dialogue: 0,0:28:14.84,0:28:22.12,English,,0,0,0,,I think in general think of C was somebody who had or a couple of people
Dialogue: 0,0:28:14.84,0:28:22.12,Chinese,,0,0,0,,我想，因为 C 语言是由 D.M.Ritchie（补充的）发明
Dialogue: 0,0:28:22.12,0:28:28.16,English,,0,0,0,,Who had been writing a lot of assembly code and wanted to lift up that level
Dialogue: 0,0:28:22.12,0:28:28.16,Chinese,,0,0,0,,他曾写过很多汇编代码，想要提升汇编代码的抽象级别
Dialogue: 0,0:28:28.16,0:28:30.80,English,,0,0,0,,So they weren't writing the same stuff over and over again
Dialogue: 0,0:28:28.16,0:28:30.80,Chinese,,0,0,0,,因为他们不想一遍又一遍地写同样的东西
Dialogue: 0,0:28:31.16,0:28:35.98,English,,0,0,0,,But not thinking in terms of how can I be the most abstract possible
Dialogue: 0,0:28:31.16,0:28:35.98,Chinese,,0,0,0,,所以他们进一步考虑高级的抽象
Dialogue: 0,0:28:35.98,0:28:41.54,English,,0,0,0,,So they were trying to provide sort of a minimum layer on top of machine level programming
Dialogue: 0,0:28:35.98,0:28:41.54,Chinese,,0,0,0,,他们只是试图在机器级编程之上提供一个小的抽象
Dialogue: 0,0:28:41.84,0:28:45.00,English,,0,0,0,,That would let them write code that could run from one machine to another
Dialogue: 0,0:28:41.84,0:28:45.00,Chinese,,0,0,0,,可以使他们编写的代码，从一个机器跨越到另一台机器
Dialogue: 0,0:28:45.38,0:28:51.84,English,,0,0,0,,So in everything they do they sort of use the most simple representation and don't assume any kind of
Dialogue: 0,0:28:45.38,0:28:51.84,Chinese,,0,0,0,,所以，他们设计的 C 语言，都使用最简单的表示方式
Dialogue: 0,0:28:52.06,0:28:58.74,English,,0,0,0,,There's no array you know most languages would have array bounds checking
Dialogue: 0,0:28:52.06,0:28:58.74,Chinese,,0,0,0,,例如，大多数语言，数组都有边界检查
Dialogue: 0,0:28:58.86,0:29:07.24,English,,0,0,0,,And array would be a data structure that would include its size you know range of values and stuff and C just doesn't
Dialogue: 0,0:28:58.86,0:29:07.24,Chinese,,0,0,0,,数组是一个数据结构，包括它的大小，值的范围和其他的东西，而 C 没有这些东西
Dialogue: 0,0:29:07.40,0:29:09.68,English,,0,0,0,,So everything about C is suit at the minimum
Dialogue: 0,0:29:07.40,0:29:09.68,Chinese,,0,0,0,,C 语言值提供基本的功能
Dialogue: 0,0:29:10.46,0:29:15.78,English,,0,0,0,,And you know it's been around for a 40 or something year so
Dialogue: 0,0:29:10.46,0:29:15.78,Chinese,,0,0,0,,而且你知道 C 语言已经存在了 40 年左右的时间
Dialogue: 0,0:29:15.78,0:29:20.68,English,,0,0,0,,[student speaking]
Dialogue: 0,0:29:15.78,0:29:20.68,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:29:20.70,0:29:25.78,English,,0,0,0,,No pascal does not proceed C no as simply not true
Dialogue: 0,0:29:20.70,0:29:25.78,Chinese,,0,0,0,,C 语言参考了 Pascal 语言，这不是真的
Dialogue: 0,0:29:26.04,0:29:31.10,English,,0,0,0,,Pascal was created as a language for teaching by Niklaus Wirth
Dialogue: 0,0:29:26.04,0:29:31.10,Chinese,,0,0,0,,Pascal 语言是 Niklaus Wirth 发明的，用于教学用的语言
Dialogue: 0,0:29:31.80,0:29:35.02,English,,0,0,0,,And it was very much an instructional language
Dialogue: 0,0:29:31.80,0:29:35.02,Chinese,,0,0,0,,它是用于教学的一种语言
Dialogue: 0,0:29:35.02,0:29:39.88,English,,0,0,0,,So it was really designed to help students who needed help
Dialogue: 0,0:29:35.02,0:29:39.88,Chinese,,0,0,0,,所以它是帮助学生理解编程
Dialogue: 0,0:29:40.34,0:29:48.72,English,,0,0,0,,And C was designed by professional programmers to let them write their code and not get in their way
Dialogue: 0,0:29:40.34,0:29:48.72,Chinese,,0,0,0,,C 由专业程序员设计，帮助他们编写代码，不是为了帮助学生学习
Dialogue: 0,0:29:48.86,0:29:52.74,English,,0,0,0,,So they're very different theory between the two languages right
Dialogue: 0,0:29:48.86,0:29:52.74,Chinese,,0,0,0,,所以这两种语言之间的理论区别比较大
Dialogue: 0,0:29:54.02,0:30:08.04,English,,0,0,0,,[student speaking]
Dialogue: 0,0:29:54.02,0:30:08.04,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:30:08.04,0:30:11.16,English,,0,0,0,,I'm sorry,oh yes,that's a mistake there
Dialogue: 0,0:30:08.04,0:30:11.16,Chinese,,0,0,0,,对不起，哦，是的，那是一个错误
Dialogue: 0,0:30:12.36,0:30:17.58,English,,0,0,0,,I'll double-check this or people could check it,I'm pretty sure this code is okay though
Dialogue: 0,0:30:12.36,0:30:17.58,Chinese,,0,0,0,,我会仔细检查这个，你们可以检查一下，我很确定这个代码是没问题的
Dialogue: 0,0:30:20.72,0:30:25.02,English,,0,0,0,,If not you can certainly say double *B = A + 3 and that would work right
Dialogue: 0,0:30:20.72,0:30:25.02,Chinese,,0,0,0,,如果有问题，可以改为 double *B = A + 3，这样改了之后没问题了
Dialogue: 0,0:30:26.24,0:30:26.80,English,,0,0,0,,Question
Dialogue: 0,0:30:26.24,0:30:26.80,Chinese,,0,0,0,,你有什么问题吗
Dialogue: 0,0:30:26.80,0:30:35.10,English,,0,0,0,,[student speaking]
Dialogue: 0,0:30:26.80,0:30:35.10,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:30:35.10,0:30:40.52,English,,0,0,0,,You think what...
Dialogue: 0,0:30:35.10,0:30:40.52,Chinese,,0,0,0,,你觉得......
Dialogue: 0,0:30:40.62,0:30:46.56,English,,0,0,0,,-You think this is 28 -Yeah -Well I'm not going to try and execute it here
Dialogue: 0,0:30:40.62,0:30:46.56,Chinese,,0,0,0,, -你认为这里应该 28 -是的 -我不会尝试在这里执行这个程序
Dialogue: 0,0:30:46.56,0:30:49.28,English,,0,0,0,,But let's check it you and I will check this code out
Dialogue: 0,0:30:46.56,0:30:49.28,Chinese,,0,0,0,,但我们会仔细检查这个代码
Dialogue: 0,0:30:49.80,0:30:53.30,English,,0,0,0,,And we'll fix it if it needs to be fixed okay, thanks for pointing it out
Dialogue: 0,0:30:49.80,0:30:53.30,Chinese,,0,0,0,,如果有错误的话我们会修复它，谢谢你指出这个问题
Dialogue: 0,0:30:53.80,0:30:54.40,English,,0,0,0,,Yeah
Dialogue: 0,0:30:53.80,0:30:54.40,Chinese,,0,0,0,,是啊
Dialogue: 0,0:30:54.54,0:31:01.92,English,,0,0,0,,[student speaking]
Dialogue: 0,0:30:54.54,0:31:01.92,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:31:01.98,0:31:04.86,English,,0,0,0,,No that doesn't make any difference at all in this code
Dialogue: 0,0:31:01.98,0:31:04.86,Chinese,,0,0,0,,不，这在代码中完全没有任何区别
Dialogue: 0,0:31:06.10,0:31:09.08,English,,0,0,0,,No know where it's allocated makes no difference at all here
Dialogue: 0,0:31:06.10,0:31:09.08,Chinese,,0,0,0,,在栈上分配内存还是在堆上分配内存在这里完全没有区别
Dialogue: 0,0:31:10.38,0:31:13.76,English,,0,0,0,,So I'll check that might have to be double *B=A+3
Dialogue: 0,0:31:10.38,0:31:13.76,Chinese,,0,0,0,,我会检查一下，这里可能是 double *B=A+3（PPT上应该是写错了，编译通过不了）
Dialogue: 0,0:31:13.76,0:31:18.02,English,,0,0,0,,But I this was a while ago that I wrote this code oh double-check it
Dialogue: 0,0:31:13.76,0:31:18.02,Chinese,,0,0,0,,这是我不久前写的代码，但我会仔细检查它
Dialogue: 0,0:31:19.76,0:31:33.04,English,,0,0,0,,Ok so anyway sets the sort of end of the story for simple simple optima
Dialogue: 0,0:31:19.76,0:31:33.04,Chinese,,0,0,0,,好吧，无论如何，这种简单的优化往往是在最后才做的
Dialogue: 0,0:31:33.08,0:31:36.38,English,,0,0,0,,and they are simple optimizations it's just you have to get in the habit of doing it
Dialogue: 0,0:31:33.08,0:31:36.38,Chinese,,0,0,0,,它们是简单的优化，但你必须养成这样做的习惯
Dialogue: 0,0:31:38.44,0:31:41.80,English,,0,0,0,,Ok now what we're going to do is go a little bit fancier than this
Dialogue: 0,0:31:38.44,0:31:41.80,Chinese,,0,0,0,,好，我们现在来看另一种比这个有趣的优化
Dialogue: 0,0:31:41.96,0:31:45.94,English,,0,0,0,,And as I said this becomes somewhat more system dependent but
Dialogue: 0,0:31:41.96,0:31:45.94,Chinese,,0,0,0,,正如我所说，这种优化更依赖于系统
Dialogue: 0,0:31:46.22,0:31:51.88,English,,0,0,0,,Pretty much nowadays all processors are have similar implementation
Dialogue: 0,0:31:46.22,0:31:51.88,Chinese,,0,0,0,,但是现在几乎所有处理器都实现了这个特性
Dialogue: 0,0:31:51.88,0:31:55.24,English,,0,0,0,,They all do what's known as out of order execution
Dialogue: 0,0:31:51.88,0:31:55.24,Chinese,,0,0,0,,名为的无序执行的特性
Dialogue: 0,0:31:56.68,0:31:59.38,English,,0,0,0,,Except for the most primitive micro controllers
Dialogue: 0,0:31:56.68,0:31:59.38,Chinese,,0,0,0,,除了最原始的微处理器
Dialogue: 0,0:31:59.92,0:32:02.84,English,,0,0,0,,And so this is a the kind of optimization oh sure
Dialogue: 0,0:31:59.92,0:32:02.84,Chinese,,0,0,0,,所以这是一种可以
Dialogue: 0,0:32:03.12,0:32:09.46,English,,0,0,0,,You'll find well this general approach will work across quite a variety machines
Dialogue: 0,0:32:03.12,0:32:09.46,Chinese,,0,0,0,,适用于各种各样的机器的通用优化方法
Dialogue: 0,0:32:11.64,0:32:15.68,English,,0,0,0,,So what I'm going to do is do this by a series of examples
Dialogue: 0,0:32:11.64,0:32:15.68,Chinese,,0,0,0,,我要通过一系列例子来说明这种优化方法
Dialogue: 0,0:32:15.76,0:32:19.70,English,,0,0,0,,Starting from some not very efficient code and making it run faster and faster
Dialogue: 0,0:32:15.76,0:32:19.70,Chinese,,0,0,0,,从一些不是非常高效的代码开始，使其运行得更快更快
Dialogue: 0,0:32:19.70,0:32:24.24,English,,0,0,0,,And we'll get a speed-up of around 40
Dialogue: 0,0:32:19.70,0:32:24.24,Chinese,,0,0,0,,优化之后的速度将达到 40 左右
Dialogue: 0,0:32:25.02,0:32:27.02,English,,0,0,0,,Just in doing what we're doing
Dialogue: 0,0:32:25.02,0:32:27.02,Chinese,,0,0,0,,仅仅只是做这种优化
Dialogue: 0,0:32:28.08,0:32:33.10,English,,0,0,0,,So as I'll start by saying well assume I have a data structure
Dialogue: 0,0:32:28.08,0:32:33.10,Chinese,,0,0,0,,首先我定义一个数据结构
Dialogue: 0,0:32:33.10,0:32:35.48,English,,0,0,0,,That looks like the way pascal implements arrays
Dialogue: 0,0:32:33.10,0:32:35.48,Chinese,,0,0,0,,这看起来像 pascal 语言实现数组的方式
Dialogue: 0,0:32:37.08,0:32:38.86,English,,0,0,0,,Sorry I have nothing against pascal
Dialogue: 0,0:32:37.08,0:32:38.86,Chinese,,0,0,0,,我没有说 Pascal 语言不好
Dialogue: 0,0:32:40.18,0:32:43.46,English,,0,0,0,,We used to teach it back in the old days but um
Dialogue: 0,0:32:40.18,0:32:43.46,Chinese,,0,0,0,,过去我们曾经教过这种语言
Dialogue: 0,0:32:43.72,0:32:47.46,English,,0,0,0,,So a typical way you'd implement an array in a language is
Dialogue: 0,0:32:43.72,0:32:47.46,Chinese,,0,0,0,,因此，在一种语言中实现数组的典型方法是
Dialogue: 0,0:32:47.72,0:32:51.66,English,,0,0,0,,You'd provide both the values that are stored in that array
Dialogue: 0,0:32:47.72,0:32:51.66,Chinese,,0,0,0,,使用一个数据结构不仅保存数组中的值
Dialogue: 0,0:32:51.94,0:32:57.28,English,,0,0,0,,And then there'd be other information associated with it for example what size it is
Dialogue: 0,0:32:51.94,0:32:57.28,Chinese,,0,0,0,,还保存与之相关的其他信息，例如它的大小
Dialogue: 0,0:32:58.02,0:33:02.64,English,,0,0,0,,And so this is sort of the sort of nice abstract way to do it
Dialogue: 0,0:32:58.02,0:33:02.64,Chinese,,0,0,0,,所以这是一种很好的抽象方式
Dialogue: 0,0:33:03.26,0:33:10.26,English,,0,0,0,,And you write code that makes sure that if you ever try to exceed the bounds on the array
Dialogue: 0,0:33:03.26,0:33:10.26,Chinese,,0,0,0,,你编写的代码可以确保，如果你对数组的访问越界了
Dialogue: 0,0:33:10.52,0:33:13.20,English,,0,0,0,,You'd return an error signal
Dialogue: 0,0:33:10.52,0:33:13.20,Chinese,,0,0,0,,会返回一个错误信号
Dialogue: 0,0:33:13.56,0:33:23.54,English,,0,0,0,,And so this particular function you're seeing is what I want to retrieve an element I passed an a pointer
Dialogue: 0,0:33:13.56,0:33:23.54,Chinese,,0,0,0,,你看到的这个函数的功能是，从数组中取出索引值对应的元素，传递一个指针
Dialogue: 0,0:33:23.74,0:33:30.08,English,,0,0,0,,And then that value the pointer gets used to retrieve the value from the array
Dialogue: 0,0:33:23.74,0:33:30.08,Chinese,,0,0,0,,然后该指针被赋值为数组中索引对应的元素
Dialogue: 0,0:33:30.82,0:33:36.20,English,,0,0,0,,And the return value of this function is then to 0 or 1 0 meaning failure in one meaning success
Dialogue: 0,0:33:30.82,0:33:36.20,Chinese,,0,0,0,,此函数的返回值为 0 或 1 0 表示失败，1 表示成功
Dialogue: 0,0:33:36.86,0:33:41.98,English,,0,0,0,,And I'm writing it this way that I use a datatype I'll call data_t
Dialogue: 0,0:33:36.86,0:33:41.98,Chinese,,0,0,0,,我将元素的数据类型定义为 data_t
Dialogue: 0,0:33:42.40,0:33:45.26,English,,0,0,0,,And that way I can run this I can compile this code
Dialogue: 0,0:33:42.40,0:33:45.26,Chinese,,0,0,0,,这样我可以修改 data_t 的定义，然后重新编译
Dialogue: 0,0:33:45.46,0:33:50.48,English,,0,0,0,,Using different definitions of data_t to get int,long,floats and doubles
Dialogue: 0,0:33:45.46,0:33:50.48,Chinese,,0,0,0,,data_t 可以定义为 int，long，float 和 double
Dialogue: 0,0:33:50.98,0:33:57.08,English,,0,0,0,,And we'll see how the performance characteristics of those shift with the different data types
Dialogue: 0,0:33:50.98,0:33:57.08,Chinese,,0,0,0,,我们将看到性能特征如何随着不同的数据类型而变化
Dialogue: 0,0:33:59.38,0:34:03.30,English,,0,0,0,,And the benchmark I'm going to use is a fairly simple one
Dialogue: 0,0:33:59.38,0:34:03.30,Chinese,,0,0,0,,我使用的基准测试非常简单
Dialogue: 0,0:34:03.30,0:34:10.06,English,,0,0,0,,It's just to for a an array or one of these vectors
Dialogue: 0,0:34:03.30,0:34:10.06,Chinese,,0,0,0,,对于这个数组
Dialogue: 0,0:34:10.88,0:34:15.76,English,,0,0,0,,I just want to combine all the elements of it either compute their sum or their product
Dialogue: 0,0:34:10.88,0:34:15.76,Chinese,,0,0,0,,我想计算数组中所有元素的总和或累积
Dialogue: 0,0:34:16.52,0:34:20.14,English,,0,0,0,,And again I'm going to use macros here IDENT and OP
Dialogue: 0,0:34:16.52,0:34:20.14,Chinese,,0,0,0,,同样，我在这里使用了两个宏定义 IDENT 和 OP
Dialogue: 0,0:34:20.76,0:34:26.30,English,,0,0,0,,And define those so that OP is addition and the IDENT value is 0
Dialogue: 0,0:34:20.76,0:34:26.30,Chinese,,0,0,0,,OP 定义为加法，且 IDENT 定义为 0
Dialogue: 0,0:34:26.88,0:34:31.36,English,,0,0,0,,Or the OP is multiplication and the IDENT element is 1
Dialogue: 0,0:34:26.88,0:34:31.36,Chinese,,0,0,0,,或者 OP 定义为乘法，且 IDENT 定义为 1
Dialogue: 0,0:34:31.66,0:34:34.24,English,,0,0,0,,So that I can compare addition in multiplication
Dialogue: 0,0:34:31.66,0:34:34.24,Chinese,,0,0,0,,这样我就可以对两种运算进行对比
Dialogue: 0,0:34:35.10,0:34:37.66,English,,0,0,0,,So that gives us sort of eight possibilities here
Dialogue: 0,0:34:35.10,0:34:37.66,Chinese,,0,0,0,,所以，我们有八种可能
Dialogue: 0,0:34:37.88,0:34:40.24,English,,0,0,0,,Two different operations in four different data types
Dialogue: 0,0:34:37.88,0:34:40.24,Chinese,,0,0,0,,四种不同数据类型和两种不同的运算的组合
Dialogue: 0,0:34:42.06,0:34:45.84,English,,0,0,0,,And so this is written in the sort of most straightforward manner that
Dialogue: 0,0:34:42.06,0:34:45.84,Chinese,,0,0,0,,基准测试是以最直接的方式编写的
Dialogue: 0,0:34:45.84,0:34:52.46,English,,0,0,0,,I'm using this function called get_vac_element to retrieve the successive values of this array
Dialogue: 0,0:34:45.84,0:34:52.46,Chinese,,0,0,0,,我先使用 get_vac_element 的函数来得到数组的第 i 个值
Dialogue: 0,0:34:53.04,0:34:55.96,English,,0,0,0,,And then performing this operation on them
Dialogue: 0,0:34:53.04,0:34:55.96,Chinese,,0,0,0,,然后累加或累积到 dest
Dialogue: 0,0:34:57.48,0:35:01.98,English,,0,0,0,,So now to express a performance of this
Dialogue: 0,0:34:57.48,0:35:01.98,Chinese,,0,0,0,,现在来看一下这个的性能
Dialogue: 0,0:35:02.62,0:35:06.58,English,,0,0,0,,We're going to use a metric I introduced called CPE
Dialogue: 0,0:35:02.62,0:35:06.58,Chinese,,0,0,0,,我们将引入的一个叫 CPE 的指标
Dialogue: 0,0:35:06.82,0:35:10.68,English,,0,0,0,,Which stands for cycles per element
Dialogue: 0,0:35:06.82,0:35:10.68,Chinese,,0,0,0,,它代表处理一个元素所花的时间周期
Dialogue: 0,0:35:11.16,0:35:15.04,English,,0,0,0,,And the idea is that usually when you write code that say steps through a vector
Dialogue: 0,0:35:11.16,0:35:15.04,Chinese,,0,0,0,,之所以用这个指标，是因为通常当你编写代码遍历处理一个数组时
Dialogue: 0,0:35:15.04,0:35:18.40,English,,0,0,0,,Anything that has sort of some linear performance as you get bigger
Dialogue: 0,0:35:15.04,0:35:18.40,Chinese,,0,0,0,,随着数组的增大，处理的时间是线性增长的
Dialogue: 0,0:35:19.02,0:35:28.88,English,,0,0,0,,You don't really want to know for exactly it takes this many seconds or microseconds or nanoseconds to do an operation
Dialogue: 0,0:35:19.02,0:35:28.88,Chinese,,0,0,0,,你并不关心对一个元素的处理需要多少秒或多少微秒或多少纳秒
Dialogue: 0,0:35:29.32,0:35:33.66,English,,0,0,0,,You kind of want to know often more what's its overall performance characteristics
Dialogue: 0,0:35:29.32,0:35:33.66,Chinese,,0,0,0,,你想知道它的整体性能特征是什么
Dialogue: 0,0:35:34.38,0:35:38.90,English,,0,0,0,,And also it turns out when you're doing low-level code optimization
Dialogue: 0,0:35:34.38,0:35:38.90,Chinese,,0,0,0,,进行低级代码优化也是如此
Dialogue: 0,0:35:38.90,0:35:44.94,English,,0,0,0,,It's much more useful to think in terms of clock cycles of the inner clock of the processor
Dialogue: 0,0:35:38.90,0:35:44.94,Chinese,,0,0,0,,使用处理器内部时钟的时钟周期作为时间单位更有用
Dialogue: 0,0:35:45.12,0:35:48.36,English,,0,0,0,,Rather than an absolute term such as nanoseconds
Dialogue: 0,0:35:45.12,0:35:48.36,Chinese,,0,0,0,,而不是像纳秒这样的时间单位
Dialogue: 0,0:35:48.66,0:35:52.88,English,,0,0,0,,Because whether a processor is running at two gigahertz or 2.3 gigahertz
Dialogue: 0,0:35:48.66,0:35:52.88,Chinese,,0,0,0,,因为处理器是以 2G 赫兹运行还是 2.3G 赫兹运行
Dialogue: 0,0:35:53.68,0:35:57.68,English,,0,0,0,,I don't really I have no control over that as a programmer
Dialogue: 0,0:35:53.68,0:35:57.68,Chinese,,0,0,0,,一名程序员是无法控制它的
Dialogue: 0,0:35:57.96,0:36:05.08,English,,0,0,0,,But I can control sort of it the low-level how many clock cycles are being used for different parts of the computation
Dialogue: 0,0:35:57.96,0:36:05.08,Chinese,,0,0,0,,但程序员可以控制程序中不同的计算部分使用了多少个时钟周期
Dialogue: 0,0:36:06.64,0:36:09.62,English,,0,0,0,,So that's why it's called cycles per element
Dialogue: 0,0:36:06.64,0:36:09.62,Chinese,,0,0,0,,所以这就是为什么它被称为每元素的周期数
Dialogue: 0,0:36:09.72,0:36:13.84,English,,0,0,0,,And you can think of it as and this shows some actual measurements
Dialogue: 0,0:36:09.72,0:36:13.84,Chinese,,0,0,0,,这里展示了函数实际测量的 CPE 值
Dialogue: 0,0:36:14.36,0:36:21.48,English,,0,0,0,,But typically a function like this get what I showed the combine will have some overhead
Dialogue: 0,0:36:14.36,0:36:21.48,Chinese,,0,0,0,,但通常像 combine 这样的函数会有一些额外的开销（类似 size 为 0 时的开销）
Dialogue: 0,0:36:21.78,0:36:27.42,English,,0,0,0,,A fixed amount that's associated with setting up the loop doing the top of a call and all that stuff
Dialogue: 0,0:36:21.78,0:36:27.42,Chinese,,0,0,0,,一个固定的开销，因为需要设置循环，调用函数和其他的一些东西
Dialogue: 0,0:36:27.82,0:36:31.20,English,,0,0,0,,And then some component that's linear in the size
Dialogue: 0,0:36:27.82,0:36:31.20,Chinese,,0,0,0,,然后是一个线性分量
Dialogue: 0,0:36:31.68,0:36:35.00,English,,0,0,0,,And so what I want to know is the slope of that linear component
Dialogue: 0,0:36:31.68,0:36:35.00,Chinese,,0,0,0,,我想知道的是线性分量的斜率
Dialogue: 0,0:36:37.66,0:36:41.56,English,,0,0,0,,I'll and that will determine that's what I'll call the cycles per element
Dialogue: 0,0:36:37.66,0:36:41.56,Chinese,,0,0,0,,斜率就是每个元素的周期
Dialogue: 0,0:36:41.56,0:36:48.36,English,,0,0,0,,You can think that the sort of incremental cost of adding one more element to the array
Dialogue: 0,0:36:41.56,0:36:48.36,Chinese,,0,0,0,,你可以认为是向数组添加一个元素的增量
Dialogue: 0,0:36:53.88,0:36:56.64,English,,0,0,0,,So now if I run this function
Dialogue: 0,0:36:53.88,0:36:56.64,Chinese,,0,0,0,,所以现在如果我运行这个函数
Dialogue: 0,0:36:57.12,0:37:01.26,English,,0,0,0,,I showed you and I'm only showing I'll mostly only show four results
Dialogue: 0,0:36:57.12,0:37:01.26,Chinese,,0,0,0,,我这里只展示四种结果
Dialogue: 0,0:37:01.26,0:37:07.44,English,,0,0,0,,Because it turns out whether it's int or long or float or double
Dialogue: 0,0:37:01.26,0:37:07.44,Chinese,,0,0,0,,因为事实上，data_t 是 int 还是 long 还是 float 或 double
Dialogue: 0,0:37:07.92,0:37:12.26,English,,0,0,0,,Is not going to actually have any effect on performance for most of the cases
Dialogue: 0,0:37:07.92,0:37:12.26,Chinese,,0,0,0,,大多数情况下都不会对性能产生影响
Dialogue: 0,0:37:13.04,0:37:15.56,English,,0,0,0,,So if I just run this code through a compiler
Dialogue: 0,0:37:13.04,0:37:15.56,Chinese,,0,0,0,,好，如果我指定优化等级为 0
Dialogue: 0,0:37:15.56,0:37:19.66,English,,0,0,0,,And don't do any optimizations it takes around 20 cycles per element
Dialogue: 0,0:37:15.56,0:37:19.66,Chinese,,0,0,0,,每个元素需要大约 20 个时钟周期
Dialogue: 0,0:37:20.22,0:37:27.92,English,,0,0,0,,And if I turn on optimization level 1 which is sort of the first serious optimization it takes the time in half
Dialogue: 0,0:37:20.22,0:37:27.92,Chinese,,0,0,0,,如果我优化级别设置为 1，它只需要花费不优化时一半的时间
Dialogue: 0,0:37:28.06,0:37:33.30,English,,0,0,0,,So I'm down to 10 clock cycles per element just by changing the compilation
Dialogue: 0,0:37:28.06,0:37:33.30,Chinese,,0,0,0,,因此，只需更改编译器的优化选项，我就可以将每个元素降低到 10 个时钟周期
Dialogue: 0,0:37:33.90,0:37:37.28,English,,0,0,0,,And that's using the most unoptimized code I could think of here
Dialogue: 0,0:37:33.90,0:37:37.28,Chinese,,0,0,0,,这个例子所用的代码是我能想到的，最不优化的代码
Dialogue: 0,0:37:41.20,0:37:44.72,English,,0,0,0,,And then I won't go through it all but using sort of...
Dialogue: 0,0:37:41.20,0:37:44.72,Chinese,,0,0,0,,然后我们可以进行一些优化...
Dialogue: 0,0:37:46.10,0:37:53.08,English,,0,0,0,,The kind of things I described earlier of sort of cut away some of the redundancy in this program
Dialogue: 0,0:37:46.10,0:37:53.08,Chinese,,0,0,0,,我们可以像前面描述的那样，减少这个程序中的一些冗余
Dialogue: 0,0:37:53.42,0:37:55.98,English,,0,0,0,,You can get it down to something a little bit simpler
Dialogue: 0,0:37:53.42,0:37:55.98,Chinese,,0,0,0,,把程序变的更简单一点
Dialogue: 0,0:37:56.10,0:37:59.58,English,,0,0,0,,And so one thing instead of you saw before I was making a call to this
Dialogue: 0,0:37:56.10,0:37:59.58,Chinese,,0,0,0,,前面看到，每次调用 get_vec_element 函数
Dialogue: 0,0:38:00.12,0:38:04.10,English,,0,0,0,,get_vec_element and every time it did that it went bounds checking
Dialogue: 0,0:38:00.12,0:38:04.10,Chinese,,0,0,0,,该函数都会检查数组索引是否越界
Dialogue: 0,0:38:04.44,0:38:08.50,English,,0,0,0,,And it's kind of silly to keep bounds checking the same array over and over again
Dialogue: 0,0:38:04.44,0:38:08.50,Chinese,,0,0,0,,一遍又一遍地检查同一个数组是否越界是很愚蠢的
Dialogue: 0,0:38:08.72,0:38:15.58,English,,0,0,0,,When I'm stepping I'm using its length as the determinate of how many elements to access
Dialogue: 0,0:38:08.72,0:38:15.58,Chinese,,0,0,0,,所以当我遍历时，我先得到它的长度来确定要访问的元素数量
Dialogue: 0,0:38:16.14,0:38:18.68,English,,0,0,0,,So if I'm willing to suit a forgo bounds checking
Dialogue: 0,0:38:16.14,0:38:18.68,Chinese,,0,0,0,,放弃 get_vec_element 函数的边界检查
Dialogue: 0,0:38:19.04,0:38:26.14,English,,0,0,0,,What I can do is introduce a function that will just give me the actual data storage part of this vector
Dialogue: 0,0:38:19.04,0:38:26.14,Chinese,,0,0,0,,我可以引入一个函数，它返回数组的长度
Dialogue: 0,0:38:26.50,0:38:28.30,English,,0,0,0,,And skip over all the other stuff
Dialogue: 0,0:38:26.50,0:38:28.30,Chinese,,0,0,0,,数组长度之外的东西就直接忽略
Dialogue: 0,0:38:29.26,0:38:35.82,English,,0,0,0,,And so I can write a loop that and I introduce you know local variables and all the kind of things we described
Dialogue: 0,0:38:29.26,0:38:35.82,Chinese,,0,0,0,,所以我可以重新编写一个循环，引入局部变量
Dialogue: 0,0:38:37.28,0:38:41.82,English,,0,0,0,,And accumulating temporaries and things like that
Dialogue: 0,0:38:37.28,0:38:41.82,Chinese,,0,0,0,,先把数据累加到临时变量，然后再赋值给 dest
Dialogue: 0,0:38:42.64,0:38:45.62,English,,0,0,0,,Then the program actually gets a lot faster
Dialogue: 0,0:38:42.64,0:38:45.62,Chinese,,0,0,0,,然后程序实际上变得更快了
Dialogue: 0,0:38:46.38,0:38:49.90,English,,0,0,0,,Again with this is everything from here out is optimization level 1
Dialogue: 0,0:38:46.38,0:38:49.90,Chinese,,0,0,0,,重申一下，这里使用的是优化级别 1
Dialogue: 0,0:38:50.54,0:38:56.94,English,,0,0,0,,And so it drops it down to a little over a clock cycle for integers addition of
Dialogue: 0,0:38:50.54,0:38:56.94,Chinese,,0,0,0,,它把整数的加法降低到 1 个多时间周期
Dialogue: 0,0:38:57.44,0:39:01.70,English,,0,0,0,,Or three clock cycles up to five clock cycles for double precision multiplier
Dialogue: 0,0:38:57.44,0:39:01.70,Chinese,,0,0,0,,整数乘法降低到了 3 个时钟周期，双精度乘法降低到了 5 个时钟周期
Dialogue: 0,0:39:02.14,0:39:06.14,English,,0,0,0,,So that's pretty good I've sort of definitely improved things
Dialogue: 0,0:39:02.14,0:39:06.14,Chinese,,0,0,0,,所以这很好，肯定有所改进
Dialogue: 0,0:39:06.52,0:39:09.70,English,,0,0,0,,But the question is well is that the best there is
Dialogue: 0,0:39:06.52,0:39:09.70,Chinese,,0,0,0,,但问题是，最好的
Dialogue: 0,0:39:09.88,0:39:15.84,English,,0,0,0,,And first and well so try to understand what is it about these numbers three five
Dialogue: 0,0:39:09.88,0:39:15.84,Chinese,,0,0,0,,先解释一下这三个数字怎么来的，3，5
Dialogue: 0,0:39:16.38,0:39:19.02,English,,0,0,0,,And this seems to be something close to one point two five
Dialogue: 0,0:39:16.38,0:39:19.02,Chinese,,0,0,0,,和 1.27
Dialogue: 0,0:39:19.02,0:39:25.58,English,,0,0,0,,So where those numbers coming from and does that indicate some fundamental limitation in my program
Dialogue: 0,0:39:19.02,0:39:25.58,Chinese,,0,0,0,,这些数字的来源暗示我的程序存在一些基本限制
Dialogue: 0,0:39:27.92,0:39:32.74,English,,0,0,0,,Well in order to do that you have to have some understanding of the underlying hardware
Dialogue: 0,0:39:27.92,0:39:32.74,Chinese,,0,0,0,,要理解这些数字的来源，你必须对底层硬件有一些了解
Dialogue: 0,0:39:32.82,0:39:38.62,English,,0,0,0,,And there's a really good course you can take I think it's called ECE 741
Dialogue: 0,0:39:32.82,0:39:38.62,Chinese,,0,0,0,,你可以选修一个非常好的课程，ECE 741
Dialogue: 0,0:39:39.82,0:39:44.02,English,,0,0,0,,That will tell you everything you ever could imagine wanting to know about processor design
Dialogue: 0,0:39:39.82,0:39:44.02,Chinese,,0,0,0,,它会教你，你能想象的，有关处理器设计的一切知识
Dialogue: 0,0:39:44.86,0:39:47.50,English,,0,0,0,,And you actually design processors like this
Dialogue: 0,0:39:44.86,0:39:47.50,Chinese,,0,0,0,,你会自己动手设计了这样的处理器
Dialogue: 0,0:39:47.98,0:39:50.36,English,,0,0,0,,But I'm assuming you're not going to do that for a while
Dialogue: 0,0:39:47.98,0:39:50.36,Chinese,,0,0,0,,但我想你暂时不打算那样做
Dialogue: 0,0:39:50.36,0:39:53.28,English,,0,0,0,,Because you have up seven prerequisites to do before that happens
Dialogue: 0,0:39:50.36,0:39:53.28,Chinese,,0,0,0,,因为这门课程有 7 门先修课程
Dialogue: 0,0:39:55.82,0:39:59.28,English,,0,0,0,,So let me just give you the simple version
Dialogue: 0,0:39:55.82,0:39:59.28,Chinese,,0,0,0,,那么，让我给你一个简单版本的处理器
Dialogue: 0,0:39:59.80,0:40:05.52,English,,0,0,0,,And this is sort of a an idea of what a processor has looked like since about 1995
Dialogue: 0,0:39:59.80,0:40:05.52,Chinese,,0,0,0,,这个处理器有点像 1995 年左右的处理器
Dialogue: 0,0:40:05.86,0:40:12.34,English,,0,0,0,,So this is old stuff but it's enough actually to really understand it
Dialogue: 0,0:40:05.86,0:40:12.34,Chinese,,0,0,0,,所以这是旧的东西，但真正理解它
Dialogue: 0,0:40:12.34,0:40:16.82,English,,0,0,0,,It's so hard it's really the details are pretty massive
Dialogue: 0,0:40:12.34,0:40:16.82,Chinese,,0,0,0,,非常困难，有很多细节
Dialogue: 0,0:40:17.26,0:40:23.70,English,,0,0,0,,And so it's not even taught for example 447 is the ECE is the computer architecture course
Dialogue: 0,0:40:17.26,0:40:23.70,Chinese,,0,0,0,,因此，即使是 ECE 447 这样的计算机架构课程也没有讲述这方面的内容
Dialogue: 0,0:40:23.70,0:40:26.60,English,,0,0,0,,And they don't really go into this kind of design here
Dialogue: 0,0:40:23.70,0:40:26.60,Chinese,,0,0,0,,他们并没有真正进入这种设计
Dialogue: 0,0:40:26.92,0:40:29.32,English,,0,0,0,,Because they're pretty hard,they're actually hard to design on your own
Dialogue: 0,0:40:26.92,0:40:29.32,Chinese,,0,0,0,,因为它们很难，要自己设计非常困难
Dialogue: 0,0:40:30.14,0:40:34.24,English,,0,0,0,,But the the basic idea is you think about a program as
Dialogue: 0,0:40:30.14,0:40:34.24,Chinese,,0,0,0,,但基本的想法是，一个程序
Dialogue: 0,0:40:34.78,0:40:39.94,English,,0,0,0,,As the computer just reads in an instruction does whatever it says to do
Dialogue: 0,0:40:34.78,0:40:39.94,Chinese,,0,0,0,,计算机会读入一条指令，然后执行这条指令
Dialogue: 0,0:40:40.64,0:40:43.52,English,,0,0,0,,Reads in another instruction does what that says to do
Dialogue: 0,0:40:40.64,0:40:43.52,Chinese,,0,0,0,,读取另一条指令，然后执行那条指令
Dialogue: 0,0:40:44.14,0:40:46.98,English,,0,0,0,,And that has nothing to do with how programs actually execute
Dialogue: 0,0:40:44.14,0:40:46.98,Chinese,,0,0,0,,这实际上和正在执行的程序无关（程序可以分解为基础指令）
Dialogue: 0,0:40:47.30,0:40:51.02,English,,0,0,0,,What they've built up is this massive hardware infrastructure
Dialogue: 0,0:40:47.30,0:40:51.02,Chinese,,0,0,0,,CPU 提供了这个庞大的硬件基础设施
Dialogue: 0,0:40:51.46,0:40:54.20,English,,0,0,0,,To make a program run way faster than
Dialogue: 0,0:40:51.46,0:40:54.20,Chinese,,0,0,0,,使程序运行速度比
Dialogue: 0,0:40:54.90,0:40:57.74,English,,0,0,0,,It would if it were just doing one instruction at a time
Dialogue: 0,0:40:54.90,0:40:57.74,Chinese,,0,0,0,,一次只执行一条指令快
Dialogue: 0,0:40:58.26,0:41:03.12,English,,0,0,0,,And it employs a technique that's called superscalar out of order execution
Dialogue: 0,0:40:58.26,0:41:03.12,Chinese,,0,0,0,,它采用了一种称为超标量乱序执行的技术
Dialogue: 0,0:41:03.76,0:41:06.18,English,,0,0,0,,And the idea is roughly speaking it
Dialogue: 0,0:41:03.76,0:41:06.18,Chinese,,0,0,0,,这个想法粗略地讲
Dialogue: 0,0:41:06.40,0:41:10.84,English,,0,0,0,,It takes your program If you think of your program as a linear sequence of instructions
Dialogue: 0,0:41:06.40,0:41:10.84,Chinese,,0,0,0,,你可以认为你的程序是一个顺序执行的指令序列
Dialogue: 0,0:41:11.40,0:41:14.12,English,,0,0,0,,And it just sucks in as many of those as it can
Dialogue: 0,0:41:11.40,0:41:14.12,Chinese,,0,0,0,,CPU 尽可能的读取多的指令序列
Dialogue: 0,0:41:14.68,0:41:18.48,English,,0,0,0,,And it pulls it apart to realize that certain operations
Dialogue: 0,0:41:14.68,0:41:18.48,Chinese,,0,0,0,,然后 CPU 把读入的指令拆开，发现有的指令之间
Dialogue: 0,0:41:18.96,0:41:23.76,English,,0,0,0,,Don't really depend on each other so I can start one even though it's later in the program
Dialogue: 0,0:41:18.96,0:41:23.76,Chinese,,0,0,0,,不是相互依赖的，所以我可以开始执行程序后面的代码
Dialogue: 0,0:41:24.18,0:41:27.51,English,,0,0,0,,Than the one I'm working on right now because they're independent of each other
Dialogue: 0,0:41:24.18,0:41:27.51,Chinese,,0,0,0,,而不是当前的代码，因为它们彼此独立
Dialogue: 0,0:41:27.82,0:41:32.34,English,,0,0,0,,And it's extracting what they call instruction level parallelism place is where
Dialogue: 0,0:41:27.82,0:41:32.34,Chinese,,0,0,0,,这被称为指令级并行性，也就是
Dialogue: 0,0:41:32.94,0:41:36.24,English,,0,0,0,,Even though your program is a linear sequence of instruction
Dialogue: 0,0:41:32.94,0:41:36.24,Chinese,,0,0,0,,即使你的程序是一个顺序的指令序列
Dialogue: 0,0:41:37.12,0:41:43.42,English,,0,0,0,,Buried in there is actually a sort of forest of different computations that need to be done
Dialogue: 0,0:41:37.12,0:41:43.42,Chinese,,0,0,0,,但实际上，这些代码可以拆分成不同的部分
Dialogue: 0,0:41:43.78,0:41:46.18,English,,0,0,0,,Some which depend on each other and some which don't
Dialogue: 0,0:41:43.78,0:41:46.18,Chinese,,0,0,0,,某些部分相互依赖，某些部分不相依
Dialogue: 0,0:41:47.24,0:41:49.44,English,,0,0,0,,And then it has a bunch of hardware
Dialogue: 0,0:41:47.24,0:41:49.44,Chinese,,0,0,0,,CPU 有一堆硬件
Dialogue: 0,0:41:50.34,0:41:57.70,English,,0,0,0,,And so that's up here this upper part shows this idea of fetching instructions
Dialogue: 0,0:41:50.34,0:41:57.70,Chinese,,0,0,0,,PP T上图的上半部分显示了获取指令的方法
Dialogue: 0,0:41:57.70,0:42:02.88,English,,0,0,0,,So there's a cache memory a high performance high speed local memory
Dialogue: 0,0:41:57.70,0:42:02.88,Chinese,,0,0,0,,这里有高性能高速本地缓存
Dialogue: 0,0:42:03.42,0:42:07.05,English,,0,0,0,,That is just pulling in your instructions as fast as it can
Dialogue: 0,0:42:03.42,0:42:07.05,Chinese,,0,0,0,,这个缓存只是尽可能快地提取你的指示
Dialogue: 0,0:42:07.72,0:42:14.00,English,,0,0,0,,And those instructions are then feeding a big pile of hardware that will extract out of it
Dialogue: 0,0:42:07.72,0:42:14.00,Chinese,,0,0,0,,然后缓存把指令送入指令译码这个硬件中
Dialogue: 0,0:42:14.36,0:42:19.00,English,,0,0,0,,These low-level operations and figure out which ones depend on which others
Dialogue: 0,0:42:14.36,0:42:19.00,Chinese,,0,0,0,,这个硬件把指令拆分为低级操作，并确定这些操作之间的依赖关系
Dialogue: 0,0:42:21.20,0:42:26.78,English,,0,0,0,,And then the there is a set of functional units in this part of it
Dialogue: 0,0:42:21.20,0:42:26.78,Chinese,,0,0,0,,CPU 还有一组功能单元
Dialogue: 0,0:42:26.78,0:42:33.90,English,,0,0,0,,That are able to perform these low-level operations to do arithmetic floating-point operations
Dialogue: 0,0:42:26.78,0:42:33.90,Chinese,,0,0,0,,能够执行这些低级操作，如算术浮点运算
Dialogue: 0,0:42:34.28,0:42:39.24,English,,0,0,0,,To read data from memory to store data back to memory
Dialogue: 0,0:42:34.28,0:42:39.24,Chinese,,0,0,0,,从内存中读取数据，写入数据到内存
Dialogue: 0,0:42:39.40,0:42:43.34,English,,0,0,0,,All using a cache which is something you're going to learn about fairly soon
Dialogue: 0,0:42:39.40,0:42:43.34,Chinese,,0,0,0,,所有的这些操作都使用缓存，你们很快就会学缓存
Dialogue: 0,0:42:43.68,0:42:50.08,English,,0,0,0,,How what all this cache is but think of this as a high speed copy of some of the data memory
Dialogue: 0,0:42:43.68,0:42:50.08,Chinese,,0,0,0,,缓存可以视为某些内存数据的高速副本
Dialogue: 0,0:42:51.44,0:43:02.48,English,,0,0,0,,And so what this logic tries to do is keep a forking out ,spawning off operations based on your program
Dialogue: 0,0:42:51.44,0:43:02.48,Chinese,,0,0,0,,总的来做，基本的思想是把你程序的操作进行拆分，重组
Dialogue: 0,0:43:02.76,0:43:05.58,English,,0,0,0,,And keeping these as busy as they can be
Dialogue: 0,0:43:02.76,0:43:05.58,Chinese,,0,0,0,,使这些基本单元尽可能保持繁忙
Dialogue: 0,0:43:05.90,0:43:11.40,English,,0,0,0,,Doing different fragments of your code, doing different instructions in a different order from before
Dialogue: 0,0:43:05.90,0:43:11.40,Chinese,,0,0,0,,执行代码的不同片段，与以前不同的顺序执行不同的指令
Dialogue: 0,0:43:12.02,0:43:20.96,English,,0,0,0,,And it turns out you think of a register as a little the set of registers is a part of memory that  get read and written
Dialogue: 0,0:43:12.02,0:43:20.96,Chinese,,0,0,0,,一组寄存器可以看做是可读可写的一段内存
Dialogue: 0,0:43:21.34,0:43:25.98,English,,0,0,0,,It turns out that in executing a register now just becomes the name
Dialogue: 0,0:43:21.34,0:43:25.98,Chinese,,0,0,0,,一个寄存器相当于一个内存符号（寄存器重命名，P360）
Dialogue: 0,0:43:26.32,0:43:30.82,English,,0,0,0,,Of something that one instruction produces and some other instructions consume
Dialogue: 0,0:43:26.32,0:43:30.82,Chinese,,0,0,0,,一条指令往写个内存写，其他一些指令读取这个内存
Dialogue: 0,0:43:30.82,0:43:34.18,English,,0,0,0,,It's a destination for some, it's a source for other
Dialogue: 0,0:43:30.82,0:43:34.18,Chinese,,0,0,0,,寄存器是一条指令产生数据的目的地，也可以是一些其他指令的数据来源
Dialogue: 0,0:43:34.72,0:43:39.84,English,,0,0,0,,And this whole a bunch of stuff here just sort of magically passes
Dialogue: 0,0:43:34.72,0:43:39.84,Chinese,,0,0,0,,有很多数据通过寄存器进行传递
Dialogue: 0,0:43:40.40,0:43:45.38,English,,0,0,0,,The results of one computation to the input to another computation
Dialogue: 0,0:43:40.40,0:43:45.38,Chinese,,0,0,0,,可能是一次计算结果，作为另一次计算的输入
Dialogue: 0,0:43:45.70,0:43:50.92,English,,0,0,0,,Based on register names without ever storing them in an explicit register file
Dialogue: 0,0:43:45.70,0:43:50.92,Chinese,,0,0,0,,基于寄存器名称而不是将它们显式存储在寄存器文件中
Dialogue: 0,0:43:51.26,0:43:55.90,English,,0,0,0,,There is a register file when things kind of settle down they get stored away
Dialogue: 0,0:43:51.26,0:43:55.90,Chinese,,0,0,0,,有一个寄存器文件，当计算的结果出来了，它们将被存储在这里
Dialogue: 0,0:43:56.68,0:43:59.14,English,,0,0,0,,Anyways there's a lot of stuff going on here
Dialogue: 0,0:43:56.68,0:43:59.14,Chinese,,0,0,0,,无论如何，这里有很多东西
Dialogue: 0,0:43:59.58,0:44:07.74,English,,0,0,0,,But the main thing to think about is your machine has resources to do multiple operations all at the same time
Dialogue: 0,0:43:59.58,0:44:07.74,Chinese,,0,0,0,,但主要考虑的事情是，你的机器有足够的资源，可以同时进行多项操作
Dialogue: 0,0:44:07.74,0:44:13.74,English,,0,0,0,,If you can somehow structure your program so that those can all get used
Dialogue: 0,0:44:07.74,0:44:13.74,Chinese,,0,0,0,,但这需要你能以某种方式构建你的程序，才能同时使用这些资源
Dialogue: 0,0:44:16.04,0:44:20.42,English,,0,0,0,,So this is as I mentioned it's called a superscalar instruct  processor
Dialogue: 0,0:44:16.04,0:44:20.42,Chinese,,0,0,0,,可以同时进行多项操作的 CPU 被称为超标量指令处理器
Dialogue: 0,0:44:20.42,0:44:23.84,English,,0,0,0,,Is one that can do more than one instruction every clock cycle
Dialogue: 0,0:44:20.42,0:44:23.84,Chinese,,0,0,0,,这种 CPU 可以在一个时钟周期执行多条指令
Dialogue: 0,0:44:25.38,0:44:32.96,English,,0,0,0,,And actually intel started in 1993 the very first Pentium could do two instructions at once
Dialogue: 0,0:44:25.38,0:44:32.96,Chinese,,0,0,0,,实际上，1993 年，Intel 的 Pentium 处理器就可以同时执行两条指令
Dialogue: 0,0:44:33.50,0:44:36.86,English,,0,0,0,,But then a little later they came out with one called the Pentium Pro
Dialogue: 0,0:44:33.50,0:44:36.86,Chinese,,0,0,0,,紧接着他们推出了一款名为 Pentium Pro 的产品
Dialogue: 0,0:44:37.04,0:44:40.08,English,,0,0,0,,Which is sort of the basis of all modern processors
Dialogue: 0,0:44:37.04,0:44:40.08,Chinese,,0,0,0,,它是所有现代处理器的基础
Dialogue: 0,0:44:40.52,0:44:43.22,English,,0,0,0,,And the lead architect by the way was a CMU graduate
Dialogue: 0,0:44:40.52,0:44:43.22,Chinese,,0,0,0,,顺便说一下，Intel 的首席架构师是 CMU 毕业生
Dialogue: 0,0:44:45.14,0:44:50.38,English,,0,0,0,,But this out of order execution is the model that's used nowadays
Dialogue: 0,0:44:45.14,0:44:50.38,Chinese,,0,0,0,,乱序执行是现在处理器的模型
Dialogue: 0,0:44:51.86,0:44:58.53,English,,0,0,0,,So the other thing is those functional units are more complex than you think they might be
Dialogue: 0,0:44:51.86,0:44:58.53,Chinese,,0,0,0,,乱序执行比较复杂，但功能单元可能比你想的更加复杂
Dialogue: 0,0:44:58.90,0:45:00.92,English,,0,0,0,,And that they have what's called pipelining
Dialogue: 0,0:44:58.90,0:45:00.92,Chinese,,0,0,0,,功能单元使用了流水线技术
Dialogue: 0,0:45:01.46,0:45:07.38,English,,0,0,0,,And the ideas of pipelining is imagine you can break up a computation into a series of distinct stages
Dialogue: 0,0:45:01.46,0:45:07.38,Chinese,,0,0,0,,流水线的基本思想是将计算分解为一系列不同的阶段
Dialogue: 0,0:45:09.24,0:45:13.50,English,,0,0,0,,A simple example is if you want to compute a*b+c
Dialogue: 0,0:45:09.24,0:45:13.50,Chinese,,0,0,0,,一个简单的例子是你想要计算 a*b+c 的值
Dialogue: 0,0:45:13.88,0:45:16.16,English,,0,0,0,,You first do the times then you do the plus
Dialogue: 0,0:45:13.88,0:45:16.16,Chinese,,0,0,0,,你先做乘法，然后做加法
Dialogue: 0,0:45:17.06,0:45:21.22,English,,0,0,0,,But it actually gets more deep than that you can take something like multiplication
Dialogue: 0,0:45:17.06,0:45:21.22,Chinese,,0,0,0,,但乘法器做乘法比人算乘法更加复杂
Dialogue: 0,0:45:22.24,0:45:26.16,English,,0,0,0,,And break it up into smaller steps
Dialogue: 0,0:45:22.24,0:45:26.16,Chinese,,0,0,0,,乘法器先将乘法分解为可以一个接一个地完成的
Dialogue: 0,0:45:26.76,0:45:28.88,English,,0,0,0,,That can be done one after the other
Dialogue: 0,0:45:26.76,0:45:28.88,Chinese,,0,0,0,,更小的步骤
Dialogue: 0,0:45:29.50,0:45:34.16,English,,0,0,0,,In a way that and then if you have a separate dedicated hardware for each of those stages
Dialogue: 0,0:45:29.50,0:45:34.16,Chinese,,0,0,0,,你可以认为每个阶段都有一个单独的专用硬件
Dialogue: 0,0:45:34.62,0:45:37.22,English,,0,0,0,,Then you can do what's called pipelining which is
Dialogue: 0,0:45:34.62,0:45:37.22,Chinese,,0,0,0,,然后你可以做流水线操作
Dialogue: 0,0:45:37.86,0:45:40.94,English,,0,0,0,,When one operation moves from one stage to the next
Dialogue: 0,0:45:37.86,0:45:40.94,Chinese,,0,0,0,,也就是，当一个操作从一个阶段移动到下一个阶段时
Dialogue: 0,0:45:41.40,0:45:45.22,English,,0,0,0,,A new operation can come in behind and start start its thing
Dialogue: 0,0:45:41.40,0:45:45.22,Chinese,,0,0,0,,前一个阶段空出来了，你可以填入新的数据
Dialogue: 0,0:45:45.82,0:45:51.98,English,,0,0,0,,So this example shows imagine I had a three stage pipeline multiplier
Dialogue: 0,0:45:45.82,0:45:51.98,Chinese,,0,0,0,,请看 PPT 上的例子，我的乘法器分为 3 个阶段
Dialogue: 0,0:45:52.56,0:45:59.56,English,,0,0,0,,And I want to do this computation a*b, a*c and now multiply those together
Dialogue: 0,0:45:52.56,0:45:59.56,Chinese,,0,0,0,,我计算 a*b，a*c 然后把两个积相乘
Dialogue: 0,0:46:00.56,0:46:06.16,English,,0,0,0,,So the thing to observe is that a*b and a*c don't depend on each other in any way
Dialogue: 0,0:46:00.56,0:46:06.16,Chinese,,0,0,0,,要注意的是 a*b 和 a*c 不以任何方式相互依赖
Dialogue: 0,0:46:07.06,0:46:12.10,English,,0,0,0,,So I can do them both and I don't have hardware to do them simultaneously
Dialogue: 0,0:46:07.06,0:46:12.10,Chinese,,0,0,0,,所以我可以同时计算它们两个的积，但我没有两个乘法器
Dialogue: 0,0:46:12.10,0:46:15.52,English,,0,0,0,,But I have them enough to do one right after the other
Dialogue: 0,0:46:12.10,0:46:15.52,Chinese,,0,0,0,,但我可以一个接一个地做一个
Dialogue: 0,0:46:16.20,0:46:23.70,English,,0,0,0,,So I can feed the first computation into the first stage a*b on step time step one
Dialogue: 0,0:46:16.20,0:46:23.70,Chinese,,0,0,0,,所以，Time 1（PPT 上的表）我可以先计算 a*b 的第一阶段
Dialogue: 0,0:46:24.24,0:46:27.06,English,,0,0,0,,And then time step two it will move on to stage two
Dialogue: 0,0:46:24.24,0:46:27.06,Chinese,,0,0,0,,当 Time 2 时，它将继续进入第二阶段
Dialogue: 0,0:46:27.06,0:46:32.18,English,,0,0,0,,And times step three it will move on to stage three
Dialogue: 0,0:46:27.06,0:46:32.18,Chinese,,0,0,0,,到了 Time 3，它将进入第三阶段
Dialogue: 0,0:46:32.82,0:46:37.28,English,,0,0,0,,But now I can start a*c in the time step two
Dialogue: 0,0:46:32.82,0:46:37.28,Chinese,,0,0,0,,但 Time 2 时，我可以同时计算 a*c 的第一阶段
Dialogue: 0,0:46:38.10,0:46:40.68,English,,0,0,0,,Because this stage became available
Dialogue: 0,0:46:38.10,0:46:40.68,Chinese,,0,0,0,,因为这个阶段是空闲的
Dialogue: 0,0:46:40.98,0:46:45.10,English,,0,0,0,,Once a*b moved from stage 1 to stage 2
Dialogue: 0,0:46:40.98,0:46:45.10,Chinese,,0,0,0,,当 a*b 从第 1 阶段移至第 2 阶段时
Dialogue: 0,0:46:45.46,0:46:51.32,English,,0,0,0,,And so I can follow right behind just one clock cycle behind this other operation
Dialogue: 0,0:46:45.46,0:46:51.32,Chinese,,0,0,0,,所以在其他操作后面的一个时钟周期，我都可以开始新的操作
Dialogue: 0,0:46:52.86,0:46:58.00,English,,0,0,0,,Now p1*p2 obviously depends on both of these products
Dialogue: 0,0:46:52.86,0:46:58.00,Chinese,,0,0,0,,现在 p1*p2 显然取决于 a*b 和 a*c 的乘积
Dialogue: 0,0:46:58.78,0:47:03.22,English,,0,0,0,,So it can't start until a*c is completed
Dialogue: 0,0:46:58.78,0:47:03.22,Chinese,,0,0,0,,因此，在 a*c 完成之前 p1*p2 无法启动
Dialogue: 0,0:47:03.68,0:47:07.32,English,,0,0,0,,And then it will run through the pipeline without anything else
Dialogue: 0,0:47:03.68,0:47:07.32,Chinese,,0,0,0,,然后我们计算 p1*p2，后面没有其他的操作，所以流水线后面是空的
Dialogue: 0,0:47:07.86,0:47:15.44,English,,0,0,0,,So overall then we've done what would have normally seemed to be nine steps worth of arithmetic
Dialogue: 0,0:47:07.86,0:47:15.44,Chinese,,0,0,0,,总的来说，我们已经完成了看起来需要 9 个步骤的乘法（3 个乘法 *3 个时钟周期）
Dialogue: 0,0:47:16.44,0:47:20.66,English,,0,0,0,,In a total of seven steps here because of pipelining
Dialogue: 0,0:47:16.44,0:47:20.66,Chinese,,0,0,0,,但由于流水线操作，这里总共有七个步骤
Dialogue: 0,0:47:20.78,0:47:27.54,English,,0,0,0,,Question
Dialogue: 0,0:47:20.78,0:47:27.54,Chinese,,0,0,0,,这位同学有问题吗
Dialogue: 0,0:47:27.56,0:47:31.84,English,,0,0,0,,What's...if you had like in this a a picture here
Dialogue: 0,0:47:27.56,0:47:31.84,Chinese,,0,0,0,,什么...PPT 的这个表
Dialogue: 0,0:47:32.58,0:47:36.50,English,,0,0,0,,If there were different multipliers in these different places yes you could do
Dialogue: 0,0:47:32.58,0:47:36.50,Chinese,,0,0,0,,如果在这些不同的地方有不同的乘数，你可以同时执行
Dialogue: 0,0:47:37.50,0:47:39.86,English,,0,0,0,,Those two completely independent of each other
Dialogue: 0,0:47:37.50,0:47:39.86,Chinese,,0,0,0,,每个阶段是完全相互独立
Dialogue: 0,0:47:39.92,0:47:48.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:47:39.92,0:47:48.78,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:47:48.80,0:47:53.50,English,,0,0,0,,Yes this is all in a single core of a single processor ,multi-core is yet another
Dialogue: 0,0:47:48.80,0:47:53.50,Chinese,,0,0,0,,是的，这一切都在单个处理器的单核中，
Dialogue: 0,0:47:53.90,0:47:57.12,English,,0,0,0,,This is a lower level parallelism than you get through multi-core
Dialogue: 0,0:47:53.90,0:47:57.12,Chinese,,0,0,0,,单核的这种并行性是一种比多核低的并行性
Dialogue: 0,0:47:57.82,0:48:04.52,English,,0,0,0,,And it's present except in the sort of lowest n lowest powered embedded processors some version of this exists
Dialogue: 0,0:47:57.82,0:48:04.52,Chinese,,0,0,0,,除了在低功率的嵌入式处理器中，其他的处理器都提供了这种并行性
Dialogue: 0,0:48:05.30,0:48:09.30,English,,0,0,0,,And most of the time your hardware is not being fully utilized it's one thing you're going to learn from this
Dialogue: 0,0:48:05.30,0:48:09.30,Chinese,,0,0,0,,并且大多数时候你的硬件没有得到充分利用
Dialogue: 0,0:48:12.50,0:48:16.64,English,,0,0,0,,So that's the idea of pipelining it,it's a sort of like parallelism
Dialogue: 0,0:48:12.50,0:48:16.64,Chinese,,0,0,0,,这就是流水线操作的基本思想，它有点像并行性
Dialogue: 0,0:48:16.64,0:48:20.96,English,,0,0,0,,But it's not that you have multiple copies of resources it's that you have
Dialogue: 0,0:48:16.64,0:48:20.96,Chinese,,0,0,0,,但这种并行性不是说你拥有多份资源（如多个乘法器）
Dialogue: 0,0:48:21.30,0:48:29.62,English,,0,0,0,,This ability to stream operations through a single hardware resource  in close succession to each other
Dialogue: 0,0:48:21.30,0:48:29.62,Chinese,,0,0,0,,而是把在单个硬件上的操作，划分为紧密联系的顺序的多个步骤
Dialogue: 0,0:48:33.28,0:48:39.34,English,,0,0,0,,And so as well which is a little bit more recent than the shark machines
Dialogue: 0,0:48:33.28,0:48:39.34,Chinese,,0,0,0,,嗯，下面将 Haswell CPU，它比 shark 机器（他们上机实验用的机器）要新一点
Dialogue: 0,0:48:39.34,0:48:41.98,English,,0,0,0,,But not that much more
Dialogue: 0,0:48:39.34,0:48:41.98,Chinese,,0,0,0,,但也查不了太多
Dialogue: 0,0:48:42.38,0:48:47.12,English,,0,0,0,,One of the...most recent versions of the intel x86 series
Dialogue: 0,0:48:42.38,0:48:47.12,Chinese,,0,0,0,,它是英特尔 x86 系列的最新版本之一
Dialogue: 0,0:48:48.60,0:48:55.50,English,,0,0,0,,And the functional units include there's a lot of functional units that can do different things
Dialogue: 0,0:48:48.60,0:48:55.50,Chinese,,0,0,0,,Haswell CPU 有许多不同功能的功能单元
Dialogue: 0,0:48:55.52,0:49:02.10,English,,0,0,0,,But when you add it all up there's a possibility of it doing  two loads and one store
Dialogue: 0,0:48:55.52,0:49:02.10,Chinese,,0,0,0,,这些功能单元组合起来，可以同时执行 2 次读内存，1 次写内存
Dialogue: 0,0:49:02.54,0:49:07.74,English,,0,0,0,,Four integer operations two floating-point multiplies one addition and one division
Dialogue: 0,0:49:02.54,0:49:07.74,Chinese,,0,0,0,,4 次整数运算，两次浮点乘法，一次浮点加法和一次浮点除法
Dialogue: 0,0:49:08.26,0:49:13.72,English,,0,0,0,,They can't all happen at the same time because there's some are share functional units
Dialogue: 0,0:49:08.26,0:49:13.72,Chinese,,0,0,0,,这些操作不可能同时发生，因为功能单元之间有一些共享资源
Dialogue: 0,0:49:13.86,0:49:17.88,English,,0,0,0,,But the point is there's really a lot of equipment there that can do stuff
Dialogue: 0,0:49:13.86,0:49:17.88,Chinese,,0,0,0,,但功能单元的确比较多
Dialogue: 0,0:49:20.30,0:49:23.82,English,,0,0,0,,And also you can measure how....
Dialogue: 0,0:49:20.30,0:49:23.82,Chinese,,0,0,0,,而你也可以测量....
Dialogue: 0,0:49:23.88,0:49:30.34,English,,0,0,0,,And instruction now has two characteristics and operation is how long does it take from beginning to end
Dialogue: 0,0:49:23.88,0:49:30.34,Chinese,,0,0,0,,指令有两个参数，延迟（Latency）是一个指令从头到尾需要多长时间
Dialogue: 0,0:49:30.78,0:49:36.84,English,,0,0,0,,But also how closely spaced can two in stations be because of this pipelining
Dialogue: 0,0:49:30.78,0:49:36.84,Chinese,,0,0,0,,但由于有流水线操作，还有一个参数（Cycles/Issue）表示两个小步骤之间的距离
Dialogue: 0,0:49:37.34,0:49:42.48,English,,0,0,0,,So you see that most to them take some number of clock cycles to perform
Dialogue: 0,0:49:37.34,0:49:42.48,Chinese,,0,0,0,,从 PPT 上我们可以看到，大多数操作需要花费几个时钟周期才能完成
Dialogue: 0,0:49:42.94,0:49:46.46,English,,0,0,0,,But they're also pipelines so that you can do a series of them
Dialogue: 0,0:49:42.94,0:49:46.46,Chinese,,0,0,0,,但它们采用了流水线的技术，流水线的一个步骤
Dialogue: 0,0:49:47.12,0:49:48.44,English,,0,0,0,,Just one cycle apart
Dialogue: 0,0:49:47.12,0:49:48.44,Chinese,,0,0,0,,只需一个时钟周期
Dialogue: 0,0:49:48.92,0:49:55.74,English,,0,0,0,,The only different ones that are does you'll notice the division is both very slow and it's not pipelined
Dialogue: 0,0:49:48.92,0:49:55.74,Chinese,,0,0,0,,注意到，除法操作非常慢，并且没有流水线
Dialogue: 0,0:49:55.74,0:50:01.28,English,,0,0,0,,And division is a very expensive operation on most machines relatively speaking
Dialogue: 0,0:49:55.74,0:50:01.28,Chinese,,0,0,0,,所以，相对而言，在大多数机器上，除法是一项非常昂贵的操作
Dialogue: 0,0:50:05.18,0:50:17.90,English,,0,0,0,,So what I claim then is these characteristics then Provide a limit on how fast our program can run our original program
Dialogue: 0,0:50:05.18,0:50:17.90,Chinese,,0,0,0,,我讲这两个参数的原因是，它们限制我们程序的运行速度
Dialogue: 0,0:50:18.72,0:50:24.02,English,,0,0,0,,in that...I have a series of multiplications for example of integers here
Dialogue: 0,0:50:18.72,0:50:24.02,Chinese,,0,0,0,,举个例子，如果我计算多个整数乘法
Dialogue: 0,0:50:25.20,0:50:27.18,English,,0,0,0,,And this shows the code for it
Dialogue: 0,0:50:25.20,0:50:27.18,Chinese,,0,0,0,,PPT 的上方是它的代码
Dialogue: 0,0:50:27.70,0:50:33.52,English,,0,0,0,,And the result of I need the result of one multiplication before I can begin the next
Dialogue: 0,0:50:27.70,0:50:33.52,Chinese,,0,0,0,,从代码中可以看出，在我开始下一个乘法之前，我需要上一次乘法的结果
Dialogue: 0,0:50:33.74,0:50:37.28,English,,0,0,0,,So there's a three clock cycle bound here
Dialogue: 0,0:50:33.74,0:50:37.28,Chinese,,0,0,0,,每次乘法需要 3 个时钟周期，所以这里得到的结果是 3 个时钟周期
Dialogue: 0,0:50:37.72,0:50:41.02,English,,0,0,0,,And you'll see that in fact my measurements all correspond to
Dialogue: 0,0:50:37.72,0:50:41.02,Chinese,,0,0,0,,实际上我的测量结果都符合
Dialogue: 0,0:50:41.02,0:50:46.78,English,,0,0,0,,What I'm calling the latency bound of these machines which is just based on
Dialogue: 0,0:50:41.02,0:50:46.78,Chinese,,0,0,0,,我称为机器延迟的限制
Dialogue: 0,0:50:46.94,0:50:51.08,English,,0,0,0,,How much time it takes from a beginning of an operation to the end
Dialogue: 0,0:50:46.94,0:50:51.08,Chinese,,0,0,0,,这种限制是基于一个操作从开始到结束需要的时间
Dialogue: 0,0:50:52.42,0:50:57.32,English,,0,0,0,,And the reason is we considered diagram the computation being done by this program
Dialogue: 0,0:50:52.42,0:50:57.32,Chinese,,0,0,0,,如果我们把程序的计算顺序画成 PPT 左侧的这张图
Dialogue: 0,0:50:57.88,0:51:00.86,English,,0,0,0,,That it's doing a series of multiplications
Dialogue: 0,0:50:57.88,0:51:00.86,Chinese,,0,0,0,,程序进行一系列的乘法运算
Dialogue: 0,0:51:01.46,0:51:06.30,English,,0,0,0,,And I require the result of one multiplication before I can start the next
Dialogue: 0,0:51:01.46,0:51:06.30,Chinese,,0,0,0,,并且在我开始下一个之前，我需要上一次乘法的结果
Dialogue: 0,0:51:07.00,0:51:09.04,English,,0,0,0,,In general if you look at this loop code
Dialogue: 0,0:51:07.00,0:51:09.04,Chinese,,0,0,0,,如果你看一下这个循环代码
Dialogue: 0,0:51:09.86,0:51:12.18,English,,0,0,0,,It has to compute %ecx
Dialogue: 0,0:51:09.86,0:51:12.18,Chinese,,0,0,0,,它必须先计算乘法，更新 %ecx 的值
Dialogue: 0,0:51:12.38,0:51:16.88,English,,0,0,0,,The updated value of it before it can now start the next one
Dialogue: 0,0:51:12.38,0:51:16.88,Chinese,,0,0,0,,然后更新 i 的值，再开始下一次循环
Dialogue: 0,0:51:18.12,0:51:23.48,English,,0,0,0,,And so that's why even though this I have a pipelined multiplier
Dialogue: 0,0:51:18.12,0:51:23.48,Chinese,,0,0,0,,所以这就是为什么，即使我有一个流水线乘法器
Dialogue: 0,0:51:24.34,0:51:30.26,English,,0,0,0,,My program itself limits me to of the sequential execution of all the multiplies
Dialogue: 0,0:51:24.34,0:51:30.26,Chinese,,0,0,0,,但我的程序本身限制了我的所有乘法必须顺序执行
Dialogue: 0,0:51:35.58,0:51:40.54,English,,0,0,0,,So let's see if we can't get beyond that bound that latency bound
Dialogue: 0,0:51:35.58,0:51:40.54,Chinese,,0,0,0,,所以让我们看看我们否能超越那个延迟界限
Dialogue: 0,0:51:41.12,0:51:46.42,English,,0,0,0,,Well there's a fairly common technique that you might have heard of before that's called loop unrolling
Dialogue: 0,0:51:41.12,0:51:46.42,Chinese,,0,0,0,,这里采用了一种技术，你可能以前听说过，叫做循环展开
Dialogue: 0,0:51:47.02,0:51:50.14,English,,0,0,0,,And the idea of loop unrolling is just that you
Dialogue: 0,0:51:47.02,0:51:50.14,Chinese,,0,0,0,,循环展开的基本思想是
Dialogue: 0,0:51:53.90,0:51:59.46,English,,0,0,0,,Rather than executing one value within a loop you execute a multiple ones
Dialogue: 0,0:51:53.90,0:51:59.46,Chinese,,0,0,0,,在循环中计算多个值，而不是一个值
Dialogue: 0,0:51:59.92,0:52:02.48,English,,0,0,0,,And so this code shows unrolling by two
Dialogue: 0,0:51:59.92,0:52:02.48,Chinese,,0,0,0,,因此，PPT 上的代码展示了 2*1 循环展开
Dialogue: 0,0:52:02.86,0:52:09.54,English,,0,0,0,,And what it says is I'm going to step through this array two elements at a time
Dialogue: 0,0:52:02.86,0:52:09.54,Chinese,,0,0,0,,也就是每次循环我处理数组的两个元素
Dialogue: 0,0:52:09.86,0:52:15.96,English,,0,0,0,,And within each of the inner group I'm going to combine the values  from d[i] and d[i+1]
Dialogue: 0,0:52:09.86,0:52:15.96,Chinese,,0,0,0,,在循环内部，我计算 x 和 d[i] 及 d[i+1] 的和或乘积
Dialogue: 0,0:52:16.42,0:52:19.08,English,,0,0,0,,And I have to put in some extra code to finish off
Dialogue: 0,0:52:16.42,0:52:19.08,Chinese,,0,0,0,,我必须加入一些额外的代码才能完成
Dialogue: 0,0:52:19.50,0:52:22.40,English,,0,0,0,,What happens if the original rate was very large
Dialogue: 0,0:52:19.50,0:52:22.40,Chinese,,0,0,0,,如果循环展开值比较大呢
Dialogue: 0,0:52:22.68,0:52:24.19,English,,0,0,0,,But you get the idea and
Dialogue: 0,0:52:22.68,0:52:24.19,Chinese,,0,0,0,,我想你明白了
Dialogue: 0,0:52:24.64,0:52:27.50,English,,0,0,0,,This idea I showed this code of of two
Dialogue: 0,0:52:24.64,0:52:27.50,Chinese,,0,0,0,,这里我展示了 2*1 的循环展开
Dialogue: 0,0:52:27.50,0:52:31.68,English,,0,0,0,,But you could imagine this applying for different values of loop unrolling
Dialogue: 0,0:52:27.50,0:52:31.68,Chinese,,0,0,0,,但你可以想象，这适用于不同的循环展开值
Dialogue: 0,0:52:32.84,0:52:34.14,English,,0,0,0,,So will this help us any well
Dialogue: 0,0:52:32.84,0:52:34.14,Chinese,,0,0,0,,这对我们有什么帮助
Dialogue: 0,0:52:35.68,0:52:41.12,English,,0,0,0,,When I run it I get that the integer addition got a little faster
Dialogue: 0,0:52:35.68,0:52:41.12,Chinese,,0,0,0,,当我运行它时，整数加法的速度提升了
Dialogue: 0,0:52:41.46,0:52:43.26,English,,0,0,0,,But the other ones didn't improve at all
Dialogue: 0,0:52:41.46,0:52:43.26,Chinese,,0,0,0,,但其他的根本没有改善
Dialogue: 0,0:52:44.58,0:52:46.70,English,,0,0,0,,So this one is going faster
Dialogue: 0,0:52:44.58,0:52:46.70,Chinese,,0,0,0,,所以这个更快
Dialogue: 0,0:52:46.70,0:52:55.66,English,,0,0,0,,Because basically the old code is the overhead of the loop indexing and incrementing was enough to be slowing me down
Dialogue: 0,0:52:46.70,0:52:55.66,Chinese,,0,0,0,,但这个是因为原来的代码在循环的计数上的开销比较大
Dialogue: 0,0:52:55.96,0:52:58.42,English,,0,0,0,,Because it's already close to a clock cycle
Dialogue: 0,0:52:55.96,0:52:58.42,Chinese,,0,0,0,,因为原来的代码已经接近一个时钟周期
Dialogue: 0,0:52:58.44,0:53:05.80,English,,0,0,0,,So I just managed to knock that down to be at the latency bound of this particular instruction
Dialogue: 0,0:52:58.44,0:53:05.80,Chinese,,0,0,0,,所以我是要超越这个特定指令的延迟界限
Dialogue: 0,0:53:06.58,0:53:11.44,English,,0,0,0,,But it didn't...have the other ones because I still have this sequential dependency
Dialogue: 0,0:53:06.58,0:53:11.44,Chinese,,0,0,0,,但它没有...主要原因是我这里的代码也需要顺序执行
Dialogue: 0,0:53:11.88,0:53:15.70,English,,0,0,0,,In order to get my new value of x I have to first
Dialogue: 0,0:53:11.88,0:53:15.70,Chinese,,0,0,0,,为了获得 x 的新值，我必须先
Dialogue: 0,0:53:16.44,0:53:21.42,English,,0,0,0,,Do one computation and then do the other before I can begin another one
Dialogue: 0,0:53:16.44,0:53:21.42,Chinese,,0,0,0,,乘以 d[i]，然后乘以 d[i+1]，然后开始另一次循环
Dialogue: 0,0:53:23.98,0:53:30.94,English,,0,0,0,,But this shows me the way I could make a very very small change and change performance fairly dramatically
Dialogue: 0,0:53:23.98,0:53:30.94,Chinese,,0,0,0,,但我可以做一个非常小的改变，就可以让性能显著提升
Dialogue: 0,0:53:31.52,0:53:36.38,English,,0,0,0,,What if I take these parentheses and shift them to the right
Dialogue: 0,0:53:31.52,0:53:36.38,Chinese,,0,0,0,,我把这些括号移到右边（代码中红色的部分）
Dialogue: 0,0:53:41.40,0:53:43.16,English,,0,0,0,,What would that make any difference
Dialogue: 0,0:53:41.40,0:53:43.16,Chinese,,0,0,0,,改了之后有什么不同呢
Dialogue: 0,0:53:44.94,0:53:49.22,English,,0,0,0,,And lo and behold yes you find that
Dialogue: 0,0:53:44.94,0:53:49.22,Chinese,,0,0,0,,你可以发现运行的时间减少了
Dialogue: 0,0:53:49.80,0:54:01.46,English,,0,0,0,,And I'll call that transformation unrolling by two computing a one element at a time
Dialogue: 0,0:53:49.80,0:54:01.46,Chinese,,0,0,0,,我把这种展开称为 2*1 循环展开
Dialogue: 0,0:54:01.46,0:54:02.70,English,,0,0,0,,I'll talk about that in a minute
Dialogue: 0,0:54:01.46,0:54:02.70,Chinese,,0,0,0,,我会在一分钟内解释它的含义
Dialogue: 0,0:54:03.38,0:54:08.16,English,,0,0,0,,But I'll use this lowercase a to say I've done an associate transformation
Dialogue: 0,0:54:03.38,0:54:08.16,Chinese,,0,0,0,,我这里用小写字母来表示我做的这个基于结合律的转换
Dialogue: 0,0:54:08.76,0:54:13.18,English,,0,0,0,,And you see all of a sudden my time's dropped in half  for these three cases
Dialogue: 0,0:54:08.76,0:54:13.18,Chinese,,0,0,0,,你可以发现这样转换之后，三种情况下时间都变为了原来的一半
Dialogue: 0,0:54:16.97,0:54:18.02,English,,0,0,0,,So something's going on
Dialogue: 0,0:54:16.97,0:54:18.02,Chinese,,0,0,0,,所以这种转换一定改变了一些东西
Dialogue: 0,0:54:20.14,0:54:24.60,English,,0,0,0,,Um and so let's see why that isn't and now I'll introduce
Dialogue: 0,0:54:20.14,0:54:24.60,Chinese,,0,0,0,,现在我来说明为什么会这样
Dialogue: 0,0:54:27.64,0:54:30.44,English,,0,0,0,,It and so if I take my picture from before
Dialogue: 0,0:54:27.64,0:54:30.44,Chinese,,0,0,0,,你们想想没有修改的代码
Dialogue: 0,0:54:31.50,0:54:34.88,English,,0,0,0,,And think about what those computations employ you'll see that
Dialogue: 0,0:54:31.50,0:54:34.88,Chinese,,0,0,0,,并考虑一下计算的顺序
Dialogue: 0,0:54:35.46,0:54:38.88,English,,0,0,0,,Right now I've changed the structure of the computation
Dialogue: 0,0:54:35.46,0:54:38.88,Chinese,,0,0,0,,你会发现我改变了计算的结构
Dialogue: 0,0:54:38.88,0:54:46.04,English,,0,0,0,,So that I'm pairwise combining each element of pair of elements of the array
Dialogue: 0,0:54:38.88,0:54:46.04,Chinese,,0,0,0,,改变之后我先计算数组中的两个元素的乘积
Dialogue: 0,0:54:46.50,0:54:51.02,English,,0,0,0,,And then accumulating those into the overall computation
Dialogue: 0,0:54:46.50,0:54:51.02,Chinese,,0,0,0,,然后将它们累积到整体的积中
Dialogue: 0,0:54:51.02,0:54:55.40,English,,0,0,0,,So I've actually that shifting of the parentheses fundamentally changed
Dialogue: 0,0:54:51.02,0:54:55.40,Chinese,,0,0,0,,所以，实际上括号的转移改变了
Dialogue: 0,0:54:55.82,0:54:57.40,English,,0,0,0,,How I'm doing my computation
Dialogue: 0,0:54:55.82,0:54:57.40,Chinese,,0,0,0,,计算的方式
Dialogue: 0,0:54:59.12,0:55:02.90,English,,0,0,0,,And you can see now that this critical path which is what determines
Dialogue: 0,0:54:59.12,0:55:02.90,Chinese,,0,0,0,,你现在可以看到，在这个例子中，决定性能
Dialogue: 0,0:55:03.30,0:55:05.96,English,,0,0,0,,In this case the the performance limitation
Dialogue: 0,0:55:03.30,0:55:05.96,Chinese,,0,0,0,,的关键路径已经变成了左边这张图
Dialogue: 0,0:55:06.20,0:55:08.66,English,,0,0,0,,Just got shorter by a factor of two
Dialogue: 0,0:55:06.20,0:55:08.66,Chinese,,0,0,0,,它的关键路径恰好是前面的一半
Dialogue: 0,0:55:08.94,0:55:11.62,English,,0,0,0,,And that's why I'm now running twice as fast
Dialogue: 0,0:55:08.94,0:55:11.62,Chinese,,0,0,0,,这就是我现在的运行速度是前面的两倍的原因
Dialogue: 0,0:55:11.82,0:55:16.50,English,,0,0,0,,For the operations not for integer addition
Dialogue: 0,0:55:11.82,0:55:16.50,Chinese,,0,0,0,,但这个转换没有提升整数加法的性能
Dialogue: 0,0:55:17.02,0:55:23.64,English,,0,0,0,,But for the other three operations I've cut by a factor or two ,just by that shift
Dialogue: 0,0:55:17.02,0:55:23.64,Chinese,,0,0,0,,但是对于其他三个运算，速度已经提升了一倍，仅仅是改变了括号的位置
Dialogue: 0,0:55:24.32,0:55:26.48,English,,0,0,0,,Now there's some good news and bad news here
Dialogue: 0,0:55:24.32,0:55:26.48,Chinese,,0,0,0,,现在这里有一些好消息和坏消息
Dialogue: 0,0:55:27.20,0:55:29.88,English,,0,0,0,,The good news is if this is integer arithmetic
Dialogue: 0,0:55:27.20,0:55:29.88,Chinese,,0,0,0,,好消息是，如果这是整数运算
Dialogue: 0,0:55:29.88,0:55:39.56,English,,0,0,0,,We know already you know that two's complement arithmetic is associative and commutative
Dialogue: 0,0:55:29.88,0:55:39.56,Chinese,,0,0,0,,你们已经知道了，二进制补码的加法和乘法运算满足交换律和结合律
Dialogue: 0,0:55:39.96,0:55:44.14,English,,0,0,0,,So it really doesn't matter for both multiplication and addition
Dialogue: 0,0:55:39.96,0:55:44.14,Chinese,,0,0,0,,因此，整数的乘法和加法进行这种转换都是没问题的
Dialogue: 0,0:55:44.32,0:55:47.24,English,,0,0,0,,So it really doesn't matter what order I combine these elements in
Dialogue: 0,0:55:44.32,0:55:47.24,Chinese,,0,0,0,,所以我可以将这些元素以任意的顺序组合
Dialogue: 0,0:55:47.24,0:55:49.84,English,,0,0,0,,I'm going to get the exact same answer no matter what
Dialogue: 0,0:55:47.24,0:55:49.84,Chinese,,0,0,0,,无论怎样组合，我都会得到完全相同的答案
Dialogue: 0,0:55:50.70,0:55:53.30,English,,0,0,0,,But you also solve for floating-point that's not the case
Dialogue: 0,0:55:50.70,0:55:53.30,Chinese,,0,0,0,,但是你知道对于浮点数的运算，并不满足结合律
Dialogue: 0,0:55:53.92,0:55:58.18,English,,0,0,0,,So with floating-point that shifting these parentheses
Dialogue: 0,0:55:53.92,0:55:58.18,Chinese,,0,0,0,,所以对于浮点数运算，如果移动这些括号
Dialogue: 0,0:55:58.74,0:56:02.58,English,,0,0,0,,Because of rounding possibilities and even potentially overflow
Dialogue: 0,0:55:58.74,0:56:02.58,Chinese,,0,0,0,,由于可能出现舍入（如大数加小数，小数会被忽略），甚至是溢出的情况
Dialogue: 0,0:56:03.12,0:56:07.02,English,,0,0,0,,You might get different values results from these computations
Dialogue: 0,0:56:03.12,0:56:07.02,Chinese,,0,0,0,,可能会导致计算的结果不同
Dialogue: 0,0:56:07.58,0:56:13.46,English,,0,0,0,,But then again if you think about you know without rounding is going to happen chances are no
Dialogue: 0,0:56:07.58,0:56:13.46,Chinese,,0,0,0,,但如果在计算过程中不会发生舍入的情况
Dialogue: 0,0:56:14.02,0:56:17.16,English,,0,0,0,,That it's not really going to affect the outcome of your program
Dialogue: 0,0:56:14.02,0:56:17.16,Chinese,,0,0,0,,那么这种转换不会影响你的计算结果
Dialogue: 0,0:56:17.46,0:56:21.64,English,,0,0,0,,But it's enough of a change that most C compilers or most compilers period
Dialogue: 0,0:56:17.46,0:56:21.64,Chinese,,0,0,0,,但即使发生舍入的情况比较少，但也足够让大多数的编译器
Dialogue: 0,0:56:21.92,0:56:24.96,English,,0,0,0,,Will not make any change that changes associativity
Dialogue: 0,0:56:21.92,0:56:24.96,Chinese,,0,0,0,,不会改变浮点数的结合性
Dialogue: 0,0:56:24.96,0:56:28.22,English,,0,0,0,,Because they're very conservative when it comes to floating-point
Dialogue: 0,0:56:24.96,0:56:28.22,Chinese,,0,0,0,,因为它们对浮点数计算的优化非常保守
Dialogue: 0,0:56:29.98,0:56:34.62,English,,0,0,0,,So that's something you as an application programmer has to have to know well enough is
Dialogue: 0,0:56:29.98,0:56:34.62,Chinese,,0,0,0,,应用程序员，你必须要充分了解这些东西
Dialogue: 0,0:56:34.62,0:56:38.20,English,,0,0,0,,This a valid can I do this transformation without messing things up
Dialogue: 0,0:56:34.62,0:56:38.20,Chinese,,0,0,0,,知道做某个转换是不是可能导致错误的结果
Dialogue: 0,0:56:41.16,0:56:45.90,English,,0,0,0,,And now without I'll say is now there's a new set of bounds
Dialogue: 0,0:56:41.16,0:56:45.90,Chinese,,0,0,0,,现在有一套新的界限
Dialogue: 0,0:56:45.90,0:56:52.46,English,,0,0,0,,So a bound is what would appear to be sort of the best you can do based on some constraint in the program
Dialogue: 0,0:56:45.90,0:56:52.46,Chinese,,0,0,0,,这个界限是你程序能够达到了最好性能
Dialogue: 0,0:56:52.88,0:56:59.58,English,,0,0,0,,And before it was saying well the latency the total time through a given for a given operation was abound
Dialogue: 0,0:56:52.88,0:56:59.58,Chinese,,0,0,0,,延迟界限是指在一系列操作必须严格顺序执行时，执行一条指令所要花费的全部时间
Dialogue: 0,0:57:00.50,0:57:05.56,English,,0,0,0,,And now I say well there's an even more fundamental bound which I'll call the throughput bound
Dialogue: 0,0:57:00.50,0:57:05.56,Chinese,,0,0,0,,但还有一个更基本的界限，我称之为吞吐量限制
Dialogue: 0,0:57:05.56,0:57:09.66,English,,0,0,0,,Which is just based on I only have so much hardware out there
Dialogue: 0,0:57:05.56,0:57:09.66,Chinese,,0,0,0,,这个限制是基于硬件的数量和性能
Dialogue: 0,0:57:09.92,0:57:12.54,English,,0,0,0,,And I can only a pump it so fast
Dialogue: 0,0:57:09.92,0:57:12.54,Chinese,,0,0,0,,基于功能单元的原始计算能力
Dialogue: 0,0:57:13.32,0:57:19.26,English,,0,0,0,,So for example these two that the throughput bound is one
Dialogue: 0,0:57:13.32,0:57:19.26,Chinese,,0,0,0,,例如，这两个操作的吞吐量界限是 1（上一张 PPT）
Dialogue: 0,0:57:19.82,0:57:28.78,English,,0,0,0,,Because I only have that actually becomes limited by the requirement
Dialogue: 0,0:57:19.82,0:57:28.78,Chinese,,0,0,0,,因为它受限于下面的要求
Dialogue: 0,0:57:28.78,0:57:32.34,English,,0,0,0,,That I'm having to read from memory
Dialogue: 0,0:57:28.78,0:57:32.34,Chinese,,0,0,0,,我必须把数据从内存中读出来
Dialogue: 0,0:57:32.74,0:57:35.10,English,,0,0,0,,And I have two different load units
Dialogue: 0,0:57:32.74,0:57:35.10,Chinese,,0,0,0,,我有两个不同的计算单元
Dialogue: 0,0:57:39.02,0:57:45.28,English,,0,0,0,,No! I'm sorry I only have one multiplier for integers in one for  addition
Dialogue: 0,0:57:39.02,0:57:45.28,Chinese,,0,0,0,,没有！对不起，我只有一个整数乘法器，一个整数加法器
Dialogue: 0,0:57:46.00,0:57:49.84,English,,0,0,0,,The throughput bound for these two actually is just a half
Dialogue: 0,0:57:46.00,0:57:49.84,Chinese,,0,0,0,,这两者的吞吐量实际上只有 0.5
Dialogue: 0,0:57:50.38,0:57:55.68,English,,0,0,0,,Because it turns out there's some odd part of the hardware design that has two floating point multipliers
Dialogue: 0,0:57:50.38,0:57:55.68,Chinese,,0,0,0,,因为这是硬件设计的一个奇怪的地方，它有两个两个浮点乘法器
Dialogue: 0,0:57:56.20,0:57:57.96,English,,0,0,0,,But only one floating point adder
Dialogue: 0,0:57:56.20,0:57:57.96,Chinese,,0,0,0,,但只有一个浮点加法器
Dialogue: 0,0:57:58.18,0:58:03.08,English,,0,0,0,,And we'll see that we can actually make this multiplication code run faster than addition code
Dialogue: 0,0:57:58.18,0:58:03.08,Chinese,,0,0,0,,所以，这里乘法实际上比加法运行得更快
Dialogue: 0,0:58:03.64,0:58:08.28,English,,0,0,0,,And over here again my limit will be that I only have two load units ,now I have to be...
Dialogue: 0,0:58:03.64,0:58:08.28,Chinese,,0,0,0,,这里虽然我有 4 个加法器，但只有两个加载(load)单元，所以性能受限于加载单元
Dialogue: 0,0:58:09.30,0:58:14.74,English,,0,0,0,,And I have to read for every element I'm computing,I have to be reading one element from memory
Dialogue: 0,0:58:09.30,0:58:14.74,Chinese,,0,0,0,,因为我必须先从内存中读取一个元素
Dialogue: 0,0:58:14.74,0:58:16.14,English,,0,0,0,,So I can't get below the
Dialogue: 0,0:58:14.74,0:58:16.14,Chinese,,0,0,0,,所以我不能低于 0.5
Dialogue: 0,0:58:20.18,0:58:23.26,English,,0,0,0,,That okay so but we saw this transformation now is let us
Dialogue: 0,0:58:20.18,0:58:23.26,Chinese,,0,0,0,,我们现在来看看这段代码实现的转化
Dialogue: 0,0:58:23.70,0:58:28.60,English,,0,0,0,,Break out of this latency limitation and get something closer to throughput
Dialogue: 0,0:58:23.70,0:58:28.60,Chinese,,0,0,0,,它使我们突破了延迟界限，接近于吞吐量界限
Dialogue: 0,0:58:29.38,0:58:35.76,English,,0,0,0,,And here's another technique that can be used to again sort of get more parallelism going
Dialogue: 0,0:58:29.38,0:58:35.76,Chinese,,0,0,0,,这是另一种可以获得更多并行性的技术
Dialogue: 0,0:58:36.04,0:58:38.30,English,,0,0,0,,And I call this multiple accumulators
Dialogue: 0,0:58:36.04,0:58:38.30,Chinese,,0,0,0,,我称之为多个累加器
Dialogue: 0,0:58:38.82,0:58:41.70,English,,0,0,0,,The idea is let's a imagine that
Dialogue: 0,0:58:38.82,0:58:41.70,Chinese,,0,0,0,,想象一下
Dialogue: 0,0:58:41.70,0:58:45.74,English,,0,0,0,,We have the odd-numbered elements and the even-numbered elements in the array
Dialogue: 0,0:58:41.70,0:58:45.74,Chinese,,0,0,0,,我们在数组中有索引为奇数的元素和索引为偶数的元素
Dialogue: 0,0:58:46.36,0:58:52.88,English,,0,0,0,,And we can we can compute separate sums or products of those two sets of elements
Dialogue: 0,0:58:46.36,0:58:52.88,Chinese,,0,0,0,,我们可以分别计算这两组元素的和或积
Dialogue: 0,0:58:53.34,0:58:56.28,English,,0,0,0,,And then the very end combine them together
Dialogue: 0,0:58:53.34,0:58:56.28,Chinese,,0,0,0,,然后最后将它们组合在一起
Dialogue: 0,0:58:56.60,0:59:00.53,English,,0,0,0,,So this is another form of and associativity transformation
Dialogue: 0,0:58:56.60,0:59:00.53,Chinese,,0,0,0,,所以这是另一种形式的结合律变换
Dialogue: 0,0:59:00.53,0:59:04.54,English,,0,0,0,,You were changing the order in which we combine things together
Dialogue: 0,0:59:00.53,0:59:04.54,Chinese,,0,0,0,,这改变了元素组合的顺序
Dialogue: 0,0:59:05.08,0:59:08.14,English,,0,0,0,,It's just that we're doing it in the suit of odd-even manner
Dialogue: 0,0:59:05.08,0:59:08.14,Chinese,,0,0,0,,我们将索引为奇数的组合在一起，索引为偶数的组合在一起
Dialogue: 0,0:59:08.14,0:59:15.78,English,,0,0,0,,Or in general every I do it by some by some parameter i
Dialogue: 0,0:59:08.14,0:59:15.78,Chinese,,0,0,0,,一般来说，我们可以通过参数 i 来将数组划分为多份
Dialogue: 0,0:59:17.92,0:59:21.58,English,,0,0,0,,It has the same issues that if it's integer arithmetic it's fine
Dialogue: 0,0:59:17.92,0:59:21.58,Chinese,,0,0,0,,它和前面的转化有同样的问题，如果它是整数运算，那很好
Dialogue: 0,0:59:21.58,0:59:26.54,English,,0,0,0,,If it's floating-point there's a risk of of changing the behavior of the program
Dialogue: 0,0:59:21.58,0:59:26.54,Chinese,,0,0,0,,如果它是浮点数，则存在改变程序行为的风险
Dialogue: 0,0:59:27.78,0:59:32.40,English,,0,0,0,,But you'll see that again we get a cutting in half here and
Dialogue: 0,0:59:27.78,0:59:32.40,Chinese,,0,0,0,,你会看到整数除加法外，其他的操作运行时间是原来的一半
Dialogue: 0,0:59:32.48,0:59:35.80,English,,0,0,0,,A little bit below one for integer addition
Dialogue: 0,0:59:32.48,0:59:35.80,Chinese,,0,0,0,,但比整数的加法要慢一点
Dialogue: 0,0:59:39.04,0:59:41.98,English,,0,0,0,,And again we can think of it by looking at these pictures
Dialogue: 0,0:59:39.04,0:59:41.98,Chinese,,0,0,0,,我们看看 PPT 左边的图
Dialogue: 0,0:59:41.98,0:59:44.16,English,,0,0,0,,Of what are the what gets computed
Dialogue: 0,0:59:41.98,0:59:44.16,Chinese,,0,0,0,,它表示了我们的计算顺序
Dialogue: 0,0:59:44.16,0:59:47.92,English,,0,0,0,,And you see what we're doing is we're computing here all the even numbers
Dialogue: 0,0:59:44.16,0:59:47.92,Chinese,,0,0,0,,我们在这里计算所有偶数
Dialogue: 0,0:59:48.36,0:59:51.58,English,,0,0,0,,Even numbered elements being combined and here all the odd ones
Dialogue: 0,0:59:48.36,0:59:51.58,Chinese,,0,0,0,,把偶数编号的元素组合在一起，这里所有奇数编号的元素
Dialogue: 0,0:59:51.88,0:59:54.12,English,,0,0,0,,And the very end we're combining those together
Dialogue: 0,0:59:51.88,0:59:54.12,Chinese,,0,0,0,,最后，我们将二者的结果组合在一起
Dialogue: 0,0:59:56.82,1:00:04.00,English,,0,0,0,,And so we can generalize this if we can unroll by a factor of K of L
Dialogue: 0,0:59:56.82,1:00:04.00,Chinese,,0,0,0,,进一步的，我们可以将其一般化，我们可以以 K 为因子展开一个长度为 L 的数组
Dialogue: 0,1:00:04.24,1:00:07.32,English,,0,0,0,,And we can accumulate K results in parallel
Dialogue: 0,1:00:04.24,1:00:07.32,Chinese,,0,0,0,,这样，我们可以并行计算 K 个值
Dialogue: 0,1:00:07.90,1:00:11.82,English,,0,0,0,,And we can use various values of l and K for it
Dialogue: 0,1:00:07.90,1:00:11.82,Chinese,,0,0,0,,我们可以使用不同的 l 和 K 值
Dialogue: 0,1:00:11.82,1:00:14.68,English,,0,0,0,,In general L has to be a multiple of K
Dialogue: 0,1:00:11.82,1:00:14.68,Chinese,,0,0,0,,一般来说 L 必须是 K 的倍数
Dialogue: 0,1:00:16.36,1:00:21.78,English,,0,0,0,,And so you run it out and you can get for floating-point multiply
Dialogue: 0,1:00:16.36,1:00:21.78,Chinese,,0,0,0,,你可以更改 K 和 L 的值，然后运行程序，这里是浮点数乘法的结果
Dialogue: 0,1:00:23.28,1:00:27.70,English,,0,0,0,,You can actually get it down almost to this throughput bounds of 0.5
Dialogue: 0,1:00:23.28,1:00:27.70,Chinese,,0,0,0,,可以看到，实际上运行速度可以接近吞吐量极限 0.5
Dialogue: 0,1:00:36.62,1:00:42.02,English,,0,0,0,,This is integer,this is integer addition I should say in tradition
Dialogue: 0,1:00:36.62,1:00:42.02,Chinese,,0,0,0,,这是整数加法的结果
Dialogue: 0,1:00:42.70,1:00:45.92,English,,0,0,0,,You can again get it down to around 0.5
Dialogue: 0,1:00:42.70,1:00:45.92,Chinese,,0,0,0,,运行速度也可以接近 0.5
Dialogue: 0,1:00:46.64,1:00:53.48,English,,0,0,0,,And in general by sort of picking the best parameters
Dialogue: 0,1:00:46.64,1:00:53.48,Chinese,,0,0,0,,一般来说，通过选择最佳参数
Dialogue: 0,1:00:53.48,1:00:57.88,English,,0,0,0,,I can get very close to the throughput bound of this processor
Dialogue: 0,1:00:53.48,1:00:57.88,Chinese,,0,0,0,,我们的运行速度可以非常接近这个处理器的吞吐量界限
Dialogue: 0,1:00:58.36,1:01:04.14,English,,0,0,0,,So I've been able to take something remember it originally was  20 clock cycles and 10
Dialogue: 0,1:00:58.36,1:01:04.14,Chinese,,0,0,0,,还记得吗，原来这个程序的 CPE 是 20 个时钟周期和 10 个时钟周期
Dialogue: 0,1:01:04.38,1:01:08.44,English,,0,0,0,,And now I'm getting it down to one or fewer clock cycles per element
Dialogue: 0,1:01:04.38,1:01:08.44,Chinese,,0,0,0,,现在我将 CPE 降低到了 1 和 0.5
Dialogue: 0,1:01:10.58,1:01:17.56,English,,0,0,0,,So now just as the final step is okay is that as good as it go actually know
Dialogue: 0,1:01:10.58,1:01:17.56,Chinese,,0,0,0,,但我们还可以把它降得更低，现在来看最后一步
Dialogue: 0,1:01:18.96,1:01:25.34,English,,0,0,0,,You remember when I talked about floating-point I mentioned that there's the special set of registers
Dialogue: 0,1:01:18.96,1:01:25.34,Chinese,,0,0,0,,讲浮点代码时，我提到过有一组特殊的寄存器
Dialogue: 0,1:01:25.70,1:01:31.96,English,,0,0,0,,That are on x86 that we're called %xmm registers on the shark machines
Dialogue: 0,1:01:25.70,1:01:31.96,Chinese,,0,0,0,,在 x86 的机器上，我们称为 ％xmm 寄存器
Dialogue: 0,1:01:32.26,1:01:36.68,English,,0,0,0,,And now this has well this newer generation have something called %ymm registers
Dialogue: 0,1:01:32.26,1:01:36.68,Chinese,,0,0,0,,而现在新一代的 CPU 上，增加了一个叫做 ％ymm 的寄存器
Dialogue: 0,1:01:37.08,1:01:40.04,English,,0,0,0,,Which have the feature being twice as big as %xmm registers
Dialogue: 0,1:01:37.08,1:01:40.04,Chinese,,0,0,0,,它的大小是 ％xmm 寄存器的两倍
Dialogue: 0,1:01:40.90,1:01:51.10,English,,0,0,0,,So in particular these registers are 32 bytes long
Dialogue: 0,1:01:40.90,1:01:51.10,Chinese,,0,0,0,,所以这些寄存器有 32 个字节
Dialogue: 0,1:01:51.76,1:01:57.38,English,,0,0,0,,And there's a new version coming out within a year or something they call AVX512
Dialogue: 0,1:01:51.76,1:01:57.38,Chinese,,0,0,0,,并且 Intel 会在一年内推出一个新的名为 AVX512 版本
Dialogue: 0,1:01:57.86,1:02:03.92,English,,0,0,0,,Where the register is 512 bits so that's 256 bytes long
Dialogue: 0,1:01:57.86,1:02:03.92,Chinese,,0,0,0,,寄存器为 512 位，因此长度为 256 字节
Dialogue: 0,1:02:04.42,1:02:10.60,English,,0,0,0,,No it's of to 512,excuse me...it's 64 bytes right
Dialogue: 0,1:02:04.42,1:02:10.60,Chinese,,0,0,0,,512 比特，对不起......长度应该是 64 字节
Dialogue: 0,1:02:11.04,1:02:13.36,English,,0,0,0,,64 bytes so it'll be twice as big as these
Dialogue: 0,1:02:11.04,1:02:13.36,Chinese,,0,0,0,,64 字节，所以它的长度是 %ymm 长度的两倍
Dialogue: 0,1:02:14.08,1:02:21.78,English,,0,0,0,,And as I mentioned before you can think of these as a way of operating on 32 individual characters
Dialogue: 0,1:02:14.08,1:02:21.78,Chinese,,0,0,0,,正如我之前提到的，你可以将它们视为 32 个 1 字节的整数
Dialogue: 0,1:02:22.30,1:02:24.52,English,,0,0,0,,Or I can treat them as floating point
Dialogue: 0,1:02:22.30,1:02:24.52,Chinese,,0,0,0,,或者把它们视为浮点数
Dialogue: 0,1:02:25.20,1:02:28.86,English,,0,0,0,,And we saw before that you nowadays the
Dialogue: 0,1:02:25.20,1:02:28.86,Chinese,,0,0,0,,好，现在
Dialogue: 0,1:02:29.26,1:02:35.52,English,,0,0,0,,The regular floating point makes use of the low order four, eight bytes of these read register
Dialogue: 0,1:02:29.26,1:02:35.52,Chinese,,0,0,0,,浮点数使用这些寄存器的低 4 位或低 8 位
Dialogue: 0,1:02:36.64,1:02:40.16,English,,0,0,0,,But there's also instructions called vector addition
Dialogue: 0,1:02:36.64,1:02:40.16,Chinese,,0,0,0,,但是，我们有一些称为矢量加法的指令
Dialogue: 0,1:02:41.22,1:02:50.76,English,,0,0,0,,Where one instruction has the effect of doing eight floating-point additions at once and float data
Dialogue: 0,1:02:41.22,1:02:50.76,Chinese,,0,0,0,,其中一条矢量加法指令具有执行八次单精度浮点加法的效果
Dialogue: 0,1:02:51.02,1:02:55.34,English,,0,0,0,,And on double precision this counterpart does four of them at once of these
Dialogue: 0,1:02:51.02,1:02:55.34,Chinese,,0,0,0,,或者相当于 4 次双精度浮点加法
Dialogue: 0,1:02:56.78,1:03:02.98,English,,0,0,0,,And the that hardware is there it's just sitting there waiting to use and it seldom gets fired up
Dialogue: 0,1:02:56.78,1:03:02.98,Chinese,,0,0,0,,但这个硬件很少处于繁忙的状态
Dialogue: 0,1:03:03.60,1:03:05.58,English,,0,0,0,,To really make use of it
Dialogue: 0,1:03:03.60,1:03:05.58,Chinese,,0,0,0,,如果这个硬件繁忙起来
Dialogue: 0,1:03:06.00,1:03:09.68,English,,0,0,0,,But so that floating point multiplier that can do
Dialogue: 0,1:03:06.00,1:03:09.68,Chinese,,0,0,0,,这样可以较大的提升乘法性能
Dialogue: 0,1:03:10.12,1:03:15.04,English,,0,0,0,,A floating point multiplication in three clock cycles and is fully pipeline
Dialogue: 0,1:03:10.12,1:03:15.04,Chinese,,0,0,0,,三个时钟周期，流水线的浮点数乘法
Dialogue: 0,1:03:16.19,1:03:24.32,English,,0,0,0,,You can actually do eight floating point multiplications in parallel and pipelined in three clock cycles
Dialogue: 0,1:03:16.19,1:03:24.32,Chinese,,0,0,0,,你可以在三个时钟周期内，并行进行八次浮点流水线乘法
Dialogue: 0,1:03:27.38,1:03:33.04,English,,0,0,0,,And as I mentioned the shark machines has an earlier version where the numbers are half of these
Dialogue: 0,1:03:27.38,1:03:33.04,Chinese,,0,0,0,,正如我所提到的，shark 机器是一个早期版本，它的 %ymm 寄存器的长度是这里的一半
Dialogue: 0,1:03:33.04,1:03:37.49,English,,0,0,0,,So it can do 4 single precision or two double precision at once
Dialogue: 0,1:03:33.04,1:03:37.49,Chinese,,0,0,0,,因此它可以同时执行 4 个单精度或两个双精度的浮点数运算
Dialogue: 0,1:03:38.76,1:03:44.16,English,,0,0,0,,And if I write code that uses that what I call vector code
Dialogue: 0,1:03:38.76,1:03:44.16,Chinese,,0,0,0,,如果我把代码改写为矢量代码
Dialogue: 0,1:03:44.70,1:03:51.16,English,,0,0,0,,Then you can see I can drop by a factor of about four across the board here
Dialogue: 0,1:03:44.70,1:03:51.16,Chinese,,0,0,0,,然后你可以看到 CPE 降低了 4 倍
Dialogue: 0,1:03:51.86,1:03:54.82,English,,0,0,0,,And make it run much faster
Dialogue: 0,1:03:51.86,1:03:54.82,Chinese,,0,0,0,,所以运行速度更快了
Dialogue: 0,1:03:54.82,1:03:58.92,English,,0,0,0,,So this 0.06 is really 0.0625 right
Dialogue: 0,1:03:54.82,1:03:58.92,Chinese,,0,0,0,,这个 0.06 是 0.0625
Dialogue: 0,1:03:58.92,1:04:05.48,English,,0,0,0,,It's doing 16 operations per clock cycle on that
Dialogue: 0,1:03:58.92,1:04:05.48,Chinese,,0,0,0,,它每个时钟周期执行 16 次操作（原来每个时钟周期执行 2 次操作，提升了 8 倍）
Dialogue: 0,1:04:10.06,1:04:14.46,English,,0,0,0,,And can't quite hit the vector throughput bound
Dialogue: 0,1:04:10.06,1:04:14.46,Chinese,,0,0,0,,但是我们最多只能接近矢量吞吐量界限
Dialogue: 0,1:04:14.46,1:04:17.68,English,,0,0,0,,But in general making this thing run much faster
Dialogue: 0,1:04:14.46,1:04:17.68,Chinese,,0,0,0,,但总的来说，运行速度已经提升了很多
Dialogue: 0,1:04:18.10,1:04:20.54,English,,0,0,0,,And so the people really worry about
Dialogue: 0,1:04:18.10,1:04:20.54,Chinese,,0,0,0,,所以人们真的很关心
Dialogue: 0,1:04:20.54,1:04:27.16,English,,0,0,0,,And you can imagine these instructions were introduced for things like video processing image processing of sound
Dialogue: 0,1:04:20.54,1:04:27.16,Chinese,,0,0,0,,你可以想象，这些指令是为视频、声音、图象处理而引入的
Dialogue: 0,1:04:27.46,1:04:31.98,English,,0,0,0,,Sort of signal processing where a performance really matters
Dialogue: 0,1:04:27.46,1:04:31.98,Chinese,,0,0,0,,这些信号处理的程序对性能的要求很高
Dialogue: 0,1:04:32.00,1:04:38.02,English,,0,0,0,,How fast you can display an image how fast you can rotate something
Dialogue: 0,1:04:32.00,1:04:38.02,Chinese,,0,0,0,,如，显示图像的速度有多快，将某个图象旋转速度有多快
Dialogue: 0,1:04:38.02,1:04:41.06,English,,0,0,0,,You know how fast you can perform graphics makes a big difference
Dialogue: 0,1:04:38.02,1:04:41.06,Chinese,,0,0,0,,渲染图象速度的快慢影响很大
Dialogue: 0,1:04:41.74,1:04:48.60,English,,0,0,0,,In video games are one of the big drivers but even for sort of other operations you might do an image
Dialogue: 0,1:04:41.74,1:04:48.60,Chinese,,0,0,0,,在电脑游戏中这是一个关键因素，在其他领域也比较重要，如你拍摄一张照片
Dialogue: 0,1:04:48.90,1:04:51.40,English,,0,0,0,,And so these instructions were really designed to do it
Dialogue: 0,1:04:48.90,1:04:51.40,Chinese,,0,0,0,,这些指令就是为了这些情景设计的
Dialogue: 0,1:04:51.40,1:04:54.10,English,,0,0,0,,And people write code for those kind of applications
Dialogue: 0,1:04:51.40,1:04:54.10,Chinese,,0,0,0,,人们为这些应用程序编写代码
Dialogue: 0,1:04:54.52,1:04:59.98,English,,0,0,0,,Get pretty good at writing code in a way that they can do this vector I what's called vectorizing
Dialogue: 0,1:04:54.52,1:04:59.98,Chinese,,0,0,0,,他们需要编写这种向量化的代码
Dialogue: 0,1:05:00.58,1:05:05.82,English,,0,0,0,,And unfortunately so the intel compiler will actually automatically do some of this for you
Dialogue: 0,1:05:00.58,1:05:05.82,Chinese,,0,0,0,,不幸的是，虽然 intel 编译器会自动做一些这方面的优化
Dialogue: 0,1:05:06.10,1:05:09.11,English,,0,0,0,,A GCC they attempted to implement it and
Dialogue: 0,1:05:06.10,1:05:09.11,Chinese,,0,0,0,,但 gcc 虽然尝试去实现这种优化
Dialogue: 0,1:05:09.11,1:05:11.96,English,,0,0,0,,It didn't work very well so I think they discontinued it
Dialogue: 0,1:05:09.11,1:05:11.96,Chinese,,0,0,0,,但实际效果不好，可能 gcc 已经没有继续这个优化了
Dialogue: 0,1:05:12.58,1:05:15.64,English,,0,0,0,,It turns out there's a web aside
Dialogue: 0,1:05:12.58,1:05:15.64,Chinese,,0,0,0,,这里有一个网络旁注
Dialogue: 0,1:05:16.90,1:05:21.44,English,,0,0,0,,So this is on the web from the books web page that describes
Dialogue: 0,1:05:16.90,1:05:21.44,Chinese,,0,0,0,,对应的网页上讲了
Dialogue: 0,1:05:21.44,1:05:23.52,English,,0,0,0,,How to do this programming if you're interested
Dialogue: 0,1:05:21.44,1:05:23.52,Chinese,,0,0,0,,如何进行这种向量化的编程，有兴趣你可以试试
Dialogue: 0,1:05:23.90,1:05:28.82,English,,0,0,0,,There's extensions to GCC that are very funky really weird stuff
Dialogue: 0,1:05:23.90,1:05:28.82,Chinese,,0,0,0,,网页上还有一些 gcc 的扩展
Dialogue: 0,1:05:29.36,1:05:32.20,English,,0,0,0,,But you can write code
Dialogue: 0,1:05:29.36,1:05:32.20,Chinese,,0,0,0,,但是你可以编写代码
Dialogue: 0,1:05:32.72,1:05:37.12,English,,0,0,0,,That then will get compiled down to make use of these kind of instructions
Dialogue: 0,1:05:32.72,1:05:37.12,Chinese,,0,0,0,,然后利用 gcc 的扩展（补充）编译，这样就可以利用这些矢量指令
Dialogue: 0,1:05:37.18,1:05:40.22,English,,0,0,0,,And that's how I did it and how I got these performance results
Dialogue: 0,1:05:37.18,1:05:40.22,Chinese,,0,0,0,,这是我的做法，也是我得到这个性能的测试结果的方法
Dialogue: 0,1:05:43.48,1:05:46.76,English,,0,0,0,,Okay so that shows you if you really want to it
Dialogue: 0,1:05:43.48,1:05:46.76,Chinese,,0,0,0,,这是我要展示的结果
Dialogue: 0,1:05:47.00,1:05:50.38,English,,0,0,0,,But that's very machine specific that will only work on
Dialogue: 0,1:05:47.00,1:05:50.38,Chinese,,0,0,0,,还有一点，这种优化是针对某个机器的
Dialogue: 0,1:05:52.02,1:05:58.46,English,,0,0,0,,Well you have to you can actually tune it so it's easy to compile it  to go between different machines
Dialogue: 0,1:05:52.02,1:05:58.46,Chinese,,0,0,0,,如果你要在不同的机器上运行程序，你需要调整 gcc 的选项
Dialogue: 0,1:05:58.46,1:06:05.34,English,,0,0,0,,But it's still a fairly specific and very specific to GCC in fact
Dialogue: 0,1:05:58.46,1:06:05.34,Chinese,,0,0,0,,这种优化依赖于 gcc
Dialogue: 0,1:06:05.92,1:06:09.48,English,,0,0,0,,So that sort of shows you though if you really want to push it what you can do
Dialogue: 0,1:06:05.92,1:06:09.48,Chinese,,0,0,0,,如果你想自己编写代码，你可以试一试
Dialogue: 0,1:06:10.48,1:06:13.16,English,,0,0,0,,Now let's uh get back to one of the thing
Dialogue: 0,1:06:10.48,1:06:13.16,Chinese,,0,0,0,,现在我们来讨论另外一件事情
Dialogue: 0,1:06:13.56,1:06:20.04,English,,0,0,0,,I told you about how you can if you think of your program as a very long linear sequence of instructions
Dialogue: 0,1:06:13.56,1:06:20.04,Chinese,,0,0,0,,前面为了简化，我们程序是一个非常长的顺序结构的指令
Dialogue: 0,1:06:20.72,1:06:26.96,English,,0,0,0,,Then the thing is trying to grab as many of those and pull them apart as fast as it can
Dialogue: 0,1:06:20.72,1:06:26.96,Chinese,,0,0,0,,然后我们的 CPU 一次读取尽可能多的指令，然后把这些指令分开
Dialogue: 0,1:06:27.52,1:06:30.40,English,,0,0,0,,But of course you know your program is actually typically a loop
Dialogue: 0,1:06:27.52,1:06:30.40,Chinese,,0,0,0,,但是，我们这里的程序实际上是一个循环
Dialogue: 0,1:06:30.78,1:06:32.69,English,,0,0,0,,And there aren't many instructions in that loop
Dialogue: 0,1:06:30.78,1:06:32.69,Chinese,,0,0,0,,并且循环中的指令不多
Dialogue: 0,1:06:33.08,1:06:35.84,English,,0,0,0,,So how is it turning that into a linear sequence
Dialogue: 0,1:06:33.08,1:06:35.84,Chinese,,0,0,0,,那怎么把它变成一个顺序指令呢
Dialogue: 0,1:06:36.72,1:06:41.52,English,,0,0,0,,Well that relies on an idea of how do you handle branches
Dialogue: 0,1:06:36.72,1:06:41.52,Chinese,,0,0,0,,这依赖于处理条件指令的方法
Dialogue: 0,1:06:42.30,1:06:48.38,English,,0,0,0,,So typically the program you know fetching ahead grabbing instructions
Dialogue: 0,1:06:42.30,1:06:48.38,Chinese,,0,0,0,,所以，现在你知道，CPU 会读取指令
Dialogue: 0,1:06:48.38,1:06:53.92,English,,0,0,0,,And it will come to a branch instruction a conditional jump of some sort
Dialogue: 0,1:06:48.38,1:06:53.92,Chinese,,0,0,0,,如果指令中有跳转指令，CPU 会跳转到对应的分支中去执行
Dialogue: 0,1:06:54.58,1:06:59.86,English,,0,0,0,,And there is a dilemma because in general this branch could either
Dialogue: 0,1:06:54.58,1:06:59.86,Chinese,,0,0,0,,这里就出现了一个两难的境地，因为这一个分支也可能被执行
Dialogue: 0,1:07:01.10,1:07:07.32,English,,0,0,0,,I'm sorry either be taken meaning it will go to the branch target
Dialogue: 0,1:07:01.10,1:07:07.32,Chinese,,0,0,0,,抱歉，这里的意思是，如果条件满足，它会跳转到对应的对应的分支
Dialogue: 0,1:07:07.80,1:07:13.70,English,,0,0,0,,Or it could do what's called fall through meaning it it the test fails and so it just continues execution
Dialogue: 0,1:07:07.80,1:07:13.70,Chinese,,0,0,0,,如果条件不满足，它会继续执行后面的代码
Dialogue: 0,1:07:14.14,1:07:19.32,English,,0,0,0,,And there's no way a priority to know what will happen these can often be data dependent
Dialogue: 0,1:07:14.14,1:07:19.32,Chinese,,0,0,0,,并且我们没有办法事先知道那个哪个会被执行，因为这与数据有关
Dialogue: 0,1:07:22.66,1:07:27.14,English,,0,0,0,,Well and so the way this is handled on a modern processor is by doing
Dialogue: 0,1:07:22.66,1:07:27.14,Chinese,,0,0,0,,所以，在现代处理器是这样处理这种情况的
Dialogue: 0,1:07:27.14,1:07:30.64,English,,0,0,0,,What's known as branch prediction which is essentially just guess
Dialogue: 0,1:07:27.14,1:07:30.64,Chinese,,0,0,0,,它采用所谓的分支预测，但本质上只是猜测
Dialogue: 0,1:07:32.10,1:07:34.64,English,,0,0,0,,Which ways this branch going to go is going to be taken or
Dialogue: 0,1:07:32.10,1:07:34.64,Chinese,,0,0,0,,猜测哪一个分支会被执行
Dialogue: 0,1:07:35.10,1:07:39.14,English,,0,0,0,,Not and you predict and then you start executing along the predicted direction
Dialogue: 0,1:07:35.10,1:07:39.14,Chinese,,0,0,0,,然后 CPU 会执行对应分支的代码
Dialogue: 0,1:07:39.56,1:07:41.98,English,,0,0,0,,But do it in a way that if you make a mistake that
Dialogue: 0,1:07:39.56,1:07:41.98,Chinese,,0,0,0,,但执行对应代码的时候，必须能够保证
Dialogue: 0,1:07:42.52,1:07:45.94,English,,0,0,0,,You haven't caused your reparable harm to the program
Dialogue: 0,1:07:42.52,1:07:45.94,Chinese,,0,0,0,,没有对该程序造成不可修复的损害
Dialogue: 0,1:07:46.44,1:07:48.40,English,,0,0,0,,And we'll see what that means
Dialogue: 0,1:07:46.44,1:07:48.40,Chinese,,0,0,0,,我们会看到这意味着什么
Dialogue: 0,1:07:48.86,1:07:52.12,English,,0,0,0,,So what really happens then is up here there's a lot of logic
Dialogue: 0,1:07:48.86,1:07:52.12,Chinese,,0,0,0,,指令控制单元（上半部分）中有许多逻辑单元
Dialogue: 0,1:07:52.12,1:07:55.60,English,,0,0,0,,That's trying to suck out instructions
Dialogue: 0,1:07:52.12,1:07:55.60,Chinese,,0,0,0,,指令高速缓存会读取指令
Dialogue: 0,1:07:56.12,1:08:02.54,English,,0,0,0,,And then there's a branch unit that's being basically coming along later and saying
Dialogue: 0,1:07:56.12,1:08:02.54,Chinese,,0,0,0,,如果遇到了分支，会先执行某个分支，当执行到后面（乱序）
Dialogue: 0,1:08:02.94,1:08:07.00,English,,0,0,0,,Yeah you're okay you predicted that correctly so you can keep going
Dialogue: 0,1:08:02.94,1:08:07.00,Chinese,,0,0,0,,发现预测是正确的，就会接着往下面指令
Dialogue: 0,1:08:07.20,1:08:10.70,English,,0,0,0,,Or it will throw up a flag and say oh wait a minute stop
Dialogue: 0,1:08:07.20,1:08:10.70,Chinese,,0,0,0,,如果预测不正确
Dialogue: 0,1:08:11.44,1:08:16.24,English,,0,0,0,,You miss predicted this branch way back 100 clock cycles ago
Dialogue: 0,1:08:11.44,1:08:16.24,Chinese,,0,0,0,,你可能要回到 100 个时钟周期前
Dialogue: 0,1:08:16.32,1:08:17.64,English,,0,0,0,,It's not that long ago but
Dialogue: 0,1:08:16.32,1:08:17.64,Chinese,,0,0,0,,这不是很久以前的事
Dialogue: 0,1:08:18.30,1:08:21.80,English,,0,0,0,,Some number of clock cycles ago you've got to fix it
Dialogue: 0,1:08:18.30,1:08:21.80,Chinese,,0,0,0,,你需要回到分支点，然后开始取出和指令另一个方向上的指令
Dialogue: 0,1:08:22.44,1:08:28.10,English,,0,0,0,,And so the hand-wave jumps then becomes more a case of
Dialogue: 0,1:08:22.44,1:08:28.10,Chinese,,0,0,0,,因此，跳转指令的指令变成了这样
Dialogue: 0,1:08:28.36,1:08:34.58,English,,0,0,0,,Of guessing up here and then either confirming or  denying that guess down below
Dialogue: 0,1:08:28.36,1:08:34.58,Chinese,,0,0,0,,先执行猜测的分支，然后在后面判断猜测是否正确
Dialogue: 0,1:08:40.58,1:08:45.60,English,,0,0,0,,So in general then if you it will predict it one way and begin executing
Dialogue: 0,1:08:40.58,1:08:45.60,Chinese,,0,0,0,,所以总的来说，如果你它会以一种方式预测并开始执行一个分支
Dialogue: 0,1:08:46.26,1:08:50.28,English,,0,0,0,,So a mention for example in a loop like I've shown you
Dialogue: 0,1:08:46.26,1:08:50.28,Chinese,,0,0,0,,举个例子，这里有一个循环
Dialogue: 0,1:08:50.56,1:08:54.80,English,,0,0,0,,That you predict that the branch will be taken that you'll go back to the start of the loop again
Dialogue: 0,1:08:50.56,1:08:54.80,Chinese,,0,0,0,,预测不会跳转，执行后面的内容，然后会再次回到循环的开始
Dialogue: 0,1:08:54.80,1:08:57.04,English,,0,0,0,,That's actually a pretty good guess
Dialogue: 0,1:08:54.80,1:08:57.04,Chinese,,0,0,0,,实际上，这是一个很好的猜测
Dialogue: 0,1:08:57.38,1:09:00.36,English,,0,0,0,,It's a good guess extol you hit the end of the loop
Dialogue: 0,1:08:57.38,1:09:00.36,Chinese,,0,0,0,,因为这执行到了循环的结尾
Dialogue: 0,1:09:00.88,1:09:02.64,English,,0,0,0,,But let's just guess that way
Dialogue: 0,1:09:00.88,1:09:02.64,Chinese,,0,0,0,,但是我们会继续这么猜
Dialogue: 0,1:09:03.18,1:09:08.56,English,,0,0,0,,And so the program will just keep guessing that the branch will be taken
Dialogue: 0,1:09:03.18,1:09:08.56,Chinese,,0,0,0,,因此程序继续执行循环体的内容
Dialogue: 0,1:09:09.02,1:09:16.28,English,,0,0,0,,And by that means by all those guesses basically create this long linear sequence of instructions
Dialogue: 0,1:09:09.02,1:09:16.28,Chinese,,0,0,0,,通过这种方式，创建了一个长的顺序指令序列
Dialogue: 0,1:09:16.66,1:09:19.68,English,,0,0,0,,That can be pulled in and executed
Dialogue: 0,1:09:16.66,1:09:19.68,Chinese,,0,0,0,,功能单元可以读取并执行
Dialogue: 0,1:09:21.88,1:09:27.60,English,,0,0,0,,And in general some of them will be fetched and some of them you'll actually have done
Dialogue: 0,1:09:21.88,1:09:27.60,Chinese,,0,0,0,,一般来说，一些指令是有效的，而一些指令是多余的
Dialogue: 0,1:09:28.20,1:09:31.06,English,,0,0,0,,The operations that are called for in the instruction
Dialogue: 0,1:09:28.20,1:09:31.06,Chinese,,0,0,0,,因为已经完成了所有的操作
Dialogue: 0,1:09:33.56,1:09:40.50,English,,0,0,0,,And then what happens is if the flag goes up they say no this was invalid
Dialogue: 0,1:09:33.56,1:09:40.50,Chinese,,0,0,0,,然后继续执行的时候，一个标志位会提示当前的分支不是无效的
Dialogue: 0,1:09:41.22,1:09:45.66,English,,0,0,0,,Then what will happen is it will go back and cancel
Dialogue: 0,1:09:41.22,1:09:45.66,Chinese,,0,0,0,,然后它会返回
Dialogue: 0,1:09:46.12,1:09:50.38,English,,0,0,0,,All the instructions that have been fetched and executed
Dialogue: 0,1:09:46.12,1:09:50.38,Chinese,,0,0,0,,并且取消所有已读取并执行的指令
Dialogue: 0,1:09:50.78,1:09:56.96,English,,0,0,0,,And the way it does that is you'll notice all these instructions only modify registers
Dialogue: 0,1:09:50.78,1:09:56.96,Chinese,,0,0,0,,注意，这里所有的指令都只修改寄存器
Dialogue: 0,1:09:57.66,1:10:00.66,English,,0,0,0,,And it has multiple copies of all the registers
Dialogue: 0,1:09:57.66,1:10:00.66,Chinese,,0,0,0,,并且，它有所有寄存器的多个副本
Dialogue: 0,1:10:01.10,1:10:03.14,English,,0,0,0,,Going back these are the registers
Dialogue: 0,1:10:01.10,1:10:03.14,Chinese,,0,0,0,,回退的时候，这些寄存器
Dialogue: 0,1:10:03.14,1:10:08.84,English,,0,0,0,,These are the values that I'm sure of these are sort of speculative values  appending updates to them
Dialogue: 0,1:10:03.14,1:10:08.84,Chinese,,0,0,0,,每一次计算的结果都依次保存在寄存器副本中，所以，猜测正确的在前，猜测错误的在后
Dialogue: 0,1:10:09.26,1:10:14.56,English,,0,0,0,,And so when it comes time to cancel it just cancels out all those pending updates
Dialogue: 0,1:10:09.26,1:10:14.56,Chinese,,0,0,0,,因此，当需要取消它时，只需取消所有待处理的更新
Dialogue: 0,1:10:14.78,1:10:17.00,English,,0,0,0,,And goes back to values that it's certain of
Dialogue: 0,1:10:14.78,1:10:17.00,Chinese,,0,0,0,,并把正确的值返回（前面是存储在副本中，并没有真正更新寄存器）
Dialogue: 0,1:10:17.12,1:10:20.40,English,,0,0,0,,Question
Dialogue: 0,1:10:17.12,1:10:20.40,Chinese,,0,0,0,,这位同学有什么问题吗
Dialogue: 0,1:10:20.40,1:10:27.66,English,,0,0,0,,The there's a big block they call the register renaming unit which is sort of
Dialogue: 0,1:10:20.40,1:10:27.66,Chinese,,0,0,0,,在 CPU 中，有一个寄存器重命名块
Dialogue: 0,1:10:27.94,1:10:31.80,English,,0,0,0,,Multiple copies of of all the registers as they get accumulated
Dialogue: 0,1:10:27.94,1:10:31.80,Chinese,,0,0,0,,它对每一个寄存器都有多个副本，计算的结果就保存在这些副本中
Dialogue: 0,1:10:31.80,1:10:42.00,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:31.80,1:10:42.00,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,1:10:42.00,1:10:45.94,English,,0,0,0,,It has many more will typically have several hundred reg of these
Dialogue: 0,1:10:42.00,1:10:45.94,Chinese,,0,0,0,,对于每个寄存器，它通常有几百个虚拟寄存器（副本）
Dialogue: 0,1:10:46.26,1:10:50.72,English,,0,0,0,,Sort of virtual registers to keep pending copies to the actual registers
Dialogue: 0,1:10:46.26,1:10:50.72,Chinese,,0,0,0,,用于存储需要更新到实际寄存器的值
Dialogue: 0,1:10:50.72,1:10:52.56,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:50.72,1:10:52.56,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,1:10:52.56,1:10:55.26,English,,0,0,0,,It does, it stores
Dialogue: 0,1:10:52.56,1:10:55.26,Chinese,,0,0,0,,嗯，对，它记录
Dialogue: 0,1:10:55.68,1:10:59.50,English,,0,0,0,,You know here's the old value Here's the first update here's the second update here's the third
Dialogue: 0,1:10:55.68,1:10:59.50,Chinese,,0,0,0,,更新的次数，知道这是第一次更新，这是第二次更新，这是第三次更新
Dialogue: 0,1:11:01.60,1:11:09.02,English,,0,0,0,,And it keeps track of all that you can imagine why this is not something you learn in a one semester course right that
Dialogue: 0,1:11:01.60,1:11:09.02,Chinese,,0,0,0,,它记录了你可以想象的一切，这不是你在一学期课程中能够学完的内容
Dialogue: 0,1:11:09.46,1:11:15.58,English,,0,0,0,,To keep track of all those different things flying by and make sure that it works is a pretty tricky business
Dialogue: 0,1:11:09.46,1:11:15.58,Chinese,,0,0,0,,它需要记录所有的内容，所以，确保它能够正常工作相当棘手
Dialogue: 0,1:11:16.06,1:11:18.48,English,,0,0,0,,But the conceptually it's a pretty simple idea
Dialogue: 0,1:11:16.06,1:11:18.48,Chinese,,0,0,0,,但从概念上讲，这是一个非常简单的想法
Dialogue: 0,1:11:18.80,1:11:24.02,English,,0,0,0,,That it just races off does a lot of things based purely on speculation
Dialogue: 0,1:11:18.80,1:11:24.02,Chinese,,0,0,0,,它只是基于猜测提前做了许多工作
Dialogue: 0,1:11:24.42,1:11:27.48,English,,0,0,0,,And then only if it makes a mistake it goes oh
Dialogue: 0,1:11:24.42,1:11:27.48,Chinese,,0,0,0,,然后只有在出错的情况下才会
Dialogue: 0,1:11:27.76,1:11:29.14,English,,0,0,0,,And it sort of rolls back
Dialogue: 0,1:11:27.76,1:11:29.14,Chinese,,0,0,0,,回退到某一个点
Dialogue: 0,1:11:29.94,1:11:32.62,English,,0,0,0,,To as if it had only executed up to a certain point
Dialogue: 0,1:11:29.94,1:11:32.62,Chinese,,0,0,0,,好像它只执行到了那个点
Dialogue: 0,1:11:33.04,1:11:34.60,English,,0,0,0,,And then it moves forward
Dialogue: 0,1:11:33.04,1:11:34.60,Chinese,,0,0,0,,然后它继续执行
Dialogue: 0,1:11:35.76,1:11:38.68,English,,0,0,0,,And starts in going the correct way
Dialogue: 0,1:11:35.76,1:11:38.68,Chinese,,0,0,0,,后面正确的分支
Dialogue: 0,1:11:39.58,1:11:46.14,English,,0,0,0,,So end up,and so it can get away with this,it's very interesting tricky stuff
Dialogue: 0,1:11:39.58,1:11:46.14,Chinese,,0,0,0,,它是如何回退的，这是非常有趣且棘手的内容
Dialogue: 0,1:11:46.48,1:11:48.80,English,,0,0,0,,But you remember we talked early in the course
Dialogue: 0,1:11:46.48,1:11:48.80,Chinese,,0,0,0,,我们在课程的早期谈过
Dialogue: 0,1:11:49.54,1:11:56.42,English,,0,0,0,,About the difference between using conditional moves and conditional jumps to implement conditional operations
Dialogue: 0,1:11:49.54,1:11:56.42,Chinese,,0,0,0,,关于条件传送和条件分支代码的区别（书 P145）
Dialogue: 0,1:11:57.08,1:12:03.72,English,,0,0,0,,And conditional moves can take place totally within the structure of this pipeline
Dialogue: 0,1:11:57.08,1:12:03.72,Chinese,,0,0,0,,条件传送可以在管道的结构内进行
Dialogue: 0,1:12:04.36,1:12:07.92,English,,0,0,0,,But a conditional jump if it's an unpredictable branch
Dialogue: 0,1:12:04.36,1:12:07.92,Chinese,,0,0,0,,如果是条件分支代码，并且是一个不可预测的数据
Dialogue: 0,1:12:08.32,1:12:13.14,English,,0,0,0,,The problem is it might go off executing and make do a lot of wasted work
Dialogue: 0,1:12:08.32,1:12:13.14,Chinese,,0,0,0,,可能会执行大量无效的工作
Dialogue: 0,1:12:13.14,1:12:16.52,English,,0,0,0,,But even worse than when it gets back and has to restart
Dialogue: 0,1:12:13.14,1:12:16.52,Chinese,,0,0,0,,但更糟糕的是，当它不得不回来重新启动时
Dialogue: 0,1:12:16.98,1:12:21.02,English,,0,0,0,,It takes a while to sort of fill up all the the buffers in the system
Dialogue: 0,1:12:16.98,1:12:21.02,Chinese,,0,0,0,,需要一段时间来填充系统中的所有缓冲区
Dialogue: 0,1:12:21.02,1:12:23.28,English,,0,0,0,,And get the whole thing running at full steam ahead
Dialogue: 0,1:12:21.02,1:12:23.28,Chinese,,0,0,0,,才能继续执行后面的代码
Dialogue: 0,1:12:27.55,1:12:32.44,English,,0,0,0,,So that kind of finishes up then the the way I describe it is
Dialogue: 0,1:12:27.55,1:12:32.44,Chinese,,0,0,0,,这节课差不多要结束了
Dialogue: 0,1:12:32.72,1:12:38.08,English,,0,0,0,,First of all don't do anything stupid even and stupid is probably it was too strong a word
Dialogue: 0,1:12:32.72,1:12:38.08,Chinese,,0,0,0,,总结一下，首先，不要做任何愚蠢的事情，愚蠢可能说的有点过了
Dialogue: 0,1:12:38.08,1:12:44.94,English,,0,0,0,,Don't do...sort of keep in mind there's certain things that you should as a programmer be doing all the time
Dialogue: 0,1:12:38.08,1:12:44.94,Chinese,,0,0,0,,然后，记住，作为一名程序员，你一直在做的某些事情可能是有问题的
Dialogue: 0,1:12:45.48,1:12:47.20,English,,0,0,0,,And they're not obvious
Dialogue: 0,1:12:45.48,1:12:47.20,Chinese,,0,0,0,,它们并不明显
Dialogue: 0,1:12:47.72,1:12:52.54,English,,0,0,0,,And then begin thinking about tuning and getting some instruction level parallelism
Dialogue: 0,1:12:47.72,1:12:52.54,Chinese,,0,0,0,,然后，我们讨论了如何通过调整代码来获得一些指令级并行性
Dialogue: 0,1:12:53.22,1:12:55.32,English,,0,0,0,,And I describe it as for the machine but
Dialogue: 0,1:12:53.22,1:12:55.32,Chinese,,0,0,0,,它们是和具体的机器相关的
Dialogue: 0,1:12:55.48,1:12:59.98,English,,0,0,0,,As I said pretty much all processors nowadays,it's a class of machines
Dialogue: 0,1:12:55.48,1:12:59.98,Chinese,,0,0,0,,但现在几乎所有的机器，都属于一类机器
Dialogue: 0,1:12:59.98,1:13:01.98,English,,0,0,0,,So these general techniques will work
Dialogue: 0,1:12:59.98,1:13:01.98,Chinese,,0,0,0,,所以，改变计算的结合性，这种技术
Dialogue: 0,1:13:02.46,1:13:05.58,English,,0,0,0,,That those ideas of changing the associativity
Dialogue: 0,1:13:02.46,1:13:05.58,Chinese,,0,0,0,,几乎对所有机器都是有效的
Dialogue: 0,1:13:05.78,1:13:10.86,English,,0,0,0,,They'll work whether it's a you know the ARM processor built into my cell phone
Dialogue: 0,1:13:05.78,1:13:10.86,Chinese,,0,0,0,,无论是手机中的 ARM 处理器
Dialogue: 0,1:13:10.86,1:13:15.90,English,,0,0,0,,Or the x86 processor built into your laptop or one of the shark machines
Dialogue: 0,1:13:10.86,1:13:15.90,Chinese,,0,0,0,,或者是笔记本电脑或 shark 机器中的 x86 处理器
Dialogue: 0,1:13:15.90,1:13:19.94,English,,0,0,0,,They all have the same general of implementation structures
Dialogue: 0,1:13:15.90,1:13:19.94,Chinese,,0,0,0,,它们都具有相同的实现结构
Dialogue: 0,1:13:19.94,1:13:23.42,English,,0,0,0,,So these techniques will work across across all of them
Dialogue: 0,1:13:19.94,1:13:23.42,Chinese,,0,0,0,,因此，这些技术将适用于这些所有的机器
Dialogue: 0,1:13:24.34,1:13:28.57,English,,0,0,0,,Okay that'll do us for today
Dialogue: 0,1:13:24.34,1:13:28.57,Chinese,,0,0,0,,好的，今天我们的课程就到这
